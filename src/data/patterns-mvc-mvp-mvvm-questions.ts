import type { Question } from '@/types/question.ts'

export const patternsMvcMvpMvvmQuestions: Question[] = [
  {
    id: 1,
    question: "Что является ключевым отличием MVC от MVP?",
    options: [
      "В MVC View знает о Model, в MVP View не знает о Model",
      "В MVC нет Presenter, в MVP нет Controller",
      "MVC используется только на сервере, MVP только на клиенте",
      "В MVC Model управляет View, в MVP наоборот"
    ],
    correctAnswer: 0,
    explanation: "Ключевое отличие: в MVC View может напрямую обращаться к Model для получения данных, в то время как в MVP View полностью изолирован от Model и взаимодействует только с Presenter, который выступает посредником.",
    topic: "Основы MVC/MVP/MVVM"
  },
  {
    id: 2,
    question: "Какая роль Controller в паттерне MVC?",
    options: [
      "Хранит бизнес-логику приложения",
      "Обрабатывает пользовательский ввод и обновляет Model",
      "Отвечает за отображение данных пользователю",
      "Синхронизирует View и Model автоматически"
    ],
    correctAnswer: 1,
    explanation: "Controller в MVC отвечает за обработку пользовательского ввода (события, действия), принимает решения о том, какие изменения нужно внести в Model, и может определять, какое View показать. Бизнес-логика находится в Model.",
    topic: "Основы MVC/MVP/MVVM"
  },
  {
    id: 3,
    question: "Что такое 'пассивное View' в паттерне MVP?",
    options: [
      "View, которое не реагирует на действия пользователя",
      "View, которое не содержит никакой логики и полностью управляется Presenter",
      "View, которое работает в фоновом режиме",
      "View, которое автоматически обновляется"
    ],
    correctAnswer: 1,
    explanation: "Пассивное View в MVP — это представление без логики, которое не знает о Model и полностью управляется Presenter. Все данные View получает от Presenter, все события передает Presenter. Это делает View максимально тестируемым.",
    topic: "Основы MVC/MVP/MVVM"
  },
  {
    id: 4,
    question: "Как работает data binding в MVVM?",
    options: [
      "Вручную синхронизируется через события",
      "Автоматически синхронизирует View и ViewModel через механизм привязки данных",
      "Требует написания специального кода для каждого поля",
      "Работает только в одном направлении от ViewModel к View"
    ],
    correctAnswer: 1,
    explanation: "Data binding в MVVM — это механизм автоматической двусторонней синхронизации между View и ViewModel. Изменения в View автоматически обновляют ViewModel и наоборот, без необходимости писать ручной код синхронизации.",
    topic: "Основы MVC/MVP/MVVM"
  },
  {
    id: 5,
    question: "В каком паттерне View наиболее зависим от Model?",
    options: [
      "MVC",
      "MVP",
      "MVVM",
      "Во всех одинаково"
    ],
    correctAnswer: 0,
    explanation: "В MVC View может напрямую обращаться к Model для получения данных, создавая прямую зависимость. В MVP и MVVM View изолирован от Model через Presenter/ViewModel соответственно.",
    topic: "Основы MVC/MVP/MVVM"
  },
  {
    id: 6,
    question: "Какой паттерн лучше всего подходит для веб-приложений с серверным рендерингом?",
    options: [
      "MVVM, так как нужен data binding",
      "MVP, так как нужна максимальная тестируемость",
      "MVC, так как он естественно соответствует архитектуре request-response",
      "Все паттерны одинаково подходят"
    ],
    correctAnswer: 2,
    explanation: "MVC естественно подходит для серверного рендеринга: Controller обрабатывает HTTP-запрос, обновляет Model, выбирает View для рендеринга. Это классическая схема веб-фреймворков типа Rails, Django, ASP.NET MVC.",
    topic: "Выбор архитектуры"
  },
  {
    id: 7,
    question: "Когда стоит выбрать MVP вместо MVC?",
    options: [
      "Когда нужна максимальная производительность",
      "Когда требуется высокая тестируемость и полная изоляция View от Model",
      "Когда проект очень маленький",
      "Когда используется серверный рендеринг"
    ],
    correctAnswer: 1,
    explanation: "MVP предпочтителен, когда важна тестируемость: пассивное View можно легко мокировать через интерфейс, вся логика в Presenter тестируется изолированно. Также MVP полезен для десктопных приложений и Android-разработки.",
    topic: "Выбор архитектуры"
  },
  {
    id: 8,
    question: "Какой паттерн наиболее подходит для современных SPA с реактивными фреймворками?",
    options: [
      "MVC",
      "MVP",
      "MVVM",
      "Ни один из них"
    ],
    correctAnswer: 2,
    explanation: "MVVM идеально подходит для SPA с реактивными фреймворками (Angular, Vue, WPF), так как data binding автоматически синхронизирует состояние, а декларативная природа View хорошо сочетается с компонентным подходом.",
    topic: "Выбор архитектуры"
  },
  {
    id: 9,
    question: "Какой фактор НЕ следует учитывать при выборе между MVC/MVP/MVVM?",
    options: [
      "Наличие встроенного data binding в платформе/фреймворке",
      "Требования к тестируемости",
      "Цвет логотипа компании",
      "Сложность пользовательского интерфейса"
    ],
    correctAnswer: 2,
    explanation: "При выборе архитектуры важны: технические возможности платформы (data binding), требования к тестируемости, сложность UI, опыт команды, размер проекта. Эстетические факторы вроде цвета логотипа не имеют отношения к архитектурным решениям.",
    topic: "Выбор архитектуры"
  },
  {
    id: 10,
    question: "Почему MVVM редко используется в бэкенд-разработке?",
    options: [
      "Слишком сложный паттерн",
      "Отсутствие механизма data binding и ненужность двусторонней синхронизации",
      "Низкая производительность",
      "Невозможность работы с базами данных"
    ],
    correctAnswer: 1,
    explanation: "MVVM требует механизма data binding, который характерен для UI-фреймворков. На бэкенде нет необходимости в двусторонней синхронизации между представлением и моделью данных, поэтому MVVM избыточен.",
    topic: "Выбор архитектуры"
  },
  {
    id: 11,
    question: "Какая связь между View и Controller в классическом MVC?",
    options: [
      "View не знает о Controller",
      "View может вызывать методы Controller напрямую",
      "Controller не знает о View",
      "Связь только через Observer pattern"
    ],
    correctAnswer: 1,
    explanation: "В классическом MVC View может напрямую вызывать Controller для обработки событий (например, клик кнопки вызывает метод Controller). Controller знает о View и может его обновить. Это создает двустороннюю связь.",
    topic: "Взаимодействие компонентов"
  },
  {
    id: 12,
    question: "Как Presenter взаимодействует с View в MVP?",
    options: [
      "Напрямую вызывает методы конкретного класса View",
      "Через интерфейс View",
      "Через глобальные переменные",
      "Только через события"
    ],
    correctAnswer: 1,
    explanation: "В MVP Presenter взаимодействует с View через интерфейс, а не с конкретной реализацией. Это позволяет легко подменять View для тестирования и обеспечивает слабую связанность компонентов.",
    topic: "Взаимодействие компонентов"
  },
  {
    id: 13,
    question: "Что происходит в MVVM, когда пользователь вводит данные в форму?",
    options: [
      "ViewModel вручную обновляется через callback",
      "Data binding автоматически обновляет свойства ViewModel",
      "View напрямую обновляет Model",
      "Нужно вызвать специальный метод синхронизации"
    ],
    correctAnswer: 1,
    explanation: "В MVVM благодаря двустороннему data binding изменения в View (например, ввод текста) автоматически обновляют соответствующие свойства ViewModel без написания ручного кода синхронизации.",
    topic: "Взаимодействие компонентов"
  },
  {
    id: 14,
    question: "Можно ли использовать несколько паттернов в одном приложении?",
    options: [
      "Нет, нужно выбрать только один паттерн",
      "Да, разные части приложения могут использовать разные паттерны",
      "Только MVC и MVP вместе",
      "Только если использовать микросервисы"
    ],
    correctAnswer: 1,
    explanation: "В больших приложениях разные модули могут использовать разные паттерны в зависимости от требований: например, административная панель на MVC, сложные формы на MVVM, а некоторые экраны на MVP для лучшей тестируемости.",
    topic: "Взаимодействие компонентов"
  },
  {
    id: 15,
    question: "Какой паттерн проще всего внедрить в существующий проект?",
    options: [
      "MVVM, так как требует меньше изменений",
      "MVP, так как не требует фреймворка",
      "MVC, так как многие проекты уже частично следуют этой структуре",
      "Все одинаково сложны"
    ],
    correctAnswer: 2,
    explanation: "MVC часто проще внедрить, так как многие проекты уже имеют некоторое разделение на модели, представления и логику управления. Постепенное формализование этих слоев легче, чем внедрение MVVM (требует data binding) или MVP (требует интерфейсов).",
    topic: "Практическое применение"
  },
  {
    id: 16,
    question: "Что усложняет тестирование в классическом MVC?",
    options: [
      "Отсутствие Model",
      "Прямая связь View с Model и Controller",
      "Слишком много абстракций",
      "Невозможность использовать моки"
    ],
    correctAnswer: 1,
    explanation: "В MVC View может напрямую обращаться к Model, а Controller часто тесно связан с конкретным View. Эти зависимости затрудняют изолированное тестирование, в отличие от MVP где все взаимодействия через интерфейсы.",
    topic: "Практическое применение"
  },
  {
    id: 17,
    question: "Какое преимущество MVVM при разработке сложных форм?",
    options: [
      "Меньше кода для синхронизации View и данных благодаря data binding",
      "Более высокая производительность",
      "Проще написать тесты",
      "Меньший размер приложения"
    ],
    correctAnswer: 0,
    explanation: "В сложных формах с множеством полей MVVM через data binding значительно уменьшает количество кода синхронизации: не нужно писать обработчики для каждого поля, привязка работает автоматически.",
    topic: "Практическое применение"
  },
  {
    id: 18,
    question: "Когда стоит избегать MVVM?",
    options: [
      "В проектах с простым UI без сложных форм",
      "Всегда стоит использовать MVVM",
      "В крупных проектах",
      "При работе с базами данных"
    ],
    correctAnswer: 0,
    explanation: "MVVM добавляет сложность через data binding и ViewModel. Для простых статических страниц или примитивного UI эта сложность избыточна — проще использовать MVC или даже обойтись без паттерна.",
    topic: "Практическое применение"
  },
  {
    id: 19,
    question: "Какой паттерн чаще всего используется в Android-разработке?",
    options: [
      "MVC",
      "MVP",
      "MVVM",
      "Все три одинаково популярны"
    ],
    correctAnswer: 2,
    explanation: "В современной Android-разработке наиболее популярен MVVM благодаря Architecture Components от Google (ViewModel, LiveData), которые предоставляют встроенную поддержку этого паттерна. MVP также используется, но MVVM стал стандартом де-факто.",
    topic: "Платформы и фреймворки"
  },
  {
    id: 20,
    question: "Какой паттерн используют классические веб-фреймворки (Rails, Django, Laravel)?",
    options: [
      "MVP",
      "MVVM",
      "MVC",
      "Flux"
    ],
    correctAnswer: 2,
    explanation: "Классические веб-фреймворки Rails, Django, Laravel, ASP.NET MVC построены на паттерне MVC: маршрутизация направляет запросы в Controller, который работает с Model и выбирает View для рендеринга.",
    topic: "Платформы и фреймворки"
  },
  {
    id: 21,
    question: "Какие фреймворки поддерживают MVVM из коробки?",
    options: [
      "React, jQuery",
      "Angular, Vue, WPF",
      "Express, Django",
      "Bootstrap, Tailwind"
    ],
    correctAnswer: 1,
    explanation: "Angular, Vue.js, WPF, Xamarin имеют встроенную поддержку MVVM с механизмами data binding. React технически не MVVM (скорее компонентная архитектура), jQuery не поддерживает паттерны MV*.",
    topic: "Платформы и фреймворки"
  },
  {
    id: 22,
    question: "В чем основное отличие Supervising Controller от Passive View в MVP?",
    options: [
      "В Supervising Controller View имеет простую логику привязки данных",
      "В Passive View нет Presenter",
      "Supervising Controller используется только на мобильных платформах",
      "Нет никакой разницы"
    ],
    correctAnswer: 0,
    explanation: "Существует два варианта MVP: Passive View (View полностью пассивен без логики) и Supervising Controller (View может иметь простую логику привязки данных, Presenter контролирует более сложные взаимодействия).",
    topic: "Вариации паттернов"
  },
  {
    id: 23,
    question: "Что такое Model-View-ViewModel-Model (MVVMM)?",
    options: [
      "Ошибка, такого паттерна не существует",
      "Вариация MVVM с дополнительным слоем для бизнес-логики",
      "Старое название MVVM",
      "MVVM для мобильных приложений"
    ],
    correctAnswer: 1,
    explanation: "MVVMM — это расширение MVVM, где добавляется дополнительный Model слой для сложной бизнес-логики, отделяя ViewModel (логику представления) от Model (бизнес-логики). Но это нестандартный термин.",
    topic: "Вариации паттернов"
  },
  {
    id: 24,
    question: "Какая главная метрика для оценки правильности выбора архитектурного паттерна?",
    options: [
      "Количество строк кода",
      "Скорость разработки и поддерживаемость в контексте требований проекта",
      "Популярность паттерна в индустрии",
      "Количество используемых классов"
    ],
    correctAnswer: 1,
    explanation: "Правильность выбора паттерна оценивается по тому, насколько он помогает команде эффективно разрабатывать и поддерживать проект с учетом конкретных требований: тестируемости, сложности UI, опыта команды, возможностей платформы.",
    topic: "Выбор архитектуры"
  }
]
