import type { Question } from '@/types/question.ts'

const additionalQuestions: Question[] = [
  {
    id: 41,
    question: "Какое свойство CSS помогает оптимизировать анимации, предупреждая браузер о будущих изменениях?",
    options: [
      "animation-hint",
      "will-change",
      "optimize-animation",
      "performance-boost"
    ],
    correctAnswer: 1,
    explanation: "Свойство will-change информирует браузер о планируемых изменениях элемента, позволяя заранее подготовить оптимизации. Например, will-change: transform создает композитный слой до начала анимации.",
    topic: "Оптимизация анимаций"
  },
  {
    id: 42,
    question: "Какие свойства CSS можно анимировать без потери производительности?",
    options: [
      "width, height, left, top",
      "transform, opacity, filter",
      "margin, padding, border-width",
      "background-color, color, font-size"
    ],
    correctAnswer: 1,
    explanation: "Только transform, opacity и filter могут анимироваться на композитном слое без вызова layout или paint. Остальные свойства требуют пересчета layout или перерисовки.",
    topic: "Анимируемые свойства"
  },
  {
    id: 43,
    question: "Что происходит при анимации составного свойства transform: translateX(100px) scale(1.5)?",
    options: [
      "Анимируются только отдельные функции",
      "Браузер интерполирует всю матрицу трансформации",
      "Анимация не работает для составных свойств",
      "Анимируется только последняя функция"
    ],
    correctAnswer: 1,
    explanation: "При анимации составного transform браузер преобразует все функции в матрицу и интерполирует значения матрицы, что может дать неожиданные промежуточные результаты.",
    topic: "Анимируемые свойства"
  },
  {
    id: 44,
    question: "Какое значение will-change следует использовать для оптимизации анимации трансформаций?",
    options: [
      "will-change: auto",
      "will-change: transform",
      "will-change: all",
      "will-change: animation"
    ],
    correctAnswer: 1,
    explanation: "will-change: transform сообщает браузеру о планируемых изменениях трансформации, что позволяет создать композитный слой и подготовить GPU-ускорение.",
    topic: "Оптимизация анимаций"
  },
  {
    id: 45,
    question: "Когда следует удалять will-change после завершения анимации?",
    options: [
      "Никогда не удалять",
      "Удалять сразу после завершения анимации",
      "Удалять через 1 секунду",
      "Браузер удаляет автоматически"
    ],
    correctAnswer: 1,
    explanation: "will-change следует удалять после завершения анимации, чтобы браузер мог освободить ресурсы композитного слоя. Постоянное наличие will-change может привести к излишнему потреблению памяти.",
    topic: "Оптимизация анимаций"
  },
  {
    id: 46,
    question: "Какая разница между CSS transition и animation для трансформаций?",
    options: [
      "Никакой разницы нет",
      "transition работает между двумя состояниями, animation позволяет множественные ключевые кадры",
      "animation работает быстрее",
      "transition поддерживает только 2D трансформации"
    ],
    correctAnswer: 1,
    explanation: "transition создает анимацию между двумя состояниями (начальное и конечное), а animation с @keyframes позволяет создавать сложные анимации с множественными промежуточными состояниями.",
    topic: "Анимации трансформаций"
  },
  {
    id: 47,
    question: "Что такое композитный слой в контексте CSS трансформаций?",
    options: [
      "Дополнительный HTML элемент",
      "Отдельный графический слой, обрабатываемый GPU",
      "CSS псевдоэлемент",
      "JavaScript объект"
    ],
    correctAnswer: 1,
    explanation: "Композитный слой - это отдельный графический слой, который обрабатывается GPU независимо от основного содержимого страницы. Трансформации, выполняемые на композитном слое, не влияют на layout остальной страницы.",
    topic: "Композитные слои"
  },
  {
    id: 48,
    question: "Какие условия автоматически создают композитный слой для элемента?",
    options: [
      "Только 3D трансформации",
      "3D трансформации, opacity меньше 1, position: fixed",
      "Любые трансформации и opacity",
      "Только анимированные элементы"
    ],
    correctAnswer: 1,
    explanation: "Композитный слой создается автоматически при наличии 3D трансформаций, opacity меньше 1, position: fixed, filters, will-change и некоторых других свойств.",
    topic: "Композитные слои"
  },
  {
    id: 49,
    question: "Что означает свойство contain: layout style paint?",
    options: [
      "Ограничивает размеры элемента",
      "Изолирует элемент от влияния на layout, стили и paint остальной страницы",
      "Скрывает элемент от поисковых систем",
      "Создает новый formatting context"
    ],
    correctAnswer: 1,
    explanation: "contain изолирует элемент, ограничивая его влияние на остальную страницу. layout предотвращает влияние на компоновку, style - на стили, paint - на перерисовку.",
    topic: "Оптимизация производительности"
  },
  {
    id: 50,
    question: "Какая временная функция (timing function) обеспечивает наиболее естественную анимацию?",
    options: [
      "linear",
      "ease",
      "ease-in-out",
      "cubic-bezier(0.25, 0.46, 0.45, 0.94)"
    ],
    correctAnswer: 2,
    explanation: "ease-in-out создает анимацию, которая начинается медленно, ускоряется в середине и замедляется к концу, что наиболее близко к естественному восприятию движения.",
    topic: "Временные функции анимации"
  },
  {
    id: 51,
    question: "Что такое 'батching' анимаций и как это влияет на производительность?",
    options: [
      "Группировка анимаций для одновременного выполнения",
      "Разделение анимаций на части",
      "Кэширование анимаций",
      "Предварительная загрузка анимаций"
    ],
    correctAnswer: 0,
    explanation: "Батching - это группировка множественных анимаций для одновременного выполнения в одном кадре рендеринга, что снижает количество перерисовок и улучшает производительность.",
    topic: "Оптимизация анимаций"
  },
  {
    id: 52,
    question: "Какое свойство позволяет контролировать, какие части элемента участвуют в stacking context?",
    options: [
      "z-index",
      "isolation",
      "contain",
      "layer-index"
    ],
    correctAnswer: 1,
    explanation: "Свойство isolation: isolate создает новый stacking context для элемента, изолируя его от blend modes и z-index родительских элементов.",
    topic: "Stacking context"
  },
  {
    id: 53,
    question: "Что произойдет при использовании transform: translateZ(0) на элементе без 3D контекста?",
    options: [
      "Ничего не произойдет",
      "Элемент принудительно создаст композитный слой",
      "Элемент исчезнет",
      "Произойдет ошибка"
    ],
    correctAnswer: 1,
    explanation: "translateZ(0) - это распространенный 'хак' для принудительного создания композитного слоя и включения GPU-ускорения, даже если реального 3D-движения нет.",
    topic: "GPU-ускорение"
  },
  {
    id: 54,
    question: "Как определить в DevTools, создает ли элемент композитный слой?",
    options: [
      "Вкладка Elements > Computed",
      "Вкладка Performance > Rendering",
      "Вкладка Layers или Rendering в DevTools",
      "Вкладка Console"
    ],
    correctAnswer: 2,
    explanation: "В Chrome DevTools можно использовать вкладку Layers для просмотра композитных слоев или включить 'Layer borders' в настройках Rendering для визуализации слоев на странице.",
    topic: "Отладка производительности"
  },
  {
    id: 55,
    question: "Какое максимальное количество одновременных анимаций рекомендуется для оптимальной производительности?",
    options: [
      "Не более 5-10 одновременных анимаций",
      "Не более 50 анимаций",
      "Количество не ограничено",
      "Зависит только от мощности устройства"
    ],
    correctAnswer: 0,
    explanation: "Рекомендуется ограничивать количество одновременных анимаций до 5-10, особенно на мобильных устройствах, чтобы поддерживать стабильную частоту кадров 60 FPS.",
    topic: "Лимиты производительности"
  },
  {
    id: 56,
    question: "Что означает 'jank' в контексте веб-анимаций?",
    options: [
      "Плавная анимация",
      "Прерывистая, неплавная анимация с пропусками кадров",
      "Быстрая анимация",
      "Цикличная анимация"
    ],
    correctAnswer: 1,
    explanation: "Jank - это термин для обозначения прерывистых, неплавных анимаций с пропусками кадров, которые происходят из-за превышения времени рендеринга 16.67мс (60 FPS).",
    topic: "Качество анимации"
  },
  {
    id: 57,
    question: "Какое свойство animation-fill-mode сохраняет финальные значения трансформации после окончания анимации?",
    options: [
      "none",
      "forwards",
      "backwards",
      "both"
    ],
    correctAnswer: 1,
    explanation: "animation-fill-mode: forwards сохраняет значения последнего ключевого кадра (@keyframes) после завершения анимации, что позволяет элементу остаться в финальном состоянии.",
    topic: "Управление анимацией"
  },
  {
    id: 58,
    question: "Как правильно анимировать элемент по сложной траектории (например, по кривой)?",
    options: [
      "Использовать только CSS transitions",
      "Использовать CSS @keyframes с множественными промежуточными точками",
      "Использовать только JavaScript",
      "Использовать SVG path animations"
    ],
    correctAnswer: 1,
    explanation: "Для анимации по сложной траектории используются CSS @keyframes с множественными промежуточными ключевыми кадрами (например, 0%, 25%, 50%, 75%, 100%), каждый из которых задает позицию на траектории.",
    topic: "Сложные анимации"
  },
  {
    id: 59,
    question: "Что произойдет при анимации transform от 'none' к 'translateX(100px) rotate(45deg)'?",
    options: [
      "Анимация не будет работать",
      "Браузер интерполирует через матрицу идентичности",
      "Анимируется только первая функция",
      "Анимация будет прерывистой"
    ],
    correctAnswer: 1,
    explanation: "При анимации от 'none' к составной трансформации браузер преобразует 'none' в матрицу идентичности matrix(1, 0, 0, 1, 0, 0) и плавно интерполирует к финальной матрице.",
    topic: "Интерполяция трансформаций"
  },
  {
    id: 60,
    question: "Какой подход наиболее эффективен для создания параллакс-эффекта?",
    options: [
      "Изменение background-position",
      "Использование transform: translateZ() и perspective",
      "Изменение position: relative с top/left",
      "Использование CSS Grid"
    ],
    correctAnswer: 1,
    explanation: "Параллакс-эффект наиболее эффективно создается с помощью transform: translateZ() в сочетании с perspective на контейнере, что позволяет использовать GPU-ускорение и избежать layout recalculation.",
    topic: "Параллакс-эффекты"
  }
];

export const questions: Question[] = [
  {
    id: 1,
    question: "Какие виды трансформаций можно применять в CSS?",
    options: [
      "Только translate() и rotate()",
      "translate(), rotate(), scale(), skew()",
      "Только scale() и skew()",
      "translate(), rotate(), opacity(), display()"
    ],
    correctAnswer: 1,
    explanation: "В CSS доступны четыре основных типа 2D трансформаций: translate() (перемещение), rotate() (поворот), scale() (масштабирование) и skew() (наклон). Также есть 3D версии этих трансформаций.",
    topic: "Трансформации в CSS"
  },
  {
    id: 2,
    question: "Какое свойство CSS используется для указания точки, относительно которой применяется трансформация?",
    options: [
      "transform-center",
      "transform-anchor",
      "transform-origin",
      "transform-point"
    ],
    correctAnswer: 2,
    explanation: "Свойство transform-origin определяет точку, относительно которой применяется трансформация. По умолчанию это центр элемента (50% 50%).",
    topic: "Трансформации в CSS"
  },
  {
    id: 3,
    question: "Что происходит с элементом при применении transform: translateZ(10px)?",
    options: [
      "Элемент перемещается на 10px вправо",
      "Элемент перемещается на 10px вниз",
      "Элемент перемещается на 10px по оси Z (ближе к пользователю)",
      "Элемент увеличивается на 10px"
    ],
    correctAnswer: 2,
    explanation: "translateZ(10px) перемещает элемент на 10 пикселей по оси Z, то есть ближе к пользователю в 3D пространстве. Это работает только при наличии perspective у родительского элемента.",
    topic: "Трансформации в CSS"
  },
  {
    id: 4,
    question: "Какие трансформации НЕ влияют на layout (не вызывают reflow) и оптимизированы для GPU?",
    options: [
      "Только translate() и rotate()",
      "Все 2D трансформации: translate(), rotate(), scale(), skew()",
      "Только scale() и skew()",
      "Трансформации не влияют на производительность"
    ],
    correctAnswer: 1,
    explanation: "Все 2D и 3D трансформации (translate, rotate, scale, skew) не влияют на layout документа и выполняются на композитном слое, что позволяет использовать аппаратное ускорение GPU для лучшей производительности.",
    topic: "Трансформации в CSS"
  },
  {
    id: 5,
    question: "Какая функция CSS позволяет комбинировать несколько трансформаций в одном объявлении?",
    options: [
      "transform: combine()",
      "transform: matrix()",
      "transform: multi()",
      "Нет такой функции, нужно использовать несколько свойств"
    ],
    correctAnswer: 1,
    explanation: "Функция matrix() позволяет объединить все 2D трансформации в одну матрицу 3x3. Также существует matrix3d() для 3D трансформаций. Кроме того, можно просто перечислить функции через пробел: transform: translateX(10px) rotate(45deg) scale(1.2).",
    topic: "Трансформации в CSS"
  },
  {
    id: 6,
    question: "Что произойдет при использовании transform: scale(-1, 1)?",
    options: [
      "Элемент отразится по горизонтали (зеркально)",
      "Элемент отразится по вертикали",
      "Элемент исчезнет",
      "Элемент повернется на 180 градусов"
    ],
    correctAnswer: 0,
    explanation: "scale(-1, 1) отражает элемент по горизонтали (зеркально), сохраняя его вертикальный размер. Отрицательное значение в scale() создает зеркальное отражение по соответствующей оси.",
    topic: "Трансформации в CSS"
  },
  {
    id: 7,
    question: "Какое свойство нужно добавить к родительскому элементу для корректной работы 3D трансформаций?",
    options: [
      "transform-3d: enable",
      "perspective: 1000px",
      "transform-style: preserve-3d",
      "Оба варианта b и c"
    ],
    correctAnswer: 3,
    explanation: "Для 3D трансформаций нужны оба свойства: perspective задает точку просмотра и глубину 3D пространства, а transform-style: preserve-3d сохраняет 3D позиционирование дочерних элементов.",
    topic: "Трансформации в CSS"
  },
  {
    id: 8,
    question: "В каком порядке применяются трансформации в объявлении transform: translateX(100px) rotate(45deg) scale(2)?",
    options: [
      "Сначала поворот, затем перемещение, затем масштабирование",
      "Слева направо: перемещение, поворот, масштабирование",
      "Справа налево: масштабирование, поворот, перемещение",
      "Одновременно, порядок не важен"
    ],
    correctAnswer: 2,
    explanation: "Трансформации применяются справа налево (или в обратном порядке записи). В данном случае: сначала scale(2), затем rotate(45deg), затем translateX(100px). Это важно, так как порядок влияет на результат.",
    topic: "Трансформации в CSS"
  },
  {
    id: 9,
    question: "Что делает свойство backface-visibility: hidden?",
    options: [
      "Скрывает элемент полностью",
      "Скрывает заднюю сторону элемента при 3D поворотах",
      "Делает элемент прозрачным",
      "Отключает все трансформации"
    ],
    correctAnswer: 1,
    explanation: "backface-visibility: hidden скрывает заднюю сторону элемента, когда он повернут в 3D пространстве так, что задняя сторона обращена к пользователю. Полезно для создания эффектов переворота карточек.",
    topic: "Трансформации в CSS"
  },
  {
    id: 10,
    question: "Какая разница между translateX(50px) и left: 50px?",
    options: [
      "Никакой разницы нет",
      "translateX() работает быстрее и не вызывает reflow",
      "left работает быстрее",
      "translateX() работает только с абсолютно позиционированными элементами"
    ],
    correctAnswer: 1,
    explanation: "translateX() работает на композитном слое и не вызывает reflow/repaint, используя аппаратное ускорение. left изменяет layout и вызывает reflow, что медленнее. Поэтому для анимаций предпочтительнее использовать transform.",
    topic: "Трансформации в CSS"
  },
  {
    id: 11,
    question: "Как правильно применить поворот вокруг произвольной точки?",
    options: [
      "Использовать только transform-origin",
      "Использовать transform-origin и transform: rotate()",
      "Использовать только rotate() с координатами",
      "Это невозможно в CSS"
    ],
    correctAnswer: 1,
    explanation: "Для поворота вокруг произвольной точки нужно установить transform-origin в нужную позицию, а затем применить rotate(). transform-origin может принимать значения в пикселях, процентах или ключевые слова (top, bottom, left, right, center).",
    topic: "Трансформации в CSS"
  },
  {
    id: 12,
    question: "Что произойдет при transform: rotateX(90deg) для элемента без perspective у родителя?",
    options: [
      "Элемент исчезнет (станет линией)",
      "Элемент повернется плоско",
      "Ничего не произойдет",
      "Элемент повернется в 2D"
    ],
    correctAnswer: 0,
    explanation: "При rotateX(90deg) без perspective элемент поворачивается на 90 градусов вокруг оси X и становится невидимым (превращается в линию), так как мы смотрим на него с торца. perspective нужна для создания 3D эффекта.",
    topic: "Трансформации в CSS"
  },
  {
    id: 13,
    question: "Какое значение transform-origin по умолчанию?",
    options: [
      "0 0 (левый верхний угол)",
      "50% 50% (центр элемента)",
      "100% 100% (правый нижний угол)",
      "Зависит от типа элемента"
    ],
    correctAnswer: 1,
    explanation: "По умолчанию transform-origin установлен в 50% 50%, что соответствует центру элемента. Это означает, что все трансформации применяются относительно центра элемента.",
    topic: "Трансформации в CSS"
  },
  {
    id: 14,
    question: "Что делает функция skew(30deg, 10deg)?",
    options: [
      "Поворачивает элемент на 30 и 10 градусов",
      "Наклоняет элемент: на 30 градусов по X и 10 градусов по Y",
      "Масштабирует элемент",
      "Перемещает элемент"
    ],
    correctAnswer: 1,
    explanation: "skew(30deg, 10deg) наклоняет элемент на 30 градусов по оси X и на 10 градусов по оси Y, создавая эффект искривления или наклона. Можно использовать отдельно skewX() и skewY().",
    topic: "Трансформации в CSS"
  },
  {
    id: 15,
    question: "Как создать анимацию, которая будет оптимальна для производительности?",
    options: [
      "Анимировать width и height",
      "Анимировать left и top",
      "Анимировать transform и opacity",
      "Анимировать margin и padding"
    ],
    correctAnswer: 2,
    explanation: "Для оптимальной производительности следует анимировать только transform и opacity, так как они не вызывают reflow/repaint и выполняются на композитном слое с аппаратным ускорением GPU.",
    topic: "Трансформации в CSS"
  },
  {
    id: 16,
    question: "Что произойдет при transform: scale(0)?",
    options: [
      "Элемент исчезнет визуально, но займет место в layout",
      "Элемент исчезнет полностью",
      "Элемент станет невидимым как при opacity: 0",
      "Произойдет ошибка"
    ],
    correctAnswer: 0,
    explanation: "При scale(0) элемент визуально исчезает (сжимается до нулевого размера), но продолжает занимать свое место в layout. Это отличается от display: none или visibility: hidden.",
    topic: "Трансформации в CSS"
  },
  {
    id: 17,
    question: "Можно ли применить разные transform-origin для разных трансформаций одного элемента?",
    options: [
      "Да, каждая трансформация может иметь свой transform-origin",
      "Нет, transform-origin один для всех трансформаций элемента",
      "Только для 3D трансформаций",
      "Только в новых браузерах"
    ],
    correctAnswer: 1,
    explanation: "transform-origin - это единое свойство элемента, которое применяется ко всем трансформациям этого элемента. Нельзя задать разные точки трансформации для разных функций в одном объявлении transform.",
    topic: "Трансформации в CSS"
  },
  {
    id: 18,
    question: "Что означает запись transform: translate3d(10px, 20px, 0)?",
    options: [
      "То же самое, что translate(10px, 20px)",
      "Перемещение в 3D с принудительным созданием композитного слоя",
      "Ошибка, так как Z-координата равна 0",
      "Работает только в 3D контексте"
    ],
    correctAnswer: 1,
    explanation: "translate3d(10px, 20px, 0) создает перемещение в 3D пространстве и принудительно создает композитный слой для аппаратного ускорения, даже если Z-координата равна 0. Это техника оптимизации, часто называемая 'хаком translate3d'.",
    topic: "Трансформации в CSS"
  },
  {
    id: 19,
    question: "Какое максимальное количество параметров может принимать функция matrix()?",
    options: [
      "4 параметра",
      "6 параметров",
      "9 параметров",
      "16 параметров"
    ],
    correctAnswer: 1,
    explanation: "Функция matrix() для 2D трансформаций принимает 6 параметров: matrix(a, b, c, d, tx, ty). Для 3D есть matrix3d() с 16 параметрами. Матрица 2D представляет все возможные 2D трансформации.",
    topic: "Трансформации в CSS"
  },
  {
    id: 20,
    question: "Что произойдет с дочерними элементами при применении transform-style: preserve-3d?",
    options: [
      "Ничего не изменится",
      "Дочерние элементы будут сохранять 3D позиционирование",
      "Дочерние элементы станут плоскими",
      "Дочерние элементы исчезнут"
    ],
    correctAnswer: 1,
    explanation: "transform-style: preserve-3d позволяет дочерним элементам сохранять свое 3D позиционирование в трехмерном пространстве, вместо того чтобы сплющиваться в плоскость родительского элемента (что происходит по умолчанию с flat).",
    topic: "Трансформации в CSS"
  },
  {
    id: 21,
    question: "Какая функция CSS позволяет создать перспективу для отдельного элемента без изменения родительского?",
    options: [
      "perspective()",
      "transform-perspective()",
      "element-perspective()",
      "local-perspective()"
    ],
    correctAnswer: 0,
    explanation: "Функция perspective() в свойстве transform позволяет применить перспективу к конкретному элементу, в отличие от свойства perspective, которое применяется к родительскому элементу и влияет на всех детей.",
    topic: "Трансформации в CSS"
  },
  {
    id: 22,
    question: "Что произойдет при transform: rotateY(180deg) rotateX(180deg)?",
    options: [
      "Элемент повернется на 360 градусов",
      "Элемент вернется в исходное положение",
      "Элемент будет повернут на 180 градусов по диагонали",
      "Элемент исчезнет"
    ],
    correctAnswer: 1,
    explanation: "Поворот на 180 градусов по оси Y, а затем на 180 градусов по оси X приводит к тому, что элемент возвращается в исходное положение, но с обратной стороной, обращенной к зрителю.",
    topic: "Трансформации в CSS"
  },
  {
    id: 23,
    question: "Какое свойство определяет, будет ли элемент участвовать в 3D трансформационном контексте?",
    options: [
      "transform-box",
      "transform-style",
      "transform-context",
      "transform-mode"
    ],
    correctAnswer: 1,
    explanation: "Свойство transform-style со значением preserve-3d создает 3D трансформационный контекст, позволяя дочерним элементам позиционироваться в 3D пространстве. Значение flat (по умолчанию) сплющивает элементы.",
    topic: "Трансформации в CSS"
  },
  {
    id: 24,
    question: "Что означает transform: translateZ(-100px) в контексте с perspective: 1000px?",
    options: [
      "Элемент приближается к зрителю",
      "Элемент отдаляется от зрителя и кажется меньше",
      "Элемент перемещается влево",
      "Элемент поворачивается"
    ],
    correctAnswer: 1,
    explanation: "Отрицательное значение translateZ() отодвигает элемент от зрителя в 3D пространстве, что при наличии perspective делает его визуально меньше и создает эффект удаления.",
    topic: "Трансформации в CSS"
  },
  {
    id: 25,
    question: "Какая комбинация создаст эффект 'флипа' карточки?",
    options: [
      "rotateY(180deg) + backface-visibility: hidden",
      "rotateX(180deg) + perspective",
      "scale(-1) + rotate(180deg)",
      "skew(180deg) + transform-origin"
    ],
    correctAnswer: 0,
    explanation: "Для создания эффекта переворота карточки используется rotateY(180deg) для поворота вокруг вертикальной оси и backface-visibility: hidden для скрытия обратной стороны элементов.",
    topic: "Трансформации в CSS"
  },
  {
    id: 26,
    question: "Что происходит с z-index при применении transform (кроме none)?",
    options: [
      "z-index игнорируется",
      "z-index работает как обычно",
      "Элемент создает новый stacking context",
      "z-index удваивается"
    ],
    correctAnswer: 2,
    explanation: "Любое значение transform, кроме none, создает новый stacking context, что влияет на то, как элемент взаимодействует с z-index и другими элементами в слоях.",
    topic: "Трансформации в CSS"
  },
  {
    id: 27,
    question: "Какой способ наиболее эффективен для центрирования элемента с помощью transform?",
    options: [
      "transform: translate(50%, 50%)",
      "transform: translate(-50%, -50%) с position: absolute",
      "transform: translateX(-50%) translateY(-50%)",
      "transform: scale(0.5) translate(100%, 100%)"
    ],
    correctAnswer: 1,
    explanation: "Для центрирования элемента используется position: absolute с left: 50%, top: 50% и transform: translate(-50%, -50%), что смещает элемент на половину его собственного размера обратно.",
    topic: "Трансформации в CSS"
  },
  {
    id: 28,
    question: "Что произойдет при использовании transform: rotate(0.5turn)?",
    options: [
      "Элемент повернется на 0.5 градуса",
      "Элемент повернется на 180 градусов",
      "Произойдет ошибка",
      "Элемент повернется на 90 градусов"
    ],
    correctAnswer: 1,
    explanation: "Единица 'turn' представляет полный оборот (360 градусов), поэтому 0.5turn равно половине оборота или 180 градусам. Также можно использовать единицы deg, rad, grad.",
    topic: "Трансформации в CSS"
  },
  {
    id: 29,
    question: "Какое свойство позволяет анимировать transform с плавными переходами?",
    options: [
      "animation",
      "transition",
      "transform-animation",
      "Оба варианта a и b"
    ],
    correctAnswer: 3,
    explanation: "Для анимации transform можно использовать как transition для простых переходов между состояниями, так и animation с @keyframes для более сложных анимаций с множественными ключевыми кадрами.",
    topic: "Трансформации в CSS"
  },
  {
    id: 30,
    question: "Что означает transform: matrix(1, 0, 0, 1, 0, 0)?",
    options: [
      "Элемент исчезает",
      "Элемент остается без изменений (идентичная матрица)",
      "Элемент поворачивается на 90 градусов",
      "Элемент увеличивается в 2 раза"
    ],
    correctAnswer: 1,
    explanation: "matrix(1, 0, 0, 1, 0, 0) представляет идентичную матрицу трансформации, которая не производит никаких изменений с элементом. Это эквивалентно transform: none.",
    topic: "Трансформации в CSS"
  },
  {
    id: 31,
    question: "Какая функция позволяет получить текущие вычисленные значения transform элемента в JavaScript?",
    options: [
      "element.style.transform",
      "getComputedStyle(element).transform",
      "element.getTransform()",
      "element.transformMatrix"
    ],
    correctAnswer: 1,
    explanation: "getComputedStyle(element).transform возвращает вычисленное значение трансформации в виде матрицы, например 'matrix(1, 0, 0, 1, 100, 50)'. Это позволяет получить итоговые значения всех примененных трансформаций.",
    topic: "Трансформации в CSS"
  },
  {
    id: 32,
    question: "Что произойдет при transform: scale(2) на элементе с overflow: hidden?",
    options: [
      "Увеличенный контент будет обрезан границами исходного элемента",
      "Элемент увеличится и выйдет за границы",
      "Ничего не произойдет",
      "overflow будет проигнорирован"
    ],
    correctAnswer: 1,
    explanation: "Трансформация scale() применяется после layout, поэтому увеличенный элемент выйдет за границы своего контейнера с overflow: hidden, так как overflow действует на исходные размеры элемента.",
    topic: "Трансформации в CSS"
  },
  {
    id: 33,
    question: "Какая трансформация создаст зеркальное отражение по вертикали?",
    options: [
      "scale(1, -1)",
      "scale(-1, 1)",
      "rotateY(180deg)",
      "skewY(180deg)"
    ],
    correctAnswer: 0,
    explanation: "scale(1, -1) создает зеркальное отражение по вертикали, сохраняя горизонтальный размер (1) и инвертируя вертикальный (-1). scale(-1, 1) создает горизонтальное отражение.",
    topic: "Трансформации в CSS"
  },
  {
    id: 34,
    question: "Что происходит с событиями мыши на трансформированном элементе?",
    options: [
      "События перестают работать",
      "События работают по визуальному положению элемента",
      "События работают по исходному положению элемента",
      "События работают только на нетрансформированной части"
    ],
    correctAnswer: 1,
    explanation: "События мыши (click, hover и т.д.) срабатывают по визуальному положению трансформированного элемента, а не по его исходному положению в DOM. Браузер автоматически пересчитывает области для событий.",
    topic: "Трансформации в CSS"
  },
  {
    id: 35,
    question: "Какое значение perspective-origin по умолчанию?",
    options: [
      "0% 0% (левый верхний угол)",
      "50% 50% (центр)",
      "100% 100% (правый нижний угол)",
      "Зависит от размера элемента"
    ],
    correctAnswer: 1,
    explanation: "По умолчанию perspective-origin установлен в 50% 50%, что означает, что точка перспективы находится в центре элемента. Это свойство определяет, откуда зритель смотрит на 3D сцену.",
    topic: "Трансформации в CSS"
  },
  {
    id: 36,
    question: "Что произойдет при transform: rotate(45deg) scale(2) translate(100px, 0)?",
    options: [
      "Элемент сначала повернется, затем увеличится, затем переместится",
      "Элемент сначала переместится, затем увеличится, затем повернется",
      "Все трансформации применятся одновременно",
      "Последняя трансформация перезапишет предыдущие"
    ],
    correctAnswer: 1,
    explanation: "Трансформации применяются справа налево: translate(100px, 0), затем scale(2), затем rotate(45deg). Такой порядок важен, поскольку каждая трансформация влияет на систему координат для следующей.",
    topic: "Трансформации в CSS"
  },
  {
    id: 37,
    question: "Какое свойство определяет, относительно какого бокса элемента применяется трансформация?",
    options: [
      "transform-box",
      "transform-area",
      "transform-region",
      "transform-scope"
    ],
    correctAnswer: 0,
    explanation: "Свойство transform-box определяет, относительно какого бокса применяется трансформация: content-box (только контент), border-box (включая границы), fill-box (для SVG), view-box (для SVG) и stroke-box (для SVG).",
    topic: "Трансформации в CSS"
  },
  {
    id: 38,
    question: "Что означает запись transform: perspective(500px) rotateX(45deg)?",
    options: [
      "Неправильная запись",
      "Применение локальной перспективы к данному элементу",
      "То же самое, что perspective: 500px на родителе",
      "Создание 3D контекста"
    ],
    correctAnswer: 1,
    explanation: "perspective() как функция в transform применяет перспективу локально к конкретному элементу. Это отличается от свойства perspective на родителе, которое влияет на всех детей. Важно: perspective() должна быть первой в списке трансформаций.",
    topic: "Трансформации в CSS"
  },
  {
    id: 39,
    question: "Как правильно анимировать появление элемента с помощью scale?",
    options: [
      "От scale(1) к scale(0)",
      "От scale(0) к scale(1)",
      "От scale(-1) к scale(1)",
      "От scale(0.5) к scale(2)"
    ],
    correctAnswer: 1,
    explanation: "Для анимации появления элемента используется переход от scale(0) к scale(1), что создает эффект увеличения от нулевого размера до нормального. Это популярный эффект для модальных окон и всплывающих элементов.",
    topic: "Трансформации в CSS"
  },
  {
    id: 40,
    question: "Что произойдет с псевдоэлементами (::before, ::after) при трансформации родительского элемента?",
    options: [
      "Псевдоэлементы не трансформируются",
      "Псевдоэлементы трансформируются вместе с родителем",
      "Псевдоэлементы исчезают",
      "Псевдоэлементы трансформируются отдельно"
    ],
    correctAnswer: 1,
    explanation: "Псевдоэлементы ::before и ::after являются дочерними элементами и трансформируются вместе со своим родительским элементом, сохраняя относительное позиционирование.",
    topic: "Трансформации в CSS"
  },
  ...additionalQuestions,
]
