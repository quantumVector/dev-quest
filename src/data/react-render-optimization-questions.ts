import type { Question } from '@/types/question.ts'

export const reactRenderOptimizationQuestions: Question[] = [
  // Тема 1: React.memo
  {
    id: 1,
    question: "Что делает React.memo?",
    options: [
      "Мемоизирует результат вычислений внутри компонента",
      "Предотвращает ререндер компонента, если props не изменились",
      "Кеширует DOM элементы компонента",
      "Оптимизирует работу с памятью"
    ],
    correctAnswer: 1,
    explanation: "React.memo - это Higher Order Component (HOC), который мемоизирует компонент и предотвращает его ререндер, если props не изменились (shallow comparison). Это помогает оптимизировать производительность.",
    topic: "React.memo"
  },
  {
    id: 2,
    question: "Как React.memo сравнивает props по умолчанию?",
    options: [
      "Deep comparison всех props",
      "Shallow comparison (поверхностное сравнение)",
      "Сравнение только примитивных значений",
      "Сравнение по JSON.stringify"
    ],
    correctAnswer: 1,
    explanation: "React.memo использует shallow comparison для сравнения props. Это означает, что сравниваются только ссылки на объекты и массивы, а не их содержимое. Для примитивов сравниваются значения.",
    topic: "React.memo"
  },
  {
    id: 3,
    question: "Когда React.memo НЕ помогает оптимизировать производительность?",
    options: [
      "Когда props часто изменяются",
      "Когда компонент получает функции как props без useCallback",
      "Когда передаются инлайн объекты или массивы",
      "Все перечисленные варианты"
    ],
    correctAnswer: 3,
    explanation: "React.memo неэффективен когда: props часто меняются (overhead на сравнение без пользы), передаются новые функции каждый рендер, или инлайн объекты/массивы (новые ссылки каждый раз). В этих случаях компонент всё равно будет перерендериваться.",
    topic: "React.memo"
  },
  {
    id: 4,
    question: "Как использовать кастомную функцию сравнения с React.memo?",
    options: [
      "React.memo(Component, compareFunction)",
      "React.memo(Component, { compare: fn })",
      "Component.memo(compareFunction)",
      "Нельзя использовать кастомную функцию"
    ],
    correctAnswer: 0,
    explanation: "React.memo принимает второй необязательный аргумент - функцию сравнения: React.memo(Component, (prevProps, nextProps) => boolean). Если функция возвращает true, ререндер пропускается.",
    topic: "React.memo"
  },
  {
    id: 5,
    question: "Что вернет кастомная функция сравнения, чтобы ПРОПУСТИТЬ ререндер?",
    options: [
      "false",
      "true",
      "undefined",
      "null"
    ],
    correctAnswer: 1,
    explanation: "Кастомная функция сравнения должна вернуть true, если props равны (ререндер пропускается), и false, если props изменились (нужен ререндер). Это противоположно логике shouldComponentUpdate.",
    topic: "React.memo"
  },
  {
    id: 6,
    question: "Можно ли использовать React.memo с компонентами, которые используют Context?",
    options: [
      "Нет, React.memo не работает с Context",
      "Да, но компонент все равно перерендерится при изменении Context",
      "Да, и Context изменения игнорируются",
      "Только с определенными типами Context"
    ],
    correctAnswer: 1,
    explanation: "React.memo работает с компонентами, использующими Context, но изменения Context все равно вызовут ререндер, даже если props не изменились. React.memo проверяет только props, не Context.",
    topic: "React.memo"
  },

  // Тема 2: Композиция компонентов
  {
    id: 7,
    question: "Что такое паттерн 'children prop' для оптимизации?",
    options: [
      "Передача компонентов через children вместо рендера внутри родителя",
      "Использование специального children API",
      "Оптимизация дочерних элементов",
      "Кеширование children"
    ],
    correctAnswer: 0,
    explanation: "Паттерн children prop: компоненты, переданные через children, создаются на уровень выше и не пересоздаются при изменении state родителя. Это естественная оптимизация без React.memo.",
    topic: "Композиция"
  },
  {
    id: 8,
    question: "Почему этот код оптимальнее?\n\n<Layout>{expensiveComponent}</Layout>\n\nвместо:\n\n<Layout>{renderExpensiveComponent()}</Layout>",
    options: [
      "Первый вариант быстрее выполняется",
      "Компонент в первом варианте не пересоздается при ререндере Layout",
      "Второй вариант вызывает ошибку",
      "Нет разницы"
    ],
    correctAnswer: 1,
    explanation: "В первом варианте expensiveComponent создается выше и передается как готовый элемент. При ререндере Layout этот элемент не пересоздается. Во втором варианте функция вызывается каждый раз, создавая новый элемент.",
    topic: "Композиция"
  },
  {
    id: 9,
    question: "Что такое 'component composition' вместо props drilling?",
    options: [
      "Использование Context API",
      "Передача компонентов как props вместо данных",
      "Создание HOC компонентов",
      "Использование Redux"
    ],
    correctAnswer: 1,
    explanation: "Component composition - передача компонентов как props (например, через children или именованные props). Это позволяет избежать props drilling и дает естественную оптимизацию, так как эти компоненты не пересоздаются.",
    topic: "Композиция"
  },
  {
    id: 10,
    question: "В чем преимущество передачи компонента через prop перед условным рендером внутри?",
    options: [
      "Более читаемый код",
      "Компонент не пересоздается при изменении state родителя",
      "Лучше для тестирования",
      "Нет преимуществ"
    ],
    correctAnswer: 1,
    explanation: "Когда компонент передается через prop, он создается на уровень выше и остается стабильным при изменениях state внутри. Условный рендер внутри пересоздает компонент каждый раз.",
    topic: "Композиция"
  },

  // Тема 3: Перемещение state вниз
  {
    id: 11,
    question: "Что означает паттерн 'state colocation' (размещение state)?",
    options: [
      "Хранение всего state в Redux",
      "Размещение state как можно ближе к компонентам, которые его используют",
      "Использование Context для всего state",
      "Централизация state в App компоненте"
    ],
    correctAnswer: 1,
    explanation: "State colocation - это принцип размещения state максимально близко к компонентам, которые его используют. Это уменьшает область влияния изменений state и предотвращает ненужные ререндеры других частей дерева.",
    topic: "State Management"
  },
  {
    id: 12,
    question: "Почему перенос state в дочерний компонент может улучшить производительность?",
    options: [
      "State в дочерних компонентах работает быстрее",
      "Изменения state не вызывают ререндер родителя и его других детей",
      "Код становится более читаемым",
      "Уменьшается размер bundle"
    ],
    correctAnswer: 1,
    explanation: "Когда state находится в дочернем компоненте, его изменения вызывают ререндер только этого компонента и его потомков, а не всего дерева от родителя. Это значительно уменьшает количество ререндеров.",
    topic: "State Management"
  },
  {
    id: 13,
    question: "Какой state НЕ стоит перемещать вниз по дереву?",
    options: [
      "State формы, используемый только в одном компоненте",
      "State анимации локального элемента",
      "State, который нужен нескольким компонентам на разных уровнях",
      "State открытия/закрытия модального окна"
    ],
    correctAnswer: 2,
    explanation: "Если state нужен нескольким компонентам на разных уровнях, его нужно держать в общем родителе или использовать Context/Redux. Перемещение вниз в этом случае приведет к props drilling.",
    topic: "State Management"
  },
  {
    id: 14,
    question: "Что такое 'heavy component' в контексте оптимизации?",
    options: [
      "Компонент с большим размером кода",
      "Компонент с дорогими вычислениями или большим деревом",
      "Компонент с многими props",
      "Компонент с async операциями"
    ],
    correctAnswer: 1,
    explanation: "Heavy component - компонент, ререндер которого дорогой: сложные вычисления, большое дерево потомков, или дорогие операции в render. Такие компоненты - первые кандидаты на оптимизацию.",
    topic: "State Management"
  },

  // Тема 4: Разделение компонентов
  {
    id: 15,
    question: "Зачем разделять компонент на несколько маленьких при оптимизации?",
    options: [
      "Для лучшей читаемости кода",
      "Чтобы изолировать части, которые меняются, от частей, которые статичны",
      "Для уменьшения размера bundle",
      "Для упрощения тестирования"
    ],
    correctAnswer: 1,
    explanation: "Разделение компонентов позволяет изолировать динамические части (которые часто меняются) от статичных. Статичные части можно обернуть в React.memo, и они не будут перерендериваться.",
    topic: "Component Splitting"
  },
  {
    id: 16,
    question: "Что лучше: один большой компонент или много маленьких для производительности?",
    options: [
      "Всегда один большой - меньше overhead",
      "Всегда много маленьких - лучше оптимизация",
      "Зависит от паттернов ререндера и возможности мемоизации",
      "Нет разницы для производительности"
    ],
    correctAnswer: 2,
    explanation: "Нет универсального правила. Если части компонента меняются независимо, разделение + мемоизация эффективно. Если весь компонент меняется вместе, разделение добавляет overhead без пользы. Нужен анализ конкретного случая.",
    topic: "Component Splitting"
  },
  {
    id: 17,
    question: "Какой признак того, что компонент стоит разделить для оптимизации?",
    options: [
      "Компонент больше 100 строк кода",
      "Часть UI меняется часто, а другая часть статична",
      "Компонент использует много props",
      "Компонент использует Context"
    ],
    correctAnswer: 1,
    explanation: "Основной признак - разная частота изменений разных частей UI. Если одна часть меняется при каждом вводе символа, а другая статична, их стоит разделить для независимой мемоизации статичной части.",
    topic: "Component Splitting"
  },

  // Тема 5: Виртуализация списков
  {
    id: 18,
    question: "Что такое виртуализация списков?",
    options: [
      "Создание виртуальных копий элементов списка",
      "Рендер только видимых элементов списка, а не всех",
      "Использование Virtual DOM для списков",
      "Кеширование элементов списка"
    ],
    correctAnswer: 1,
    explanation: "Виртуализация - техника, при которой рендерятся только элементы списка, видимые в viewport (+ небольшой буфер). Остальные элементы не создаются в DOM, что резко улучшает производительность для больших списков.",
    topic: "Виртуализация"
  },
  {
    id: 19,
    question: "Какая библиотека чаще всего используется для виртуализации в React?",
    options: [
      "react-virtual",
      "react-window или react-virtualized",
      "virtual-list",
      "react-infinite-scroll"
    ],
    correctAnswer: 1,
    explanation: "react-window (более легкая, современная) и react-virtualized (более функциональная, но тяжелее) - самые популярные библиотеки. react-window рекомендуется для большинства случаев как более производительная.",
    topic: "Виртуализация"
  },
  {
    id: 20,
    question: "Когда НЕ стоит использовать виртуализацию?",
    options: [
      "Для списков меньше 100 элементов",
      "Когда элементы списка имеют разную высоту",
      "Для горизонтальных списков",
      "Когда нужна печать списка"
    ],
    correctAnswer: 0,
    explanation: "Для небольших списков (<100-200 элементов) виртуализация добавляет сложность без существенного выигрыша. Браузеры хорошо справляются с сотнями DOM элементов. Виртуализация критична для тысяч элементов.",
    topic: "Виртуализация"
  },
  {
    id: 21,
    question: "Какая проблема может возникнуть при виртуализации списков с элементами разной высоты?",
    options: [
      "Виртуализация не работает",
      "Сложность расчета позиции элементов и прыжки скролла",
      "Медленный рендер",
      "Проблемы с доступностью"
    ],
    correctAnswer: 1,
    explanation: "Для элементов разной высоты сложно рассчитать позицию элементов без их рендера. Это может вызывать прыжки скролла. Решение: использовать динамическую виртуализацию (react-window Dynamic lists) или фиксированную высоту.",
    topic: "Виртуализация"
  },

  // Тема 6: Debouncing и Throttling
  {
    id: 22,
    question: "В чем разница между debouncing и throttling?",
    options: [
      "Debouncing вызывает функцию после паузы, throttling - с фиксированной частотой",
      "Debouncing быстрее, throttling медленнее",
      "Нет разницы, это синонимы",
      "Debouncing для input, throttling для scroll"
    ],
    correctAnswer: 0,
    explanation: "Debouncing откладывает вызов функции до момента, когда события прекратятся на N мс (для поиска). Throttling вызывает функцию максимум раз в N мс, игнорируя промежуточные события (для scroll).",
    topic: "Debouncing/Throttling"
  },
  {
    id: 23,
    question: "Когда использовать debouncing?",
    options: [
      "Для scroll событий",
      "Для поиска при вводе текста",
      "Для resize событий",
      "Для анимаций"
    ],
    correctAnswer: 1,
    explanation: "Debouncing идеален для input/search: мы хотим подождать, пока пользователь закончит печатать, и только тогда сделать запрос. Это экономит API calls и улучшает UX.",
    topic: "Debouncing/Throttling"
  },
  {
    id: 24,
    question: "Когда использовать throttling?",
    options: [
      "Для поиска",
      "Для scroll или resize событий",
      "Для click событий",
      "Для form submission"
    ],
    correctAnswer: 1,
    explanation: "Throttling подходит для событий, которые срабатывают очень часто (scroll, resize, mousemove), но нам нужно обрабатывать их с разумной частотой (например, раз в 100ms), не пропуская все события.",
    topic: "Debouncing/Throttling"
  },
  {
    id: 25,
    question: "Как правильно реализовать debounce в React?",
    options: [
      "Создавать новую debounced функцию при каждом рендере",
      "Использовать useCallback/useMemo для стабильности функции",
      "Использовать setTimeout напрямую",
      "Не использовать debounce в React"
    ],
    correctAnswer: 1,
    explanation: "Debounced функцию нужно мемоизировать (useCallback с lodash.debounce или useMemo), чтобы она была стабильной между рендерами. Иначе debounce не работает - создается новая функция каждый раз.",
    topic: "Debouncing/Throttling"
  },

  // Тема 7: Оптимизация Context
  {
    id: 26,
    question: "Почему Context может вызывать проблемы с производительностью?",
    options: [
      "Context медленно читает данные",
      "Все компоненты-consumers перерендериваются при любом изменении Context",
      "Context использует много памяти",
      "Context блокирует Event Loop"
    ],
    correctAnswer: 1,
    explanation: "Когда значение Context меняется, ВСЕ компоненты, использующие useContext, перерендериваются, даже если используют только часть значения, которая не изменилась. Это может вызвать массу ненужных ререндеров.",
    topic: "Context Optimization"
  },
  {
    id: 27,
    question: "Как оптимизировать Context с частыми изменениями?",
    options: [
      "Не использовать Context вообще",
      "Разделить на несколько мелких Context",
      "Использовать useMemo для значения Context",
      "Варианты B и C"
    ],
    correctAnswer: 3,
    explanation: "Два подхода: 1) Разделить Context на несколько (state, actions) - consumers подписываются только на нужное. 2) useMemo для значения Context предотвращает лишние изменения ссылки при ререндере Provider.",
    topic: "Context Optimization"
  },
  {
    id: 28,
    question: "Что такое паттерн 'split Context' для оптимизации?",
    options: [
      "Использование двух Providers",
      "Разделение state и dispatch в разные Context",
      "Использование Context.Provider внутри другого Provider",
      "Создание Context для каждого компонента"
    ],
    correctAnswer: 1,
    explanation: "Split Context: разделить данные (state) и actions (dispatch/setters) в разные Context. Компоненты, которые только читают данные, не перерендерятся при изменении actions, и наоборот.",
    topic: "Context Optimization"
  },
  {
    id: 29,
    question: "Помогает ли React.memo при использовании Context?",
    options: [
      "Нет, Context игнорирует React.memo",
      "Да, если компонент не использует Context",
      "Да, всегда предотвращает ререндер",
      "Только для определенных типов Context"
    ],
    correctAnswer: 0,
    explanation: "React.memo НЕ помогает, если компонент использует Context. Изменение Context вызывает ререндер всех consumers независимо от memo. Memo проверяет только props, не Context subscriptions.",
    topic: "Context Optimization"
  },
  {
    id: 30,
    question: "Что лучше для глобального state с точки зрения производительности?",
    options: [
      "Один большой Context со всем state",
      "Несколько маленьких Context по feature",
      "Redux или Zustand",
      "Варианты B и C"
    ],
    correctAnswer: 3,
    explanation: "Несколько мелких Context или внешняя библиотека (Redux, Zustand) с селекторами - оба подхода позволяют подписываться только на нужные части state. Один большой Context вызывает ререндер всех consumers при любом изменении.",
    topic: "Context Optimization"
  },

  // Тема 8: Key prop оптимизация
  {
    id: 31,
    question: "Как правильный key влияет на производительность?",
    options: [
      "Key не влияет на производительность",
      "Правильный key помогает React эффективно обновлять списки",
      "Key только для предотвращения warning",
      "Key ускоряет рендер компонентов"
    ],
    correctAnswer: 1,
    explanation: "Правильный key позволяет React идентифицировать элементы списка при изменениях (добавление, удаление, перестановка) и переиспользовать DOM узлы вместо пересоздания, что значительно эффективнее.",
    topic: "Keys Optimization"
  },
  {
    id: 32,
    question: "Почему использование index как key - плохая практика для динамических списков?",
    options: [
      "Index не уникален",
      "При изменении порядка элементов React не сможет правильно их идентифицировать",
      "Index замедляет рендер",
      "React не рекомендует использовать numbers как key"
    ],
    correctAnswer: 1,
    explanation: "При использовании index как key, перестановка элементов не изменит key (index остается тем же для позиции). React подумает, что элементы не менялись, и обновит только props, что может вызвать баги с state.",
    topic: "Keys Optimization"
  },
  {
    id: 33,
    question: "Когда можно использовать index как key?",
    options: [
      "Никогда",
      "Когда список статичен (не добавляются, не удаляются, не сортируются элементы)",
      "Только для списков меньше 10 элементов",
      "Всегда можно использовать"
    ],
    correctAnswer: 1,
    explanation: "Index как key допустим только для полностью статичных списков, которые никогда не меняются (не добавляются, не удаляются, не переставляются элементы). В остальных случаях используйте уникальный ID.",
    topic: "Keys Optimization"
  },
  {
    id: 34,
    question: "Что произойдет, если использовать нестабильный key (например, Math.random())?",
    options: [
      "React выбросит ошибку",
      "Элементы будут пересоздаваться при каждом рендере, теряя state",
      "Ничего, это нормальная практика",
      "Производительность улучшится"
    ],
    correctAnswer: 1,
    explanation: "Нестабильный key (Math.random(), Date.now()) меняется при каждом рендере. React считает это новым элементом, размонтирует старый и монтирует новый, теряя state и ухудшая производительность.",
    topic: "Keys Optimization"
  },

  // Тема 9: Lazy loading и Code splitting
  {
    id: 35,
    question: "Что делает React.lazy?",
    options: [
      "Откладывает рендер компонента",
      "Динамически импортирует компонент при первом использовании",
      "Ленивая загрузка данных",
      "Откладывает выполнение effects"
    ],
    correctAnswer: 1,
    explanation: "React.lazy позволяет динамически импортировать компонент (code splitting). Код компонента загружается только когда он впервые рендерится, уменьшая начальный размер bundle.",
    topic: "Lazy Loading"
  },
  {
    id: 36,
    question: "Какой компонент нужен для работы с React.lazy?",
    options: [
      "ErrorBoundary",
      "Suspense",
      "Fragment",
      "StrictMode"
    ],
    correctAnswer: 1,
    explanation: "React.lazy требует оборачивания в Suspense компонент, который показывает fallback UI (например, loader) пока компонент загружается. Без Suspense React выбросит ошибку.",
    topic: "Lazy Loading"
  },
  {
    id: 37,
    question: "Когда использовать React.lazy для оптимизации?",
    options: [
      "Для всех компонентов приложения",
      "Для больших компонентов, которые не нужны при начальной загрузке",
      "Только для страниц роутинга",
      "Никогда, это замедляет приложение"
    ],
    correctAnswer: 1,
    explanation: "React.lazy эффективен для: маршрутов (страниц), модальных окон, тяжелых компонентов (графики, редакторы), которые не нужны сразу. Это уменьшает начальный bundle и ускоряет первую загрузку.",
    topic: "Lazy Loading"
  },
  {
    id: 38,
    question: "Какой недостаток у React.lazy?",
    options: [
      "Не работает с SSR (Server-Side Rendering)",
      "Медленная загрузка компонента",
      "Сложность реализации",
      "Большой размер bundle"
    ],
    correctAnswer: 0,
    explanation: "React.lazy не поддерживает SSR (работает только на клиенте). Для SSR нужно использовать библиотеки типа loadable-components или Next.js dynamic imports с ssr: true.",
    topic: "Lazy Loading"
  },

  // Тема 10: Профилирование и измерение
  {
    id: 39,
    question: "Какой инструмент использовать для профилирования React приложения?",
    options: [
      "console.log",
      "React DevTools Profiler",
      "Chrome DevTools Performance",
      "Варианты B и C"
    ],
    correctAnswer: 3,
    explanation: "React DevTools Profiler показывает какие компоненты рендерились, сколько времени заняли, почему. Chrome Performance показывает общую картину: JS execution, layout, paint. Используйте оба для полного анализа.",
    topic: "Профилирование"
  },
  {
    id: 40,
    question: "Что показывает flame graph в React Profiler?",
    options: [
      "Ошибки в приложении",
      "Визуализацию времени рендера компонентов в виде дерева",
      "Использование памяти",
      "Network requests"
    ],
    correctAnswer: 1,
    explanation: "Flame graph визуализирует дерево компонентов, где ширина блока - время рендера. Это помогает быстро найти медленные компоненты. Цвет показывает относительную скорость (желтый - медленнее).",
    topic: "Профилирование"
  },
  {
    id: 41,
    question: "Когда стоит начинать оптимизацию производительности?",
    options: [
      "С самого начала разработки",
      "После измерения и выявления реальных проблем",
      "Перед релизом",
      "Когда пользователи жалуются"
    ],
    correctAnswer: 1,
    explanation: "Правило: измеряй сначала, оптимизируй потом. Преждевременная оптимизация усложняет код без гарантии пользы. Используй Profiler, найди узкие места, оптимизируй их, измерь результат.",
    topic: "Профилирование"
  },
  {
    id: 42,
    question: "Что такое 'why-did-you-render' библиотека?",
    options: [
      "Библиотека для рендера компонентов",
      "Development tool для логирования причин ререндеров",
      "Production optimization library",
      "Testing utility"
    ],
    correctAnswer: 1,
    explanation: "why-did-you-render - dev-only библиотека, которая логирует в консоль когда и почему компоненты ререндерятся (изменились props, state, hooks). Помогает найти ненужные ререндеры.",
    topic: "Профилирование"
  },

  // Тема 11: Продвинутые техники
  {
    id: 43,
    question: "Что такое 'bailout' в React?",
    options: [
      "Ошибка рендера",
      "Механизм пропуска ререндера при неизменном state",
      "Выход из компонента",
      "Отмена side effects"
    ],
    correctAnswer: 1,
    explanation: "Bailout - встроенная оптимизация React. Если setState получает то же значение (Object.is), React пропускает ререндер компонента. Это работает автоматически без memo.",
    topic: "Продвинутые техники"
  },
  {
    id: 44,
    question: "Как работает bailout для объектов в state?",
    options: [
      "Deep comparison объекта",
      "Сравнение по ссылке (Object.is)",
      "Сравнение по JSON.stringify",
      "Bailout не работает для объектов"
    ],
    correctAnswer: 1,
    explanation: "Bailout использует Object.is (сравнение по ссылке). Даже если объект имеет те же данные, но это новая ссылка, bailout не сработает. Нужно вернуть тот же объект: setState(prev => prev).",
    topic: "Продвинутые техники"
  },
  {
    id: 45,
    question: "Что такое 'windowing' (виртуализация) для таблиц?",
    options: [
      "Рендер только видимых строк таблицы",
      "Открытие таблицы в новом окне",
      "Анимация таблицы",
      "Сортировка таблицы"
    ],
    correctAnswer: 0,
    explanation: "Windowing (виртуализация) для таблиц - рендер только видимых строк + небольшой буфер. Для больших таблиц (1000+ строк) это критично. Используйте react-window VariableSizeGrid или react-virtualized.",
    topic: "Продвинутые техники"
  },
  {
    id: 46,
    question: "Что делает флаг 'concurrent mode' в React 18 для производительности?",
    options: [
      "Ускоряет все рендеры",
      "Позволяет React прерывать рендер для обработки срочных обновлений",
      "Использует Web Workers",
      "Включает автоматическую мемоизацию"
    ],
    correctAnswer: 1,
    explanation: "Concurrent mode (React 18) позволяет React прерывать низкоприоритетные рендеры для обработки срочных обновлений (input, clicks), делая UI более отзывчивым. Используется через startTransition, useDeferredValue.",
    topic: "Продвинутые техники"
  },
  {
    id: 47,
    question: "Когда использовать startTransition?",
    options: [
      "Для всех setState вызовов",
      "Для обновлений UI, которые могут подождать (фильтрация, поиск)",
      "Для обработки форм",
      "Для анимаций"
    ],
    correctAnswer: 1,
    explanation: "startTransition помечает обновления state как низкоприоритетные (transitions). Подходит для некритичных обновлений (фильтрация большого списка, поиск), позволяя React сохранить отзывчивость UI.",
    topic: "Продвинутые техники"
  },
  {
    id: 48,
    question: "Что такое useDeferredValue и когда его использовать?",
    options: [
      "Хук для отложенной загрузки данных",
      "Хук для создания отложенной версии значения (debouncing на уровне рендера)",
      "Хук для async/await",
      "Хук для мемоизации"
    ],
    correctAnswer: 1,
    explanation: "useDeferredValue создает отложенную версию значения. Пока идет ререндер с новым значением, React показывает старое, позволяя UI оставаться отзывчивым. Полезно для дорогих вычислений на основе input.",
    topic: "Продвинутые техники"
  },

  // Тема 12: Антипаттерны оптимизации
  {
    id: 49,
    question: "Почему мемоизация всех компонентов - это антипаттерн?",
    options: [
      "Это усложняет код без гарантии выигрыша",
      "Shallow comparison добавляет overhead",
      "Ухудшает читаемость и maintainability",
      "Все перечисленные варианты"
    ],
    correctAnswer: 3,
    explanation: "Мемоизация везде - антипаттерн: усложняет код, добавляет overhead на сравнение, ухудшает читаемость. Если props часто меняются или рендер дешевый, мемоизация замедлит. Измеряйте, оптимизируйте bottlenecks.",
    topic: "Антипаттерны"
  },
  {
    id: 50,
    question: "Какая ошибка в этом коде?\n\nconst Component = React.memo(({ onClick }) => <button onClick={onClick} />);\n\nfunction Parent() {\n  return <Component onClick={() => {}} />;\n}",
    options: [
      "Нет ошибки",
      "onClick создается заново каждый рендер, memo бесполезен",
      "React.memo не работает с функциями",
      "Нужно использовать forwardRef"
    ],
    correctAnswer: 1,
    explanation: "Стрелочная функция создается заново каждый рендер Parent (новая ссылка). React.memo сравнит onClick, увидит изменение и перерендерит Component. Memo бесполезен. Нужен useCallback для onClick.",
    topic: "Антипаттерны"
  }
]
