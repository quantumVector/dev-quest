import type { Question } from '@/types/question.ts'

export const reactMemoCallbackQuestions: Question[] = [
  // Тема 1: Основы useMemo
  {
    id: 1,
    question: "Для чего используется хук useMemo?",
    options: [
      "Для запоминания функций между рендерами",
      "Для мемоизации вычисленных значений между рендерами",
      "Для оптимизации всех операций в компоненте",
      "Для предотвращения ре-рендеров компонента"
    ],
    correctAnswer: 1,
    explanation: "useMemo используется для мемоизации результата вычислений, возвращая кешированное значение до тех пор, пока зависимости не изменятся. Это помогает избежать дорогостоящих вычислений при каждом рендере.",
    topic: "Основы useMemo"
  },
  {
    id: 2,
    question: "Какую сигнатуру имеет хук useMemo?",
    options: [
      "useMemo(value, dependencies)",
      "useMemo(() => value, [dependencies])",
      "useMemo(callback)",
      "useMemo(value)"
    ],
    correctAnswer: 1,
    explanation: "useMemo принимает функцию, которая возвращает значение, и массив зависимостей: useMemo(() => computeExpensiveValue(a, b), [a, b]).",
    topic: "Основы useMemo"
  },
  {
    id: 3,
    question: "Что вернет useMemo при первом рендере?",
    options: [
      "undefined",
      "Результат выполнения переданной функции",
      "Кешированное значение из предыдущего рендера",
      "null"
    ],
    correctAnswer: 1,
    explanation: "При первом рендере useMemo выполняет переданную функцию и возвращает её результат, так как кеша еще не существует.",
    topic: "Основы useMemo"
  },
  {
    id: 4,
    question: "Когда useMemo пересчитывает значение?",
    options: [
      "При каждом рендере компонента",
      "Только когда изменяются зависимости из массива deps",
      "Никогда после первого рендера",
      "Случайным образом для оптимизации"
    ],
    correctAnswer: 1,
    explanation: "useMemo пересчитывает значение только когда хотя бы одна из зависимостей в массиве deps изменилась (используется Object.is для сравнения).",
    topic: "Основы useMemo"
  },
  {
    id: 5,
    question: "Что произойдет, если не передать массив зависимостей в useMemo?",
    options: [
      "Значение будет вычисляться при каждом рендере",
      "Значение вычислится один раз и никогда не обновится",
      "React выдаст ошибку",
      "useMemo будет игнорироваться"
    ],
    correctAnswer: 0,
    explanation: "Без массива зависимостей useMemo будет вычислять новое значение при каждом рендере, что делает его бесполезным для мемоизации.",
    topic: "Основы useMemo"
  },
  {
    id: 6,
    question: "Что произойдет, если передать пустой массив зависимостей []?",
    options: [
      "Значение вычислится при каждом рендере",
      "Значение вычислится только один раз при монтировании",
      "React выдаст предупреждение",
      "useMemo не будет работать"
    ],
    correctAnswer: 1,
    explanation: "С пустым массивом зависимостей [] значение вычислится только при первом рендере (монтировании) и будет возвращать тот же результат при последующих рендерах.",
    topic: "Основы useMemo"
  },

  // Тема 2: Основы useCallback
  {
    id: 7,
    question: "Для чего используется хук useCallback?",
    options: [
      "Для мемоизации вычисленных значений",
      "Для мемоизации функций между рендерами",
      "Для вызова функций при изменении зависимостей",
      "Для создания асинхронных функций"
    ],
    correctAnswer: 1,
    explanation: "useCallback возвращает мемоизированную версию callback-функции, которая изменяется только если изменились зависимости. Это предотвращает создание новой функции при каждом рендере.",
    topic: "Основы useCallback"
  },
  {
    id: 8,
    question: "Какую сигнатуру имеет хук useCallback?",
    options: [
      "useCallback(fn, [dependencies])",
      "useCallback(() => fn, dependencies)",
      "useCallback(value, [dependencies])",
      "useCallback([dependencies], fn)"
    ],
    correctAnswer: 0,
    explanation: "useCallback принимает функцию и массив зависимостей: useCallback((arg) => { doSomething(arg) }, [dependency]).",
    topic: "Основы useCallback"
  },
  {
    id: 9,
    question: "В чем главное отличие useCallback от useMemo?",
    options: [
      "useCallback работает быстрее",
      "useCallback мемоизирует саму функцию, useMemo — результат выполнения функции",
      "useMemo используется только для примитивов",
      "Нет отличий, это синонимы"
    ],
    correctAnswer: 1,
    explanation: "useCallback возвращает саму мемоизированную функцию, а useMemo возвращает результат выполнения функции. По сути useCallback(fn, deps) эквивалентен useMemo(() => fn, deps).",
    topic: "Основы useCallback"
  },
  {
    id: 10,
    question: "Что вернет useCallback при первом рендере?",
    options: [
      "undefined",
      "Переданную функцию",
      "Результат выполнения функции",
      "null"
    ],
    correctAnswer: 1,
    explanation: "При первом рендере useCallback возвращает переданную функцию. При последующих рендерах будет возвращать ту же ссылку на функцию, если зависимости не изменились.",
    topic: "Основы useCallback"
  },
  {
    id: 11,
    question: "Когда useCallback возвращает новую функцию?",
    options: [
      "При каждом рендере",
      "Только когда изменяются зависимости",
      "Никогда",
      "При размонтировании компонента"
    ],
    correctAnswer: 1,
    explanation: "useCallback возвращает новую функцию только когда одна из зависимостей в массиве deps изменилась.",
    topic: "Основы useCallback"
  },

  // Тема 3: Когда использовать useMemo
  {
    id: 12,
    question: "В каком случае useMemo действительно полезен?",
    options: [
      "Для всех вычислений в компоненте",
      "Для дорогостоящих вычислений или предотвращения пересоздания объектов",
      "Только для примитивных значений",
      "Никогда, это устаревший хук"
    ],
    correctAnswer: 1,
    explanation: "useMemo полезен для дорогостоящих вычислений (сложные расчеты, фильтрация больших массивов) и для сохранения ссылочной идентичности объектов/массивов, передаваемых как пропсы или зависимости.",
    topic: "Когда использовать useMemo"
  },
  {
    id: 13,
    question: "Стоит ли оборачивать в useMemo простые вычисления?",
    options: [
      "Да, всегда для оптимизации",
      "Нет, накладные расходы на мемоизацию могут превысить выгоду",
      "Только в production режиме",
      "Только для строк и чисел"
    ],
    correctAnswer: 1,
    explanation: "Для простых вычислений (сложение чисел, конкатенация строк) useMemo не нужен, так как сам механизм мемоизации имеет накладные расходы, которые могут быть больше, чем стоимость вычислений.",
    topic: "Когда использовать useMemo"
  },
  {
    id: 14,
    question: "Зачем использовать useMemo для объектов или массивов?",
    options: [
      "Для экономии памяти",
      "Для сохранения ссылочной идентичности между рендерами",
      "Для ускорения создания объектов",
      "Это не имеет смысла"
    ],
    correctAnswer: 1,
    explanation: "useMemo для объектов/массивов сохраняет ссылочную идентичность. Это важно, если они передаются как пропсы в React.memo компоненты или используются как зависимости в других хуках.",
    topic: "Когда использовать useMemo"
  },
  {
    id: 15,
    question: "Что выведет этот код?\n\nconst obj = { count: 1 };\n// При каждом рендере\n<Child data={obj} />",
    options: [
      "Child не ре-рендерится",
      "Child ре-рендерится при каждом рендере родителя",
      "Child ре-рендерится только при изменении count",
      "Ошибка"
    ],
    correctAnswer: 1,
    explanation: "Объект { count: 1 } создается заново при каждом рендере родителя, получая новую ссылку. Даже если Child обернут в React.memo, он будет ре-рендериться, так как пропс data имеет новую ссылку.",
    topic: "Когда использовать useMemo"
  },
  {
    id: 16,
    question: "Как правильно мемоизировать объект для передачи в дочерний компонент?",
    options: [
      "const obj = useMemo(() => ({ count }), [count])",
      "const obj = useCallback({ count }, [count])",
      "const obj = { count }",
      "const obj = memo({ count })"
    ],
    correctAnswer: 0,
    explanation: "useMemo(() => ({ count }), [count]) создаст объект один раз и будет возвращать ту же ссылку до тех пор, пока count не изменится.",
    topic: "Когда использовать useMemo"
  },

  // Тема 4: Когда использовать useCallback
  {
    id: 17,
    question: "Когда useCallback действительно полезен?",
    options: [
      "Для всех функций в компоненте",
      "Когда функция передается как пропс в мемоизированный компонент или используется как зависимость",
      "Только для обработчиков событий",
      "Никогда"
    ],
    correctAnswer: 1,
    explanation: "useCallback полезен когда функция передается в React.memo компонент или используется как зависимость в useEffect/useMemo/useCallback, где важна ссылочная идентичность.",
    topic: "Когда использовать useCallback"
  },
  {
    id: 18,
    question: "Нужен ли useCallback для обычных обработчиков событий?",
    options: [
      "Да, всегда",
      "Нет, если функция не передается как пропс или зависимость",
      "Только для onClick",
      "Только в классовых компонентах"
    ],
    correctAnswer: 1,
    explanation: "Для обработчиков событий (onClick, onChange) в том же компоненте useCallback обычно не нужен. Создание новой функции при каждом рендере не является проблемой производительности.",
    topic: "Когда использовать useCallback"
  },
  {
    id: 19,
    question: "Что произойдет в этом коде?\n\nfunction Parent() {\n  const handleClick = () => console.log('click');\n  return <Child onClick={handleClick} />;\n}",
    options: [
      "Child не ре-рендерится",
      "Child ре-рендерится при каждом рендере Parent",
      "Ошибка выполнения",
      "Child ре-рендерится только при клике"
    ],
    correctAnswer: 1,
    explanation: "handleClick создается заново при каждом рендере Parent, получая новую ссылку. Если Child обернут в React.memo, он все равно будет ре-рендериться из-за нового пропса onClick.",
    topic: "Когда использовать useCallback"
  },
  {
    id: 20,
    question: "Как правильно мемоизировать обработчик для React.memo компонента?",
    options: [
      "const handleClick = useCallback(() => { ... }, [])",
      "const handleClick = useMemo(() => { ... }, [])",
      "const handleClick = memo(() => { ... })",
      "const handleClick = () => { ... }"
    ],
    correctAnswer: 0,
    explanation: "useCallback(() => { ... }, [deps]) вернет мемоизированную функцию, которая не изменится между рендерами, если зависимости не изменились.",
    topic: "Когда использовать useCallback"
  },

  // Тема 5: Массив зависимостей
  {
    id: 21,
    question: "Что произойдет, если забыть добавить зависимость в массив deps?",
    options: [
      "React выдаст ошибку",
      "Функция/значение может использовать устаревшие данные (stale closure)",
      "Ничего, это не важно",
      "Компонент не отрендерится"
    ],
    correctAnswer: 1,
    explanation: "Если не добавить зависимость в deps, может возникнуть проблема stale closure — функция будет использовать старые значения переменных из замыкания.",
    topic: "Массив зависимостей"
  },
  {
    id: 22,
    question: "Какое правило следует соблюдать при указании зависимостей?",
    options: [
      "Включать только примитивы",
      "Включать все значения из компонента, используемые внутри функции",
      "Никогда не включать функции",
      "Использовать только константы"
    ],
    correctAnswer: 1,
    explanation: "Все значения из области видимости компонента, которые используются внутри callback-функции или вычисления, должны быть перечислены в deps. Это правило помогает соблюдать ESLint plugin.",
    topic: "Массив зависимостей"
  },
  {
    id: 23,
    question: "Что делать, если зависимость — это объект или функция?",
    options: [
      "Никогда не добавлять в deps",
      "Добавлять в deps, но убедиться что она мемоизирована",
      "Создавать новый объект при каждом рендере",
      "Использовать JSON.stringify"
    ],
    correctAnswer: 1,
    explanation: "Объекты и функции можно добавлять в deps, но они сами должны быть мемоизированы (useMemo/useCallback), иначе зависимость будет считаться измененной при каждом рендере.",
    topic: "Массив зависимостей"
  },
  {
    id: 24,
    question: "Что произойдет в этом коде?\n\nconst obj = { x: 1 };\nuseMemo(() => obj.x * 2, [obj])",
    options: [
      "Значение пересчитается при изменении x",
      "Значение пересчитается при каждом рендере",
      "Значение вычислится один раз",
      "Ошибка выполнения"
    ],
    correctAnswer: 1,
    explanation: "obj создается заново при каждом рендере, поэтому считается новым значением. useMemo будет пересчитывать значение каждый раз. Нужно мемоизировать сам obj или добавить в deps obj.x.",
    topic: "Массив зависимостей"
  },
  {
    id: 25,
    question: "Какой ESLint rule помогает с зависимостями?",
    options: [
      "react/no-unused-deps",
      "react-hooks/exhaustive-deps",
      "react/deps-required",
      "react-hooks/deps-array"
    ],
    correctAnswer: 1,
    explanation: "Правило react-hooks/exhaustive-deps предупреждает о пропущенных зависимостях в useEffect, useMemo, useCallback и предлагает их добавить.",
    topic: "Массив зависимостей"
  },

  // Тема 6: Антипаттерны и частые ошибки
  {
    id: 26,
    question: "Является ли антипаттерном оборачивание всех значений в useMemo?",
    options: [
      "Нет, это best practice",
      "Да, это преждевременная оптимизация",
      "Только в development режиме",
      "Зависит от размера компонента"
    ],
    correctAnswer: 1,
    explanation: "Оборачивание всех значений в useMemo — это преждевременная оптимизация. Мемоизация имеет свои накладные расходы и должна применяться только там, где действительно нужна.",
    topic: "Антипаттерны"
  },
  {
    id: 27,
    question: "Что не так с этим кодом?\n\nconst memoized = useMemo(() => {\n  setValue(value + 1);\n  return value;\n}, [value])",
    options: [
      "Все правильно",
      "В useMemo не должно быть побочных эффектов (вызова setState)",
      "Должен быть useCallback вместо useMemo",
      "Не хватает зависимостей"
    ],
    correctAnswer: 1,
    explanation: "useMemo должен быть чистой функцией без побочных эффектов. Для побочных эффектов используйте useEffect. React может вызывать функцию useMemo несколько раз.",
    topic: "Антипаттерны"
  },
  {
    id: 28,
    question: "Что не так с этим кодом?\n\nconst handleClick = useCallback(() => {\n  console.log(count);\n}, [])",
    options: [
      "Все правильно",
      "count не указан в deps, будет stale closure",
      "Нужен useMemo вместо useCallback",
      "Нельзя использовать console.log"
    ],
    correctAnswer: 1,
    explanation: "count должен быть в массиве зависимостей. Без этого функция всегда будет использовать значение count из первого рендера (stale closure).",
    topic: "Антипаттерны"
  },
  {
    id: 29,
    question: "Нужно ли мемоизировать примитивные значения (строки, числа)?",
    options: [
      "Да, всегда",
      "Нет, примитивы сравниваются по значению, мемоизация бессмысленна",
      "Только строки",
      "Только числа"
    ],
    correctAnswer: 1,
    explanation: "Примитивы в JavaScript сравниваются по значению, поэтому мемоизация через useMemo не имеет смысла для простых вычислений примитивов.",
    topic: "Антипаттерны"
  },
  {
    id: 30,
    question: "Что произойдет если использовать useMemo для API вызова?\n\nconst data = useMemo(() => fetch('/api'), [])",
    options: [
      "Данные загрузятся один раз",
      "Это антипаттерн, для API вызовов используйте useEffect",
      "Данные будут кешироваться правильно",
      "Ничего плохого"
    ],
    correctAnswer: 1,
    explanation: "useMemo предназначен для синхронных вычислений. Для асинхронных операций (API вызовы, таймеры) используйте useEffect. React может вызывать функцию useMemo произвольное количество раз.",
    topic: "Антипаттерны"
  },

  // Тема 7: useMemo vs React.memo
  {
    id: 31,
    question: "В чем разница между useMemo и React.memo?",
    options: [
      "Нет разницы",
      "useMemo — хук для мемоизации значений, React.memo — HOC для мемоизации компонентов",
      "React.memo быстрее",
      "useMemo работает только с функциями"
    ],
    correctAnswer: 1,
    explanation: "useMemo — это хук для мемоизации вычисленных значений внутри компонента. React.memo — это Higher-Order Component для мемоизации всего компонента, предотвращающий его ре-рендер.",
    topic: "useMemo vs React.memo"
  },
  {
    id: 32,
    question: "Можно ли использовать useMemo вместо React.memo?",
    options: [
      "Да, они взаимозаменяемы",
      "Нет, у них разное назначение",
      "Только для функциональных компонентов",
      "Только в React 18+"
    ],
    correctAnswer: 1,
    explanation: "useMemo мемоизирует результат вычислений внутри компонента, React.memo мемоизирует сам компонент, пропуская ре-рендер если пропсы не изменились. Это разные инструменты для разных задач.",
    topic: "useMemo vs React.memo"
  },
  {
    id: 33,
    question: "Когда нужно использовать и useMemo, и React.memo вместе?",
    options: [
      "Никогда",
      "Когда передаете мемоизированные объекты/функции в мемоизированный компонент",
      "Всегда для максимальной оптимизации",
      "Только в production"
    ],
    correctAnswer: 1,
    explanation: "Если компонент обернут в React.memo, но получает объект/функцию как проп, этот проп должен быть мемоизирован (useMemo/useCallback), иначе React.memo не даст эффекта.",
    topic: "useMemo vs React.memo"
  },

  // Тема 8: Производительность
  {
    id: 34,
    question: "Всегда ли useMemo улучшает производительность?",
    options: [
      "Да, всегда",
      "Нет, иногда накладные расходы превышают выгоду",
      "Только в production",
      "Только для больших компонентов"
    ],
    correctAnswer: 1,
    explanation: "useMemo имеет накладные расходы (хранение значения в памяти, сравнение зависимостей). Для простых вычислений эти расходы могут превысить стоимость самих вычислений.",
    topic: "Производительность"
  },
  {
    id: 35,
    question: "Как измерить, нужен ли useMemo для конкретного случая?",
    options: [
      "Использовать React DevTools Profiler",
      "Угадать по размеру кода",
      "Всегда использовать useMemo для безопасности",
      "Никак, это невозможно"
    ],
    correctAnswer: 0,
    explanation: "React DevTools Profiler позволяет измерить время рендеров и увидеть, действительно ли мемоизация уменьшает время выполнения.",
    topic: "Производительность"
  },
  {
    id: 36,
    question: "Сколько памяти потребляет useMemo?",
    options: [
      "Нисколько",
      "Память для хранения мемоизированного значения и массива зависимостей",
      "1 КБ фиксированно",
      "Зависит от размера компонента"
    ],
    correctAnswer: 1,
    explanation: "useMemo хранит в памяти мемоизированное значение и массив зависимостей. Для больших объектов или массивов это может быть значительный объем памяти.",
    topic: "Производительность"
  },
  {
    id: 37,
    question: "Влияет ли количество useMemo в компоненте на производительность?",
    options: [
      "Нет, можно использовать сколько угодно",
      "Да, каждый useMemo добавляет накладные расходы",
      "Только в development режиме",
      "Влияет только после 10+ использований"
    ],
    correctAnswer: 1,
    explanation: "Каждый useMemo добавляет накладные расходы на сравнение зависимостей и хранение в памяти. Чрезмерное использование может негативно повлиять на производительность.",
    topic: "Производительность"
  },

  // Тема 9: Практические примеры
  {
    id: 38,
    question: "Как правильно мемоизировать фильтрацию большого массива?",
    options: [
      "const filtered = items.filter(item => item.active)",
      "const filtered = useMemo(() => items.filter(item => item.active), [items])",
      "const filtered = useCallback(() => items.filter(item => item.active), [items])",
      "const filtered = memo(items.filter(item => item.active))"
    ],
    correctAnswer: 1,
    explanation: "useMemo(() => items.filter(...), [items]) пересчитает отфильтрованный массив только когда items изменится, избегая повторной фильтрации при каждом рендере.",
    topic: "Практические примеры"
  },
  {
    id: 39,
    question: "Как правильно мемоизировать сортировку массива?",
    options: [
      "const sorted = [...items].sort()",
      "const sorted = useMemo(() => [...items].sort(), [items])",
      "const sorted = items.sort()",
      "const sorted = useCallback(() => items.sort(), [items])"
    ],
    correctAnswer: 1,
    explanation: "useMemo(() => [...items].sort(), [items]) выполнит сортировку только при изменении items. Важно создать копию массива [...items], так как sort мутирует оригинал.",
    topic: "Практические примеры"
  },
  {
    id: 40,
    question: "Как правильно мемоизировать обработчик с параметрами?\n\nconst handleClick = (id) => { ... }",
    options: [
      "const handleClick = useCallback((id) => { ... }, [])",
      "const handleClick = (id) => useCallback(() => { ... }, [id])",
      "const handleClick = useCallback((id) => { ... }, [id])",
      "Нельзя мемоизировать функции с параметрами"
    ],
    correctAnswer: 0,
    explanation: "Параметры функции не нужно добавлять в deps. В deps добавляются только значения из замыкания компонента, которые используются внутри функции: useCallback((id) => { doSmth(id, count) }, [count]).",
    topic: "Практические примеры"
  }
]
