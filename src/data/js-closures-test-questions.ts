import type { Question } from '@/types/question.ts'

export const jsClosuresQuestions: Question[] = [
  // Тема 1: Что такое замыкание?
  {
    id: 1,
    question: "Что такое замыкание (closure) в JavaScript?",
    options: [
      "Функция, которая возвращает другую функцию",
      "Функция, которая имеет доступ к переменным из внешней области видимости даже после завершения выполнения внешней функции",
      "Функция, которая вызывает саму себя",
      "Функция, которая не имеет параметров"
    ],
    correctAnswer: 1,
    explanation: "Замыкание — это функция, которая имеет доступ к переменным из внешней (лексической) области видимости даже после того, как внешняя функция завершила выполнение. Замыкание 'замыкает' переменные из внешнего контекста.",
    topic: "Основы замыканий"
  },
  {
    id: 2,
    question: "Что произойдет при выполнении этого кода?\n\nfunction outer() {\n  let x = 10;\n  return function inner() {\n    console.log(x);\n  };\n}\n\nconst closure = outer();\nclosure();",
    options: [
      "Выведет undefined",
      "Выведет 10",
      "Выдаст ошибку ReferenceError",
      "Выведет null"
    ],
    correctAnswer: 1,
    explanation: "Внутренняя функция inner создает замыкание и сохраняет доступ к переменной x из внешней функции outer, даже после завершения выполнения outer(). Поэтому выведется 10.",
    topic: "Основы замыканий"
  },
  {
    id: 3,
    question: "В каком случае НЕ создается замыкание?",
    options: [
      "Когда внутренняя функция обращается к переменным внешней функции",
      "Когда внутренняя функция возвращается из внешней функции",
      "Когда внутренняя функция использует только свои локальные переменные и параметры",
      "Когда внутренняя функция передается как callback"
    ],
    correctAnswer: 2,
    explanation: "Замыкание создается только когда внутренняя функция ссылается на переменные из внешней области видимости. Если функция использует только свои локальные переменные и параметры, замыкание не создается.",
    topic: "Основы замыканий"
  },
  {
    id: 4,
    question: "Какую проблему решают замыкания в JavaScript?",
    options: [
      "Ускоряют выполнение программы",
      "Позволяют создавать приватные переменные и инкапсулировать данные",
      "Уменьшают использование памяти",
      "Упрощают синтаксис функций"
    ],
    correctAnswer: 1,
    explanation: "Замыкания позволяют создавать приватные переменные и методы, инкапсулируя данные внутри функции. Это один из основных паттернов для создания модулей и защиты данных от внешнего доступа.",
    topic: "Основы замыканий"
  },
  {
    id: 5,
    question: "Что выведет этот код?\n\nfunction createCounter() {\n  let count = 0;\n  return function() {\n    return ++count;\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\nconsole.log(counter1()); // ?\nconsole.log(counter1()); // ?\nconsole.log(counter2()); // ?",
    options: [
      "1, 2, 3",
      "1, 2, 1",
      "1, 1, 1",
      "0, 1, 2"
    ],
    correctAnswer: 1,
    explanation: "Каждый вызов createCounter() создает новое лексическое окружение с собственной переменной count. counter1 и counter2 — это независимые замыкания с собственными счетчиками.",
    topic: "Основы замыканий"
  },

  // Тема 2: Лексическое окружение (LexicalEnvironment) переменной
  {
    id: 6,
    question: "Что такое лексическое окружение (Lexical Environment) в JavaScript?",
    options: [
      "Место в коде, где объявлена переменная",
      "Структура данных, которая содержит переменные и ссылку на внешнее окружение",
      "Область памяти для хранения функций",
      "Контекст выполнения функции"
    ],
    correctAnswer: 1,
    explanation: "Лексическое окружение — это структура данных, состоящая из Environment Record (записи переменных) и ссылки на внешнее лексическое окружение. Оно определяет, какие переменные доступны в конкретном месте кода.",
    topic: "Лексическое окружение"
  },
  {
    id: 7,
    question: "Когда создается новое лексическое окружение?",
    options: [
      "Только при вызове функции",
      "При объявлении переменной",
      "При выполнении функции, блока кода или модуля",
      "При создании объекта"
    ],
    correctAnswer: 2,
    explanation: "Новое лексическое окружение создается при выполнении функции, блока кода (например, внутри {}) или модуля. Каждое такое окружение имеет свой набор переменных и ссылку на внешнее окружение.",
    topic: "Лексическое окружение"
  },
  {
    id: 8,
    question: "Что происходит с лексическим окружением функции после завершения её выполнения?",
    options: [
      "Оно всегда удаляется из памяти",
      "Оно сохраняется, если на него есть ссылки через замыкания",
      "Оно превращается в глобальное окружение",
      "Оно объединяется с родительским окружением"
    ],
    correctAnswer: 1,
    explanation: "Лексическое окружение функции сохраняется в памяти, если на него есть ссылки через замыкания. Это позволяет внутренним функциям обращаться к переменным внешней функции даже после её завершения.",
    topic: "Лексическое окружение"
  },
  {
    id: 9,
    question: "Как происходит поиск переменной в лексических окружениях?",
    options: [
      "Поиск начинается с глобального окружения",
      "Поиск происходит случайным образом",
      "Поиск начинается с текущего окружения и идет вверх по цепочке до глобального",
      "Поиск происходит только в текущем окружении"
    ],
    correctAnswer: 2,
    explanation: "При поиске переменной JavaScript начинает с текущего лексического окружения и, если переменная не найдена, поднимается по цепочке внешних окружений до глобального. Это называется scope chain (цепочка областей видимости).",
    topic: "Лексическое окружение"
  },
  {
    id: 10,
    question: "Что произойдет в этом коде?\n\nlet x = 'global';\nfunction outer() {\n  let x = 'outer';\n  function inner() {\n    console.log(x);\n  }\n  return inner;\n}\nouter()();",
    options: [
      "Выведет 'global'",
      "Выведет 'outer'",
      "Выдаст ошибку",
      "Выведет undefined"
    ],
    correctAnswer: 1,
    explanation: "Функция inner ищет переменную x в своем лексическом окружении, не находит, затем ищет во внешнем окружении (функция outer) и находит там 'outer'. Глобальная переменная x игнорируется из-за затенения (shadowing).",
    topic: "Лексическое окружение"
  },

  // Тема 3: В какой момент создаётся лексическое окружение функции
  {
    id: 11,
    question: "В какой момент создается лексическое окружение функции?",
    options: [
      "В момент объявления функции",
      "В момент вызова функции",
      "В момент компиляции скрипта",
      "В момент первого обращения к переменной внутри функции"
    ],
    correctAnswer: 1,
    explanation: "Лексическое окружение функции создается в момент её вызова, а не объявления. При объявлении функция запоминает ссылку на внешнее лексическое окружение, а собственное создает при выполнении.",
    topic: "Момент создания окружения"
  },
  {
    id: 12,
    question: "Что происходит с замыканием при каждом вызове внешней функции?",
    options: [
      "Используется то же самое лексическое окружение",
      "Создается новое лексическое окружение",
      "Лексическое окружение обновляется",
      "Замыкание не создается при повторных вызовах"
    ],
    correctAnswer: 1,
    explanation: "При каждом вызове внешней функции создается новое лексическое окружение, поэтому каждое замыкание имеет доступ к своему уникальному набору переменных. Это объясняет, почему разные экземпляры замыканий независимы.",
    topic: "Момент создания окружения"
  },
  {
    id: 13,
    question: "Что выведет этот код?\n\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}",
    options: [
      "0, 1, 2",
      "3, 3, 3",
      "undefined, undefined, undefined",
      "0, 0, 0"
    ],
    correctAnswer: 1,
    explanation: "Все функции в setTimeout создают замыкания над одной и той же переменной i (var имеет функциональную область видимости). К моменту выполнения setTimeout цикл завершен и i равно 3, поэтому выведется 3, 3, 3.",
    topic: "Момент создания окружения"
  },
  {
    id: 14,
    question: "Как исправить предыдущий пример, чтобы вывелось 0, 1, 2?",
    options: [
      "Использовать let вместо var",
      "Обернуть setTimeout в IIFE с передачей i",
      "Использовать bind для привязки значения i",
      "Все вышеперечисленные способы"
    ],
    correctAnswer: 3,
    explanation: "Все три способа решают проблему: let создает новое лексическое окружение для каждой итерации; IIFE создает новую область видимости; bind создает новую функцию с привязанным значением.",
    topic: "Момент создания окружения"
  },
  {
    id: 15,
    question: "Что произойдет в этом коде?\n\nfunction test() {\n  console.log(typeof myFunc);\n  var myFunc = function() {};\n  console.log(typeof myFunc);\n}\ntest();",
    options: [
      "undefined, function",
      "function, function",
      "undefined, undefined",
      "ReferenceError"
    ],
    correctAnswer: 0,
    explanation: "Переменная myFunc поднимается (hoisting) в начало функции и инициализируется как undefined. Первый console.log выведет 'undefined', а второй — 'function', так как к тому моменту функция уже присвоена.",
    topic: "Момент создания окружения"
  },
  {
    id: 16,
    question: "В чем разница между этими двумя подходами к созданию замыканий?\n\n// Подход 1\nfunction createFunction() {\n  var x = 1;\n  return function() { console.log(x); };\n}\n\n// Подход 2\nvar x = 1;\nfunction createFunction() {\n  return function() { console.log(x); };\n}",
    options: [
      "Никакой разницы нет",
      "В первом подходе каждое замыкание имеет свою копию x, во втором — все используют одну переменную",
      "Второй подход работает быстрее",
      "Первый подход создает memory leak"
    ],
    correctAnswer: 1,
    explanation: "В первом подходе каждый вызов createFunction() создает новое лексическое окружение с собственной переменной x. Во втором — все замыкания ссылаются на одну глобальную переменную x.",
    topic: "Момент создания окружения"
  },
  {
    id: 17,
    question: "Что такое 'утечка памяти' в контексте замыканий?",
    options: [
      "Когда замыкание обращается к несуществующей переменной",
      "Когда замыкание удерживает ссылки на большие объекты, которые больше не нужны",
      "Когда создается слишком много замыканий",
      "Когда замыкание вызывает само себя"
    ],
    correctAnswer: 1,
    explanation: "Утечка памяти происходит, когда замыкание удерживает ссылки на большие объекты или DOM-элементы через лексическое окружение, даже когда эти объекты больше не нужны. Это препятствует сборке мусора.",
    topic: "Момент создания окружения"
  },
  {
    id: 18,
    question: "Какой паттерн лучше использовать для создания модуля с приватными переменными?",
    options: [
      "Глобальные переменные",
      "IIFE (Immediately Invoked Function Expression) с замыканием",
      "Только классы ES6",
      "Переменные в прототипе"
    ],
    correctAnswer: 1,
    explanation: "IIFE с замыканием — классический паттерн для создания модулей с приватными переменными. Внешняя функция создает изолированное окружение, а возвращаемый объект предоставляет публичный API.",
    topic: "Момент создания окружения"
  },
  {
    id: 19,
    question: "Что выведет этот код?\n\nfunction outer() {\n  let a = 1;\n  let b = 2;\n  return function inner() {\n    console.log(a);\n    // переменная b не используется\n  };\n}\nconst closure = outer();",
    options: [
      "Замыкание будет содержать только переменную a",
      "Замыкание будет содержать обе переменные a и b",
      "Замыкание не будет содержать никаких переменных",
      "Поведение зависит от браузера"
    ],
    correctAnswer: 1,
    explanation: "Современные JavaScript движки оптимизируют замыкания и включают в них только те переменные, которые действительно используются внутренней функцией. В данном случае будет сохранена только переменная a.",
    topic: "Момент создания окружения"
  },
  {
    id: 20,
    question: "Как правильно освободить память, занятую замыканием?",
    options: [
      "Вызвать delete на замыкании",
      "Присвоить замыканию значение null",
      "Использовать garbage collector вручную",
      "Память освобождается автоматически"
    ],
    correctAnswer: 1,
    explanation: "Чтобы освободить память, занятую замыканием, нужно убрать все ссылки на функцию-замыкание, присвоив переменным значение null. После этого сборщик мусора сможет очистить лексическое окружение.",
    topic: "Момент создания окружения"
  }
]
