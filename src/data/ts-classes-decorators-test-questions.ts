import type { Question } from '@/types/question.ts'

export const tsClassesDecoratorsQuestions: Question[] = [
  // Тема 1: Основы классов в TypeScript
  {
    id: 1,
    question: "Какое главное отличие классов TypeScript от классов JavaScript?",
    options: [
      "TypeScript классы быстрее работают",
      "TypeScript добавляет модификаторы доступа и типизацию",
      "TypeScript классы не поддерживают наследование",
      "TypeScript классы компилируются в функции"
    ],
    correctAnswer: 1,
    explanation: "TypeScript расширяет возможности классов JavaScript, добавляя модификаторы доступа (public, private, protected), статическую типизацию свойств и методов, абстрактные классы и другие возможности.",
    topic: "Основы классов"
  },
  {
    id: 2,
    question: "Что произойдет с этим кодом?\n\nclass Person {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}",
    options: [
      "Ошибка компиляции",
      "Скомпилируется успешно",
      "name будет undefined",
      "Нужно добавить модификатор доступа"
    ],
    correctAnswer: 1,
    explanation: "Код корректен. В TypeScript можно явно объявлять свойства класса с их типами перед конструктором. Если модификатор доступа не указан, по умолчанию используется public.",
    topic: "Основы классов"
  },
  {
    id: 3,
    question: "Как можно упростить объявление свойств в конструкторе?\n\nclass User {\n  name: string\n  age: number\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n}",
    options: [
      "Использовать parameter properties",
      "Использовать spread оператор",
      "Использовать Object.assign",
      "Нельзя упростить"
    ],
    correctAnswer: 0,
    explanation: "Parameter properties позволяют объявлять и инициализировать свойства одновременно в параметрах конструктора: constructor(public name: string, public age: number) {}. TypeScript автоматически создаст свойства и присвоит им значения.",
    topic: "Основы классов"
  },
  {
    id: 4,
    question: "Что такое readonly модификатор в классах?",
    options: [
      "Свойство можно изменить только в конструкторе",
      "Свойство видно только внутри класса",
      "Свойство нельзя удалить",
      "Свойство можно читать, но не записывать нигде"
    ],
    correctAnswer: 0,
    explanation: "readonly свойства можно инициализировать только при объявлении или в конструкторе. После инициализации их значение нельзя изменить. Это защита на уровне типов, в runtime ограничения нет.",
    topic: "Основы классов"
  },
  {
    id: 5,
    question: "Какой модификатор доступа используется по умолчанию?",
    options: [
      "private",
      "protected",
      "public",
      "internal"
    ],
    correctAnswer: 2,
    explanation: "Если модификатор доступа не указан явно, TypeScript использует public по умолчанию. Это означает, что свойство или метод доступны везде.",
    topic: "Основы классов"
  },

  // Тема 2: Модификаторы доступа
  {
    id: 6,
    question: "В чем разница между private и protected?",
    options: [
      "Никакой разницы нет",
      "private доступен в классе, protected — в классе и наследниках",
      "protected более строгий чем private",
      "private работает в runtime, protected — нет"
    ],
    correctAnswer: 1,
    explanation: "private члены доступны только внутри самого класса. protected члены доступны в классе и во всех его наследниках. Это ограничения уровня типов, в скомпилированном JavaScript они не работают.",
    topic: "Модификаторы доступа"
  },
  {
    id: 7,
    question: "Что произойдет с этим кодом?\n\nclass Base {\n  private secret = 'base'\n}\n\nclass Derived extends Base {\n  showSecret() {\n    console.log(this.secret)\n  }\n}",
    options: [
      "Выведет 'base'",
      "Ошибка компиляции",
      "Выведет undefined",
      "Ошибка в runtime"
    ],
    correctAnswer: 1,
    explanation: "Код не скомпилируется, так как private члены недоступны в наследниках. Для доступа в наследниках нужно использовать protected вместо private.",
    topic: "Модификаторы доступа"
  },
  {
    id: 8,
    question: "Как сделать приватное свойство, которое будет приватным и в runtime?",
    options: [
      "Использовать private",
      "Использовать #property синтаксис",
      "Использовать _property",
      "Нельзя сделать"
    ],
    correctAnswer: 1,
    explanation: "TypeScript поддерживает ES2022 private fields синтаксис (#property), который работает и в runtime. В отличие от модификатора private, который существует только на уровне типов.",
    topic: "Модификаторы доступа"
  },
  {
    id: 9,
    question: "В чем разница между private и #private?",
    options: [
      "Никакой разницы нет",
      "private — только типы, #private — и runtime",
      "#private работает только в строгом режиме",
      "private более производительный"
    ],
    correctAnswer: 1,
    explanation: "Модификатор private — это особенность TypeScript, которая проверяется только при компиляции. #private — это ES2022 private fields, которые действительно приватны в runtime и недоступны извне даже через bracket notation.",
    topic: "Модификаторы доступа"
  },
  {
    id: 10,
    question: "Можно ли получить доступ к private свойству через bracket notation в runtime?",
    options: [
      "Нет, никогда",
      "Да, для TypeScript private, но не для #private",
      "Да, для обоих",
      "Только в нестрогом режиме"
    ],
    correctAnswer: 1,
    explanation: "TypeScript модификатор private существует только на уровне типов. В скомпилированном коде можно обратиться к такому свойству через obj['property']. Но #private поля действительно недоступны в runtime.",
    topic: "Модификаторы доступа"
  },

  // Тема 3: Статические члены и абстрактные классы
  {
    id: 11,
    question: "Что такое статические члены класса?",
    options: [
      "Члены, которые нельзя изменить",
      "Члены, принадлежащие классу, а не экземпляру",
      "Члены с модификатором private",
      "Члены, которые вычисляются один раз"
    ],
    correctAnswer: 1,
    explanation: "Статические члены (static) принадлежат самому классу, а не его экземплярам. К ним обращаются через имя класса: ClassName.staticMember, а не через this.",
    topic: "Статические члены"
  },
  {
    id: 12,
    question: "Как обратиться к статическому свойству внутри статического метода?",
    options: [
      "this.property",
      "ClassName.property",
      "super.property",
      "static.property"
    ],
    correctAnswer: 1,
    explanation: "Внутри статических методов this указывает на конструктор класса, но безопаснее и понятнее использовать имя класса напрямую: ClassName.property. Также можно использовать this.constructor.property.",
    topic: "Статические члены"
  },
  {
    id: 13,
    question: "Что такое абстрактный класс в TypeScript?",
    options: [
      "Класс без реализации методов",
      "Класс, который нельзя инстанцировать напрямую",
      "Класс с модификатором private",
      "Класс без конструктора"
    ],
    correctAnswer: 1,
    explanation: "Абстрактный класс (abstract class) — это базовый класс, который нельзя инстанцировать напрямую. Он может содержать абстрактные методы (без реализации) и обычные методы. Используется как база для наследования.",
    topic: "Абстрактные классы"
  },
  {
    id: 14,
    question: "Что произойдет с этим кодом?\n\nabstract class Animal {\n  abstract makeSound(): void\n}\n\nconst animal = new Animal()",
    options: [
      "Создастся экземпляр Animal",
      "Ошибка компиляции",
      "animal будет undefined",
      "Ошибка в runtime"
    ],
    correctAnswer: 1,
    explanation: "Абстрактные классы нельзя инстанцировать напрямую. TypeScript выдаст ошибку: 'Cannot create an instance of an abstract class'. Нужно создать конкретный класс-наследник.",
    topic: "Абстрактные классы"
  },
  {
    id: 15,
    question: "Обязательно ли реализовывать абстрактные методы в наследнике?",
    options: [
      "Нет, это опционально",
      "Да, если наследник не абстрактный",
      "Да, всегда",
      "Нет, они унаследуются автоматически"
    ],
    correctAnswer: 1,
    explanation: "Если класс-наследник не абстрактный, он обязан реализовать все абстрактные методы родителя. Если наследник тоже абстрактный, он может не реализовывать абстрактные методы.",
    topic: "Абстрактные классы"
  },

  // Тема 4: Основы декораторов
  {
    id: 16,
    question: "Что такое декораторы в TypeScript?",
    options: [
      "Функции для стилизации компонентов",
      "Специальные функции для изменения поведения классов и их членов",
      "Паттерн проектирования",
      "Синтаксический сахар для наследования"
    ],
    correctAnswer: 1,
    explanation: "Декораторы — это специальный синтаксис TypeScript для аннотирования и модификации классов и их членов (свойств, методов, аксессоров, параметров). Они выполняются во время объявления класса.",
    topic: "Основы декораторов"
  },
  {
    id: 17,
    question: "Что нужно включить в tsconfig.json для использования декораторов?",
    options: [
      "\"decorators\": true",
      "\"experimentalDecorators\": true",
      "\"allowDecorators\": true",
      "Ничего, они включены по умолчанию"
    ],
    correctAnswer: 1,
    explanation: "Для использования декораторов нужно включить опцию \"experimentalDecorators\": true в tsconfig.json, так как декораторы пока находятся в стадии предложения (stage 3) и считаются экспериментальной функцией.",
    topic: "Основы декораторов"
  },
  {
    id: 18,
    question: "В каком порядке выполняются декораторы класса?\n\n@first\n@second\nclass Example {}",
    options: [
      "first, затем second",
      "second, затем first",
      "Одновременно",
      "Порядок не определен"
    ],
    correctAnswer: 1,
    explanation: "Декораторы выполняются снизу вверх (от ближайшего к объявлению к самому дальнему). В данном случае сначала выполнится @second, затем @first. Это как композиция функций.",
    topic: "Основы декораторов"
  },
  {
    id: 19,
    question: "Какие типы декораторов существуют в TypeScript?",
    options: [
      "Только класс и метод",
      "Класс, свойство, метод, аксессор, параметр",
      "Класс, интерфейс, тип",
      "Публичный и приватный"
    ],
    correctAnswer: 1,
    explanation: "TypeScript поддерживает 5 типов декораторов: класс (class decorator), свойство (property decorator), метод (method decorator), аксессор (accessor decorator) и параметр (parameter decorator).",
    topic: "Основы декораторов"
  },
  {
    id: 20,
    question: "Когда выполняются декораторы?",
    options: [
      "При создании экземпляра класса",
      "При вызове метода",
      "При объявлении/определении класса",
      "При компиляции"
    ],
    correctAnswer: 2,
    explanation: "Декораторы выполняются один раз при объявлении/определении класса, а не при создании экземпляров или вызове методов. Они модифицируют класс и его члены во время загрузки модуля.",
    topic: "Основы декораторов"
  },

  // Тема 5: Декораторы классов
  {
    id: 21,
    question: "Какую сигнатуру имеет декоратор класса?",
    options: [
      "(target: any) => void",
      "(target: Function) => Function | void",
      "(constructor: new () => any) => void",
      "(target: object) => object"
    ],
    correctAnswer: 1,
    explanation: "Декоратор класса принимает конструктор класса как единственный параметр и может вернуть новый конструктор для замены класса или ничего не возвращать (void).",
    topic: "Декораторы классов"
  },
  {
    id: 22,
    question: "Как декоратор класса может изменить класс?\n\nfunction logger(constructor: Function) {\n  // ???\n}",
    options: [
      "Вернуть новый класс/конструктор",
      "Изменить прототип",
      "Добавить свойства в конструктор",
      "Все перечисленное"
    ],
    correctAnswer: 3,
    explanation: "Декоратор класса может: вернуть новый класс-обертку, модифицировать прототип класса, добавить статические свойства/методы, или комбинировать эти подходы для изменения поведения класса.",
    topic: "Декораторы классов"
  },
  {
    id: 23,
    question: "Что произойдет с типами, если декоратор вернет новый класс?\n\nfunction decorator<T extends new (...args: any[]) => any>(constructor: T) {\n  return class extends constructor {\n    newProperty = 'value'\n  }\n}\n\n@decorator\nclass MyClass {}",
    options: [
      "TypeScript знает о newProperty",
      "TypeScript не знает о newProperty",
      "Ошибка компиляции",
      "newProperty будет any"
    ],
    correctAnswer: 1,
    explanation: "Декораторы не изменяют типы в системе типов TypeScript. Если декоратор добавляет новые свойства, TypeScript не будет знать о них. Нужно использовать type assertion или declaration merging.",
    topic: "Декораторы классов"
  },

  // Тема 6: Декораторы методов и свойств
  {
    id: 24,
    question: "Какую сигнатуру имеет декоратор метода?",
    options: [
      "(target: any, propertyKey: string) => void",
      "(target: any, propertyKey: string, descriptor: PropertyDescriptor) => void",
      "(method: Function) => Function",
      "(target: object, key: string) => void"
    ],
    correctAnswer: 1,
    explanation: "Декоратор метода получает три параметра: target (прототип класса для методов экземпляра или конструктор для статических), propertyKey (имя метода), и descriptor (дескриптор свойства).",
    topic: "Декораторы методов"
  },
  {
    id: 25,
    question: "Как декоратор метода может изменить поведение метода?",
    options: [
      "Изменить метод напрямую",
      "Заменить descriptor.value на новую функцию",
      "Вернуть новую функцию",
      "Изменить прототип класса"
    ],
    correctAnswer: 1,
    explanation: "Декоратор метода может изменить поведение, модифицируя descriptor.value — заменив его на функцию-обертку, которая вызывает оригинальный метод с дополнительной логикой.",
    topic: "Декораторы методов"
  },
  {
    id: 26,
    question: "В чем отличие декоратора свойства от декоратора метода?",
    options: [
      "Никакого отличия нет",
      "Декоратор свойства не получает PropertyDescriptor",
      "Декоратор свойства не может изменять значение",
      "Декоратор свойства выполняется позже"
    ],
    correctAnswer: 1,
    explanation: "Декоратор свойства получает только target и propertyKey, но НЕ получает PropertyDescriptor. Это ограничивает возможности по изменению поведения. Он в основном используется для метаданных.",
    topic: "Декораторы свойств"
  },
  {
    id: 27,
    question: "Что произойдет с этим кодом?\n\nfunction readonly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  descriptor.writable = false\n}\n\nclass User {\n  @readonly\n  name = 'John'\n}",
    options: [
      "name будет readonly",
      "Ошибка: декоратор свойства не получает descriptor",
      "Ничего не изменится",
      "Ошибка компиляции"
    ],
    correctAnswer: 1,
    explanation: "Декораторы свойств не получают PropertyDescriptor в качестве третьего аргумента (он будет undefined). Для создания readonly свойства нужен другой подход или использование декоратора аксессора.",
    topic: "Декораторы свойств"
  },

  // Тема 7: Фабрики декораторов
  {
    id: 28,
    question: "Что такое фабрика декораторов (decorator factory)?",
    options: [
      "Паттерн проектирования для создания классов",
      "Функция, которая возвращает декоратор",
      "Класс, который создает декораторы",
      "Встроенная функция TypeScript"
    ],
    correctAnswer: 1,
    explanation: "Фабрика декораторов — это функция, которая принимает параметры конфигурации и возвращает функцию-декоратор. Это позволяет параметризовать декораторы: @log('debug') вместо просто @log.",
    topic: "Фабрики декораторов"
  },
  {
    id: 29,
    question: "Как создать параметризованный декоратор?\n\nfunction log(level: string) {\n  // ???\n}",
    options: [
      "Вернуть функцию-декоратор",
      "Использовать bind",
      "Создать класс",
      "Использовать curry"
    ],
    correctAnswer: 0,
    explanation: "Фабрика декораторов должна вернуть функцию с сигнатурой декоратора. Параметры фабрики попадут в замыкание декоратора: function log(level: string) { return function(target, key, descriptor) { /* использовать level */ } }",
    topic: "Фабрики декораторов"
  },
  {
    id: 30,
    question: "В чем преимущество фабрик декораторов?",
    options: [
      "Лучшая производительность",
      "Возможность передавать параметры конфигурации",
      "Автоматическая типизация",
      "Упрощение синтаксиса"
    ],
    correctAnswer: 1,
    explanation: "Фабрики декораторов позволяют создавать конфигурируемые декораторы, принимающие параметры. Это делает декораторы более гибкими и переиспользуемыми в различных контекстах.",
    topic: "Фабрики декораторов"
  },

  // Тема 8: Метаданные и Reflect Metadata
  {
    id: 31,
    question: "Что такое Reflect Metadata API?",
    options: [
      "Встроенный API TypeScript",
      "Библиотека для работы с метаданными декораторов",
      "Способ создания зеркальных классов",
      "API для рефлексии типов"
    ],
    correctAnswer: 1,
    explanation: "Reflect Metadata — это библиотека (reflect-metadata), которая позволяет декораторам сохранять и читать метаданные о классах, свойствах и методах. Часто используется с DI фреймворками.",
    topic: "Метаданные"
  },
  {
    id: 32,
    question: "Для чего в tsconfig.json нужна опция emitDecoratorMetadata?",
    options: [
      "Для включения декораторов",
      "Для автоматической генерации метаданных о типах",
      "Для оптимизации декораторов",
      "Для поддержки старых браузеров"
    ],
    correctAnswer: 1,
    explanation: "\"emitDecoratorMetadata\": true заставляет TypeScript автоматически добавлять метаданные о типах (design:type, design:paramtypes, design:returntype) для декорированных элементов. Используется с Reflect Metadata.",
    topic: "Метаданные"
  },
  {
    id: 33,
    question: "Какие метаданные о типах генерирует TypeScript с emitDecoratorMetadata?",
    options: [
      "Только тип возвращаемого значения",
      "design:type, design:paramtypes, design:returntype",
      "Полную информацию о структуре класса",
      "Только названия типов"
    ],
    correctAnswer: 1,
    explanation: "TypeScript генерирует три ключа метаданных: design:type (тип свойства/возвращаемого значения метода), design:paramtypes (типы параметров метода), design:returntype (явный тип возврата метода).",
    topic: "Метаданные"
  },
  {
    id: 34,
    question: "Что произойдет с типами в метаданных после компиляции?",
    options: [
      "Сохранятся полностью",
      "Преобразуются в конструкторы (String, Number и т.д.)",
      "Удалятся полностью",
      "Сохранятся как строки"
    ],
    correctAnswer: 1,
    explanation: "Примитивные типы преобразуются в их конструкторы (String, Number, Boolean), интерфейсы становятся Object, кастомные классы остаются собой. Сложные union/intersection типы теряются (становятся Object).",
    topic: "Метаданные"
  },

  // Тема 9: Практическое применение
  {
    id: 35,
    question: "Какой паттерн часто реализуется с помощью декораторов?",
    options: [
      "Singleton",
      "Dependency Injection",
      "Factory",
      "Observer"
    ],
    correctAnswer: 1,
    explanation: "Dependency Injection часто реализуется с помощью декораторов (@Injectable, @Inject). Декораторы позволяют аннотировать классы и параметры конструктора для автоматического разрешения зависимостей.",
    topic: "Практическое применение"
  },
  {
    id: 36,
    question: "Для чего используются декораторы в Angular?",
    options: [
      "Только для красоты кода",
      "Для определения компонентов, сервисов, модулей",
      "Для оптимизации производительности",
      "Для совместимости с React"
    ],
    correctAnswer: 1,
    explanation: "В Angular декораторы (@Component, @Injectable, @NgModule и др.) используются для определения метаданных о классах, что позволяет фреймворку понимать роль класса и настраивать DI, рендеринг, модульную систему.",
    topic: "Практическое применение"
  },
  {
    id: 37,
    question: "Какой декоратор можно создать для логирования вызовов методов?",
    options: [
      "Декоратор класса",
      "Декоратор метода",
      "Декоратор свойства",
      "Декоратор параметра"
    ],
    correctAnswer: 1,
    explanation: "Декоратор метода идеален для логирования: он может обернуть оригинальный метод, логировать параметры, результат, время выполнения и ошибки, сохраняя исходное поведение метода.",
    topic: "Практическое применение"
  },
  {
    id: 38,
    question: "Как декораторы могут помочь с валидацией?",
    options: [
      "Аннотировать свойства правилами валидации",
      "Автоматически валидировать типы",
      "Генерировать формы",
      "Создавать тесты"
    ],
    correctAnswer: 0,
    explanation: "Декораторы свойств могут аннотировать поля метаданными валидации (@IsEmail, @MinLength и т.д.). Библиотеки валидации (class-validator) читают эти метаданные и проверяют значения согласно правилам.",
    topic: "Практическое применение"
  },

  // Тема 10: Ограничения и подводные камни
  {
    id: 39,
    question: "Какое главное ограничение декораторов в TypeScript?",
    options: [
      "Медленная работа",
      "Не влияют на систему типов",
      "Не работают с async",
      "Нельзя использовать с классами"
    ],
    correctAnswer: 1,
    explanation: "Декораторы изменяют runtime поведение, но не влияют на типы в системе типов TypeScript. Если декоратор добавляет свойства/методы, TypeScript не будет знать о них без дополнительных type assertions или declaration merging.",
    topic: "Ограничения"
  },
  {
    id: 40,
    question: "Почему декораторы называются экспериментальными?",
    options: [
      "Они работают нестабильно",
      "TC39 proposal еще не финализирован",
      "Они доступны только в beta версии",
      "Они скоро будут удалены"
    ],
    correctAnswer: 1,
    explanation: "Декораторы находятся на stage 3 TC39 proposal и еще не стандартизированы. Реализация TypeScript может отличаться от финальной спецификации, поэтому требуется experimentalDecorators флаг.",
    topic: "Ограничения"
  }
]
