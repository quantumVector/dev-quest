import type { Question } from '@/types/question.ts'

export const reactRerenderCausesQuestions: Question[] = [
  // Тема 1: Основные причины ререндера
  {
    id: 1,
    question: "Какие основные причины вызывают ререндер React компонента?",
    options: [
      "Только изменение state",
      "Изменение state, props, или ререндер родительского компонента",
      "Только изменение props",
      "Изменение глобальных переменных"
    ],
    correctAnswer: 1,
    explanation: "React компонент перерендеривается в трёх основных случаях: при изменении своего state, при изменении props, или когда родительский компонент перерендеривается (даже если props не изменились).",
    topic: "Причины ререндера"
  },
  {
    id: 2,
    question: "Что произойдёт, если родительский компонент перерендерился, а props дочернего компонента не изменились?",
    options: [
      "Дочерний компонент не перерендерится",
      "Дочерний компонент всё равно перерендерится по умолчанию",
      "React автоматически применит оптимизацию",
      "Произойдёт ошибка"
    ],
    correctAnswer: 1,
    explanation: "По умолчанию React перерендеривает все дочерние компоненты при ререндере родителя, независимо от того, изменились ли props. Это можно оптимизировать с помощью React.memo или shouldComponentUpdate.",
    topic: "Причины ререндера"
  },
  {
    id: 3,
    question: "Вызовет ли изменение локальной переменной (не state) ререндер компонента?",
    options: [
      "Да, всегда",
      "Нет, только изменение state или props вызывает ререндер",
      "Да, если переменная используется в JSX",
      "Зависит от типа переменной"
    ],
    correctAnswer: 1,
    explanation: "Изменение обычной переменной (не state, не props) не вызывает ререндер. React перерендеривает компонент только при изменении state, props или при ререндере родителя.",
    topic: "Причины ререндера"
  },
  {
    id: 4,
    question: "Что вызовет ререндер в этом коде?\n\nconst [count, setCount] = useState(0);\nsetCount(0); // текущее значение уже 0",
    options: [
      "Ререндера не будет, React оптимизирует одинаковые значения",
      "Произойдёт ререндер",
      "Ререндер произойдёт только в development режиме",
      "Выбросится ошибка"
    ],
    correctAnswer: 0,
    explanation: "React сравнивает новое значение state со старым с помощью Object.is(). Если значения идентичны, ререндер не происходит. Это встроенная оптимизация.",
    topic: "Причины ререндера"
  },
  {
    id: 5,
    question: "Перерендерится ли компонент при изменении Context значения, если компонент использует useContext?",
    options: [
      "Нет, Context не вызывает ререндер",
      "Да, все компоненты, использующие этот Context, перерендерятся",
      "Только если Context Provider перерендерился",
      "Зависит от размера Context"
    ],
    correctAnswer: 1,
    explanation: "Когда значение Context изменяется, все компоненты, использующие useContext с этим Context, автоматически перерендериваются, независимо от того, используют ли они изменённую часть значения.",
    topic: "Причины ререндера"
  },

  // Тема 2: Изменение State
  {
    id: 6,
    question: "Что произойдёт при вызове setState с объектом?\n\nconst [user, setUser] = useState({ name: 'John' });\nsetUser({ name: 'John' });",
    options: [
      "Ререндера не будет, так как данные те же",
      "Произойдёт ререндер, так как это новый объект",
      "React сделает deep comparison и пропустит ререндер",
      "Выбросится предупреждение"
    ],
    correctAnswer: 1,
    explanation: "React использует shallow comparison (Object.is) для сравнения state. { name: 'John' } !== { name: 'John' } - это разные объекты, поэтому произойдёт ререндер, даже если данные идентичны.",
    topic: "Изменение State"
  },
  {
    id: 7,
    question: "Как избежать лишнего ререндера при работе с объектами в state?",
    options: [
      "Использовать тот же объект, если данные не изменились",
      "Всегда создавать новый объект",
      "Использовать массивы вместо объектов",
      "Использовать JSON.stringify для сравнения"
    ],
    correctAnswer: 0,
    explanation: "Чтобы избежать лишнего ререндера, нужно возвращать тот же объект из setState, если данные действительно не изменились. React сравнивает по ссылке.",
    topic: "Изменение State"
  },
  {
    id: 8,
    question: "Что произойдёт при вызове нескольких setState подряд?\n\nsetCount(count + 1);\nsetCount(count + 1);\nsetCount(count + 1);",
    options: [
      "count увеличится на 3",
      "count увеличится на 1 (все обновления batch-атся)",
      "Произойдёт 3 ререндера",
      "Выбросится ошибка"
    ],
    correctAnswer: 1,
    explanation: "React батчит (группирует) обновления state. Все три вызова используют одно и то же значение count, поэтому count увеличится только на 1. Для правильного поведения нужна функциональная форма: setCount(c => c + 1).",
    topic: "Изменение State"
  },
  {
    id: 9,
    question: "Вызовет ли изменение ref ререндер компонента?",
    options: [
      "Да, ref работает как state",
      "Нет, изменение ref не вызывает ререндер",
      "Только если ref используется в JSX",
      "Зависит от типа ref"
    ],
    correctAnswer: 1,
    explanation: "Изменение ref.current не вызывает ререндер компонента. Ref предназначен для хранения изменяемых значений, которые не должны триггерить ререндер.",
    topic: "Изменение State"
  },
  {
    id: 10,
    question: "Что делает React.memo в контексте ререндеров?",
    options: [
      "Предотвращает все ререндеры компонента",
      "Пропускает ререндер, если props не изменились (shallow comparison)",
      "Кеширует результат рендера навсегда",
      "Увеличивает производительность всегда"
    ],
    correctAnswer: 1,
    explanation: "React.memo делает shallow comparison props. Если props не изменились, компонент не перерендерится даже при ререндере родителя. Но это не панацея - работает только со стабильными props.",
    topic: "Изменение State"
  },

  // Тема 3: Изменение Props
  {
    id: 11,
    question: "Что произойдёт, если передать новую функцию как prop при каждом рендере?\n\n<Child onClick={() => handleClick()} />",
    options: [
      "Child не перерендерится, React оптимизирует функции",
      "Child перерендерится, даже если обёрнут в React.memo",
      "Child перерендерится только если вызвать функцию",
      "Произойдёт ошибка"
    ],
    correctAnswer: 1,
    explanation: "Стрелочная функция создаётся заново при каждом рендере, это новая ссылка. Даже если Child обёрнут в React.memo, он перерендерится, так как prop изменился (новая функция !== старая функция).",
    topic: "Изменение Props"
  },
  {
    id: 12,
    question: "Как сделать prop функцию стабильной, чтобы избежать лишних ререндеров?",
    options: [
      "Использовать useMemo",
      "Использовать useCallback",
      "Определить функцию вне компонента",
      "Варианты B и C верны"
    ],
    correctAnswer: 3,
    explanation: "useCallback мемоизирует функцию, возвращая ту же ссылку между рендерами. Также можно определить функцию вне компонента, если она не использует props/state.",
    topic: "Изменение Props"
  },
  {
    id: 13,
    question: "Что произойдёт при передаче инлайн объекта как prop?\n\n<Child config={{ theme: 'dark' }} />",
    options: [
      "Child не перерендерится, React оптимизирует объекты",
      "Child перерендерится при каждом рендере родителя",
      "Child перерендерится только если изменить theme",
      "React выбросит предупреждение"
    ],
    correctAnswer: 1,
    explanation: "Инлайн объект создаётся заново при каждом рендере. Это новая ссылка, поэтому даже с React.memo компонент перерендерится. Нужно использовать useMemo для стабильной ссылки.",
    topic: "Изменение Props"
  },
  {
    id: 14,
    question: "Какой prop НЕ вызовет ререндер мемоизированного компонента?\n\nconst Child = React.memo(({ value }) => ...);\n<Child value={...} />",
    options: [
      "value={5}",
      "value=\"text\"",
      "value={[1, 2, 3]}",
      "Варианты A и B"
    ],
    correctAnswer: 3,
    explanation: "Примитивные значения (числа, строки, boolean) сравниваются по значению. 5 === 5 и \"text\" === \"text\" вернут true. Но [1,2,3] !== [1,2,3] - это разные массивы.",
    topic: "Изменение Props"
  },
  {
    id: 15,
    question: "Что делает второй параметр React.memo?",
    options: [
      "Задаёт время кеширования",
      "Кастомная функция сравнения props",
      "Список зависимостей для мемоизации",
      "Callback при ререндере"
    ],
    correctAnswer: 1,
    explanation: "Второй параметр React.memo - это кастомная функция сравнения: arePropsEqual(prevProps, nextProps). Если возвращает true - ререндер пропускается, false - компонент перерендерится.",
    topic: "Изменение Props"
  },

  // Тема 4: Ререндер родительского компонента
  {
    id: 16,
    question: "Что произойдёт с дочерними компонентами при ререндере родителя?",
    options: [
      "Перерендерятся только те, чьи props изменились",
      "Перерендерятся все дочерние компоненты по умолчанию",
      "Ничего не произойдёт",
      "React сам решит, что оптимальнее"
    ],
    correctAnswer: 1,
    explanation: "По умолчанию React перерендеривает все дочерние компоненты при ререндере родителя, независимо от изменения props. Это можно оптимизировать с помощью React.memo.",
    topic: "Ререндер родителя"
  },
  {
    id: 17,
    question: "Какой компонент НЕ перерендерится при изменении state в Parent?\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  return <div><Child1 /><Child2 count={count} /></div>;\n}",
    options: [
      "Child1 не перерендерится",
      "Child2 не перерендерится",
      "Оба перерендерятся",
      "Зависит от React.memo"
    ],
    correctAnswer: 2,
    explanation: "Оба компонента перерендерятся, так как Parent перерендерился. Child1 перерендерится, хотя у него нет props, Child2 - потому что изменились props и Parent перерендерился.",
    topic: "Ререндер родителя"
  },
  {
    id: 18,
    question: "Как изолировать часть дерева компонентов от ререндеров родителя?",
    options: [
      "Использовать React.memo на дочерних компонентах",
      "Вынести state ближе к компонентам, которые его используют",
      "Использовать композицию через children prop",
      "Все варианты верны"
    ],
    correctAnswer: 3,
    explanation: "Все подходы работают: React.memo предотвращает ререндер при неизменных props, перенос state вниз уменьшает область влияния, children prop не перерендеривается при изменении state родителя.",
    topic: "Ререндер родителя"
  },
  {
    id: 19,
    question: "Что такое паттерн \"поднятие содержимого\" (content lifting) для оптимизации?",
    options: [
      "Передача JSX через children prop, чтобы избежать ререндера",
      "Перемещение компонентов выше по дереву",
      "Использование Context API",
      "Оптимизация CSS"
    ],
    correctAnswer: 0,
    explanation: "Если передать компоненты через children prop, они не перерендерятся при изменении state в родителе, так как были созданы выше и передаются как готовые элементы.",
    topic: "Ререндер родителя"
  },
  {
    id: 20,
    question: "В чём преимущество паттерна composition (children) над React.memo?",
    options: [
      "Проще в использовании",
      "Дети вообще не создаются заново при ререндере родителя",
      "Лучше производительность",
      "Не требует дополнительных проверок props"
    ],
    correctAnswer: 1,
    explanation: "При использовании children элементы создаются на уровень выше и передаются готовыми. Они вообще не попадают в процесс reconciliation при ререндере родителя. React.memo же требует сравнения props.",
    topic: "Ререндер родителя"
  },

  // Тема 5: Выявление лишних ререндеров
  {
    id: 21,
    question: "Какой инструмент React DevTools помогает отследить ререндеры?",
    options: [
      "Components tab",
      "Profiler tab",
      "Console",
      "Network tab"
    ],
    correctAnswer: 1,
    explanation: "React DevTools Profiler позволяет записывать сессию и видеть, какие компоненты перерендерились, почему и сколько времени это заняло. Можно включить 'Highlight updates when components render'.",
    topic: "Выявление ререндеров"
  },
  {
    id: 22,
    question: "Как включить подсветку ререндеров в React DevTools?",
    options: [
      "Settings -> Highlight updates when components render",
      "Profiler -> Start profiling",
      "Components -> Show renders",
      "Автоматически включено"
    ],
    correctAnswer: 0,
    explanation: "В настройках React DevTools есть опция 'Highlight updates when components render', которая подсвечивает компоненты при их ререндере цветной рамкой.",
    topic: "Выявление ререндеров"
  },
  {
    id: 23,
    question: "Что показывает Profiler при записи взаимодействия?",
    options: [
      "Только количество ререндеров",
      "Компоненты, которые перерендерились, время рендера, причину",
      "Только ошибки рендера",
      "Изменения в DOM"
    ],
    correctAnswer: 1,
    explanation: "Profiler показывает flame graph всех перерендеренных компонентов, время каждого рендера, причину ререндера (props, state, hooks, parent) и позволяет анализировать производительность.",
    topic: "Выявление ререндеров"
  },
  {
    id: 24,
    question: "Как использовать why-did-you-render библиотеку?",
    options: [
      "Подключить в production для мониторинга",
      "Подключить в development для отладки лишних ререндеров",
      "Использовать вместо React DevTools",
      "Не рекомендуется использовать"
    ],
    correctAnswer: 1,
    explanation: "why-did-you-render - это development-only библиотека, которая логирует в консоль информацию о ререндерах компонентов и помогает найти лишние ререндеры, вызванные props/state.",
    topic: "Выявление ререндеров"
  },
  {
    id: 25,
    question: "Какой цвет подсветки в React DevTools указывает на частые ререндеры?",
    options: [
      "Зелёный",
      "Жёлтый",
      "Красный",
      "Синий"
    ],
    correctAnswer: 2,
    explanation: "React DevTools использует цветовую схему от зелёного к красному: зелёный - редкие ререндеры, жёлтый - средние, красный - частые. Это помогает быстро найти проблемные компоненты.",
    topic: "Выявление ререндеров"
  },

  // Тема 6: Оптимизация ререндеров
  {
    id: 26,
    question: "Какой хук помогает избежать создания новых функций при каждом рендере?",
    options: [
      "useMemo",
      "useCallback",
      "useRef",
      "useEffect"
    ],
    correctAnswer: 1,
    explanation: "useCallback мемоизирует функцию и возвращает ту же ссылку между рендерами, если зависимости не изменились. Это предотвращает ререндер дочерних компонентов, получающих эту функцию как prop.",
    topic: "Оптимизация ререндеров"
  },
  {
    id: 27,
    question: "Когда стоит использовать useMemo для props?",
    options: [
      "Всегда для любых объектов и массивов",
      "Когда вычисления дорогие или объект передаётся в мемоизированный компонент",
      "Никогда, React сам оптимизирует",
      "Только для массивов"
    ],
    correctAnswer: 1,
    explanation: "useMemo стоит использовать для дорогих вычислений или когда объект/массив передаётся в React.memo компонент. Преждевременная оптимизация может ухудшить читаемость без заметного выигрыша.",
    topic: "Оптимизация ререндеров"
  },
  {
    id: 28,
    question: "В чём разница между useMemo и useCallback?",
    options: [
      "Никакой разницы",
      "useMemo мемоизирует значение, useCallback мемоизирует функцию",
      "useMemo быстрее работает",
      "useCallback для классовых компонентов"
    ],
    correctAnswer: 1,
    explanation: "useMemo(() => value) мемоизирует результат выполнения функции (любое значение), useCallback(fn) мемоизирует саму функцию. useCallback(fn, deps) === useMemo(() => fn, deps).",
    topic: "Оптимизация ререндеров"
  },
  {
    id: 29,
    question: "Всегда ли React.memo улучшает производительность?",
    options: [
      "Да, всегда",
      "Нет, может ухудшить, если props часто меняются",
      "Только в production",
      "Только для больших компонентов"
    ],
    correctAnswer: 1,
    explanation: "React.memo добавляет overhead на сравнение props. Если props часто меняются, компонент всё равно будет перерендериваться, но с дополнительной проверкой. Оптимизация может стать медленнее без оптимизации.",
    topic: "Оптимизация ререндеров"
  },
  {
    id: 30,
    question: "Как оптимизировать Context, чтобы избежать ререндера всех consumers?",
    options: [
      "Разделить Context на несколько мелких",
      "Использовать useMemo для значения Context",
      "Использовать композицию и memo на уровне consumers",
      "Все варианты верны"
    ],
    correctAnswer: 3,
    explanation: "Все подходы работают: разделение Context уменьшает количество компонентов, которые ререндерятся; useMemo предотвращает лишние изменения значения; композиция и memo позволяют изолировать части дерева.",
    topic: "Оптимизация ререндеров"
  },

  // Тема 7: Антипаттерны и ошибки
  {
    id: 31,
    question: "Какая проблема с этим кодом?\n\nconst MemoChild = React.memo(Child);\nfunction Parent() {\n  return <MemoChild onClick={() => {}} />;\n}",
    options: [
      "Проблем нет",
      "onClick создаётся заново, MemoChild всё равно перерендерится",
      "React.memo не работает с onClick",
      "Нужно использовать useMemo"
    ],
    correctAnswer: 1,
    explanation: "Стрелочная функция создаётся заново при каждом рендере Parent, это новая ссылка. React.memo сравнит props, увидит изменение onClick и перерендерит компонент. Нужен useCallback.",
    topic: "Антипаттерны"
  },
  {
    id: 32,
    question: "Почему этот код вызывает бесконечный ререндер?\n\nfunction Component() {\n  const [state, setState] = useState(0);\n  setState(state + 1);\n  return <div>{state}</div>;\n}",
    options: [
      "setState нельзя вызывать в теле компонента",
      "Нужно использовать useEffect",
      "state не изменяется",
      "Всё правильно"
    ],
    correctAnswer: 0,
    explanation: "setState в теле компонента вызывается при каждом рендере, что вызывает новый рендер, который снова вызывает setState - бесконечный цикл. setState нужно вызывать в обработчиках или effects.",
    topic: "Антипаттерны"
  },
  {
    id: 33,
    question: "В чём проблема этого паттерна оптимизации?\n\nconst data = useMemo(() => props.items.map(...), []);",
    options: [
      "Проблем нет",
      "Пустой массив зависимостей - данные не обновятся при изменении props",
      "useMemo не работает с массивами",
      "Нужен useCallback"
    ],
    correctAnswer: 1,
    explanation: "Пустой массив зависимостей означает, что мемоизированное значение вычислится только один раз при монтировании. Изменения props.items игнорируются, данные устаревают. Нужно: [props.items].",
    topic: "Антипаттерны"
  },
  {
    id: 34,
    question: "Почему не стоит оборачивать все компоненты в React.memo?",
    options: [
      "Добавляет overhead на сравнение props без гарантии выигрыша",
      "React.memo работает только с функциональными компонентами",
      "Усложняет отладку",
      "Варианты A и C"
    ],
    correctAnswer: 3,
    explanation: "Преждевременная оптимизация с React.memo добавляет сложность кода и overhead на shallow comparison. Если props часто меняются, выигрыша не будет. Оптимизировать стоит после измерения производительности.",
    topic: "Антипаттерны"
  },
  {
    id: 35,
    question: "Какая проблема с передачей инлайн стилей?\n\n<Component style={{ color: 'red' }} />",
    options: [
      "Проблем нет",
      "Новый объект при каждом рендере вызовет ререндер мемоизированного компонента",
      "Инлайн стили медленнее работают",
      "Нельзя использовать инлайн стили в React"
    ],
    correctAnswer: 1,
    explanation: "Инлайн объект создаётся заново при каждом рендере (новая ссылка). Если Component обёрнут в React.memo, он перерендерится, так как style prop изменился. Нужно вынести объект или использовать useMemo.",
    topic: "Антипаттерны"
  },

  // Тема 8: Продвинутые сценарии
  {
    id: 36,
    question: "Как работает bailout при setState с тем же значением?",
    options: [
      "React всегда рендерит компонент",
      "React пропускает ререндер текущего компонента, но рендерит детей",
      "React полностью пропускает reconciliation для поддерева",
      "Зависит от типа значения"
    ],
    correctAnswer: 1,
    explanation: "Когда setState получает то же значение (Object.is), React пропускает ререндер текущего компонента, но всё равно проверяет детей. Это называется bailout. Полный bailout (включая детей) происходит только при неизменных props.",
    topic: "Продвинутые сценарии"
  },
  {
    id: 37,
    question: "Что такое tearing в контексте Concurrent React?",
    options: [
      "Разрыв соединения с сервером",
      "Визуальная несогласованность UI из-за разных версий данных",
      "Ошибка рендера",
      "Утечка памяти"
    ],
    correctAnswer: 1,
    explanation: "Tearing - это когда разные части UI показывают разные версии одних данных из-за прерывания рендера в Concurrent режиме. useSyncExternalStore помогает избежать tearing для внешних store.",
    topic: "Продвинутые сценарии"
  },
  {
    id: 38,
    question: "Как useTransition влияет на ререндеры?",
    options: [
      "Предотвращает все ререндеры",
      "Помечает обновления как низкоприоритетные, позволяя прервать рендер",
      "Ускоряет ререндеры",
      "Батчит все обновления"
    ],
    correctAnswer: 1,
    explanation: "useTransition помечает обновления state как transitions (низкий приоритет). React может прервать такой рендер для обработки срочных обновлений, улучшая отзывчивость UI.",
    topic: "Продвинутые сценарии"
  },
  {
    id: 39,
    question: "Что делает useDeferredValue с ререндерами?",
    options: [
      "Откладывает все ререндеры",
      "Создаёт отложенную версию значения, позволяя показывать старое значение",
      "Пропускает ререндеры",
      "Батчит обновления"
    ],
    correctAnswer: 1,
    explanation: "useDeferredValue возвращает отложенную версию значения. Пока идёт рендер с новым значением, React показывает старое, позволяя UI оставаться отзывчивым. Это debouncing на уровне рендера.",
    topic: "Продвинутые сценарии"
  },
  {
    id: 40,
    question: "Как работает batching в React 18?",
    options: [
      "Только в event handlers",
      "Автоматический batching везде, включая promises, setTimeout, native events",
      "Нужно включать вручную",
      "Работает только с useState"
    ],
    correctAnswer: 1,
    explanation: "React 18 ввёл автоматический batching для всех обновлений, не только в event handlers. Несколько setState в promises, setTimeout, native events батчатся в один ререндер. Можно отключить через flushSync.",
    topic: "Продвинутые сценарии"
  },

  // Дополнительные вопросы по конкретным сценариям
  {
    id: 41,
    question: "Перерендерится ли компонент при изменении значения в глобальном store (например, Redux)?",
    options: [
      "Нет, глобальный store не вызывает ререндер",
      "Да, если компонент подписан на этот slice store (useSelector)",
      "Да, всегда при любом изменении store",
      "Зависит от middleware"
    ],
    correctAnswer: 1,
    explanation: "Компонент перерендерится только если он подписан на изменившуюся часть store через useSelector (Redux) или useStore (Zustand). Selector определяет, какие изменения триггерят ререндер.",
    topic: "Практические сценарии"
  },
  {
    id: 42,
    question: "Как reducer влияет на ререндеры по сравнению с useState?",
    options: [
      "useReducer всегда быстрее",
      "Одинаково - оба вызывают ререндер при изменении state",
      "useReducer не вызывает ререндер",
      "useReducer батчит обновления автоматически"
    ],
    correctAnswer: 1,
    explanation: "useReducer и useState работают одинаково в плане ререндеров. Оба используют Object.is для сравнения. Преимущество useReducer - в группировке сложной логики и стабильности dispatch функции.",
    topic: "Практические сценарии"
  },
  {
    id: 43,
    question: "Что происходит при изменении key у компонента?",
    options: [
      "Компонент просто перерендерится",
      "Компонент размонтируется и монтируется заново с новым state",
      "Ничего не происходит",
      "Выбросится ошибка"
    ],
    correctAnswer: 1,
    explanation: "Изменение key заставляет React рассматривать компонент как новый. Старый экземпляр размонтируется (cleanup), новый монтируется с начальным state. Это полный reset компонента.",
    topic: "Практические сценарии"
  },
  {
    id: 44,
    question: "Как портал (Portal) влияет на ререндеры?",
    options: [
      "Портал предотвращает ререндеры",
      "Компонент в портале перерендеривается при ререндере родителя как обычно",
      "Портал полностью изолирует компонент",
      "Портал увеличивает количество ререндеров"
    ],
    correctAnswer: 1,
    explanation: "Portal только меняет место в DOM дереве, но не влияет на React дерево. Компонент в портале остаётся ребёнком родителя в React дереве и перерендеривается при его ререндере.",
    topic: "Практические сценарии"
  },
  {
    id: 45,
    question: "Как ErrorBoundary влияет на ререндеры при ошибке?",
    options: [
      "Останавливает все ререндеры приложения",
      "Перерендеривает только ErrorBoundary с fallback UI",
      "Приложение крашится",
      "Продолжает рендерить компонент с ошибкой"
    ],
    correctAnswer: 1,
    explanation: "При ошибке в компоненте ErrorBoundary ловит её, переходит в error state и рендерит fallback UI. Дерево компонентов под ErrorBoundary размонтируется, остальное приложение работает.",
    topic: "Практические сценарии"
  },
  {
    id: 46,
    question: "Влияет ли Suspense на ререндеры компонентов?",
    options: [
      "Suspense предотвращает ререндеры",
      "Suspense может вызывать дополнительный рендер при resolve данных",
      "Suspense не влияет на ререндеры",
      "Suspense увеличивает количество ререндеров вдвое"
    ],
    correctAnswer: 1,
    explanation: "Когда suspended компонент готов (promise resolved), Suspense перерендеривается для показа реального контента вместо fallback. Это дополнительный рендер, но с лучшим UX.",
    topic: "Практические сценарии"
  },
  {
    id: 47,
    question: "Как lazy() и code splitting влияют на ререндеры?",
    options: [
      "Увеличивают количество ререндеров",
      "Первая загрузка вызывает Suspense, дальше работает как обычный компонент",
      "Предотвращают ререндеры",
      "Компонент рендерится каждый раз заново"
    ],
    correctAnswer: 1,
    explanation: "lazy() загружает компонент асинхронно при первом использовании (Suspense показывает fallback). После загрузки компонент работает как обычный и перерендеривается по стандартным правилам.",
    topic: "Практические сценарии"
  },
  {
    id: 48,
    question: "Что такое selector bailout в Redux?",
    options: [
      "Пропуск ререндера если selector вернул то же значение",
      "Отмена подписки на store",
      "Кеширование результата selector",
      "Пропуск вызова selector"
    ],
    correctAnswer: 0,
    explanation: "useSelector в Redux сравнивает новое значение со старым (по умолчанию через ===). Если значения идентичны, компонент не перерендеривается. Это bailout оптимизация.",
    topic: "Практические сценарии"
  },
  {
    id: 49,
    question: "Как React.StrictMode влияет на ререндеры?",
    options: [
      "Удваивает количество ререндеров в development",
      "Предотвращает лишние ререндеры",
      "Не влияет на ререндеры",
      "Работает только в production"
    ],
    correctAnswer: 0,
    explanation: "StrictMode в development намеренно вызывает двойной рендер компонентов, чтобы помочь найти побочные эффекты. В production двойного рендера нет. Это помогает найти проблемы рано.",
    topic: "Практические сценарии"
  },
  {
    id: 50,
    question: "Какой подход лучше для оптимизации списков с тысячами элементов?",
    options: [
      "Обернуть каждый элемент в React.memo",
      "Использовать виртуализацию (react-window, react-virtualized)",
      "Использовать useMemo для всего списка",
      "Разбить на страницы"
    ],
    correctAnswer: 1,
    explanation: "Для больших списков виртуализация - лучшее решение. Рендерятся только видимые элементы, остальные не создаются вообще. React.memo не поможет, если нужно рендерить тысячи элементов одновременно.",
    topic: "Практические сценарии"
  }
]
