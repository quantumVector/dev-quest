import type { Question } from '@/types/question.ts'

export const jsAsyncQuestions: Question[] = [
  // Тема 1: Для чего нам нужна асинхронность
  {
    id: 1,
    question: "Для чего в JavaScript нужна асинхронность?",
    options: [
      "Для ускорения выполнения синхронного кода",
      "Для предотвращения блокировки основного потока при выполнении длительных операций",
      "Для экономии памяти при работе с большими данными",
      "Для улучшения безопасности приложения"
    ],
    correctAnswer: 1,
    explanation: "Асинхронность в JavaScript нужна для предотвращения блокировки основного потока (main thread) при выполнении длительных операций, таких как запросы к серверу, чтение файлов или таймеры. Это позволяет интерфейсу оставаться отзывчивым.",
    topic: "Необходимость асинхронности"
  },
  {
    id: 2,
    question: "Что произойдет, если выполнить длительную синхронную операцию в браузере?",
    options: [
      "Операция будет выполнена в фоновом режиме",
      "Интерфейс заморозится до завершения операции",
      "Операция будет автоматически отменена",
      "Браузер создаст новый поток для выполнения"
    ],
    correctAnswer: 1,
    explanation: "JavaScript в браузере выполняется в одном потоке. Длительная синхронная операция заблокирует весь интерфейс, делая страницу неотзывчивой до завершения операции.",
    topic: "Необходимость асинхронности"
  },
  {
    id: 3,
    question: "Какой из примеров НЕ является асинхронной операцией?",
    options: [
      "setTimeout()",
      "fetch()",
      "Math.random()",
      "addEventListener()"
    ],
    correctAnswer: 2,
    explanation: "Math.random() выполняется синхронно и сразу возвращает результат. setTimeout(), fetch() и addEventListener() работают асинхронно.",
    topic: "Необходимость асинхронности"
  },
  {
    id: 4,
    question: "Что такое 'блокирующий' код в контексте JavaScript?",
    options: [
      "Код, который содержит ошибки",
      "Код, который выполняется синхронно и останавливает выполнение других операций",
      "Код, который использует много памяти",
      "Код, который работает с DOM"
    ],
    correctAnswer: 1,
    explanation: "Блокирующий код — это синхронный код, который выполняется последовательно и не позволяет выполняться другим операциям до своего завершения, блокируя тем самым основной поток.",
    topic: "Необходимость асинхронности"
  },
  {
    id: 5,
    question: "Какое основное преимущество асинхронного программирования в веб-разработке?",
    options: [
      "Более быстрое выполнение кода",
      "Возможность выполнения нескольких операций одновременно без блокировки UI",
      "Уменьшение размера кода",
      "Лучшая совместимость с браузерами"
    ],
    correctAnswer: 1,
    explanation: "Главное преимущество асинхронности — возможность выполнения нескольких операций параллельно без блокировки пользовательского интерфейса, что делает приложение отзывчивым.",
    topic: "Необходимость асинхронности"
  },

  // Тема 2: Как осуществлялась работа до введения промисов. Какие состояния есть у промисов?
  {
    id: 6,
    question: "Как осуществлялась асинхронная работа в JavaScript до появления промисов?",
    options: [
      "Через async/await",
      "Через callback-функции",
      "Через setTimeout только",
      "Через глобальные переменные"
    ],
    correctAnswer: 1,
    explanation: "До появления промисов асинхронная работа осуществлялась в основном через callback-функции, которые передавались в асинхронные операции и вызывались при их завершении.",
    topic: "До промисов и состояния промисов"
  },
  {
    id: 7,
    question: "Что такое 'callback hell' (ад обратных вызовов)?",
    options: [
      "Ошибка в callback-функции",
      "Глубокая вложенность callback-функций, делающая код трудночитаемым",
      "Бесконечный цикл в callback",
      "Слишком много параметров в callback"
    ],
    correctAnswer: 1,
    explanation: "Callback hell — это ситуация, когда множество асинхронных операций вкладываются друг в друга через callback-функции, создавая глубокую пирамиду кода, которую трудно читать и поддерживать.",
    topic: "До промисов и состояния промисов"
  },
  {
    id: 8,
    question: "Какие три основных состояния есть у промисов?",
    options: [
      "created, running, finished",
      "pending, fulfilled, rejected",
      "waiting, success, error",
      "start, process, complete"
    ],
    correctAnswer: 1,
    explanation: "У промисов есть три состояния: pending (ожидание), fulfilled (выполнен успешно), rejected (отклонен с ошибкой). Промис может находиться только в одном из этих состояний.",
    topic: "До промисов и состояния промисов"
  },
  {
    id: 9,
    question: "Может ли промис изменить свое состояние после того, как он был разрешен (fulfilled) или отклонен (rejected)?",
    options: [
      "Да, промис можно перевести в любое состояние многократно",
      "Нет, промис может изменить состояние только один раз",
      "Да, но только из rejected в fulfilled",
      "Да, но только с помощью специальных методов"
    ],
    correctAnswer: 1,
    explanation: "Промис может изменить свое состояние только один раз. Как только он переходит из pending в fulfilled или rejected, его состояние становится неизменным (immutable).",
    topic: "До промисов и состояния промисов"
  },
  {
    id: 10,
    question: "Что произойдет с этим кодом?\n\nconst promise = new Promise((resolve, reject) => {\n  resolve('success');\n  reject('error');\n});\n\npromise.then(console.log).catch(console.log);",
    options: [
      "Выведет 'success', затем 'error'",
      "Выведет только 'success'",
      "Выведет только 'error'",
      "Выдаст ошибку"
    ],
    correctAnswer: 1,
    explanation: "Выведет только 'success', потому что после первого вызова resolve() промис переходит в состояние fulfilled и больше не может изменить свое состояние. Вызов reject() игнорируется.",
    topic: "До промисов и состояния промисов"
  },
  {
    id: 11,
    question: "Какая основная проблема была у callback-подхода, которую решили промисы?",
    options: [
      "Callback выполнялись слишком медленно",
      "Сложность обработки ошибок и композиции асинхронных операций",
      "Callback использовали слишком много памяти",
      "Callback не поддерживались во всех браузерах"
    ],
    correctAnswer: 1,
    explanation: "Основные проблемы callback-подхода: сложность обработки ошибок (нужно проверять в каждом callback), сложность композиции операций (callback hell) и отсутствие единого стандарта обработки асинхронности.",
    topic: "До промисов и состояния промисов"
  },
  {
    id: 12,
    question: "В каком состоянии находится только что созданный промис?",
    options: [
      "fulfilled",
      "rejected",
      "pending",
      "resolved"
    ],
    correctAnswer: 2,
    explanation: "Только что созданный промис находится в состоянии pending (ожидание), пока не будет вызван resolve() или reject().",
    topic: "До промисов и состояния промисов"
  },

  // Тема 3: Как вызвать итерируемую коллекцию промисов сразу
  {
    id: 13,
    question: "Какой метод используется для выполнения всех промисов параллельно и получения всех результатов?",
    options: [
      "Promise.all()",
      "Promise.race()",
      "Promise.forEach()",
      "Promise.map()"
    ],
    correctAnswer: 0,
    explanation: "Promise.all() выполняет все промисы параллельно и возвращает массив результатов в том же порядке. Если хотя бы один промис отклоняется, весь Promise.all отклоняется.",
    topic: "Коллекции промисов"
  },
  {
    id: 14,
    question: "Что произойдет, если один из промисов в Promise.all() будет отклонен?",
    options: [
      "Будут возвращены только успешные результаты",
      "Весь Promise.all() будет отклонен немедленно",
      "Выполнение остальных промисов остановится",
      "Отклоненный промис будет проигнорирован"
    ],
    correctAnswer: 1,
    explanation: "Если хотя бы один промис в Promise.all() отклоняется, весь Promise.all() немедленно переходит в состояние rejected с ошибкой этого промиса. Остальные промисы продолжают выполняться, но их результаты игнорируются.",
    topic: "Коллекции промисов"
  },
  {
    id: 15,
    question: "В каком порядке Promise.all() возвращает результаты?",
    options: [
      "В порядке завершения промисов",
      "В том же порядке, в котором промисы были переданы в массиве",
      "В случайном порядке",
      "Сначала успешные, потом отклоненные"
    ],
    correctAnswer: 1,
    explanation: "Promise.all() всегда возвращает результаты в том же порядке, в котором промисы были переданы в массиве, независимо от порядка их завершения.",
    topic: "Коллекции промисов"
  },
  {
    id: 16,
    question: "Что выведет этот код?\n\nconst promises = [\n  Promise.resolve(1),\n  Promise.resolve(2),\n  Promise.resolve(3)\n];\n\nPromise.all(promises).then(console.log);",
    options: [
      "[1, 2, 3]",
      "6",
      "1, 2, 3",
      "Promise объект"
    ],
    correctAnswer: 0,
    explanation: "Promise.all() вернет массив результатов [1, 2, 3] в том же порядке, в котором промисы были переданы.",
    topic: "Коллекции промисов"
  },
  {
    id: 17,
    question: "Какой метод лучше использовать, если нужно выполнить промисы параллельно, но получить результаты по мере их выполнения?",
    options: [
      "Promise.all()",
      "Цикл for await...of",
      "Promise.allSettled()",
      "Promise.race() в цикле"
    ],
    correctAnswer: 1,
    explanation: "Для получения результатов по мере выполнения лучше использовать цикл for await...of, который будет обрабатывать промисы последовательно, или комбинацию Promise.all() с отдельной обработкой каждого промиса.",
    topic: "Коллекции промисов"
  },

  // Тема 4: Promise.race/any/allSettled
  {
    id: 18,
    question: "Что делает Promise.race()?",
    options: [
      "Выполняет все промисы и возвращает массив результатов",
      "Возвращает результат первого завершившегося промиса (успешно или с ошибкой)",
      "Возвращает только успешные результаты",
      "Отменяет все остальные промисы после завершения первого"
    ],
    correctAnswer: 1,
    explanation: "Promise.race() возвращает результат первого завершившегося промиса, независимо от того, был ли он успешным или отклоненным. Остальные промисы продолжают выполняться, но их результаты игнорируются.",
    topic: "Promise.race/any/allSettled"
  },
  {
    id: 19,
    question: "В чем разница между Promise.race() и Promise.any()?",
    options: [
      "Promise.any() быстрее выполняется",
      "Promise.race() возвращает первый завершившийся промис, Promise.any() — первый успешный",
      "Promise.any() выполняет промисы последовательно",
      "Никакой разницы нет"
    ],
    correctAnswer: 1,
    explanation: "Promise.race() возвращает первый завершившийся промис (успешный или неудачный), а Promise.any() ждет первого успешно выполненного промиса, игнорируя отклоненные.",
    topic: "Promise.race/any/allSettled"
  },
  {
    id: 20,
    question: "Что произойдет, если все промисы в Promise.any() будут отклонены?",
    options: [
      "Вернется undefined",
      "Будет выброшен AggregateError со всеми ошибками",
      "Вернется null",
      "Будет выброшена первая ошибка"
    ],
    correctAnswer: 1,
    explanation: "Если все промисы в Promise.any() отклоняются, будет выброшен AggregateError, который содержит массив всех ошибок от отклоненных промисов.",
    topic: "Promise.race/any/allSettled"
  },
  {
    id: 21,
    question: "Что возвращает Promise.allSettled()?",
    options: [
      "Массив только успешных результатов",
      "Массив объектов с информацией о состоянии каждого промиса",
      "Первый успешный результат",
      "true или false в зависимости от результата"
    ],
    correctAnswer: 1,
    explanation: "Promise.allSettled() возвращает массив объектов, где каждый объект содержит status ('fulfilled' или 'rejected') и value (для успешных) или reason (для отклоненных).",
    topic: "Promise.race/any/allSettled"
  },
  {
    id: 22,
    question: "Какой метод никогда не отклоняется?",
    options: [
      "Promise.all()",
      "Promise.race()",
      "Promise.any()",
      "Promise.allSettled()"
    ],
    correctAnswer: 3,
    explanation: "Promise.allSettled() никогда не отклоняется. Он всегда выполняется успешно и возвращает информацию о состоянии всех переданных промисов.",
    topic: "Promise.race/any/allSettled"
  },
  {
    id: 23,
    question: "Когда стоит использовать Promise.race()?",
    options: [
      "Когда нужны все результаты",
      "Когда нужен таймаут для операции или первый доступный результат",
      "Когда нужно обработать ошибки",
      "Когда промисы зависят друг от друга"
    ],
    correctAnswer: 1,
    explanation: "Promise.race() полезен для реализации таймаутов операций, получения первого доступного результата из нескольких источников, или реализации отмены операций.",
    topic: "Promise.race/any/allSettled"
  },
  {
    id: 24,
    question: "Что выведет этот код?\n\nPromise.allSettled([\n  Promise.resolve(1),\n  Promise.reject('error'),\n  Promise.resolve(3)\n]).then(console.log);",
    options: [
      "[1, 3]",
      "error",
      "[{status: 'fulfilled', value: 1}, {status: 'rejected', reason: 'error'}, {status: 'fulfilled', value: 3}]",
      "1"
    ],
    correctAnswer: 2,
    explanation: "Promise.allSettled() вернет массив объектов с информацией о каждом промисе: их статусе и результате/ошибке.",
    topic: "Promise.race/any/allSettled"
  }
]
