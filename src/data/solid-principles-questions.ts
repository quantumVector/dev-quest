import type { Question } from '@/types/question.ts'

export const solidPrinciplesQuestions: Question[] = [
  // Single Responsibility Principle (SRP)
  {
    id: 1,
    question: "Что означает Single Responsibility Principle (SRP) во фронтенде?",
    options: [
      "Компонент должен иметь только один метод",
      "Компонент должен иметь только одну причину для изменения",
      "Компонент должен использоваться только в одном месте",
      "Компонент должен рендерить только один элемент"
    ],
    correctAnswer: 1,
    explanation: "SRP означает, что компонент должен иметь только одну ответственность и одну причину для изменения. Это делает код более понятным, тестируемым и поддерживаемым.",
    topic: "Single Responsibility Principle"
  },
  {
    id: 2,
    question: "Какой компонент нарушает Single Responsibility Principle?",
    options: [
      "Компонент, который только отображает данные пользователя",
      "Компонент, который делает API запрос, обрабатывает ошибки, форматирует данные и рендерит UI",
      "Компонент, который принимает props и рендерит их",
      "Компонент, который использует useState для локального состояния"
    ],
    correctAnswer: 1,
    explanation: "Компонент, совмещающий логику API запросов, обработку ошибок, форматирование и рендеринг, нарушает SRP. Эти обязанности должны быть разделены между разными модулями/компонентами.",
    topic: "Single Responsibility Principle"
  },
  {
    id: 3,
    question: "Как правильно применить SRP к компоненту формы?",
    options: [
      "Разместить всю логику валидации, отправки и UI в одном компоненте",
      "Создать отдельные компоненты для UI, кастомный хук для логики формы и утилиты для валидации",
      "Использовать только классовые компоненты",
      "Создать один большой useState для всех полей"
    ],
    correctAnswer: 1,
    explanation: "Разделение на presentation компонент, custom hook для логики и отдельные утилиты валидации соответствует SRP: каждая часть имеет одну ответственность.",
    topic: "Single Responsibility Principle"
  },
  {
    id: 4,
    question: "Какой признак указывает на нарушение SRP в React компоненте?",
    options: [
      "Использование useEffect",
      "Компонент содержит более 200 строк кода с бизнес-логикой, API запросами и сложным UI",
      "Использование props",
      "Наличие локального state"
    ],
    correctAnswer: 1,
    explanation: "Большой компонент с множеством разных обязанностей (бизнес-логика + API + UI) - явный признак нарушения SRP. Это затрудняет тестирование и поддержку.",
    topic: "Single Responsibility Principle"
  },
  {
    id: 5,
    question: "Как SRP применяется к React хукам?",
    options: [
      "Один хук должен содержать всю логику приложения",
      "Каждый кастомный хук должен решать одну конкретную задачу",
      "Хуки не должны использовать другие хуки",
      "SRP не применим к хукам"
    ],
    correctAnswer: 1,
    explanation: "Кастомные хуки должны следовать SRP: useAuth для аутентификации, useFetch для запросов, useForm для форм. Каждый хук имеет одну четкую ответственность.",
    topic: "Single Responsibility Principle"
  },

  // Open/Closed Principle (OCP)
  {
    id: 6,
    question: "Что означает Open/Closed Principle для фронтенд компонентов?",
    options: [
      "Компоненты должны быть открыты для изменений, закрыты для расширений",
      "Компоненты должны быть открыты для расширений, закрыты для модификаций",
      "Компоненты должны быть полностью закрыты",
      "Компоненты должны быть полностью открыты"
    ],
    correctAnswer: 1,
    explanation: "OCP: код должен быть открыт для расширений (можно добавлять новую функциональность), но закрыт для модификаций (не нужно изменять существующий код).",
    topic: "Open/Closed Principle"
  },
  {
    id: 7,
    question: "Какой паттерн лучше всего демонстрирует Open/Closed Principle в React?",
    options: [
      "Хардкодинг всех вариантов в switch/case внутри компонента",
      "Использование композиции и render props/children для расширения функциональности",
      "Создание нового компонента для каждого варианта",
      "Использование глобальных переменных"
    ],
    correctAnswer: 1,
    explanation: "Композиция через props.children, render props, HOC позволяет расширять компонент без изменения его кода, что соответствует OCP.",
    topic: "Open/Closed Principle"
  },
  {
    id: 8,
    question: "Как применить OCP к компоненту Button с разными вариантами стилей?",
    options: [
      "Добавлять новые if/else для каждого варианта внутри компонента",
      "Использовать пропсы variant и стили из theme, позволяя расширять через theme provider",
      "Копировать компонент для каждого варианта",
      "Использовать inline стили для каждого случая"
    ],
    correctAnswer: 1,
    explanation: "Использование системы тем и variant props позволяет добавлять новые варианты стилей через конфигурацию без изменения кода компонента.",
    topic: "Open/Closed Principle"
  },
  {
    id: 9,
    question: "Какой код нарушает Open/Closed Principle?",
    options: [
      "Компонент с props для кастомизации",
      "Компонент, в который нужно добавлять новый case в switch при каждом новом типе данных",
      "Компонент с композицией через children",
      "Компонент с использованием HOC"
    ],
    correctAnswer: 1,
    explanation: "Необходимость модифицировать switch/case при добавлении нового типа нарушает OCP. Лучше использовать полиморфизм, strategy pattern или композицию.",
    topic: "Open/Closed Principle"
  },
  {
    id: 10,
    question: "Как OCP применяется к системе роутинга в SPA?",
    options: [
      "Хардкодить все роуты в одном файле",
      "Использовать конфигурационный подход с массивом/объектом роутов, позволяющий добавлять новые без изменения роутера",
      "Создавать новый роутер для каждого роута",
      "Использовать только hash-based routing"
    ],
    correctAnswer: 1,
    explanation: "Конфигурационный подход к роутингу позволяет добавлять новые роуты через конфигурацию без изменения кода роутера, что соответствует OCP.",
    topic: "Open/Closed Principle"
  },

  // Liskov Substitution Principle (LSP)
  {
    id: 11,
    question: "Что означает Liskov Substitution Principle для React компонентов?",
    options: [
      "Все компоненты должны быть классовыми",
      "Компонент-наследник должен работать везде, где работает базовый компонент, без нарушения ожидаемого поведения",
      "Компоненты не должны принимать props",
      "Все компоненты должны быть функциональными"
    ],
    correctAnswer: 1,
    explanation: "LSP: если компонент B расширяет компонент A (или используется вместо него), он должен работать корректно везде, где ожидается A, без изменения поведения.",
    topic: "Liskov Substitution Principle"
  },
  {
    id: 12,
    question: "Какой пример нарушает LSP?",
    options: [
      "BaseButton принимает onClick, ExtendedButton тоже принимает onClick и добавляет analytics",
      "BaseInput принимает onChange, но ExtendedInput игнорирует onChange и работает иначе",
      "BaseCard рендерит children, ExtendedCard тоже рендерит children с дополнительным стилем",
      "BaseModal показывает контент, ExtendedModal добавляет анимацию"
    ],
    correctAnswer: 1,
    explanation: "Если ExtendedInput игнорирует или меняет поведение базового onChange, это нарушает LSP - код, ожидающий BaseInput, не будет корректно работать с ExtendedInput.",
    topic: "Liskov Substitution Principle"
  },
  {
    id: 13,
    question: "Как правильно расширить компонент согласно LSP?",
    options: [
      "Изменить типы props на несовместимые",
      "Добавить новые props, сохраняя поведение базовых props",
      "Удалить обязательные props базового компонента",
      "Изменить возвращаемую структуру JSX на несовместимую"
    ],
    correctAnswer: 1,
    explanation: "Расширяя компонент, можно добавлять новые props и функциональность, но базовые props должны работать так же, как в родительском компоненте.",
    topic: "Liskov Substitution Principle"
  },
  {
    id: 14,
    question: "Применим ли LSP к TypeScript интерфейсам компонентов?",
    options: [
      "Нет, LSP только для классов",
      "Да, интерфейс расширенного компонента должен быть совместим с базовым интерфейсом",
      "LSP не применим к TypeScript",
      "Только для generic типов"
    ],
    correctAnswer: 1,
    explanation: "LSP применим к типизации: если ExtendedButtonProps extends BaseButtonProps, то ExtendedButton должен принимать все props BaseButton и работать корректно.",
    topic: "Liskov Substitution Principle"
  },
  {
    id: 15,
    question: "Какой признак нарушения LSP в системе компонентов?",
    options: [
      "Компонент использует useState",
      "При замене базового компонента на расширенный ломается существующая функциональность",
      "Компонент имеет children prop",
      "Компонент использует useEffect"
    ],
    correctAnswer: 1,
    explanation: "Если замена базового компонента на расширенный вызывает ошибки или неожиданное поведение - это явное нарушение LSP.",
    topic: "Liskov Substitution Principle"
  },

  // Interface Segregation Principle (ISP)
  {
    id: 16,
    question: "Что означает Interface Segregation Principle для React компонентов?",
    options: [
      "Все компоненты должны использовать интерфейсы TypeScript",
      "Компоненты не должны зависеть от props, которые им не нужны",
      "Нужно создавать один большой интерфейс для всех компонентов",
      "Интерфейсы не нужны в JavaScript"
    ],
    correctAnswer: 1,
    explanation: "ISP: не заставляйте компоненты зависеть от props/методов, которые им не нужны. Создавайте узкие, специфичные интерфейсы.",
    topic: "Interface Segregation Principle"
  },
  {
    id: 17,
    question: "Какой пример нарушает ISP?",
    options: [
      "Компонент UserCard принимает только { name, avatar }",
      "Компонент Avatar принимает огромный объект User со 100+ полями, хотя нужен только avatarUrl",
      "Компонент Button принимает { label, onClick }",
      "Компонент Input принимает { value, onChange }"
    ],
    correctAnswer: 1,
    explanation: "Передача огромного объекта User, когда нужно только одно поле - нарушение ISP. Компонент становится зависим от ненужных данных.",
    topic: "Interface Segregation Principle"
  },
  {
    id: 18,
    question: "Как применить ISP к пропсам компонента?",
    options: [
      "Передавать весь store/context в каждый компонент",
      "Передавать только необходимые данные, используя деструктуризацию или селекторы",
      "Использовать глобальные переменные",
      "Всегда передавать полные объекты сущностей"
    ],
    correctAnswer: 1,
    explanation: "ISP: передавайте компоненту только то, что ему нужно. Используйте селекторы, деструктуризацию, создавайте специфичные интерфейсы для каждого компонента.",
    topic: "Interface Segregation Principle"
  },
  {
    id: 19,
    question: "Какой подход соответствует ISP при работе с Context API?",
    options: [
      "Один огромный context для всего приложения",
      "Разделение на множество специализированных contexts (AuthContext, ThemeContext, UserContext)",
      "Использование только глобального state",
      "Отказ от Context API"
    ],
    correctAnswer: 1,
    explanation: "Разделение на специализированные contexts соответствует ISP: компоненты подписываются только на нужные им данные, а не на весь глобальный стейт.",
    topic: "Interface Segregation Principle"
  },
  {
    id: 20,
    question: "Как ISP влияет на дизайн API кастомных хуков?",
    options: [
      "Хуки должны возвращать всю информацию сразу",
      "Хуки должны возвращать только необходимые данные и методы для конкретного use case",
      "Все хуки должны иметь одинаковый интерфейс",
      "ISP не применим к хукам"
    ],
    correctAnswer: 1,
    explanation: "Хук должен предоставлять минимальный необходимый интерфейс. Например, useAuth может возвращать { isAuthenticated, login, logout } без лишних деталей.",
    topic: "Interface Segregation Principle"
  },

  // Dependency Inversion Principle (DIP)
  {
    id: 21,
    question: "Что означает Dependency Inversion Principle для фронтенда?",
    options: [
      "Высокоуровневые модули не должны зависеть от низкоуровневых, оба должны зависеть от абстракций",
      "Все зависимости должны быть глобальными",
      "Нужно избегать всех зависимостей",
      "Зависимости должны быть только в одном направлении"
    ],
    correctAnswer: 0,
    explanation: "DIP: компоненты верхнего уровня не должны напрямую зависеть от деталей реализации. Вместо этого оба зависят от абстракций (интерфейсов, контрактов).",
    topic: "Dependency Inversion Principle"
  },
  {
    id: 22,
    question: "Какой код нарушает DIP?",
    options: [
      "Компонент использует API service через dependency injection",
      "Компонент напрямую импортирует и использует конкретный класс API с axios внутри",
      "Компонент использует хук, который абстрагирует API логику",
      "Компонент принимает функцию fetchData через props"
    ],
    correctAnswer: 1,
    explanation: "Прямая зависимость компонента от конкретной реализации API нарушает DIP. Компонент должен зависеть от абстракции (интерфейс, хук, инъекция).",
    topic: "Dependency Inversion Principle"
  },
  {
    id: 23,
    question: "Как правильно применить DIP к компоненту, использующему API?",
    options: [
      "Хардкодить fetch('/api/users') прямо в компоненте",
      "Использовать кастомный хук или функцию из props, предоставляющую абстракцию над API",
      "Импортировать axios напрямую в каждый компонент",
      "Использовать только XMLHttpRequest"
    ],
    correctAnswer: 1,
    explanation: "DIP: компонент должен зависеть от абстракции (useFetchUsers хук или fetchUsers prop), а не от конкретной реализации HTTP клиента.",
    topic: "Dependency Inversion Principle"
  },
  {
    id: 24,
    question: "Какой паттерн помогает реализовать DIP во фронтенде?",
    options: [
      "Прямой импорт всех зависимостей",
      "Dependency Injection через props, Context API или DI контейнеры",
      "Использование только глобальных переменных",
      "Встраивание всей логики в компонент"
    ],
    correctAnswer: 1,
    explanation: "Dependency Injection (через props, Context, DI библиотеки) позволяет инвертировать зависимости: компонент получает абстракцию, а конкретная реализация внедряется извне.",
    topic: "Dependency Inversion Principle"
  },
  {
    id: 25,
    question: "Как DIP применяется к тестированию React компонентов?",
    options: [
      "Делает тестирование невозможным",
      "Позволяет легко мокать зависимости, передавая mock функции через props или Context",
      "Требует тестирования только integration тестов",
      "DIP не влияет на тестирование"
    ],
    correctAnswer: 1,
    explanation: "Благодаря DIP можно легко подменять зависимости в тестах: вместо реального API service передаем mock, что упрощает unit тестирование.",
    topic: "Dependency Inversion Principle"
  },

  // Комплексные вопросы
  {
    id: 26,
    question: "Какие принципы SOLID нарушены в компоненте, который делает API запрос, валидирует данные, форматирует и рендерит UI?",
    options: [
      "Только SRP",
      "SRP и OCP",
      "SRP и DIP",
      "Все принципы SOLID"
    ],
    correctAnswer: 2,
    explanation: "Нарушены SRP (множество ответственностей) и DIP (прямая зависимость от API реализации). Также может нарушаться ISP, если компонент требует избыточные props.",
    topic: "Комплексные вопросы"
  },
  {
    id: 27,
    question: "Какой подход лучше всего следует всем принципам SOLID?",
    options: [
      "Один большой компонент со всей логикой",
      "Разделение на презентационные компоненты, кастомные хуки для логики, service слой для API, внедрение зависимостей",
      "Использование только классовых компонентов",
      "Избегание любых абстракций"
    ],
    correctAnswer: 1,
    explanation: "Разделение ответственностей (SRP), использование композиции (OCP), зависимость от абстракций (DIP), узкие интерфейсы (ISP) - соответствует всем принципам SOLID.",
    topic: "Комплексные вопросы"
  },
  {
    id: 28,
    question: "Как SOLID принципы влияют на архитектуру Feature-Sliced Design?",
    options: [
      "SOLID не применим к FSD",
      "Каждый слой (ui, model, api) следует SRP, использует DIP для связи между слоями",
      "FSD противоречит SOLID",
      "В FSD используется только OCP"
    ],
    correctAnswer: 1,
    explanation: "FSD построен на SOLID: разделение на слои (SRP), public API слоев (ISP), независимость от конкретных реализаций (DIP), возможность расширения (OCP).",
    topic: "Комплексные вопросы"
  },
  {
    id: 29,
    question: "Какой антипаттерн указывает на игнорирование SOLID принципов?",
    options: [
      "Использование TypeScript",
      "God Component/Object - огромный компонент/объект, делающий всё",
      "Разделение на маленькие компоненты",
      "Использование кастомных хуков"
    ],
    correctAnswer: 1,
    explanation: "God Component/Object нарушает практически все принципы SOLID: множество ответственностей (SRP), сложность расширения (OCP), избыточные зависимости (ISP, DIP).",
    topic: "Комплексные вопросы"
  },
  {
    id: 30,
    question: "Как применение SOLID влияет на производительность фронтенд приложения?",
    options: [
      "Всегда ухудшает производительность",
      "Может улучшить через лучшее мемоизацию, code splitting и переиспользование компонентов",
      "Не влияет на производительность",
      "Только замедляет приложение"
    ],
    correctAnswer: 1,
    explanation: "SOLID способствует созданию переиспользуемых, независимых компонентов, что упрощает мемоизацию, code splitting и оптимизацию ре-рендеров, положительно влияя на производительность.",
    topic: "Комплексные вопросы"
  },

  // Практические примеры
  {
    id: 31,
    question: "Какой рефакторинг соответствует SRP для компонента UserProfile?",
    options: [
      "Добавить ещё больше логики в один компонент",
      "Разделить на UserProfileView (UI), useUserProfile (данные), useUserValidation (валидация)",
      "Удалить все useState",
      "Использовать только inline стили"
    ],
    correctAnswer: 1,
    explanation: "Разделение на отдельные модули с четкими ответственностями: View для UI, хуки для логики и валидации - классический пример применения SRP.",
    topic: "Практические примеры"
  },
  {
    id: 32,
    question: "Как OCP помогает при создании библиотеки UI компонентов?",
    options: [
      "Компоненты нельзя кастомизировать",
      "Через систему тем, variants, composition patterns компоненты расширяются без изменения кода библиотеки",
      "Нужно форкать библиотеку для каждого изменения",
      "OCP не применим к UI библиотекам"
    ],
    correctAnswer: 1,
    explanation: "Хорошая UI библиотека следует OCP: theme provider, variant props, composition через children/slots позволяют расширять компоненты без изменения их кода.",
    topic: "Практические примеры"
  },
  {
    id: 33,
    question: "Какой пример демонстрирует правильное применение LSP в системе форм?",
    options: [
      "TextInput и EmailInput имеют разные обязательные props",
      "BaseInput, TextInput extends BaseInput (добавляет autocomplete), все работают с formik",
      "Каждый инпут имеет собственный уникальный API",
      "Инпуты не совместимы между собой"
    ],
    correctAnswer: 1,
    explanation: "Если все инпуты наследуют BaseInput и работают с одной системой форм (formik), можно безопасно заменять базовый инпут на специализированный - это LSP.",
    topic: "Практические примеры"
  },
  {
    id: 34,
    question: "Как ISP применяется при проектировании Redux store?",
    options: [
      "Один огромный slice для всего приложения",
      "Разделение на feature-specific slices, компоненты подписываются через селекторы только на нужные данные",
      "Все компоненты должны подписываться на весь store",
      "ISP не применим к Redux"
    ],
    correctAnswer: 1,
    explanation: "Разделение store на слайсы и использование селекторов - пример ISP: компонент зависит только от необходимой части стейта, а не от всего store.",
    topic: "Практические примеры"
  },
  {
    id: 35,
    question: "Какой паттерн лучше всего демонстрирует DIP при работе с external API?",
    options: [
      "Прямой вызов fetch в каждом компоненте",
      "API Service Layer с интерфейсом + React Query/SWR хуки для абстракции",
      "Копирование кода fetch везде",
      "Использование только XMLHttpRequest"
    ],
    correctAnswer: 1,
    explanation: "Service Layer предоставляет абстракцию над HTTP клиентом, а React Query/SWR абстрагируют кеширование и синхронизацию - компоненты зависят от абстракций, не от деталей.",
    topic: "Практические примеры"
  },

  // Edge cases и продвинутые вопросы
  {
    id: 36,
    question: "Можно ли следовать SOLID слишком строго во фронтенде?",
    options: [
      "Нет, нужно всегда следовать на 100%",
      "Да, чрезмерная абстракция может привести к over-engineering и усложнению кода",
      "SOLID вообще не нужен во фронтенде",
      "SOLID применим только к бэкенду"
    ],
    correctAnswer: 1,
    explanation: "SOLID - это принципы, а не догмы. Важен баланс: применять где это улучшает код, но избегать чрезмерной абстракции, которая усложняет понимание и поддержку.",
    topic: "Продвинутые вопросы"
  },
  {
    id: 37,
    question: "Как SOLID соотносится с принципом KISS (Keep It Simple)?",
    options: [
      "Противоречат друг другу",
      "Дополняют: SOLID помогает структурировать, KISS напоминает не усложнять без необходимости",
      "KISS важнее SOLID",
      "SOLID важнее KISS"
    ],
    correctAnswer: 1,
    explanation: "SOLID и KISS дополняют друг друга: SOLID дает структуру и принципы, KISS напоминает о простоте. Цель - простой, но хорошо структурированный код.",
    topic: "Продвинутые вопросы"
  },
  {
    id: 38,
    question: "Влияет ли размер проекта на применимость SOLID?",
    options: [
      "SOLID только для больших проектов",
      "SOLID масштабируется: в маленьких проектах можно быть гибче, в больших принципы критичнее",
      "SOLID только для маленьких проектов",
      "Размер не влияет, нужно всегда применять одинаково строго"
    ],
    correctAnswer: 1,
    explanation: "В прототипах/MVP можно быть прагматичнее, но с ростом проекта SOLID становится критичным для поддерживаемости. Важно найти баланс для текущего масштаба.",
    topic: "Продвинутые вопросы"
  },
  {
    id: 39,
    question: "Как SOLID принципы помогают при рефакторинге legacy кода?",
    options: [
      "Не помогают, нужно переписать всё с нуля",
      "Предоставляют направление: разделить ответственности, выделить абстракции, уменьшить связанность",
      "SOLID только для нового кода",
      "Рефакторинг невозможен с SOLID"
    ],
    correctAnswer: 1,
    explanation: "SOLID дает методологию рефакторинга: выделение ответственностей (SRP), создание абстракций (DIP), уменьшение зависимостей (ISP) - пошаговое улучшение legacy кода.",
    topic: "Продвинутые вопросы"
  },
  {
    id: 40,
    question: "Какой главный критерий успешного применения SOLID во фронтенде?",
    options: [
      "Количество созданных абстракций",
      "Баланс между структурированностью кода и простотой понимания, легкость тестирования и поддержки",
      "Строгое следование всем принципам всегда",
      "Количество файлов в проекте"
    ],
    correctAnswer: 1,
    explanation: "Главный критерий - код стал понятнее, легче тестируется и поддерживается. SOLID - средство достижения этих целей, а не самоцель.",
    topic: "Продвинутые вопросы"
  }
]
