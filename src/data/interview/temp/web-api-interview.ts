export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webAPIInterviewQuestions: InterviewQuestion[] = [
  {
    id: 61,
    question: "Что такое ResizeObserver и для чего он используется?",
    answer: "<p><strong>ResizeObserver</strong> — это Web API для асинхронного отслеживания изменений размеров DOM элементов:</p><h4>Основное назначение:</h4><p>Позволяет эффективно отслеживать когда элементы меняют свои размеры, в отличие от <code>window.resize</code> который отслеживает только размер окна браузера.</p><h4>Создание и использование:</h4><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;for (const entry of entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Width:', entry.contentRect.width);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Height:', entry.contentRect.height);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>observer.observe(element);</code></p><h4>Основные применения:</h4><ul><li><strong>Container Queries:</strong> Адаптивные компоненты на основе их размера</li><li><strong>Canvas:</strong> Обновление разрешения при изменении размера</li><li><strong>Виртуализация:</strong> Отслеживание высот элементов в списках</li><li><strong>Адаптивная типографика:</strong> Изменение размера шрифта</li><li><strong>Grid layouts:</strong> Динамическое количество колонок</li></ul><p><em>Ключевое отличие:</em> Реагирует на изменения размеров конкретных элементов из-за CSS, контента, родительских контейнеров — не только viewport.</p>",
    difficulty: 'junior',
    tags: ['ResizeObserver', 'основы', 'Web API', 'DOM']
  },
  {
    id: 62,
    question: "Каким образом можно отслеживать изменения размеров нескольких элементов с помощью ResizeObserver?",
    answer: "<p>Один ResizeObserver может эффективно наблюдать за множеством элементов одновременно:</p><h4>Базовый подход:</h4><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const width = entry.contentRect.width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Element \${element.id}: \${width}px\`);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>// Наблюдаем за несколькими элементами</code><br><code>const sidebar = document.querySelector('.sidebar');</code><br><code>const main = document.querySelector('.main');</code><br><code>const footer = document.querySelector('.footer');</code></p><p><code>observer.observe(sidebar);</code><br><code>observer.observe(main);</code><br><code>observer.observe(footer);</code></p><h4>С индивидуальными callback:</h4><p><code>const callbacks = new Map();</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const callback = callbacks.get(entry.target);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (callback) callback(entry);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>function observeElement(element, callback) {</code><br><code>&nbsp;&nbsp;callbacks.set(element, callback);</code><br><code>&nbsp;&nbsp;observer.observe(element);</code><br><code>}</code></p><p><code>observeElement(sidebar, (entry) => {</code><br><code>&nbsp;&nbsp;console.log('Sidebar:', entry.contentRect.width);</code><br><code>});</code></p><p><em>Преимущество:</em> Браузер оптимизирует вызовы callback, батчируя изменения всех наблюдаемых элементов.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'несколько элементов', 'оптимизация', 'паттерны']
  },
  {
    id: 63,
    question: "В чем разница между contentRect, contentBoxSize и borderBoxSize в ResizeObserver?",
    answer: "<p>ResizeObserver предоставляет три способа получения размеров элемента с разными box models:</p><h4>1. contentRect (устаревший, но широко поддерживается):</h4><p>Возвращает размеры <strong>content-box</strong> — только контент без padding.</p><p><code>observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;const height = entries[0].contentRect.height;</code><br><code>});</code></p><h4>2. contentBoxSize (современный):</h4><p>Массив размеров content-box с <code>inlineSize</code> и <code>blockSize</code>:</p><p><code>const size = Array.isArray(entry.contentBoxSize)</code><br><code>&nbsp;&nbsp;? entry.contentBoxSize[0]</code><br><code>&nbsp;&nbsp;: entry.contentBoxSize;</code></p><p><code>console.log('Width:', size.inlineSize);</code><br><code>console.log('Height:', size.blockSize);</code></p><h4>3. borderBoxSize:</h4><p>Размеры <strong>border-box</strong> — включая padding и border:</p><p><code>const size = Array.isArray(entry.borderBoxSize)</code><br><code>&nbsp;&nbsp;? entry.borderBoxSize[0]</code><br><code>&nbsp;&nbsp;: entry.borderBoxSize;</code></p><h4>4. devicePixelContentBoxSize:</h4><p>Размеры в device pixels для canvas и Retina дисплеев:</p><p><code>const size = entry.devicePixelContentBoxSize[0];</code><br><code>canvas.width = size.inlineSize;</code><br><code>canvas.height = size.blockSize;</code></p><h4>Указание box model при наблюдении:</h4><p><code>observer.observe(element, { box: 'border-box' });</code><br><code>// Опции: 'content-box', 'border-box', 'device-pixel-content-box'</code></p><p><em>Когда использовать:</em> content-box для контента, border-box для общих размеров элемента, device-pixel-content-box для canvas с правильным DPI.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'box model', 'contentRect', 'размеры']
  },
  {
    id: 64,
    question: "Как правильно освобождать ресурсы ResizeObserver при размонтировании компонента?",
    answer: "<p>Правильная очистка ResizeObserver критична для предотвращения утечек памяти:</p><h4>Методы очистки:</h4><p><strong>disconnect():</strong> Останавливает наблюдение за всеми элементами</p><p><code>observer.disconnect();</code></p><p><strong>unobserve(element):</strong> Прекращает наблюдение за конкретным элементом</p><p><code>observer.unobserve(element);</code></p><h4>В vanilla JavaScript:</h4><p><code>class Component {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;mount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.element);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;unmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>В React:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;const element = elementRef.current;</code></p><p><code>&nbsp;&nbsp;if (element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element) observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;};</code><br><code>}, []);</code></p><h4>В Vue:</h4><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;observer.value = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;observer.value.observe(element.value);</code><br><code>});</code></p><p><code>onUnmounted(() => {</code><br><code>&nbsp;&nbsp;observer.value?.disconnect();</code><br><code>&nbsp;&nbsp;observer.value = null;</code><br><code>});</code></p><p><em>Критично:</em> Всегда вызывайте disconnect() или unobserve() при размонтировании, иначе observer продолжит работать и занимать память.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'cleanup', 'утечки памяти', 'lifecycle']
  },
  {
    id: 65,
    question: "Как оптимизировать производительность при использовании ResizeObserver для частых изменений?",
    answer: "<p>ResizeObserver callback может вызываться очень часто, требуя оптимизации:</p><h4>1. Debounce для тяжелых операций:</h4><p><code>function debounce(func, wait) {</code><br><code>&nbsp;&nbsp;let timeout;</code><br><code>&nbsp;&nbsp;return (...args) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = setTimeout(() => func(...args), wait);</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>const debouncedHandler = debounce((entry) => {</code><br><code>&nbsp;&nbsp;// Тяжелые вычисления</code><br><code>}, 250);</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(debouncedHandler);</code><br><code>});</code></p><h4>2. requestAnimationFrame для обновлений DOM:</h4><p><code>let rafId = null;</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (rafId) cancelAnimationFrame(rafId);</code></p><p><code>&nbsp;&nbsp;rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обновление DOM</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;rafId = null;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>3. Батчинг обновлений:</h4><p><code>class BatchedObserver {</code><br><code>&nbsp;&nbsp;constructor(callback, delay = 16) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pending = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.set(entry.target, entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(Array.from(this.pending.values()));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.clear();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>4. Условное наблюдение:</h4><p><code>class ConditionalObserver {</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements.forEach(el => this.observer.observe(el));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer?.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Золотое правило:</em> Callback должен быть быстрым. Тяжелые операции выносить в Web Workers или оптимизировать через debounce/RAF.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'производительность', 'оптимизация', 'debounce']
  },
  {
    id: 66,
    question: "Как использовать ResizeObserver для адаптивных компонентов (Container Queries)?",
    answer: "<p>ResizeObserver позволяет создавать адаптивные компоненты на основе их собственного размера, а не viewport:</p><h4>Базовая реализация:</h4><p><code>const card = document.querySelector('.card');</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;// Удаляем старые классы</code><br><code>&nbsp;&nbsp;card.classList.remove('small', 'medium', 'large');</code></p><p><code>&nbsp;&nbsp;// Добавляем класс в зависимости от ширины компонента</code><br><code>&nbsp;&nbsp;if (width < 400) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;card.classList.add('small');</code><br><code>&nbsp;&nbsp;} else if (width < 800) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;card.classList.add('medium');</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;card.classList.add('large');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>observer.observe(card);</code></p><h4>CSS стили для разных размеров:</h4><p><code>.card.small {</code><br><code>&nbsp;&nbsp;flex-direction: column;</code><br><code>&nbsp;&nbsp;font-size: 14px;</code><br><code>}</code></p><p><code>.card.medium {</code><br><code>&nbsp;&nbsp;flex-direction: row;</code><br><code>&nbsp;&nbsp;font-size: 16px;</code><br><code>}</code></p><p><code>.card.large {</code><br><code>&nbsp;&nbsp;font-size: 20px;</code><br><code>}</code></p><h4>Адаптивная grid система:</h4><p><code>const grid = document.querySelector('.grid');</code></p><p><code>const gridObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;const minColumnWidth = 200;</code><br><code>&nbsp;&nbsp;const columns = Math.max(1, Math.floor(width / minColumnWidth));</code></p><p><code>&nbsp;&nbsp;grid.style.gridTemplateColumns = \`repeat(\${columns}, 1fr)\`;</code><br><code>});</code></p><p><code>gridObserver.observe(grid);</code></p><h4>В React хук:</h4><p><code>function useContainerQuery(breakpoints) {</code><br><code>&nbsp;&nbsp;const [size, setSize] = useState('large');</code><br><code>&nbsp;&nbsp;const ref = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (width < breakpoints.small) setSize('small');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (width < breakpoints.medium) setSize('medium');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else setSize('large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (ref.current) observer.observe(ref.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return [ref, size];</code><br><code>}</code></p><p><em>Преимущество:</em> Компонент адаптируется к своему контейнеру, а не к размеру экрана — идеально для переиспользуемых компонентов.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'Container Queries', 'адаптивность', 'компоненты']
  },
  {
    id: 67,
    question: "Как использовать ResizeObserver для правильного масштабирования canvas на Retina дисплеях?",
    answer: "<p>ResizeObserver с <code>device-pixel-content-box</code> позволяет правильно масштабировать canvas для Retina дисплеев:</p><h4>Проблема без ResizeObserver:</h4><p><code>// ❌ Размытый canvas на Retina</code><br><code>canvas.width = canvas.offsetWidth;</code><br><code>canvas.height = canvas.offsetHeight;</code></p><h4>Решение с ResizeObserver:</h4><p><code>const canvas = document.querySelector('canvas');</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;for (const entry of entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let width, height;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Используем device-pixel-content-box если доступен</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.devicePixelContentBoxSize) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const size = Array.isArray(entry.devicePixelContentBoxSize)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? entry.devicePixelContentBoxSize[0]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: entry.devicePixelContentBoxSize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width = size.inlineSize;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = size.blockSize;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fallback для старых браузеров</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const dpr = window.devicePixelRatio || 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width = entry.contentRect.width * dpr;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = entry.contentRect.height * dpr;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Устанавливаем размеры canvas в device pixels</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.width = width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.height = height;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// CSS размеры остаются в CSS pixels</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.style.width = entry.contentRect.width + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.style.height = entry.contentRect.height + 'px';</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Перерисовка canvas</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;redrawCanvas();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>// Указываем box model для device pixels</code><br><code>observer.observe(canvas, { box: 'device-pixel-content-box' });</code></p><h4>Класс-обертка для canvas:</h4><p><code>class ResponsiveCanvas {</code><br><code>&nbsp;&nbsp;constructor(canvas) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.canvas = canvas;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ctx = canvas.getContext('2d');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(canvas, { box: 'device-pixel-content-box' });</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const entry = entries[0];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Логика из примера выше</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Результат:</em> Четкий canvas на всех дисплеях, включая Retina, с автоматическим обновлением при изменении размеров.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'canvas', 'Retina', 'device pixels']
  },
  {
    id: 68,
    question: "В чем разница между ResizeObserver и window.resize event?",
    answer: "<p>ResizeObserver и window.resize решают разные задачи и имеют существенные различия:</p><h4>window.resize event:</h4><p><strong>Что отслеживает:</strong> Только изменения размера окна браузера (viewport)</p><p><code>window.addEventListener('resize', () => {</code><br><code>&nbsp;&nbsp;const width = window.innerWidth;</code><br><code>&nbsp;&nbsp;console.log('Window width:', width);</code><br><code>});</code></p><p><strong>Проблемы:</strong></p><ul><li>Не реагирует на изменения размеров элементов</li><li>Срабатывает очень часто (требует throttle)</li><li>Нужно вручную вычислять размеры элементов</li><li>getBoundingClientRect() вызывает reflow</li></ul><h4>ResizeObserver:</h4><p><strong>Что отслеживает:</strong> Размеры конкретных DOM элементов</p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;console.log('Element width:', width);</code><br><code>});</code><br><code>observer.observe(element);</code></p><p><strong>Преимущества:</strong></p><ul><li>Реагирует на CSS изменения, добавление контента</li><li>Работает с элементами внутри скролла</li><li>Браузер оптимизирует вызовы (батчинг)</li><li>Асинхронные вычисления без reflow</li><li>Не требует throttle из коробки</li></ul><h4>Сравнение кода:</h4><p><code>// ❌ window.resize - неэффективно для элементов</code><br><code>let timeout;</code><br><code>window.addEventListener('resize', () => {</code><br><code>&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;timeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const rect = element.getBoundingClientRect(); // Reflow!</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Width:', rect.width);</code><br><code>&nbsp;&nbsp;}, 100);</code><br><code>});</code></p><p><code>// ✅ ResizeObserver - эффективно и просто</code><br><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;console.log('Width:', entries[0].contentRect.width);</code><br><code>});</code><br><code>observer.observe(element);</code></p><h4>Когда использовать:</h4><p><strong>window.resize:</strong> Адаптивность на уровне viewport, медиа-запросы в JS</p><p><strong>ResizeObserver:</strong> Адаптивные компоненты, Container Queries, элемент-специфичная логика</p><p><em>Вывод:</em> Для отслеживания размеров элементов всегда используйте ResizeObserver — он эффективнее и точнее.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'window.resize', 'сравнение', 'различия']
  },
  {
    id: 69,
    question: "Как интегрировать ResizeObserver в React компонент?",
    answer: "<p>Существует несколько паттернов интеграции ResizeObserver с React:</p><h4>1. Хук useResizeObserver:</h4><p><code>import { useEffect, useRef } from 'react';</code></p><p><code>function useResizeObserver(callback) {</code><br><code>&nbsp;&nbsp;const observerRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observerRef.current?.disconnect();</code><br><code>&nbsp;&nbsp;}, [callback]);</code></p><p><code>&nbsp;&nbsp;const observe = (element) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element) observerRef.current?.observe(element);</code><br><code>&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;return { observe };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function MyComponent() {</code><br><code>&nbsp;&nbsp;const divRef = useRef(null);</code><br><code>&nbsp;&nbsp;const [size, setSize] = useState({ width: 0, height: 0 });</code></p><p><code>&nbsp;&nbsp;const { observe } = useResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const { width, height } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setSize({ width, height });</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (divRef.current) observe(divRef.current);</code><br><code>&nbsp;&nbsp;}, [observe]);</code></p><p><code>&nbsp;&nbsp;return &lt;div ref={divRef}&gt;{size.width}x{size.height}&lt;/div&gt;;</code><br><code>}</code></p><h4>2. Хук с ref:</h4><p><code>function useElementSize() {</code><br><code>&nbsp;&nbsp;const [size, setSize] = useState({ width: 0, height: 0 });</code><br><code>&nbsp;&nbsp;const elementRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = elementRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!element) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const { width, height } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setSize({ width, height });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return [elementRef, size];</code><br><code>}</code></p><p><code>// Использование</code><br><code>function Component() {</code><br><code>&nbsp;&nbsp;const [ref, size] = useElementSize();</code><br><code>&nbsp;&nbsp;return &lt;div ref={ref}&gt;Width: {size.width}px&lt;/div&gt;;</code><br><code>}</code></p><h4>3. Адаптивный компонент:</h4><p><code>function AdaptiveCard() {</code><br><code>&nbsp;&nbsp;const [layout, setLayout] = useState('large');</code><br><code>&nbsp;&nbsp;const cardRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (width < 300) setLayout('small');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (width < 600) setLayout('medium');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else setLayout('large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (cardRef.current) observer.observe(cardRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return &lt;div ref={cardRef} className={\`card--\${layout}\`}&gt;...&lt;/div&gt;;</code><br><code>}</code></p><p><em>Best practice:</em> Всегда очищайте observer в cleanup функции useEffect для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'React', 'hooks', 'интеграция']
  },
  {
    id: 70,
    question: "Как интегрировать ResizeObserver в Vue компонент?",
    answer: "<p>В Vue 3 ResizeObserver интегрируется через composables и директивы:</p><h4>1. Composable useResizeObserver:</h4><p><code>import { ref, onMounted, onUnmounted } from 'vue';</code></p><p><code>export function useResizeObserver(callback, options = {}) {</code><br><code>&nbsp;&nbsp;const observer = ref(null);</code></p><p><code>&nbsp;&nbsp;const observe = (element) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!element) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!observer.value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observer.value = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.value.observe(element, options);</code><br><code>&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;const disconnect = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.value?.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.value = null;</code><br><code>&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;onUnmounted(() => disconnect());</code></p><p><code>&nbsp;&nbsp;return { observe, disconnect };</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>const boxRef = ref(null);</code><br><code>const size = ref({ width: 0, height: 0 });</code></p><p><code>const { observe } = useResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const { width, height } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;size.value = { width, height };</code><br><code>});</code></p><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;if (boxRef.value) observe(boxRef.value);</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div ref=\"boxRef\"&gt;{{ size.width }}x{{ size.height }}&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>2. Composable для размеров элемента:</h4><p><code>export function useElementSize(elementRef) {</code><br><code>&nbsp;&nbsp;const width = ref(0);</code><br><code>&nbsp;&nbsp;const height = ref(0);</code></p><p><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!elementRef.value) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const { width: w, height: h } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width.value = w;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height.value = h;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(elementRef.value);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;onUnmounted(() => observer.disconnect());</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;return { width, height };</code><br><code>}</code></p><h4>3. Директива v-resize:</h4><p><code>export const vResize = {</code><br><code>&nbsp;&nbsp;mounted(el, binding) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const callback = binding.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof callback !== 'function') return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;el._resizeObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(entries[0]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;el._resizeObserver.observe(el);</code><br><code>&nbsp;&nbsp;},</code></p><p><code>&nbsp;&nbsp;unmounted(el) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;el._resizeObserver?.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;delete el._resizeObserver;</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><p><code>// Использование</code><br><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div v-resize=\"handleResize\"&gt;Content&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><p><code>&lt;script setup&gt;</code><br><code>function handleResize(entry) {</code><br><code>&nbsp;&nbsp;console.log('Width:', entry.contentRect.width);</code><br><code>}</code><br><code>&lt;/script&gt;</code></p><p><em>Best practice:</em> Используйте composables для переиспользуемой логики и директивы для простых случаев.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'Vue', 'composables', 'директивы']
  },
  {
    id: 71,
    question: "Какие есть подводные камни и ограничения при работе с ResizeObserver?",
    answer: "<p>При работе с ResizeObserver важно знать о возможных проблемах и ограничениях:</p><h4>1. Infinite loop при изменении размеров в callback:</h4><p><strong>Проблема:</strong> Изменение размеров элемента внутри callback вызывает новый resize</p><p><code>// ❌ Бесконечный цикл!</code><br><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const element = entries[0].target;</code><br><code>&nbsp;&nbsp;element.style.width = entries[0].contentRect.width + 10 + 'px';</code><br><code>});</code></p><p><strong>Решение:</strong> Не изменять размеры наблюдаемых элементов в callback</p><h4>2. Частые вызовы callback:</h4><p><strong>Проблема:</strong> Callback может вызываться очень часто при анимациях</p><p><strong>Решение:</strong> Использовать debounce или requestAnimationFrame</p><h4>3. Поддержка браузеров:</h4><p><strong>Проблема:</strong> Не поддерживается в старых браузерах (IE, старые Safari)</p><p><strong>Решение:</strong> Использовать полифил или проверку поддержки:</p><p><code>if ('ResizeObserver' in window) {</code><br><code>&nbsp;&nbsp;// Используем ResizeObserver</code><br><code>} else {</code><br><code>&nbsp;&nbsp;// Fallback на window.resize</code><br><code>}</code></p><h4>4. Асинхронность callback:</h4><p><strong>Проблема:</strong> Callback вызывается асинхронно, есть небольшая задержка</p><p><strong>Решение:</strong> Учитывать задержку, использовать rootMargin для предзагрузки</p><h4>5. Не отслеживает изменения размеров автоматически:</h4><p><strong>Проблема:</strong> Нужно явно вызвать observe() для каждого элемента</p><p><strong>Решение:</strong> Использовать MutationObserver для динамически добавляемых элементов</p><h4>6. Проблемы с display:none:</h4><p><strong>Проблема:</strong> Может некорректно работать с элементами display:none</p><p><strong>Решение:</strong> Начинать наблюдение после отображения элемента</p><h4>7. Производительность при большом количестве элементов:</h4><p><strong>Проблема:</strong> Наблюдение за тысячами элементов может снизить производительность</p><p><strong>Решение:</strong> Ограничивать количество, использовать виртуализацию</p><h4>8. SSR проблемы:</h4><p><strong>Проблема:</strong> ResizeObserver недоступен на сервере</p><p><strong>Решение:</strong> Создавать observer только на клиенте:</p><p><code>if (typeof window !== 'undefined') {</code><br><code>&nbsp;&nbsp;const observer = new ResizeObserver(...);</code><br><code>}</code></p><h4>9. Утечки памяти:</h4><p><strong>Проблема:</strong> Забытый observer продолжает работать</p><p><strong>Решение:</strong> Всегда вызывать disconnect() при размонтировании</p><p><em>Вывод:</em> ResizeObserver — мощный API, но требует понимания ограничений и правильной обработки edge cases.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'ограничения', 'проблемы', 'troubleshooting']
  },
  {
    id: 72,
    question: "Как реализовать виртуализацию списка с динамической высотой элементов через ResizeObserver?",
    answer: "<p>ResizeObserver идеален для виртуализации списков где элементы имеют неизвестную высоту:</p><h4>Проблема виртуализации:</h4><p>В классической виртуализации нужно знать высоту элементов заранее. ResizeObserver позволяет измерять реальные высоты.</p><h4>Базовая реализация:</h4><p><code>class VirtualList {</code><br><code>&nbsp;&nbsp;constructor(container, items) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.items = items;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.itemHeights = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.estimatedHeight = 50; // Примерная высота</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;renderItem(item, index) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.className = 'list-item';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.textContent = item;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.dataset.index = index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за каждым элементом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return element;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const index = parseInt(entry.target.dataset.index);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const height = entry.contentRect.height;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем реальную высоту</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.itemHeights.set(index, height);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Пересчитываем виртуальный скролл</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateVirtualScroll();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;getItemOffset(index) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let offset = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < index; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += this.itemHeights.get(i) || this.estimatedHeight;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return offset;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;updateVirtualScroll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const scrollTop = this.container.scrollTop;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const viewportHeight = this.container.clientHeight;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Находим видимые элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let startIndex = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let currentOffset = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;while (currentOffset < scrollTop && startIndex < this.items.length) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentOffset += this.itemHeights.get(startIndex) || this.estimatedHeight;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startIndex++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Рендерим видимые элементы + буфер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.render(startIndex);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React реализация:</h4><p><code>function VirtualList({ items }) {</code><br><code>&nbsp;&nbsp;const [itemHeights, setItemHeights] = useState(new Map());</code><br><code>&nbsp;&nbsp;const observerRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newHeights = new Map(itemHeights);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const index = parseInt(entry.target.dataset.index);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHeights.set(index, entry.contentRect.height);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setItemHeights(newHeights);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observerRef.current?.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;// Логика виртуализации...</code><br><code>}</code></p><p><em>Преимущество:</em> Виртуализация работает даже с элементами неизвестной и изменяющейся высоты.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'виртуализация', 'списки', 'производительность']
  },
  {
    id: 73,
    question: "Как использовать ResizeObserver для адаптивной типографики?",
    answer: "<p>ResizeObserver позволяет создавать адаптивную типографику на уровне компонента:</p><h4>Базовый пример — масштабирование шрифта:</h4><p><code>const textElement = document.querySelector('.responsive-text');</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;// Адаптивный размер шрифта</code><br><code>&nbsp;&nbsp;let fontSize;</code><br><code>&nbsp;&nbsp;if (width < 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '14px';</code><br><code>&nbsp;&nbsp;} else if (width < 600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '16px';</code><br><code>&nbsp;&nbsp;} else if (width < 900) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '18px';</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '20px';</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;textElement.style.fontSize = fontSize;</code><br><code>});</code></p><p><code>observer.observe(textElement);</code></p><h4>Fluid typography с формулой:</h4><p><code>const fluidObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;// Линейная интерполяция</code><br><code>&nbsp;&nbsp;const minWidth = 320;</code><br><code>&nbsp;&nbsp;const maxWidth = 1200;</code><br><code>&nbsp;&nbsp;const minFontSize = 16;</code><br><code>&nbsp;&nbsp;const maxFontSize = 24;</code></p><p><code>&nbsp;&nbsp;const clampedWidth = Math.max(minWidth, Math.min(width, maxWidth));</code><br><code>&nbsp;&nbsp;const fontSize = minFontSize + </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;(maxFontSize - minFontSize) * </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;((clampedWidth - minWidth) / (maxWidth - minWidth));</code></p><p><code>&nbsp;&nbsp;textElement.style.fontSize = fontSize + 'px';</code><br><code>});</code></p><h4>Адаптация всей типографики:</h4><p><code>class ResponsiveTypography {</code><br><code>&nbsp;&nbsp;constructor(container) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(container);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Базовый размер шрифта</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const baseFontSize = this.calculateFontSize(width, 16, 20);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.fontSize = baseFontSize + 'px';</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Межстрочный интервал</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const lineHeight = width < 600 ? 1.5 : 1.6;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.lineHeight = lineHeight;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Ширина контента</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const maxWidth = width < 800 ? '100%' : '70ch';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.maxWidth = maxWidth;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отступы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const padding = width < 600 ? '1rem' : '2rem';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.padding = padding;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;calculateFontSize(width, min, max) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const minWidth = 320;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const maxWidth = 1200;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const clampedWidth = Math.max(minWidth, Math.min(width, maxWidth));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return min + (max - min) * ((clampedWidth - minWidth) / (maxWidth - minWidth));</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React компонент:</h4><p><code>function ResponsiveText({ children }) {</code><br><code>&nbsp;&nbsp;const [fontSize, setFontSize] = useState(16);</code><br><code>&nbsp;&nbsp;const textRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const size = 14 + (width / 100);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setFontSize(Math.min(24, Math.max(14, size)));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (textRef.current) observer.observe(textRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div ref={textRef} style={{ fontSize: \`\${fontSize}px\` }}&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{children}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Применение:</em> Карточки товаров, адаптивные заголовки, текст в sidebar, модальные окна — везде где размер контейнера непредсказуем.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'типографика', 'адаптивность', 'responsive']
  },
  {
    id: 74,
    question: "Как реализовать debounce и throttle для ResizeObserver?",
    answer: "<p>ResizeObserver callback может вызываться очень часто, особенно при анимациях. Debounce и throttle помогают оптимизировать:</p><h4>1. Debounce (задержка до последнего изменения):</h4><p><code>function debounce(func, wait) {</code><br><code>&nbsp;&nbsp;let timeout;</code><br><code>&nbsp;&nbsp;return function executedFunction(...args) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const later = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func(...args);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = setTimeout(later, wait);</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>const debouncedHandler = debounce((entry) => {</code><br><code>&nbsp;&nbsp;console.log('Debounced resize:', entry.contentRect.width);</code><br><code>&nbsp;&nbsp;// Тяжелые вычисления</code><br><code>}, 250);</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(debouncedHandler);</code><br><code>});</code></p><h4>2. Throttle (ограничение частоты):</h4><p><code>function throttle(func, limit) {</code><br><code>&nbsp;&nbsp;let inThrottle;</code><br><code>&nbsp;&nbsp;return function(...args) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!inThrottle) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func.apply(this, args);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inThrottle = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => inThrottle = false, limit);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>const throttledHandler = throttle((entry) => {</code><br><code>&nbsp;&nbsp;console.log('Throttled resize:', entry.contentRect.width);</code><br><code>}, 100);</code></p><p><code>const throttledObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(throttledHandler);</code><br><code>});</code></p><h4>3. requestAnimationFrame подход:</h4><p><code>let rafId = null;</code></p><p><code>const rafObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (rafId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(rafId);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('RAF resize:', entry.contentRect.width);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обновление DOM</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;rafId = null;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>4. Батчинг с задержкой:</h4><p><code>class BatchedResizeObserver {</code><br><code>&nbsp;&nbsp;constructor(callback, delay = 16) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pending = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timeoutId = null;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Собираем все изменения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.set(entry.target, entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Откладываем обработку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.timeoutId) clearTimeout(this.timeoutId);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const entries = Array.from(this.pending.values());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback(entries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.clear();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;observe(element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const batchedObserver = new BatchedResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;console.log('Batched resize for', entries.length, 'elements');</code><br><code>});</code></p><h4>Когда использовать:</h4><ul><li><strong>Debounce:</strong> Тяжелые вычисления после завершения изменений</li><li><strong>Throttle:</strong> Регулярные обновления во время изменений</li><li><strong>RAF:</strong> Визуальные обновления DOM</li><li><strong>Батчинг:</strong> Множество элементов, одна обработка</li></ul><p><em>Важно:</em> Не все случаи требуют оптимизации — простые операции можно выполнять напрямую.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'debounce', 'throttle', 'оптимизация']
  },
  {
    id: 75,
    question: "Когда следует использовать ResizeObserver вместо CSS Container Queries?",
    answer: "<p>CSS Container Queries и ResizeObserver решают похожие задачи, но имеют разные применения:</p><h4>CSS Container Queries (современный стандарт):</h4><p><strong>Что это:</strong> CSS правила, зависящие от размера контейнера</p><p><code>/* CSS */</code><br><code>.container {</code><br><code>&nbsp;&nbsp;container-type: inline-size;</code><br><code>}</code></p><p><code>@container (min-width: 400px) {</code><br><code>&nbsp;&nbsp;.card {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;flex-direction: row;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><strong>Преимущества:</strong></p><ul><li>Декларативный подход</li><li>Оптимизирован браузером</li><li>Нет JavaScript</li><li>Работает с CSS transitions/animations</li></ul><p><strong>Ограничения:</strong></p><ul><li>Только стили, нет логики</li><li>Поддержка браузеров (2023+)</li><li>Нельзя читать размеры в JS</li></ul><h4>ResizeObserver:</h4><p><strong>Когда использовать:</strong></p><p><strong>1. Нужна логика в JavaScript:</strong></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Сложная логика</code><br><code>&nbsp;&nbsp;if (shouldLoadMore(width)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loadMoreItems();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><strong>2. Canvas или WebGL:</strong></p><p><code>observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const size = entries[0].devicePixelContentBoxSize[0];</code><br><code>&nbsp;&nbsp;canvas.width = size.inlineSize;</code><br><code>&nbsp;&nbsp;canvas.height = size.blockSize;</code><br><code>&nbsp;&nbsp;redraw();</code><br><code>});</code></p><p><strong>3. Динамические вычисления:</strong></p><p><code>observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;const columns = Math.floor(width / 200);</code><br><code>&nbsp;&nbsp;updateGridColumns(columns);</code><br><code>});</code></p><p><strong>4. Интеграция с фреймворками:</strong></p><p><code>// React state обновления</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setWidth(entries[0].contentRect.width);</code><br><code>&nbsp;&nbsp;});</code><br><code>}, []);</code></p><p><strong>5. Старые браузеры:</strong></p><p>Container Queries поддерживаются с 2023, ResizeObserver — с 2019</p><h4>Сравнение применений:</h4><table><tr><th>Задача</th><th>Лучший выбор</th></tr><tr><td>Адаптивные стили</td><td>Container Queries</td></tr><tr><td>Canvas размеры</td><td>ResizeObserver</td></tr><tr><td>Grid columns</td><td>Container Queries или ResizeObserver</td></tr><tr><td>Виртуализация</td><td>ResizeObserver</td></tr><tr><td>Вызов API</td><td>ResizeObserver</td></tr><tr><td>Анимации</td><td>Container Queries</td></tr></table><h4>Комбинированный подход:</h4><p><code>/* CSS для стилей */</code><br><code>@container (min-width: 600px) {</code><br><code>&nbsp;&nbsp;.card { ... }</code><br><code>}</code></p><p><code>// JS для логики</code><br><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (entries[0].contentRect.width > 600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loadHighResImages();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><em>Вывод:</em> Container Queries для стилей, ResizeObserver для логики. Используйте оба при необходимости.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'Container Queries', 'сравнение', 'CSS']
  },
  {
    id: 76,
    question: "Что такое MutationObserver и для чего он используется?",
    answer: "<p><strong>MutationObserver</strong> — это Web API для асинхронного отслеживания изменений в DOM-дереве:</p><h4>Основное назначение:</h4><p>Позволяет наблюдать за добавлением/удалением элементов, изменением атрибутов и текстового содержимого, предоставляя механизм реагирования на DOM-мутации.</p><h4>Создание наблюдателя:</h4><p><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Тип изменения:', mutation.type);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Целевой элемент:', mutation.target);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>observer.observe(targetElement, {</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;subtree: true</code><br><code>});</code></p><h4>Основные применения:</h4><ul><li><strong>Мониторинг:</strong> Отслеживание изменений для аналитики</li><li><strong>Автоматизация:</strong> Автосохранение, анимации при появлении</li><li><strong>Интеграция:</strong> Работа со сторонними библиотеками</li><li><strong>Безопасность:</strong> Обнаружение инъекций скриптов</li><li><strong>Ленивая загрузка:</strong> Загрузка контента при появлении</li></ul><p><em>Ключевое отличие:</em> Асинхронный и эффективный в отличие от setInterval для проверки DOM.</p>",
    difficulty: 'junior',
    tags: ['MutationObserver', 'основы', 'Web API', 'DOM']
  },

  {
    id: 77,
    question: "Какие типы изменений может отслеживать MutationObserver?",
    answer: "<p>MutationObserver может отслеживать три основных типа изменений в DOM:</p><h4>1. childList - изменения дочерних элементов:</h4><p><code>observer.observe(element, {</code><br><code>&nbsp;&nbsp;childList: true</code><br><code>});</code></p><p>Отслеживает добавление и удаление дочерних узлов. Свойства MutationRecord: <code>addedNodes</code>, <code>removedNodes</code>, <code>previousSibling</code>, <code>nextSibling</code></p><h4>2. attributes - изменения атрибутов:</h4><p><code>observer.observe(element, {</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;attributeOldValue: true,</code><br><code>&nbsp;&nbsp;attributeFilter: ['class', 'style']</code><br><code>});</code></p><p>Отслеживает изменения атрибутов элемента. Свойства: <code>attributeName</code>, <code>oldValue</code></p><h4>3. characterData - изменения текста:</h4><p><code>observer.observe(textNode, {</code><br><code>&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;characterDataOldValue: true</code><br><code>});</code></p><p>Отслеживает изменения текстового содержимого узлов. Свойства: <code>oldValue</code>, <code>target.data</code></p><h4>Дополнительные опции:</h4><ul><li><code>subtree: true</code> — наблюдать за всем поддеревом</li><li><code>attributeOldValue: true</code> — сохранять предыдущие значения атрибутов</li><li><code>characterDataOldValue: true</code> — сохранять предыдущий текст</li><li><code>attributeFilter: ['attr1', 'attr2']</code> — отслеживать только указанные атрибуты</li></ul><p><em>Важно:</em> Хотя бы одна из основных опций (childList, attributes, characterData) обязательна.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'типы мутаций', 'конфигурация', 'API']
  },

  {
    id: 78,
    question: "Как правильно настроить конфигурацию MutationObserver?",
    answer: "<p>Конфигурация определяет какие изменения отслеживать и как их обрабатывать:</p><h4>Минимальная конфигурация:</h4><p><code>const config = {</code><br><code>&nbsp;&nbsp;childList: true // Обязательна хотя бы одна опция</code><br><code>};</code></p><h4>Полная конфигурация:</h4><p><code>const fullConfig = {</code><br><code>&nbsp;&nbsp;// Основные опции (хотя бы одна обязательна)</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Расширенные опции</code><br><code>&nbsp;&nbsp;subtree: true,</code><br><code>&nbsp;&nbsp;attributeOldValue: true,</code><br><code>&nbsp;&nbsp;characterDataOldValue: true,</code><br><code>&nbsp;&nbsp;attributeFilter: ['class', 'id', 'data-state']</code><br><code>};</code></p><h4>Примеры под задачи:</h4><p><strong>Отслеживание классов:</strong></p><p><code>{ attributes: true, attributeFilter: ['class'] }</code></p><p><strong>Глубокое наблюдение:</strong></p><p><code>{ childList: true, subtree: true }</code></p><p><strong>Мониторинг редактора:</strong></p><p><code>{ childList: true, characterData: true, subtree: true }</code></p><h4>Типичные ошибки:</h4><p><code>// ❌ Нет основной опции</code><br><code>{ subtree: true }</code></p><p><code>// ❌ attributeOldValue без attributes</code><br><code>{ childList: true, attributeOldValue: true }</code></p><p><code>// ✅ Правильно</code><br><code>{ attributes: true, attributeOldValue: true }</code></p><p><em>Best practice:</em> Используйте только необходимые опции для оптимизации производительности.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'конфигурация', 'опции', 'настройка']
  },

  {
    id: 79,
    question: "Как работать с MutationRecord и какая информация в нем доступна?",
    answer: "<p><strong>MutationRecord</strong> — объект, описывающий одно изменение в DOM, передается в callback:</p><h4>Общие свойства для всех типов:</h4><p><code>mutation.type</code> — тип изменения ('childList', 'attributes', 'characterData')</p><p><code>mutation.target</code> — элемент, в котором произошло изменение</p><h4>Для childList мутаций:</h4><p><code>mutation.addedNodes</code> — NodeList добавленных узлов</p><p><code>mutation.removedNodes</code> — NodeList удаленных узлов</p><p><code>mutation.previousSibling</code> — предыдущий сосед</p><p><code>mutation.nextSibling</code> — следующий сосед</p><h4>Для attributes мутаций:</h4><p><code>mutation.attributeName</code> — имя измененного атрибута</p><p><code>mutation.oldValue</code> — предыдущее значение (если attributeOldValue: true)</p><h4>Для characterData мутаций:</h4><p><code>mutation.oldValue</code> — предыдущий текст (если characterDataOldValue: true)</p><p><code>mutation.target.data</code> — новый текст</p><h4>Пример обработки:</h4><p><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (mutation.type) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'childList':</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Добавлено:', mutation.addedNodes.length);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Удалено:', mutation.removedNodes.length);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'attributes':</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newValue = mutation.target.getAttribute(mutation.attributeName);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${mutation.attributeName}: \${mutation.oldValue} → \${newValue}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'characterData':</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Текст: \${mutation.oldValue} → \${mutation.target.data}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><em>Важно:</em> Проверяйте nodeType добавленных/удаленных узлов — могут быть текстовые узлы и комментарии.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'MutationRecord', 'свойства', 'обработка']
  },

  {
    id: 80,
    question: "В чем разница между disconnect(), takeRecords() и unobserve()?",
    answer: "<p>MutationObserver предоставляет три метода управления наблюдением:</p><h4>1. disconnect() - полная остановка:</h4><p><code>observer.disconnect();</code></p><p><strong>Что делает:</strong></p><ul><li>Останавливает все наблюдение</li><li>Очищает очередь накопленных мутаций</li><li>Освобождает ресурсы</li></ul><p><strong>Когда использовать:</strong> При размонтировании компонента, когда observer больше не нужен</p><h4>2. takeRecords() - синхронное получение:</h4><p><code>const pendingMutations = observer.takeRecords();</code></p><p><strong>Что делает:</strong></p><ul><li>Возвращает массив накопленных мутаций</li><li>Очищает очередь мутаций</li><li>НЕ останавливает наблюдение</li><li>НЕ вызывает callback</li></ul><p><strong>Когда использовать:</strong> Для синхронной обработки перед disconnect, для немедленной обработки без ожидания callback</p><p><code>// Пример использования</code><br><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;const mutations = observer.takeRecords();</code><br><code>&nbsp;&nbsp;if (mutations.length > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Синхронная обработка перед закрытием</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;processMutations(mutations);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;observer.disconnect();</code><br><code>});</code></p><h4>3. unobserve() - НЕ существует!</h4><p><strong>Важно:</strong> В отличие от IntersectionObserver и ResizeObserver, у MutationObserver НЕТ метода unobserve(). Можно только полностью остановить наблюдение через disconnect() и затем создать новый observer с нужной конфигурацией.</p><h4>Сравнение:</h4><table><tr><th>Метод</th><th>Останавливает</th><th>Очищает очередь</th><th>Возвращает мутации</th></tr><tr><td>disconnect()</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>takeRecords()</td><td>❌</td><td>✅</td><td>✅</td></tr></table><p><em>Best practice:</em> Всегда вызывайте disconnect() при удалении компонента для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'методы', 'управление', 'lifecycle']
  },

  {
    id: 81,
    question: "Как реализовать автосохранение контента с помощью MutationObserver?",
    answer: "<p>Автосохранение при редактировании — классическое применение MutationObserver:</p><h4>Базовая реализация с debounce:</h4><p><code>class AutoSave {</code><br><code>&nbsp;&nbsp;constructor(element, saveCallback, delay = 2000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.element = element;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.saveCallback = saveCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.saveTimeout = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.hasUnsavedChanges = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hasUnsavedChanges = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.scheduleSave();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.element, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;scheduleSave() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.saveTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.saveTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.save();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;async save() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.hasUnsavedChanges) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const content = this.element.innerHTML;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Автосохранение...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await this.saveCallback(content);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hasUnsavedChanges = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showSaveStatus('Сохранено');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showSaveStatus('Ошибка сохранения', 'error');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;showSaveStatus(message, type = 'success') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Показать индикатор статуса</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.saveTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const editor = document.querySelector('#editor');</code><br><code>const autoSave = new AutoSave(editor, async (content) => {</code><br><code>&nbsp;&nbsp;// Сохранение в localStorage</code><br><code>&nbsp;&nbsp;localStorage.setItem('draft', content);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Или отправка на сервер</code><br><code>&nbsp;&nbsp;await fetch('/api/save', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({ content }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers: { 'Content-Type': 'application/json' }</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Расширенная версия с индикатором:</h4><p><code>class AdvancedAutoSave extends AutoSave {</code><br><code>&nbsp;&nbsp;constructor(element, saveCallback, delay) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super(element, saveCallback, delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.createStatusIndicator();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;createStatusIndicator() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = 'save-status';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.element.parentElement.appendChild(this.indicator);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;scheduleSave() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super.scheduleSave();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = 'Несохраненные изменения...';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = 'save-status pending';</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;showSaveStatus(message, type) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = message;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = \`save-status \${type}\`;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = '';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 2000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Ключевые моменты:</em> Debounce для предотвращения частых сохранений, индикатор статуса для UX, обработка ошибок, cleanup при уничтожении.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'автосохранение', 'практика', 'UX']
  },

  {
    id: 82,
    question: "Как отслеживать появление элементов в DOM для lazy loading?",
    answer: "<p>MutationObserver идеален для отслеживания динамически добавляемых элементов:</p><h4>Реализация lazy loader:</h4><p><code>class LazyLoadObserver {</code><br><code>&nbsp;&nbsp;constructor(selector, loadCallback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.selector = selector;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback = loadCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements = new WeakSet();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.checkExistingElements();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем сам узел</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.nodeType === Node.ELEMENT_NODE) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkElement(node);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем потомков</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const elements = node.querySelectorAll(this.selector);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements.forEach(el => this.checkElement(el));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkExistingElements() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем уже существующие элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.querySelectorAll(this.selector).forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkElement(el);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkElement(element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element.matches && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.matches(this.selector) && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!this.loadedElements.has(element)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements.add(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование для изображений:</h4><p><code>// HTML: &lt;img data-src=\"image.jpg\" class=\"lazy\"&gt;</code></p><p><code>const lazyImages = new LazyLoadObserver('img[data-src]', (img) => {</code><br><code>&nbsp;&nbsp;img.src = img.dataset.src;</code><br><code>&nbsp;&nbsp;img.classList.add('loaded');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.classList.add('fade-in');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Загружено:', img.dataset.src);</code><br><code>&nbsp;&nbsp;};</code><br><code>});</code></p><h4>Для динамических компонентов:</h4><p><code>const componentLoader = new LazyLoadObserver('[data-component]', (element) => {</code><br><code>&nbsp;&nbsp;const componentName = element.dataset.component;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Динамическая загрузка модуля</code><br><code>&nbsp;&nbsp;import(\`./components/\${componentName}.js\`)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.then(module => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module.init(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.catch(err => console.error('Ошибка загрузки:', err));</code><br><code>});</code></p><h4>С приоритетами загрузки:</h4><p><code>class PriorityLazyLoader extends LazyLoadObserver {</code><br><code>&nbsp;&nbsp;checkElement(element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.loadedElements.has(element)) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const priority = element.dataset.priority || 'normal';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (priority === 'high') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements.add(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestIdleCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements.add(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Преимущество:</em> Автоматически обрабатывает все элементы, добавляемые в DOM в любой момент, без необходимости явных вызовов.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'lazy loading', 'динамический контент', 'производительность']
  },

  {
    id: 83,
    question: "Как использовать MutationObserver для отслеживания изменений темы (светлая/темная)?",
    answer: "<p>Отслеживание изменений темы полезно для обновления зависимых компонентов:</p><h4>Базовая реализация:</h4><p><code>class ThemeObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentTheme = this.detectTheme();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;detectTheme() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return document.body.classList.contains('dark-theme') </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? 'dark' </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 'light';</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mutation.type === 'attributes' && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.attributeName === 'class') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newTheme = this.detectTheme();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newTheme !== this.currentTheme) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentTheme = newTheme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.notifyThemeChange(newTheme);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributeFilter: ['class']</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;onThemeChange(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.push(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызываем сразу с текущей темой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;callback(this.currentTheme);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;offThemeChange(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const index = this.callbacks.indexOf(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (index > -1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.splice(index, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;notifyThemeChange(theme) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Тема изменена на:', theme);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.forEach(callback => callback(theme));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const themeObserver = new ThemeObserver();</code></p><p><code>// Обновление графиков</code><br><code>themeObserver.onThemeChange((theme) => {</code><br><code>&nbsp;&nbsp;chart.updateOptions({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;theme: { mode: theme }</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>// Обновление карты</code><br><code>themeObserver.onThemeChange((theme) => {</code><br><code>&nbsp;&nbsp;map.setStyle(theme === 'dark' ? 'dark-style' : 'light-style');</code><br><code>});</code></p><p><code>// Сохранение в localStorage</code><br><code>themeObserver.onThemeChange((theme) => {</code><br><code>&nbsp;&nbsp;localStorage.setItem('preferred-theme', theme);</code><br><code>});</code></p><h4>Расширенная версия с data-атрибутом:</h4><p><code>class AdvancedThemeObserver extends ThemeObserver {</code><br><code>&nbsp;&nbsp;detectTheme() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const dataTheme = document.body.dataset.theme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (dataTheme) return dataTheme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Fallback на класс</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return super.detectTheme();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mutation.type === 'attributes') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newTheme = this.detectTheme();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newTheme !== this.currentTheme) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentTheme = newTheme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.notifyThemeChange(newTheme);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributeFilter: ['class', 'data-theme']</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Применение:</em> Синхронизация UI компонентов, графиков, карт, видео-плееров с текущей темой без prop drilling.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'темы', 'UI синхронизация', 'практика']
  },

  {
    id: 84,
    question: "Как оптимизировать производительность MutationObserver при частых изменениях?",
    answer: "<p>MutationObserver callback может вызываться очень часто, требуя оптимизации:</p><h4>1. Debounce для тяжелых операций:</h4><p><code>class DebouncedObserver {</code><br><code>&nbsp;&nbsp;constructor(target, config, callback, delay = 250) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timeout = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations.push(...mutations);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback(this.pendingMutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(target, config);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>2. Throttle для ограничения частоты:</h4><p><code>class ThrottledObserver {</code><br><code>&nbsp;&nbsp;constructor(target, config, callback, interval = 1000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.interval = interval;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations.push(...mutations);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const timeSinceLastCall = now - this.lastCall;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timeSinceLastCall >= this.interval) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback(this.pendingMutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = now;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(target, config);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>3. requestAnimationFrame для DOM обновлений:</h4><p><code>let rafId = null;</code></p><p><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;if (rafId) cancelAnimationFrame(rafId);</code></p><p><code>&nbsp;&nbsp;rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обновления DOM синхронизированы с браузером</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateUI(mutation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;rafId = null;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>4. Batch DOM операций:</h4><p><code>// ❌ ПЛОХО - observer срабатывает для каждого appendChild</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;const div = document.createElement('div');</code><br><code>&nbsp;&nbsp;div.textContent = item;</code><br><code>&nbsp;&nbsp;container.appendChild(div);</code><br><code>});</code></p><p><code>// ✅ ХОРОШО - observer срабатывает ОДИН раз</code><br><code>const fragment = document.createDocumentFragment();</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;const div = document.createElement('div');</code><br><code>&nbsp;&nbsp;div.textContent = item;</code><br><code>&nbsp;&nbsp;fragment.appendChild(div);</code><br><code>});</code><br><code>container.appendChild(fragment);</code></p><h4>5. Отключение при неактивности:</h4><p><code>class SmartObserver {</code><br><code>&nbsp;&nbsp;constructor(target, config, callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.target = target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.config = config;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupVisibilityListener();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.start();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupVisibilityListener() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener('visibilitychange', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (document.hidden) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.stop();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.start();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.observer) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.target, this.config);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.observer) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Ограничение конфигурации:</h4><p><code>// ❌ Слишком широкая конфигурация</code><br><code>{ childList: true, attributes: true, subtree: true }</code></p><p><code>// ✅ Только необходимое</code><br><code>{ attributes: true, attributeFilter: ['class'] }</code></p><p><em>Золотое правило:</em> Callback должен выполняться быстро. Тяжелые операции — в Web Workers или через debounce/throttle.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'оптимизация', 'производительность', 'debounce']
  },

  {
    id: 85,
    question: "Как отслеживать добавление скриптов для обеспечения безопасности?",
    answer: "<p>MutationObserver можно использовать для обнаружения инъекций вредоносных скриптов:</p><h4>Детектор инъекций скриптов:</h4><p><code>class ScriptInjectionDetector {</code><br><code>&nbsp;&nbsp;constructor(allowedScripts = []) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.allowedScripts = new Set(allowedScripts);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.tagName === 'SCRIPT') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkScript(node);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за всем документом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.documentElement, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkScript(scriptElement) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const src = scriptElement.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const inlineCode = scriptElement.textContent;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка внешнего скрипта</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (src && !this.isAllowed(src)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('🚨 Неавторизованный скрипт:', src);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scriptElement.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportToServer({ type: 'external', src });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка inline скрипта</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (inlineCode && !this.isAllowedInline(inlineCode)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('🚨 Подозрительный inline скрипт:', inlineCode);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scriptElement.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportToServer({ type: 'inline', code: inlineCode });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;isAllowed(src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка по whitelist</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.allowedScripts.has(src)) return true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка по домену</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const url = new URL(src);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const allowedDomains = ['cdn.example.com', 'analytics.google.com'];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return allowedDomains.some(domain => url.hostname === domain);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;isAllowedInline(code) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка на подозрительные паттерны</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const suspiciousPatterns = [</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/eval\\(/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/Function\\(/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/document\\.write\\(/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/innerHTML\\s*=/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/crypto/i</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return !suspiciousPatterns.some(pattern => pattern.test(code));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;reportToServer(incident) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/security/report', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers: { 'Content-Type': 'application/json' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...incident,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: window.location.href,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userAgent: navigator.userAgent</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).catch(console.error);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const detector = new ScriptInjectionDetector([</code><br><code>&nbsp;&nbsp;'https://cdn.example.com/app.js',</code><br><code>&nbsp;&nbsp;'https://www.google-analytics.com/analytics.js'</code><br><code>]);</code></p><h4>Расширенная версия с CSP проверкой:</h4><p><code>class AdvancedSecurityObserver extends ScriptInjectionDetector {</code><br><code>&nbsp;&nbsp;constructor(allowedScripts) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super(allowedScripts);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.checkCSP();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkCSP() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const csp = document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!csp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('⚠️ CSP не настроен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super.setupObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Также отслеживаем iframe</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const iframeObserver = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.tagName === 'IFRAME') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkIframe(node);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;iframeObserver.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkIframe(iframe) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const src = iframe.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (src && !this.isAllowed(src)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('🚨 Подозрительный iframe:', src);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iframe.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportToServer({ type: 'iframe', src });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Применение:</em> Защита от XSS, обнаружение вредоносных расширений браузера, мониторинг целостности приложения.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'безопасность', 'XSS', 'защита']
  },

  {
    id: 86,
    question: "Как использовать MutationObserver для мониторинга производительности рендеринга?",
    answer: "<p>MutationObserver можно использовать для обнаружения проблем с производительностью DOM:</p><h4>Монитор производительности:</h4><p><code>class PerformanceMonitor {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.mutationCount = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.mutationRate = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.mutationsByType = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characterData: 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.slowMutations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.startReporting();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const startTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationCount += mutations.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationsByType[mutation.type]++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const endTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const duration = endTime - startTime;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обнаружение медленных обработок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (duration > 16) { // > 1 фрейма при 60fps</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.slowMutations.push({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duration,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: mutations.length,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn(\`⚠️ Медленная обработка мутаций: \${duration.toFixed(2)}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Предупреждение о высокой частоте</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.mutationCount > 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('⚠️ Высокая частота DOM мутаций:', this.mutationCount);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.logMutationsSummary(mutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;startReporting() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отчет каждую секунду</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationRate = this.mutationCount;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationCount = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.mutationRate > 50) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Мутаций/сек: \${this.mutationRate}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.table(this.mutationsByType);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 1000);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Детальный отчет каждые 10 секунд</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.generateReport();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 10000);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;logMutationsSummary(mutations) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const summary = mutations.reduce((acc, m) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const key = \`\${m.type}:\${m.target.tagName || m.target.nodeName}\`;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc[key] = (acc[key] || 0) + 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return acc;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, {});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;console.table(summary);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;generateReport() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const report = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalMutations: Object.values(this.mutationsByType).reduce((a, b) => a + b, 0),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutationsByType: { ...this.mutationsByType },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowMutationsCount: this.slowMutations.length,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;averageSlowDuration: this.slowMutations.length > 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? this.slowMutations.reduce((sum, m) => sum + m.duration, 0) / this.slowMutations.length</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('📊 Отчет производительности:');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.table(report);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка на сервер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sendToAnalytics(report);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сброс данных</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.slowMutations = [];</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;sendToAnalytics(report) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка метрик</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if ('sendBeacon' in navigator) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.sendBeacon('/api/metrics', JSON.stringify(report));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const perfMonitor = new PerformanceMonitor();</code></p><p><code>// В продакшене - условная активация</code><br><code>if (window.location.search.includes('debug=perf')) {</code><br><code>&nbsp;&nbsp;new PerformanceMonitor();</code><br><code>}</code></p><p><em>Применение:</em> Обнаружение проблем производительности, оптимизация рендеринга, мониторинг в production, A/B тестирование.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'производительность', 'мониторинг', 'метрики']
  },

  {
    id: 87,
    question: "В чем разница между MutationObserver и другими методами отслеживания DOM?",
    answer: "<p>Существует несколько способов отслеживания изменений DOM, каждый со своими особенностями:</p><h4>MutationObserver:</h4><p><strong>Преимущества:</strong></p><ul><li>Асинхронный — не блокирует main thread</li><li>Эффективный — batch обработка мутаций</li><li>Детальная информация о каждом изменении</li><li>Поддержка всех типов изменений (childList, attributes, characterData)</li><li>Может наблюдать за всем поддеревом (subtree)</li></ul><p><strong>Недостатки:</strong></p><ul><li>Более сложный API</li><li>Требует понимания конфигурации</li><li>Не поддерживается в IE10 и ниже</li></ul><h4>DOM Events (DOMSubtreeModified и др.):</h4><p><code>element.addEventListener('DOMSubtreeModified', handler);</code></p><p><strong>Недостатки:</strong></p><ul><li>❌ Deprecated (устарел)</li><li>Синхронный — блокирует выполнение</li><li>Очень низкая производительность</li><li>Вызывается для КАЖДОГО изменения</li><li>Не рекомендуется к использованию</li></ul><h4>setInterval проверка:</h4><p><code>setInterval(() => {</code><br><code>&nbsp;&nbsp;const currentState = element.innerHTML;</code><br><code>&nbsp;&nbsp;if (currentState !== lastState) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Изменение обнаружено</code><br><code>&nbsp;&nbsp;}</code><br><code>}, 100);</code></p><p><strong>Недостатки:</strong></p><ul><li>Очень неэффективно</li><li>Может пропускать быстрые изменения</li><li>Постоянно работает даже без изменений</li><li>Нет информации о типе изменения</li></ul><h4>Custom Events:</h4><p><code>element.dispatchEvent(new CustomEvent('contentChanged'));</code></p><p><strong>Преимущества:</strong></p><ul><li>Простой и явный контроль</li><li>Можете передавать данные</li></ul><p><strong>Недостатки:</strong></p><ul><li>Требует явных вызовов в коде</li><li>Не работает для изменений извне</li><li>Не подходит для сторонних библиотек</li></ul><h4>Proxy для данных:</h4><p><code>const proxy = new Proxy(data, {</code><br><code>&nbsp;&nbsp;set(target, property, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;target[property] = value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;updateDOM();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><strong>Применение:</strong> Реактивность данных (Vue, MobX), но НЕ для отслеживания DOM</p><h4>Сравнительная таблица:</h4><table><tr><th>Метод</th><th>Производительность</th><th>Детальность</th><th>Асинхронность</th><th>Использование</th></tr><tr><td>MutationObserver</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>✅</td><td>✅ Рекомендуется</td></tr><tr><td>DOM Events</td><td>⭐</td><td>⭐⭐</td><td>❌</td><td>❌ Deprecated</td></tr><tr><td>setInterval</td><td>⭐</td><td>⭐</td><td>❌</td><td>❌ Не использовать</td></tr><tr><td>Custom Events</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>✅</td><td>✅ Для своего кода</td></tr></table><p><em>Вывод:</em> MutationObserver — современный стандарт для отслеживания DOM. Не используйте DOMSubtreeModified или setInterval.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'сравнение', 'альтернативы', 'производительность']
  },

  {
    id: 88,
    question: "Как работает MutationObserver с Shadow DOM?",
    answer: "<p>MutationObserver и Shadow DOM имеют специфическое взаимодействие:</p><h4>Основное правило:</h4><p>MutationObserver наблюдает только за тем деревом, на котором вызван <code>observe()</code>. Изменения внутри Shadow DOM невидимы для observer'а, подключенного к light DOM.</p><h4>Наблюдение за light DOM:</h4><p><code>// Этот observer НЕ увидит изменения внутри shadowRoot</code><br><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;console.log('Light DOM изменен');</code><br><code>});</code></p><p><code>observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;subtree: true</code><br><code>});</code></p><h4>Наблюдение за Shadow DOM:</h4><p><code>class MyElement extends HTMLElement {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.attachShadow({ mode: 'open' });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer для Shadow DOM</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shadowObserver = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Shadow DOM изменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за shadowRoot</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shadowObserver.observe(this.shadowRoot, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnectedCallback() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shadowObserver.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Универсальный wrapper для компонентов:</h4><p><code>class ShadowDOMObserver {</code><br><code>&nbsp;&nbsp;constructor(hostElement, callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.hostElement = hostElement;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObservers();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObservers() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer для host элемента (light DOM)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const lightObserver = new MutationObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;lightObserver.observe(this.hostElement, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers.push(lightObserver);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer для shadow DOM если есть</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.hostElement.shadowRoot) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const shadowObserver = new MutationObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowObserver.observe(this.hostElement.shadowRoot, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observers.push(shadowObserver);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers.forEach(obs => obs.disconnect());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const myComponent = document.querySelector('my-component');</code><br><code>const observer = new ShadowDOMObserver(myComponent, (mutations) => {</code><br><code>&nbsp;&nbsp;console.log('Изменения в компоненте:', mutations);</code><br><code>});</code></p><h4>Особенности:</h4><ul><li><strong>mode: 'closed':</strong> Если shadowRoot закрыт, наблюдение невозможно извне</li><li><strong>Slotted content:</strong> Slotted элементы остаются в light DOM, видны light observer'у</li><li><strong>События:</strong> События из Shadow DOM всплывают в light DOM с retargeting</li></ul><h4>Отслеживание динамических компонентов:</h4><p><code>// Автоматическое подключение к новым shadow DOM</code><br><code>const globalObserver = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.shadowRoot) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Подключаем observer к новому shadowRoot</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observeShadowRoot(node.shadowRoot);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>globalObserver.observe(document.body, {</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;subtree: true</code><br><code>});</code></p><p><em>Ключевой момент:</em> Для каждого Shadow DOM нужен отдельный MutationObserver, подключенный к shadowRoot.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'Shadow DOM', 'Web Components', 'инкапсуляция']
  },

  {
    id: 89,
    question: "Какие есть best practices и подводные камни при работе с MutationObserver?",
    answer: "<p>При работе с MutationObserver важно следовать лучшим практикам и избегать распространенных ошибок:</p><h4>✅ Best Practices:</h4><p><strong>1. Всегда вызывайте disconnect():</strong></p><p><code>// React</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new MutationObserver(callback);</code><br><code>&nbsp;&nbsp;observer.observe(element, config);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return () => observer.disconnect(); // Cleanup!</code><br><code>}, []);</code></p><p><strong>2. Используйте attributeFilter:</strong></p><p><code>// ❌ Плохо - наблюдает за всеми атрибутами</code><br><code>{ attributes: true }</code></p><p><code>// ✅ Хорошо - только нужные атрибуты</code><br><code>{ attributes: true, attributeFilter: ['class', 'data-state'] }</code></p><p><strong>3. Batch DOM операции:</strong></p><p><code>// ✅ Используйте DocumentFragment</code><br><code>const fragment = document.createDocumentFragment();</code><br><code>items.forEach(item => fragment.appendChild(createItem(item)));</code><br><code>container.appendChild(fragment); // Один observer callback</code></p><p><strong>4. Debounce/throttle для частых изменений:</strong></p><p><code>let timeout;</code><br><code>const observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;timeout = setTimeout(heavyOperation, 250);</code><br><code>});</code></p><p><strong>5. Проверяйте nodeType:</strong></p><p><code>mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;if (node.nodeType === Node.ELEMENT_NODE) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка только элементов</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><strong>6. Используйте WeakSet для отслеженных элементов:</strong></p><p><code>const processed = new WeakSet();</code><br><code>if (!processed.has(element)) {</code><br><code>&nbsp;&nbsp;processed.add(element);</code><br><code>&nbsp;&nbsp;processElement(element);</code><br><code>}</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Бесконечные циклы:</strong></p><p><code>// ❌ ОПАСНО - бесконечный цикл!</code><br><code>const observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;element.classList.toggle('active'); // Вызовет новую мутацию!</code><br><code>});</code><br><code>observer.observe(element, { attributes: true });</code></p><p><code>// ✅ Решение - временно отключать observer</code><br><code>const observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;element.classList.toggle('active');</code><br><code>&nbsp;&nbsp;observer.observe(element, config);</code><br><code>});</code></p><p><strong>2. Забытые observers:</strong></p><p><code>// ❌ Утечка памяти</code><br><code>const observer = new MutationObserver(callback);</code><br><code>observer.observe(element, config);</code><br><code>// Никогда не вызывается disconnect()!</code></p><p><strong>3. Асинхронность callback:</strong></p><p><code>// ❌ Неправильное понимание</code><br><code>element.appendChild(newNode);</code><br><code>console.log('Callback вызван'); // Это выполнится РАНЬШЕ callback!</code></p><p><strong>4. Производительность при subtree: true:</strong></p><p><code>// ❌ Очень затратно для больших деревьев</code><br><code>observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;subtree: true // Наблюдает за ВСЕМ в body!</code><br><code>});</code></p><p><strong>5. Неправильная конфигурация:</strong></p><p><code>// ❌ Ошибка - нет основной опции</code><br><code>{ subtree: true, attributeOldValue: true }</code></p><p><code>// ✅ Правильно</code><br><code>{ attributes: true, subtree: true, attributeOldValue: true }</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не отключать observer при размонтировании</li><li>Тяжелые операции в callback</li><li>Модификация DOM внутри callback → бесконечный цикл</li><li>Использование для пользовательских событий (используйте addEventListener)</li><li>Ожидание синхронного выполнения callback</li><li>Забывать про nodeType проверку</li></ol><h4>🎯 Когда НЕ использовать:</h4><ul><li>Для событий click, input, change — используйте DOM events</li><li>Для контроля собственного кода — структурируйте логику</li><li>Для реактивности данных — используйте Proxy, фреймворки</li><li>Для проверки каждую секунду — используйте setInterval (если действительно нужно)</li></ul><p><em>Золотое правило:</em> MutationObserver для наблюдения за изменениями, которые вы НЕ контролируете (сторонние библиотеки, расширения, динамический контент).</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'best practices', 'подводные камни', 'ошибки']
  },
  {
    id: 90,
    question: "Как интегрировать MutationObserver в современные фреймворки (React/Vue/Angular)?",
    answer: "<p>MutationObserver можно эффективно использовать в современных фреймворках:</p><h4>React интеграция:</h4><p><code>// Хук useMutationObserver</code><br><code>import { useEffect, useRef } from 'react';</code></p><p><code>function useMutationObserver(callback, config) {</code><br><code>&nbsp;&nbsp;const targetRef = useRef(null);</code><br><code>&nbsp;&nbsp;const observerRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!targetRef.current) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current = new MutationObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current.observe(targetRef.current, config);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current?.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}, [callback, config]);</code></p><p><code>&nbsp;&nbsp;return targetRef;</code><br><code>}</code></p><p><code>// Использование</code><br><code>function MyComponent() {</code><br><code>&nbsp;&nbsp;const [mutationCount, setMutationCount] = useState(0);</code></p><p><code>&nbsp;&nbsp;const elementRef = useMutationObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;(mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setMutationCount(prev => prev + mutations.length);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{ childList: true, subtree: true }</code><br><code>&nbsp;&nbsp;);</code></p><p><code>&nbsp;&nbsp;return &lt;div ref={elementRef}&gt;Mutations: {mutationCount}&lt;/div&gt;;</code><br><code>}</code></p><h4>Vue 3 Composition API:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, onMounted, onUnmounted } from 'vue';</code></p><p><code>const elementRef = ref(null);</code><br><code>const mutationCount = ref(0);</code><br><code>let observer = null;</code></p><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;if (!elementRef.value) return;</code></p><p><code>&nbsp;&nbsp;observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;mutationCount.value += mutations.length;</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;observer.observe(elementRef.value, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>onUnmounted(() => {</code><br><code>&nbsp;&nbsp;observer?.disconnect();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div ref=\"elementRef\"&gt;Mutations: {{ mutationCount }}&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>Vue Composable:</h4><p><code>// composables/useMutationObserver.js</code><br><code>import { onMounted, onUnmounted } from 'vue';</code></p><p><code>export function useMutationObserver(targetRef, callback, options) {</code><br><code>&nbsp;&nbsp;let observer = null;</code></p><p><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!targetRef.value) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observer = new MutationObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(targetRef.value, options);</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;onUnmounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer?.disconnect();</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;return { observer };</code><br><code>}</code></p><h4>Angular интеграция:</h4><p><code>import { Directive, ElementRef, Output, EventEmitter, OnDestroy, OnInit } from '@angular/core';</code></p><p><code>@Directive({</code><br><code>&nbsp;&nbsp;selector: '[appMutationObserver]'</code><br><code>})</code><br><code>export class MutationObserverDirective implements OnInit, OnDestroy {</code><br><code>&nbsp;&nbsp;@Output() mutations = new EventEmitter&lt;MutationRecord[]&gt;();</code><br><code>&nbsp;&nbsp;private observer: MutationObserver;</code></p><p><code>&nbsp;&nbsp;constructor(private elementRef: ElementRef) {}</code></p><p><code>&nbsp;&nbsp;ngOnInit() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutations.emit(mutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.elementRef.nativeElement, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;ngOnDestroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer?.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;div appMutationObserver (mutations)=\"onMutations($event)\"&gt;</code><br><code>&nbsp;&nbsp;Content</code><br><code>&lt;/div&gt;</code></p><h4>Важные моменты:</h4><ul><li><strong>React:</strong> Используйте useRef для элемента, useEffect для lifecycle</li><li><strong>Vue:</strong> onMounted/onUnmounted для управления observer</li><li><strong>Angular:</strong> Директивы или сервисы с ngOnDestroy cleanup</li><li><strong>Всегда:</strong> Отключайте observer при размонтировании компонента</li></ul><h4>Мониторинг сторонних компонентов:</h4><p><code>// React - наблюдение за компонентом библиотеки</code><br><code>function ThirdPartyWrapper() {</code><br><code>&nbsp;&nbsp;const wrapperRef = useMutationObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;(mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Реагируем на изменения внутри библиотечного компонента</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Library component changed');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{ childList: true, subtree: true }</code><br><code>&nbsp;&nbsp;);</code></p><p><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div ref={wrapperRef}&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ThirdPartyComponent /&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Best practice:</em> Создавайте переиспользуемые хуки/composables/директивы для MutationObserver вместо дублирования кода.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'React', 'Vue', 'Angular', 'интеграция']
  },
  {
    id: 91,
    question: "Что такое AbortController и для чего он используется?",
    answer: "<p><strong>AbortController</strong> — это Web API для отмены асинхронных операций, таких как Fetch запросы, чтение файлов или другие длительные операции:</p><h4>Основное назначение:</h4><p>Позволяет программно прерывать операции, которые больше не нужны, экономя ресурсы и улучшая производительность.</p><h4>Создание и использование:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code><br><code></code><br><code>fetch('/api/data', { signal })</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code></code><br><code>// Отмена запроса</code><br><code>controller.abort();</code></p><h4>Основные применения:</h4><ul><li><strong>Отмена запросов:</strong> Прерывание Fetch при навигации</li><li><strong>Timeout:</strong> Автоматическая отмена по таймауту</li><li><strong>Debounce поиска:</strong> Отмена предыдущих запросов</li><li><strong>Отмена загрузки:</strong> Прерывание загрузки файлов</li><li><strong>Cleanup:</strong> Отмена операций при размонтировании</li></ul><h4>Основные компоненты:</h4><p><strong>AbortController:</strong> Контроллер для управления отменой</p><p><strong>AbortSignal:</strong> Сигнал, передаваемый в операции</p><p><strong>abort():</strong> Метод для отмены операций</p><p><em>Важно:</em> После вызова abort() signal становится aborted навсегда, нельзя переиспользовать.</p>",
    difficulty: 'junior',
    tags: ['AbortController', 'основы', 'отмена запросов', 'Web API']
  },
  {
    id: 92,
    question: "Как отменить Fetch запрос с помощью AbortController?",
    answer: "<p>AbortController — стандартный способ отмены Fetch запросов:</p><h4>Базовое использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>fetch('https://api.example.com/data', {</code><br><code>&nbsp;&nbsp;signal: controller.signal</code><br><code>})</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.then(data => console.log(data))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос был отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Ошибка:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить запрос</code><br><code>controller.abort();</code></p><h4>С async/await:</h4><p><code>async function fetchWithAbort() {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return data;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отмена по кнопке:</h4><p><code>let currentController;</code></p><p><code>async function loadData() {</code><br><code>&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;if (currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;currentController.abort();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;currentController = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;displayData(data);</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Ошибка загрузки:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// HTML</code><br><code>// &lt;button onclick=\"loadData()\"&gt;Загрузить&lt;/button&gt;</code><br><code>// &lt;button onclick=\"currentController?.abort()\"&gt;Отменить&lt;/button&gt;</code></p><h4>Проверка состояния signal:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code></p><p><code>console.log(signal.aborted); // false</code></p><p><code>controller.abort();</code></p><p><code>console.log(signal.aborted); // true</code></p><p><em>Важно:</em> Всегда проверяйте <code>error.name === 'AbortError'</code> для отличия отмены от реальных ошибок.</p>",
    difficulty: 'junior',
    tags: ['AbortController', 'Fetch', 'отмена запроса', 'базовое использование']
  },
  {
    id: 93,
    question: "Как реализовать timeout для Fetch запроса с помощью AbortController?",
    answer: "<p>AbortController идеален для реализации timeout'ов для Fetch запросов:</p><h4>Базовая реализация:</h4><p><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Автоматическая отмена через timeout</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем таймер при успехе</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Request timeout after \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>try {</code><br><code>&nbsp;&nbsp;const response = await fetchWithTimeout('/api/data', 3000);</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;console.log(data);</code><br><code>} catch (error) {</code><br><code>&nbsp;&nbsp;console.error(error.message); // 'Request timeout after 3000ms'</code><br><code>}</code></p><h4>С использованием AbortSignal.timeout() (современный подход):</h4><p><code>// Chrome 103+, Safari 16+, Firefox 100+</code><br><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: AbortSignal.timeout(timeout)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'TimeoutError' || error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Request timeout after \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Комбинирование нескольких сигналов:</h4><p><code>async function fetchWithTimeoutAndCancel(url, timeout, userController) {</code><br><code>&nbsp;&nbsp;const timeoutController = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => timeoutController.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Слушаем оба сигнала</code><br><code>&nbsp;&nbsp;userController.signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutController.abort();</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: timeoutController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Универсальная обертка:</h4><p><code>class FetchWithTimeout {</code><br><code>&nbsp;&nbsp;constructor(defaultTimeout = 10000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.defaultTimeout = defaultTimeout;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeout = options.timeout || this.defaultTimeout;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Timeout: Request exceeded \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const fetcher = new FetchWithTimeout(5000);</code><br><code>const response = await fetcher.fetch('/api/data', { timeout: 3000 });</code></p><p><em>Best practice:</em> Всегда очищайте timeout через clearTimeout() для избежания утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'timeout', 'Fetch', 'таймауты']
  },
  {
    id: 94,
    question: "Как отменить предыдущие запросы при быстрой печати в поиске (debounce с отменой)?",
    answer: "<p>AbortController позволяет отменять устаревшие поисковые запросы при быстрой печати:</p><h4>Базовая реализация:</h4><p><code>class SearchWithAbort {</code><br><code>&nbsp;&nbsp;constructor(searchCallback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback = searchCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async search(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentController.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем новый контроллер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/search?q=\${query}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback(results);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Search error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование с input:</h4><p><code>const search = new SearchWithAbort((results) => {</code><br><code>&nbsp;&nbsp;displaySearchResults(results);</code><br><code>});</code></p><p><code>const searchInput = document.querySelector('#search');</code><br><code>searchInput.addEventListener('input', (e) => {</code><br><code>&nbsp;&nbsp;search.search(e.target.value);</code><br><code>});</code></p><h4>С debounce:</h4><p><code>class DebouncedSearch {</code><br><code>&nbsp;&nbsp;constructor(searchCallback, delay = 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback = searchCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.debounceTimeout = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;search(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий таймер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.debounceTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentController.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Запускаем с задержкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.debounceTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.performSearch(query);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async performSearch(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/search?q=\${query}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback(results);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Search error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React хук:</h4><p><code>function useSearchWithAbort(searchFn, delay = 300) {</code><br><code>&nbsp;&nbsp;const [results, setResults] = useState([]);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;const timeoutRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const search = useCallback((query) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка предыдущих</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResults([]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutRef.current = setTimeout(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = await searchFn(query, controllerRef.current.signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResults(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;}, [searchFn, delay]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { results, loading, search };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function SearchComponent() {</code><br><code>&nbsp;&nbsp;const { results, loading, search } = useSearchWithAbort(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;async (query, signal) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const res = await fetch(\`/api/search?q=\${query}\`, { signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;input </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={(e) => search(e.target.value)}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder=\"Поиск...\"</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;/&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Преимущество:</em> Экономит bandwidth и ресурсы сервера, отменяя устаревшие запросы.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'поиск', 'debounce', 'оптимизация']
  },
  {
    id: 95,
    question: "Как использовать AbortSignal для прослушивания события отмены?",
    answer: "<p>AbortSignal предоставляет событие 'abort' для реагирования на отмену операций:</p><h4>Базовое прослушивание:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code></p><p><code>signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;console.log('Операция отменена!');</code><br><code>&nbsp;&nbsp;console.log('Причина:', signal.reason);</code><br><code>});</code></p><p><code>controller.abort('Отменено пользователем');</code></p><h4>Проверка состояния:</h4><p><code>const signal = controller.signal;</code></p><p><code>// Проверка до операции</code><br><code>if (signal.aborted) {</code><br><code>&nbsp;&nbsp;console.log('Уже отменено');</code><br><code>&nbsp;&nbsp;return;</code><br><code>}</code></p><p><code>// Реактивная проверка</code><br><code>signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;// Прерывание операции</code><br><code>});</code></p><h4>Использование в асинхронной функции:</h4><p><code>async function processWithAbort(signal) {</code><br><code>&nbsp;&nbsp;// Проверяем в начале</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Already aborted');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Прерываем обработку...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;cleanup();</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Длительная операция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < 1000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Периодическая проверка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Operation aborted');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка слушателя</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Создание Promise с отменой:</h4><p><code>function createAbortablePromise(signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем сразу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Aborted'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Слушаем отмену</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Aborted'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Асинхронная операция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;doAsyncWork()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Передача причины отмены:</h4><p><code>const controller = new AbortController();</code></p><p><code>controller.signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;const reason = controller.signal.reason;</code><br><code>&nbsp;&nbsp;console.log('Причина отмены:', reason);</code><br><code>});</code></p><p><code>// Отмена с причиной</code><br><code>controller.abort('Timeout exceeded');</code><br><code>// или</code><br><code>controller.abort(new Error('User cancelled'));</code></p><h4>Очистка ресурсов при отмене:</h4><p><code>class ResourceManager {</code><br><code>&nbsp;&nbsp;constructor(signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cleanup();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;allocate(resource) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources.push(resource);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cleanup() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Очистка ресурсов...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources.forEach(r => r.dispose());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Всегда удаляйте слушателей abort события для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortSignal', 'события', 'прослушивание', 'cleanup']
  },
  {
    id: 96,
    question: "Как комбинировать несколько AbortSignal (AbortSignal.any)?",
    answer: "<p>Иногда нужно отменить операцию по нескольким условиям — для этого используется <code>AbortSignal.any()</code>:</p><h4>Базовое использование AbortSignal.any():</h4><p><code>const userController = new AbortController();</code><br><code>const timeoutController = new AbortController();</code></p><p><code>// Комбинируем сигналы</code><br><code>const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;userController.signal,</code><br><code>&nbsp;&nbsp;timeoutController.signal</code><br><code>]);</code></p><p><code>fetch('/api/data', { signal: combinedSignal })</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Отменено (пользователем или таймаутом)');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отмена таймаутом через 5 секунд</code><br><code>setTimeout(() => timeoutController.abort(), 5000);</code></p><p><code>// Или пользователем</code><br><code>// userController.abort();</code></p><h4>Практический пример - запрос с таймаутом и ручной отменой:</h4><p><code>async function fetchWithTimeoutAndCancel(url, timeout, userSignal) {</code><br><code>&nbsp;&nbsp;// Создаем сигнал для таймаута</code><br><code>&nbsp;&nbsp;const timeoutSignal = AbortSignal.timeout(timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Комбинируем</code><br><code>&nbsp;&nbsp;const combinedSignal = AbortSignal.any([userSignal, timeoutSignal]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError' || error.name === 'TimeoutError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timeoutSignal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Timeout');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (userSignal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('User cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Polyfill для старых браузеров:</h4><p><code>if (!AbortSignal.any) {</code><br><code>&nbsp;&nbsp;AbortSignal.any = function(signals) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signals.forEach(signal => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort(signal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort(signal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, { once: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return controller.signal;</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><h4>Множественные условия отмены:</h4><p><code>async function complexFetch(url) {</code><br><code>&nbsp;&nbsp;const userController = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutSignal = AbortSignal.timeout(10000);</code><br><code>&nbsp;&nbsp;const networkController = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Отмена при потере сети</code><br><code>&nbsp;&nbsp;window.addEventListener('offline', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;networkController.abort('Network lost');</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;userController.signal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutSignal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;networkController.signal</code><br><code>&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Abort reason:', combinedSignal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React пример:</h4><p><code>function DataLoader() {</code><br><code>&nbsp;&nbsp;const userControllerRef = useRef(new AbortController());</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = userControllerRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отмена при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const loadData = async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userControllerRef.current.signal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbortSignal.timeout(5000)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// ...</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><em>Поддержка:</em> AbortSignal.any() доступен в Chrome 116+, Safari 17+, Firefox 115+. Используйте polyfill для старых браузеров.</p>",
    difficulty: 'senior',
    tags: ['AbortSignal', 'комбинирование', 'AbortSignal.any', 'продвинутое']
  },
  {
    id: 97,
    question: "Как использовать AbortController с XMLHttpRequest?",
    answer: "<p>XMLHttpRequest не поддерживает AbortSignal напрямую, но можно реализовать отмену вручную:</p><h4>Базовая реализация:</h4><p><code>function xhrWithAbort(url, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед запуском</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Слушатель отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(xhr.responseText);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Network error'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('GET', url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send();</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>xhrWithAbort('/api/data', controller.signal)</code><br><code>&nbsp;&nbsp;.then(data => console.log(data))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('XHR request aborted');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отмена</code><br><code>controller.abort();</code></p><h4>С upload progress:</h4><p><code>function uploadWithAbort(url, formData, signal, onProgress) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Upload progress</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onProgress?.(percent);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(xhr.responseText);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Upload failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('POST', url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(formData);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Класс-обертка:</h4><p><code>class XHRWithAbortSignal {</code><br><code>&nbsp;&nbsp;constructor(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.url = url;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.options = options;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async send(signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.onload = () => resolve(this.xhr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.onerror = () => reject(new Error('Network error'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.open(this.options.method || 'GET', this.url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Установка заголовков</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.options.headers) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.entries(this.options.headers).forEach(([key, value]) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.setRequestHeader(key, value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.send(this.options.body);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const controller = new AbortController();</code><br><code>const xhr = new XHRWithAbortSignal('/api/data');</code></p><p><code>xhr.send(controller.signal)</code><br><code>&nbsp;&nbsp;.then(xhr => console.log(xhr.responseText))</code><br><code>&nbsp;&nbsp;.catch(error => console.error(error));</code></p><p><em>Важно:</em> Всегда очищайте слушателей abort события для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'XMLHttpRequest', 'интеграция', 'upload']
  },
  {
    id: 98,
    question: "Как отменить чтение файла с FileReader?",
    answer: "<p>FileReader API не поддерживает AbortSignal напрямую, но можно реализовать отмену:</p><h4>Обертка с AbortController:</h4><p><code>function readFileWithAbort(file, signal, method = 'readAsText') {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const reader = new FileReader();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед началом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызов нужного метода</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader[method](file);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code><br><code>const fileInput = document.querySelector('input[type=\"file\"]');</code></p><p><code>fileInput.addEventListener('change', async (e) => {</code><br><code>&nbsp;&nbsp;const file = e.target.files[0];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const content = await readFileWithAbort(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.signal, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'readAsText'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('File content:', content);</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('File reading cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>// Отмена чтения</code><br><code>cancelButton.onclick = () => controller.abort();</code></p><h4>С прогрессом:</h4><p><code>function readFileWithProgress(file, signal, onProgress) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const reader = new FileReader();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Прогресс чтения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onProgress?.(percent);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.readAsDataURL(file);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Класс FileReaderWithAbort:</h4><p><code>class FileReaderWithAbort {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reader = new FileReader();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;read(file, method, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(this.reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(this.reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onabort = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader[method](file);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsText(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsText', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsDataURL(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsDataURL', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsArrayBuffer(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsArrayBuffer', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const reader = new FileReaderWithAbort();</code><br><code>const controller = new AbortController();</code></p><p><code>reader.readAsText(file, controller.signal)</code><br><code>&nbsp;&nbsp;.then(content => console.log(content))</code><br><code>&nbsp;&nbsp;.catch(err => console.error(err));</code></p><p><em>Применение:</em> Отмена чтения больших файлов, обработка изображений, парсинг CSV/JSON.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'FileReader', 'файлы', 'чтение']
  },
  {
    id: 99,
    question: "Как использовать AbortController в React для отмены запросов при размонтировании?",
    answer: "<p>AbortController критичен для предотвращения утечек памяти и ошибок при размонтировании компонентов:</p><h4>Базовая интеграция с useEffect:</h4><p><code>import { useEffect, useState } from 'react';</code></p><p><code>function DataComponent() {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/data', { signal: controller.signal })</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(setData)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;</code><br><code>}</code></p><h4>Переиспользуемый хук useFetch:</h4><p><code>function useFetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const [error, setError] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(url, { </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(data => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.finally(() => setLoading(false));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, [url]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function App() {</code><br><code>&nbsp;&nbsp;const { data, loading, error } = useFetch('/api/users');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;</code><br><code>&nbsp;&nbsp;if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;</code><br><code>}</code></p><h4>С ручной отменой:</h4><p><code>function useFetchWithManualAbort(url) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controllerRef.current.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, [url]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const cancel = useCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function DataLoader() {</code><br><code>&nbsp;&nbsp;const { data, loading, execute, cancel } = useFetchWithManualAbort('/api/data');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={execute}&gt;Загрузить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cancel}&gt;Отменить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{loading && &lt;div&gt;Loading...&lt;/div&gt;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{data && &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><h4>С зависимостями:</h4><p><code>function UserProfile({ userId }) {</code><br><code>&nbsp;&nbsp;const [user, setUser] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/users/\${userId}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(setUser)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем при изменении userId или размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, [userId]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{user?.name}&lt;/div&gt;;</code><br><code>}</code></p><p><em>Критически важно:</em> Всегда возвращайте cleanup функцию с abort() из useEffect для предотвращения ошибок \"Can't perform a React state update on an unmounted component\".</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'React', 'hooks', 'useEffect']
  },
  {
    id: 100,
    question: "Как использовать AbortController в Vue для отмены запросов?",
    answer: "<p>В Vue 3 AbortController интегрируется через lifecycle hooks и composables:</p><h4>Options API с lifecycle hooks:</h4><p><code>export default {</code><br><code>&nbsp;&nbsp;data() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: null,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller: null</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;mounted() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadData();</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;beforeUnmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем запрос при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controller?.abort();</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;methods: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;async loadData() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Composition API с onBeforeUnmount:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, onMounted, onBeforeUnmount } from 'vue';</code></p><p><code>const data = ref(null);</code><br><code>const controller = ref(null);</code></p><p><code>async function loadData() {</code><br><code>&nbsp;&nbsp;controller.value = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.value.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data.value = await response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>onMounted(() => loadData());</code></p><p><code>onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;controller.value?.abort();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><h4>Переиспользуемый composable useFetch:</h4><p><code>// composables/useFetch.js</code><br><code>import { ref, onBeforeUnmount } from 'vue';</code></p><p><code>export function useFetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;const data = ref(null);</code><br><code>&nbsp;&nbsp;const loading = ref(false);</code><br><code>&nbsp;&nbsp;const error = ref(null);</code><br><code>&nbsp;&nbsp;const controller = ref(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async function execute() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loading.value = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.value = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.value.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.value = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.value = err;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loading.value = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function cancel() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error, execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>import { useFetch } from '@/composables/useFetch';</code></p><p><code>const { data, loading, error, execute, cancel } = useFetch('/api/users');</code><br><code></code><br><code>// Автоматически загрузить при монтировании</code><br><code>onMounted(() => execute());</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click=\"execute\"&gt;Загрузить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click=\"cancel\"&gt;Отменить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-if=\"loading\"&gt;Загрузка...&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-else-if=\"error\"&gt;Ошибка: {{ error.message }}&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-else-if=\"data\"&gt;{{ data }}&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>С watch для реактивных зависимостей:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, watch, onBeforeUnmount } from 'vue';</code></p><p><code>const props = defineProps(['userId']);</code><br><code>const user = ref(null);</code><br><code>let controller = null;</code></p><p><code>async function loadUser(id) {</code><br><code>&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;controller?.abort();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/users/\${id}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;user.value = await response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Загружаем при изменении userId</code><br><code>watch(() => props.userId, (newId) => {</code><br><code>&nbsp;&nbsp;if (newId) loadUser(newId);</code><br><code>}, { immediate: true });</code></p><p><code>onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;controller?.abort();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><em>Best practice:</em> Создавайте переиспользуемые composables для логики с AbortController вместо дублирования кода в каждом компоненте.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'Vue', 'Composition API', 'composables']
  },
  {
    id: 101,
    question: "Как отменить загрузку изображений, скриптов и других ресурсов?",
    answer: "<p>Отмена загрузки ресурсов полезна для оптимизации и экономии трафика:</p><h4>Отмена загрузки изображений:</h4><p><code>function loadImageWithAbort(src, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед началом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const img = new Image();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Прерываем загрузку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.src = '';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(img);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Image load failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.src = src;</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>loadImageWithAbort('/image.jpg', controller.signal)</code><br><code>&nbsp;&nbsp;.then(img => document.body.appendChild(img))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Image loading cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить загрузку</code><br><code>controller.abort();</code></p><h4>Отмена загрузки скриптов:</h4><p><code>function loadScriptWithAbort(src, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const script = document.createElement('script');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.src = src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(script);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Script load failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.head.appendChild(script);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Менеджер загрузки ресурсов:</h4><p><code>class ResourceLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async loadImage(id, src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.set(id, controller);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const img = await loadImageWithAbort(src, controller.signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelLoad(id) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = this.controllers.get(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (controller) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelAll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.forEach(controller => controller.abort());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const loader = new ResourceLoader();</code></p><p><code>loader.loadImage('hero', '/hero.jpg')</code><br><code>&nbsp;&nbsp;.then(img => document.body.appendChild(img));</code></p><p><code>// Отменить конкретную загрузку</code><br><code>loader.cancelLoad('hero');</code></p><p><code>// Или все загрузки</code><br><code>loader.cancelAll();</code></p><p><em>Применение:</em> Карусели изображений, ленивая загрузка, отмена при смене роута, экономия трафика.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'изображения', 'ресурсы', 'загрузка']
  },
  {
    id: 102,
    question: "Какие есть best practices и подводные камни при работе с AbortController?",
    answer: "<p>При работе с AbortController важно следовать лучшим практикам и избегать распространенных ошибок:</p><h4>✅ Best Practices:</h4><p><strong>1. Всегда проверяйте signal.aborted:</strong></p><p><code>async function operation(signal) {</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Already aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Длительная операция...</code><br><code>}</code></p><p><strong>2. Очищайте слушателей событий:</strong></p><p><code>const abortHandler = () => cleanup();</code><br><code>signal.addEventListener('abort', abortHandler);</code><br><code></code><br><code>// В конце</code><br><code>signal.removeEventListener('abort', abortHandler);</code></p><p><strong>3. Используйте { once: true } для автоочистки:</strong></p><p><code>signal.addEventListener('abort', handler, { once: true });</code></p><p><strong>4. Проверяйте error.name === 'AbortError':</strong></p><p><code>catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Это нормальная отмена, не логируем как ошибку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;console.error('Реальная ошибка:', error);</code><br><code>}</code></p><p><strong>5. Создавайте новый контроллер для каждой операции:</strong></p><p><code>// ❌ Плохо - переиспользование</code><br><code>const controller = new AbortController();</code><br><code>controller.abort();</code><br><code>// Нельзя переиспользовать!</code></p><p><code>// ✅ Хорошо - новый контроллер</code><br><code>function makeRequest() {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;return { controller, promise: fetch(url, { signal: controller.signal }) };</code><br><code>}</code></p><p><strong>6. Передавайте причину отмены:</strong></p><p><code>controller.abort('User cancelled');</code><br><code>// или</code><br><code>controller.abort(new Error('Timeout exceeded'));</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Забытые cleanup:</strong></p><p><code>// ❌ Утечка памяти в React</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;// Забыли return cleanup!</code><br><code>}, []);</code></p><p><code>// ✅ Правильно</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;return () => controller.abort();</code><br><code>}, []);</code></p><p><strong>2. Переиспользование AbortSignal:</strong></p><p><code>// ❌ Нельзя переиспользовать</code><br><code>const signal = controller.signal;</code><br><code>controller.abort();</code><br><code>// signal.aborted === true навсегда!</code></p><p><strong>3. Игнорирование AbortError:</strong></p><p><code>// ❌ Плохо - логируем нормальную отмену</code><br><code>catch (error) {</code><br><code>&nbsp;&nbsp;console.error('Error:', error); // Логирует AbortError</code><br><code>}</code></p><p><code>// ✅ Хорошо</code><br><code>catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><strong>4. Забытые слушатели:</strong></p><p><code>// ❌ Слушатель не удален</code><br><code>signal.addEventListener('abort', handler);</code><br><code>// Работает постоянно!</code></p><p><code>// ✅ Используйте once или удаляйте</code><br><code>signal.addEventListener('abort', handler, { once: true });</code></p><p><strong>5. Неправильное использование в циклах:</strong></p><p><code>// ❌ Плохо - все запросы с одним signal</code><br><code>const controller = new AbortController();</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;fetch(item.url, { signal: controller.signal });</code><br><code>});</code><br><code>// abort() отменит ВСЕ запросы</code></p><p><strong>6. Отсутствие обработки в long operations:</strong></p><p><code>// ❌ Плохо - нет проверки abort</code><br><code>async function longOperation(signal) {</code><br><code>&nbsp;&nbsp;for (let i = 0; i < 10000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i); // Нельзя прервать!</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// ✅ Хорошо - периодическая проверка</code><br><code>async function longOperation(signal) {</code><br><code>&nbsp;&nbsp;for (let i = 0; i < 10000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не отменять запросы при размонтировании компонентов</li><li>Переиспользовать уже отмененный контроллер</li><li>Забывать проверять signal.aborted в длительных операциях</li><li>Не обрабатывать AbortError отдельно от других ошибок</li><li>Создавать глобальные контроллеры вместо локальных</li></ol><h4>🎯 Когда НЕ использовать:</h4><ul><li>Для простых синхронных операций</li><li>Когда запрос уже завершился</li><li>Для отмены setTimeout (используйте clearTimeout)</li><li>Для отмены setInterval (используйте clearInterval)</li></ul><p><em>Золотое правило:</em> Создавайте новый AbortController для каждой отменяемой операции, всегда очищайте ресурсы.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'best practices', 'подводные камни', 'ошибки']
  },
  {
    id: 103,
    question: "Как использовать AbortController для отмены нескольких связанных запросов?",
    answer: "<p>Часто нужно отменить группу связанных запросов одновременно:</p><h4>Базовый подход - один контроллер для всех:</h4><p><code>async function loadPageData(pageId) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;const signal = controller.signal;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Параллельные запросы с одним signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const [user, posts, comments] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/users/\${pageId}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/posts?userId=\${pageId}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/comments?userId=\${pageId}\`, { signal })</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: await user.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posts: await posts.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comments: await comments.json()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('All requests cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const controller = new AbortController();</code><br><code>loadPageData(123);</code><br><code></code><br><code>// Отменяет ВСЕ три запроса</code><br><code>controller.abort();</code></p><h4>Менеджер запросов с группировкой:</h4><p><code>class RequestManager {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;createGroup(groupId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.set(groupId, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests: []</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return controller.signal;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(groupId, url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const group = this.groups.get(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!group) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Group \${groupId} not found\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const promise = fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: group.controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;group.requests.push(promise);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return promise;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelGroup(groupId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const group = this.groups.get(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (group) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.groups.delete(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelAll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.forEach((group, groupId) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const manager = new RequestManager();</code></p><p><code>async function loadDashboard() {</code><br><code>&nbsp;&nbsp;const groupId = 'dashboard';</code><br><code>&nbsp;&nbsp;manager.createGroup(groupId);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const [users, stats, activities] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/users'),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/stats'),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/activities')</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return { users, stats, activities };</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Отменить группу запросов</code><br><code>manager.cancelGroup('dashboard');</code></p><h4>Последовательные запросы с общей отменой:</h4><p><code>async function loadWithDependencies(signal) {</code><br><code>&nbsp;&nbsp;// Шаг 1: Загружаем пользователя</code><br><code>&nbsp;&nbsp;const userRes = await fetch('/api/user', { signal });</code><br><code>&nbsp;&nbsp;const user = await userRes.json();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Проверка перед следующим шагом</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Шаг 2: Загружаем данные пользователя</code><br><code>&nbsp;&nbsp;const [posts, followers] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/posts?userId=\${user.id}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/followers?userId=\${user.id}\`, { signal })</code><br><code>&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;user,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;posts: await posts.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;followers: await followers.json()</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><h4>React хук для группы запросов:</h4><p><code>function useGroupedRequests() {</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async (requests) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущую группу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const signal = controllerRef.current.signal;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Выполняем все запросы с одним signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await Promise.all(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests.map(req => fetch(req.url, { ...req.options, signal }))</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Promise.all(results.map(r => r.json()));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const cancel = useCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function Dashboard() {</code><br><code>&nbsp;&nbsp;const { execute, cancel } = useGroupedRequests();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const loadData = async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await execute([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/users' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/stats' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/activities' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка данных</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cancel}&gt;Cancel All&lt;/button&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Применение:</em> Загрузка связанных данных, dashboard с множеством виджетов, отмена при смене роута.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'множественные запросы', 'группировка', 'Promise.all']
  },
  {
    id: 104,
    question: "Как реализовать retry механизм с поддержкой отмены через AbortController?",
    answer: "<p>Комбинирование retry логики с возможностью отмены повышает надежность приложения:</p><h4>Базовая реализация retry с abort:</h4><p><code>async function fetchWithRetry(url, options = {}, retries = 3, signal) {</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= retries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка отмены перед попыткой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Не retry при отмене</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Последняя попытка - выбрасываем ошибку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === retries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exponential backoff</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.pow(2, attempt) * 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${retries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Ожидание с проверкой отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await sleep(delay, signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Функция sleep с поддержкой abort</code><br><code>function sleep(ms, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeout = setTimeout(resolve, ms);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal?.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, { once: true });</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>try {</code><br><code>&nbsp;&nbsp;const response = await fetchWithRetry(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'/api/data',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;3, // 3 попытки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.signal</code><br><code>&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;console.log(data);</code><br><code>} catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Request cancelled during retry');</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('All retries failed:', error);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Отменить в любой момент (даже во время ожидания retry)</code><br><code>controller.abort();</code></p><h4>Класс с конфигурируемым retry:</h4><p><code>class RetryableFetch {</code><br><code>&nbsp;&nbsp;constructor(config = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxRetries = config.maxRetries || 3;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.retryDelay = config.retryDelay || 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.retryOn = config.retryOn || [500, 502, 503, 504];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.backoffMultiplier = config.backoffMultiplier || 2;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(url, options = {}, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let lastError;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let attempt = 0; attempt <= this.maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { ...options, signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Успех</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем, нужен ли retry для этого статуса</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.retryOn.includes(response.status)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response; // Не retry для 4xx ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastError = error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt < this.maxRetries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = this.retryDelay * Math.pow(this.backoffMultiplier, attempt);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${this.maxRetries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await sleep(delay, signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw lastError;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const fetcher = new RetryableFetch({</code><br><code>&nbsp;&nbsp;maxRetries: 5,</code><br><code>&nbsp;&nbsp;retryDelay: 1000,</code><br><code>&nbsp;&nbsp;retryOn: [500, 502, 503, 504],</code><br><code>&nbsp;&nbsp;backoffMultiplier: 2</code><br><code>});</code></p><p><code>const controller = new AbortController();</code></p><p><code>fetcher.fetch('/api/data', {}, controller.signal)</code><br><code>&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;.then(data => console.log(data));</code></p><p><code>// Отменить retry</code><br><code>setTimeout(() => controller.abort(), 5000);</code></p><h4>React хук с retry:</h4><p><code>function useFetchWithRetry(url, options = {}, retries = 3) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const [error, setError] = useState(null);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setError(null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetchWithRetry(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retries,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(err);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, [url, retries]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error, execute };</code><br><code>}</code></p><p><em>Применение:</em> Ненадежные API, временные проблемы с сетью, rate limiting, улучшение UX при проблемах соединения.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'retry', 'надежность', 'error handling']
  },
  {
    id: 105,
    question: "В чем разница между AbortController и другими методами отмены операций?",
    answer: "<p>Существует несколько способов отмены асинхронных операций, каждый со своими особенностями:</p><h4>AbortController (современный стандарт):</h4><p><strong>Преимущества:</strong></p><ul><li>Стандартизированный Web API</li><li>Работает с Fetch, ReadableStream, addEventListener</li><li>Поддержка причины отмены (signal.reason)</li><li>Можно комбинировать сигналы (AbortSignal.any)</li><li>Событие 'abort' для реактивной обработки</li><li>Встроенная поддержка в браузерах</li></ul><p><strong>Недостатки:</strong></p><ul><li>Нельзя переиспользовать после abort()</li><li>Не работает с setTimeout/setInterval напрямую</li><li>Требует ручной интеграции в старых API</li></ul><h4>Promise cancellation паттерны:</h4><p><code>// Старый подход - флаг отмены</code><br><code>let cancelled = false;</code><br><code></code><br><code>async function operation() {</code><br><code>&nbsp;&nbsp;if (cancelled) return;</code><br><code>&nbsp;&nbsp;await step1();</code><br><code>&nbsp;&nbsp;if (cancelled) return;</code><br><code>&nbsp;&nbsp;await step2();</code><br><code>}</code></p><p><strong>Проблемы:</strong></p><ul><li>Нет стандартизации</li><li>Нужно вручную проверять флаг</li><li>Сложно с вложенными операциями</li><li>Нет событий отмены</li></ul><h4>Библиотечные решения (Bluebird, Axios):</h4><p><code>// Bluebird cancellable promises</code><br><code>const promise = new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;// ...</code><br><code>}).cancellable();</code></p><p><code>promise.cancel();</code></p><p><code>// Axios CancelToken (устаревший)</code><br><code>const CancelToken = axios.CancelToken;</code><br><code>const source = CancelToken.source();</code><br><code></code><br><code>axios.get('/api/data', {</code><br><code>&nbsp;&nbsp;cancelToken: source.token</code><br><code>});</code><br><code></code><br><code>source.cancel('Cancelled');</code></p><p><strong>Проблемы:</strong></p><ul><li>Не стандарт, зависимость от библиотеки</li><li>Axios перешел на AbortController</li><li>Разные API в разных библиотеках</li></ul><h4>clearTimeout / clearInterval:</h4><p><code>const timeoutId = setTimeout(callback, 1000);</code><br><code>clearTimeout(timeoutId);</code></p><p><strong>Применение:</strong> Только для таймеров, не для fetch/promises</p><h4>removeEventListener:</h4><p><code>element.addEventListener('click', handler);</code><br><code>element.removeEventListener('click', handler);</code></p><p><strong>Применение:</strong> Только для DOM событий</p><h4>Сравнительная таблица:</h4><table><tr><th>Метод</th><th>Стандарт</th><th>Fetch</th><th>Универсальность</th><th>Причина отмены</th></tr><tr><td>AbortController</td><td>✅ Web API</td><td>✅</td><td>⭐⭐⭐⭐⭐</td><td>✅</td></tr><tr><td>Флаг cancelled</td><td>❌</td><td>❌</td><td>⭐⭐</td><td>❌</td></tr><tr><td>Bluebird</td><td>❌</td><td>❌</td><td>⭐⭐⭐</td><td>✅</td></tr><tr><td>Axios CancelToken</td><td>❌</td><td>N/A</td><td>⭐⭐⭐</td><td>✅</td></tr><tr><td>clearTimeout</td><td>✅</td><td>❌</td><td>⭐</td><td>❌</td></tr></table><h4>Миграция на AbortController:</h4><p><code>// ❌ Старый Axios</code><br><code>const source = axios.CancelToken.source();</code><br><code>axios.get(url, { cancelToken: source.token });</code><br><code>source.cancel();</code></p><p><code>// ✅ Новый Axios с AbortController</code><br><code>const controller = new AbortController();</code><br><code>axios.get(url, { signal: controller.signal });</code><br><code>controller.abort();</code></p><h4>Когда использовать что:</h4><ul><li><strong>AbortController:</strong> Fetch, потоки, современные async операции</li><li><strong>clearTimeout:</strong> Только для setTimeout/setInterval</li><li><strong>removeEventListener:</strong> Только для DOM событий</li><li><strong>Флаги:</strong> Простые внутренние операции (не рекомендуется)</li></ul><p><em>Вывод:</em> AbortController — современный стандарт для отмены асинхронных операций. Мигрируйте с устаревших подходов.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'сравнение', 'альтернативы', 'стандарты']
  },
  {
    id: 106,
    question: "Что такое Web Storage API и какие два типа хранилищ он предоставляет?",
    answer: "<p><strong>Web Storage API</strong> — это механизм для хранения пар ключ-значение в браузере на стороне клиента:</p><h4>Два типа хранилищ:</h4><p><strong>localStorage:</strong> Постоянное хранилище без срока действия. Данные сохраняются даже после закрытия браузера и перезагрузки компьютера.</p><p><strong>sessionStorage:</strong> Временное хранилище на время сессии. Данные удаляются при закрытии вкладки или браузера.</p><h4>Основные характеристики:</h4><ul><li>Синхронный API</li><li>Хранение только строк</li><li>Ограничение ~5-10 МБ на домен</li><li>Доступ только с того же origin</li><li>Не отправляются на сервер автоматически</li></ul><p><em>Ключевое отличие от cookies:</em> Web Storage не отправляется с каждым HTTP-запросом, что экономит bandwidth.</p>",
    difficulty: 'junior',
    tags: ['Web Storage', 'localStorage', 'sessionStorage', 'основы']
  },
  {
    id: 107,
    question: "В чем разница между localStorage и sessionStorage?",
    answer: "<p>localStorage и sessionStorage имеют одинаковый API, но разную область видимости и время жизни:</p><h4>localStorage:</h4><ul><li><strong>Время жизни:</strong> Постоянное, до явного удаления</li><li><strong>Область:</strong> Общий для всех вкладок и окон одного origin</li><li><strong>Сохранение:</strong> Остается после закрытия браузера</li><li><strong>Удаление:</strong> Только программно или через настройки браузера</li></ul><h4>sessionStorage:</h4><ul><li><strong>Время жизни:</strong> До закрытия вкладки/окна</li><li><strong>Область:</strong> Уникальный для каждой вкладки</li><li><strong>Сохранение:</strong> Удаляется при закрытии вкладки</li><li><strong>Удаление:</strong> Автоматически при закрытии</li></ul><h4>Когда использовать:</h4><p><strong>localStorage:</strong> Настройки темы, язык интерфейса, токены, preferences, кэш данных</p><p><strong>sessionStorage:</strong> Данные формы, состояние wizard'а, временные фильтры, одноразовые данные</p><p><em>Важно:</em> Даже дублирование вкладки (Ctrl+Shift+T) создает новый sessionStorage.</p>",
    difficulty: 'junior',
    tags: ['localStorage', 'sessionStorage', 'различия', 'область видимости']
  },
  {
    id: 108,
    question: "Какие типы данных можно сохранять в localStorage/sessionStorage?",
    answer: "<p>Web Storage может хранить <strong>только строки</strong>. Все остальные типы нужно преобразовывать:</p><h4>Строки — напрямую:</h4><p><code>localStorage.setItem('name', 'John');</code></p><h4>Числа — преобразуются в строку:</h4><p><code>localStorage.setItem('age', 25); // Сохранится как '25'</code><br><code>const age = Number(localStorage.getItem('age')); // Обратно в число</code></p><h4>Булевы значения — преобразуются в строку:</h4><p><code>localStorage.setItem('isActive', true); // Сохранится как 'true'</code><br><code>const isActive = localStorage.getItem('isActive') === 'true';</code></p><h4>Объекты и массивы — через JSON:</h4><p><code>const user = { name: 'John', age: 25 };</code><br><code>localStorage.setItem('user', JSON.stringify(user));</code><br><code></code><br><code>const savedUser = JSON.parse(localStorage.getItem('user'));</code></p><h4>Date — преобразование через ISO:</h4><p><code>const date = new Date();</code><br><code>localStorage.setItem('date', date.toISOString());</code><br><code></code><br><code>const savedDate = new Date(localStorage.getItem('date'));</code></p><h4>Что нельзя сохранить:</h4><ul><li>Функции (потеряются при JSON.stringify)</li><li>Symbol (не сериализуются)</li><li>undefined (превратится в строку 'undefined')</li><li>Циклические ссылки (ошибка при stringify)</li></ul><p><em>Best practice:</em> Всегда оборачивайте JSON.parse в try-catch для обработки невалидных данных.</p>",
    difficulty: 'junior',
    tags: ['localStorage', 'типы данных', 'JSON', 'сериализация']
  },
  {
    id: 109,
    question: "Как проверить доступность и размер Web Storage?",
    answer: "<p>Важно проверять доступность и ограничения Storage перед использованием:</p><h4>Проверка поддержки:</h4><p><code>function isStorageAvailable(type) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const storage = window[type];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const test = '__storage_test__';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;storage.setItem(test, test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;storage.removeItem(test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>if (isStorageAvailable('localStorage')) {</code><br><code>&nbsp;&nbsp;// Можно использовать</code><br><code>}</code></p><h4>Определение размера хранилища:</h4><p><code>function getStorageSize() {</code><br><code>&nbsp;&nbsp;let total = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;for (let key in localStorage) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (localStorage.hasOwnProperty(key)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total += localStorage[key].length + key.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (total / 1024).toFixed(2) + ' KB';</code><br><code>}</code></p><h4>Проверка лимита:</h4><p><code>function getStorageLimit() {</code><br><code>&nbsp;&nbsp;let max = 0;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const test = '0'.repeat(1024); // 1KB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let i = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (i < 10000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem('test' + i, test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;max = i;</code><br><code>&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let j = 0; j < i; j++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem('test' + j);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return max + ' KB примерно';</code><br><code>}</code></p><h4>Причины недоступности:</h4><ul><li>Режим приватного просмотра (некоторые браузеры)</li><li>Пользователь отключил Storage в настройках</li><li>Хранилище переполнено (QuotaExceededError)</li><li>Старые браузеры без поддержки</li></ul><p><em>Типичный лимит:</em> 5MB для localStorage и sessionStorage в большинстве браузеров.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'проверка доступности', 'размер', 'ограничения']
  },
  {
    id: 110,
    question: "Как обрабатывать ошибку QuotaExceededError при переполнении Storage?",
    answer: "<p>QuotaExceededError возникает когда Storage переполнен. Важно правильно обрабатывать эту ошибку:</p><h4>Базовая обработка:</h4><p><code>function safeSetItem(key, value) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Storage full');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw e;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Автоматическая очистка старых данных:</h4><p><code>function setItemWithExpiry(key, value, ttl) {</code><br><code>&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;value: value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttl</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Очищаем истекшие элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanupExpired();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Пробуем снова</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e2) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Storage still full');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>function cleanupExpired() {</code><br><code>&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.expiry && item.expiry < now) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Невалидные данные - можно удалить</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>LRU (Least Recently Used) стратегия:</h4><p><code>class LRUStorage {</code><br><code>&nbsp;&nbsp;set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastUsed: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeLeastRecentlyUsed();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;removeLeastRecentlyUsed() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let oldestKey = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let oldestTime = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.lastUsed < oldestTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldestTime = item.lastUsed;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldestKey = key;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (oldestKey) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(oldestKey);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Всегда оборачивайте setItem в try-catch и имейте стратегию очистки.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'QuotaExceededError', 'обработка ошибок', 'очистка']
  },
  {
    id: 111,
    question: "Как работать с событием storage для синхронизации между вкладками?",
    answer: "<p>Событие <code>storage</code> позволяет синхронизировать данные между вкладками одного origin:</p><h4>Базовое использование:</h4><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;console.log('Key:', e.key);</code><br><code>&nbsp;&nbsp;console.log('Old value:', e.oldValue);</code><br><code>&nbsp;&nbsp;console.log('New value:', e.newValue);</code><br><code>&nbsp;&nbsp;console.log('URL:', e.url);</code><br><code>&nbsp;&nbsp;console.log('Storage:', e.storageArea);</code><br><code>});</code></p><h4>Важные особенности:</h4><ul><li>Срабатывает ТОЛЬКО в других вкладках, не в той где произошло изменение</li><li>Работает только для localStorage, не для sessionStorage</li><li>e.key === null при вызове clear()</li><li>e.oldValue и e.newValue всегда строки</li></ul><h4>Синхронизация темы между вкладками:</h4><p><code>// Во вкладке 1</code><br><code>function setTheme(theme) {</code><br><code>&nbsp;&nbsp;localStorage.setItem('theme', theme);</code><br><code>&nbsp;&nbsp;applyTheme(theme);</code><br><code>}</code></p><p><code>// Во вкладке 2 - автообновление</code><br><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'theme' && e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;applyTheme(e.newValue);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Синхронизация состояния аутентификации:</h4><p><code>// Logout во всех вкладках</code><br><code>function logout() {</code><br><code>&nbsp;&nbsp;localStorage.removeItem('token');</code><br><code>&nbsp;&nbsp;redirectToLogin();</code><br><code>}</code></p><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'token' && !e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Токен удален в другой вкладке</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;redirectToLogin();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Broadcast сообщений между вкладками:</h4><p><code>function broadcastMessage(type, data) {</code><br><code>&nbsp;&nbsp;const message = { type, data, timestamp: Date.now() };</code><br><code>&nbsp;&nbsp;localStorage.setItem('broadcast', JSON.stringify(message));</code><br><code>&nbsp;&nbsp;localStorage.removeItem('broadcast'); // Триггер события</code><br><code>}</code></p><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'broadcast' && e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(e.newValue);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;handleMessage(message);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><em>Альтернатива:</em> Для более надежной коммуникации используйте BroadcastChannel API.</p>",
    difficulty: 'middle',
    tags: ['storage event', 'синхронизация', 'вкладки', 'коммуникация']
  },
  {
    id: 112,
    question: "Как реализовать хранение данных с TTL (временем жизни)?",
    answer: "<p>TTL (Time To Live) позволяет автоматически удалять устаревшие данные:</p><h4>Базовая реализация:</h4><p><code>const StorageWithTTL = {</code><br><code>&nbsp;&nbsp;set(key, value, ttlMinutes) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttlMinutes * 60 * 1000</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemStr = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!itemStr) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(itemStr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка истечения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (Date.now() > item.expiry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return item.value;</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>// Сохранить на 30 минут</code><br><code>StorageWithTTL.set('sessionData', userData, 30);</code></p><p><code>// Получить (вернет null если истекло)</code><br><code>const data = StorageWithTTL.get('sessionData');</code></p><h4>Класс с автоочисткой:</h4><p><code>class CacheStorage {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cleanup(); // Очистка при инициализации</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, value, ttlSeconds = 3600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttlSeconds * 1000</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemStr = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!itemStr) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(itemStr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Date.now() > item.expiry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;remove(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cleanup() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.expiry && item.expiry < now) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Игнорируем невалидные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Запускайте cleanup() при инициализации приложения для удаления истекших данных.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'TTL', 'кэширование', 'expiry']
  },
  {
    id: 113,
    question: "В чем разница между Web Storage и Cookies?",
    answer: "<p>Web Storage и Cookies решают похожие задачи, но имеют существенные различия:</p><h4>Web Storage (localStorage/sessionStorage):</h4><ul><li><strong>Размер:</strong> ~5-10 МБ</li><li><strong>Отправка на сервер:</strong> Никогда, только клиентская сторона</li><li><strong>API:</strong> Простой и синхронный</li><li><strong>Доступ:</strong> Только JavaScript</li><li><strong>Срок жизни:</strong> localStorage - постоянно, sessionStorage - до закрытия вкладки</li></ul><h4>Cookies:</h4><ul><li><strong>Размер:</strong> ~4 КБ</li><li><strong>Отправка на сервер:</strong> С каждым HTTP-запросом</li><li><strong>API:</strong> Строка document.cookie, неудобный</li><li><strong>Доступ:</strong> JavaScript и сервер</li><li><strong>Срок жизни:</strong> Настраивается через expires/max-age</li><li><strong>Безопасность:</strong> HttpOnly, Secure, SameSite флаги</li></ul><h4>Когда использовать:</h4><p><strong>Web Storage:</strong></p><ul><li>Настройки UI (тема, язык)</li><li>Кэширование данных</li><li>Временное состояние приложения</li><li>Большие объемы данных</li></ul><p><strong>Cookies:</strong></p><ul><li>Аутентификация (токены)</li><li>Сессии на сервере</li><li>Tracking и аналитика</li><li>Данные, нужные серверу</li></ul><h4>Производительность:</h4><p>Web Storage не увеличивает размер HTTP-запросов, в отличие от cookies которые отправляются с каждым запросом.</p><p><em>Вывод:</em> Используйте Web Storage для клиентских данных, cookies - для серверной коммуникации.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'Cookies', 'сравнение', 'различия']
  },
  {
    id: 114,
    question: "Какие существуют best practices при работе с Web Storage?",
    answer: "<p>Следование best practices критично для безопасности и производительности:</p><h4>1. Всегда оборачивайте в try-catch:</h4><p><code>try {</code><br><code>&nbsp;&nbsp;localStorage.setItem('key', 'value');</code><br><code>} catch (e) {</code><br><code>&nbsp;&nbsp;// QuotaExceededError или другие ошибки</code><br><code>}</code></p><h4>2. Проверяйте доступность:</h4><p><code>if (typeof Storage !== 'undefined') {</code><br><code>&nbsp;&nbsp;// Storage доступен</code><br><code>}</code></p><h4>3. Не храните чувствительные данные:</h4><p>❌ НЕ хранить: пароли, номера карт, SSN, приватные ключи</p><p>✅ Можно: публичные настройки, кэш, UI состояние</p><h4>4. Используйте префиксы для ключей:</h4><p><code>const APP_PREFIX = 'myapp_';</code><br><code>localStorage.setItem(APP_PREFIX + 'theme', 'dark');</code></p><h4>5. Валидируйте данные при чтении:</h4><p><code>function safeGetItem(key) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return item ? JSON.parse(item) : null;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key); // Удаляем невалидные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Ограничивайте размер данных:</h4><p><code>function setItemIfFits(key, value) {</code><br><code>&nbsp;&nbsp;const str = JSON.stringify(value);</code><br><code>&nbsp;&nbsp;if (str.length > 1024 * 1024) { // > 1MB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Data too large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;localStorage.setItem(key, str);</code><br><code>}</code></p><h4>7. Очищайте старые данные:</h4><p><code>// При инициализации приложения</code><br><code>function cleanupOldData() {</code><br><code>&nbsp;&nbsp;const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;</code><br><code>&nbsp;&nbsp;// Логика очистки...</code><br><code>}</code></p><h4>8. Используйте namespace:</h4><p><code>const storage = {</code><br><code>&nbsp;&nbsp;prefix: 'myapp_',</code><br><code>&nbsp;&nbsp;set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(this.prefix + key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(localStorage.getItem(this.prefix + key));</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>9. Минимизируйте частоту записи:</h4><p>Используйте debounce для частых обновлений, так как Storage операции синхронные.</p><h4>10. Документируйте структуру данных:</h4><p>Ведите документацию какие ключи используются и их формат.</p><p><em>Критично:</em> Storage доступен любому JavaScript на странице - не храните секреты!</p>",
    difficulty: 'senior',
    tags: ['Web Storage', 'best practices', 'безопасность', 'производительность']
  },
  {
    id: 115,
    question: "Какие существуют альтернативы Web Storage для хранения данных?",
    answer: "<p>Существует несколько альтернатив Web Storage для разных сценариев:</p><h4>1. IndexedDB:</h4><p><strong>Когда использовать:</strong> Большие объемы структурированных данных (>10MB), офлайн приложения</p><p><strong>Преимущества:</strong></p><ul><li>Практически неограниченный размер</li><li>Асинхронный API</li><li>Поддержка индексов и транзакций</li><li>Хранение объектов без сериализации</li></ul><p><strong>Недостатки:</strong> Сложный API</p><h4>2. Cache API:</h4><p><strong>Когда использовать:</strong> Кэширование HTTP-запросов, офлайн PWA</p><p><strong>Преимущества:</strong></p><ul><li>Оптимизирован для Response объектов</li><li>Работает с Service Workers</li><li>Большой размер</li></ul><h4>3. Cookies:</h4><p><strong>Когда использовать:</strong> Аутентификация, данные для сервера</p><p><strong>Преимущества:</strong></p><ul><li>Автоматическая отправка на сервер</li><li>HttpOnly для безопасности</li><li>Контроль срока жизни</li></ul><p><strong>Недостатки:</strong> Маленький размер (4KB)</p><h4>4. File System Access API:</h4><p><strong>Когда использовать:</strong> Работа с файловой системой, редакторы</p><p><strong>Преимущества:</strong> Доступ к реальным файлам пользователя</p><h4>5. WebSQL (устаревший):</h4><p><strong>Статус:</strong> Deprecated, не использовать</p><h4>6. Memory (переменные):</h4><p><strong>Когда использовать:</strong> Временные данные в рамках сессии</p><p><strong>Недостатки:</strong> Теряется при перезагрузке страницы</p><h4>Сравнительная таблица:</h4><table><tr><th>Технология</th><th>Размер</th><th>Асинхронность</th><th>Сложность</th></tr><tr><td>localStorage</td><td>~5MB</td><td>❌</td><td>⭐</td></tr><tr><td>IndexedDB</td><td>Большой</td><td>✅</td><td>⭐⭐⭐⭐</td></tr><tr><td>Cache API</td><td>Большой</td><td>✅</td><td>⭐⭐⭐</td></tr><tr><td>Cookies</td><td>4KB</td><td>❌</td><td>⭐⭐</td></tr></table><p><em>Выбор зависит:</em> от размера данных, нужны ли они серверу, требуется ли офлайн доступ.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'альтернативы', 'IndexedDB', 'Cache API']
  },
  {
    id: 116,
    question: "Как безопасно хранить токены аутентификации?",
    answer: "<p>Хранение токенов — критический вопрос безопасности приложения:</p><h4>Варианты хранения:</h4><p><strong>1. HttpOnly Cookies (РЕКОМЕНДУЕТСЯ):</strong></p><p>✅ Преимущества:</p><ul><li>Недоступны для JavaScript (защита от XSS)</li><li>Автоматически отправляются на сервер</li><li>Secure флаг для HTTPS only</li><li>SameSite защита от CSRF</li></ul><p>❌ Недостатки: Нужна настройка на сервере</p><p><strong>2. localStorage (НЕ РЕКОМЕНДУЕТСЯ):</strong></p><p>❌ Проблемы:</p><ul><li>Доступен любому JavaScript (уязвим к XSS)</li><li>Нет защиты от кражи токена</li><li>Постоянное хранение</li></ul><p>✅ Когда можно: SPA без серверного рендеринга, краткосрочные токены</p><p><strong>3. sessionStorage (КОМПРОМИСС):</strong></p><p>Чуть безопаснее localStorage, так как удаляется при закрытии вкладки, но все еще уязвим к XSS.</p><p><strong>4. Memory (в переменной):</strong></p><p>✅ Самое безопасное для клиента</p><p>❌ Теряется при перезагрузке страницы</p><h4>Best practices:</h4><p><code>// ❌ ПЛОХО - токен в localStorage</code><br><code>localStorage.setItem('token', token);</code></p><p><code>// ✅ ЛУЧШЕ - HttpOnly cookie (настраивается на сервере)</code><br><code>// Set-Cookie: token=xxx; HttpOnly; Secure; SameSite=Strict</code></p><p><code>// ✅ КОМПРОМИСС - короткоживущие токены</code><br><code>sessionStorage.setItem('token', token);</code><br><code>// + Refresh token в HttpOnly cookie</code></p><h4>Дополнительные меры безопасности:</h4><ul><li>Используйте короткие сроки жизни токенов</li><li>Implement token rotation</li><li>Проверяйте fingerprint браузера</li><li>Логируйте подозрительную активность</li><li>CSP заголовки для защиты от XSS</li></ul><p><em>Золотое правило:</em> Если возможно - используйте HttpOnly cookies. Если нет - sessionStorage с короткими токенами и refresh механизмом.</p>",
    difficulty: 'senior',
    tags: ['безопасность', 'токены', 'аутентификация', 'XSS']
  },
  {
    id: 117,
    question: "Как реализовать версионирование данных в Storage?",
    answer: "<p>Версионирование помогает избежать проблем при изменении структуры данных:</p><h4>Базовая схема версионирования:</h4><p><code>const STORAGE_VERSION = 2;</code></p><p><code>function saveData(key, data) {</code><br><code>&nbsp;&nbsp;const versioned = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;version: STORAGE_VERSION,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data: data</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(versioned));</code><br><code>}</code></p><p><code>function loadData(key) {</code><br><code>&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const parsed = JSON.parse(item);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Проверка версии</code><br><code>&nbsp;&nbsp;if (parsed.version !== STORAGE_VERSION) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return migrateData(parsed, key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return parsed.data;</code><br><code>}</code></p><h4>Миграция между версиями:</h4><p><code>function migrateData(oldData, key) {</code><br><code>&nbsp;&nbsp;const version = oldData.version || 1;</code><br><code>&nbsp;&nbsp;let data = oldData.data;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Миграция с версии 1 на 2</code><br><code>&nbsp;&nbsp;if (version === 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...data,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newField: 'defaultValue'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Сохраняем обновленные данные</code><br><code>&nbsp;&nbsp;saveData(key, data);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return data;</code><br><code>}</code></p><h4>Класс с автомиграцией:</h4><p><code>class VersionedStorage {</code><br><code>&nbsp;&nbsp;constructor(version, migrations = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.version = version;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.migrations = migrations;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version: this.version,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let parsed = JSON.parse(item);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemVersion = parsed.version || 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем все необходимые миграции</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let v = itemVersion; v < this.version; v++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const migration = this.migrations[v];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (migration) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsed.data = migration(parsed.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем мигрированные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (itemVersion < this.version) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.set(key, parsed.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return parsed.data;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const storage = new VersionedStorage(3, {</code><br><code>&nbsp;&nbsp;1: (data) => ({ ...data, newField: 'default' }),</code><br><code>&nbsp;&nbsp;2: (data) => ({ ...data, renamedField: data.oldField })</code><br><code>});</code></p><p><code>storage.set('userData', { name: 'John' });</code><br><code>const data = storage.get('userData'); // Автоматическая миграция</code></p><p><em>Best practice:</em> Всегда тестируйте миграции и сохраняйте backup перед применением.</p>",
    difficulty: 'senior',
    tags: ['версионирование', 'миграция', 'данные', 'архитектура']
  },
  {
    id: 118,
    question: "Как отладить проблемы с Web Storage в DevTools?",
    answer: "<p>Chrome DevTools предоставляют мощные инструменты для работы с Storage:</p><h4>Application Tab → Storage:</h4><p><strong>Просмотр данных:</strong></p><ul><li>Application → Local Storage / Session Storage</li><li>Видны все ключи и значения</li><li>Можно редактировать значения напрямую</li><li>Показывает размер каждого элемента</li></ul><p><strong>Очистка данных:</strong></p><ul><li>ПКМ на домене → Clear</li><li>Или кнопка «Clear All» для всего Storage</li></ul><h4>Console методы:</h4><p><code>// Просмотр всех ключей</code><br><code>console.table(localStorage);</code></p><p><code>// Размер Storage</code><br><code>let size = 0;</code><br><code>for (let key in localStorage) {</code><br><code>&nbsp;&nbsp;size += localStorage[key].length + key.length;</code><br><code>}</code><br><code>console.log(size / 1024 + ' KB');</code></p><p><code>// Поиск по ключам</code><br><code>Object.keys(localStorage).filter(key => key.includes('user'));</code></p><h4>Мониторинг изменений:</h4><p><code>// Перехват setItem</code><br><code>const originalSetItem = localStorage.setItem;</code><br><code>localStorage.setItem = function(key, value) {</code><br><code>&nbsp;&nbsp;console.log('Storage set:', key, value);</code><br><code>&nbsp;&nbsp;originalSetItem.apply(this, arguments);</code><br><code>};</code></p><h4>Breakpoints на Storage:</h4><ul><li>Sources → Event Listener Breakpoints</li><li>Выбрать «storage» для отслеживания изменений</li></ul><h4>Network Tab:</h4><p>Проверяйте размер cookies в заголовках запросов - иногда проблемы с Storage связаны с переполнением cookies.</p><h4>Частые проблемы и решения:</h4><p><strong>1. QuotaExceededError:</strong> Проверьте размер данных, очистите старые</p><p><strong>2. Данные не сохраняются:</strong> Проверьте режим инкогнито, настройки браузера</p><p><strong>3. Данные пропадают:</strong> Проверьте sessionStorage vs localStorage</p><p><strong>4. JSON.parse ошибка:</strong> Валидация данных перед парсингом</p><p><em>Совет:</em> Используйте console.table() для удобного просмотра всех данных Storage.</p>",
    difficulty: 'middle',
    tags: ['отладка', 'DevTools', 'Chrome', 'debugging']
  },
  {
    id: 119,
    question: "Как реализовать Storage с сжатием данных?",
    answer: "<p>Сжатие позволяет обойти ограничение размера Storage:</p><h4>Использование LZ-based алгоритмов:</h4><p><code>// Используем библиотеку lz-string</code><br><code>import LZString from 'lz-string';</code></p><p><code>const CompressedStorage = {</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, compressed);</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!compressed) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = LZString.decompress(compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(json);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Класс с автоматическим сжатием:</h4><p><code>class SmartStorage {</code><br><code>&nbsp;&nbsp;constructor(compressionThreshold = 1024) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.threshold = compressionThreshold;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сжимаем только если больше порога</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (json.length > this.threshold) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, 'compressed:' + compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем префикс сжатия</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (item.startsWith('compressed:')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const compressed = item.slice(11);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = LZString.decompress(compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(item);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Статистика сжатия:</h4><p><code>function compressionStats(data) {</code><br><code>&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const original = json.length;</code><br><code>&nbsp;&nbsp;const compressed = compressed.length;</code><br><code>&nbsp;&nbsp;const ratio = ((1 - compressed / original) * 100).toFixed(2);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;console.log(\`Original: \${original} bytes\`);</code><br><code>&nbsp;&nbsp;console.log(\`Compressed: \${compressed} bytes\`);</code><br><code>&nbsp;&nbsp;console.log(\`Saved: \${ratio}%\`);</code><br><code>}</code></p><h4>Преимущества:</h4><ul><li>Можно сохранить в 2-10 раз больше данных</li><li>Особенно эффективно для текста и JSON</li><li>Прозрачно для остального кода</li></ul><h4>Недостатки:</h4><ul><li>Дополнительное время на сжатие/распаковку</li><li>Нужна внешняя библиотека</li><li>Не все данные хорошо сжимаются</li></ul><p><em>Best practice:</em> Сжимайте только большие объекты (>1KB) для оптимального баланса производительности.</p>",
    difficulty: 'senior',
    tags: ['сжатие', 'оптимизация', 'производительность', 'размер']
  },
  {
    id: 120,
    question: "Как имитировать асинхронный API для Storage?",
    answer: "<p>Web Storage синхронен, но иногда нужен асинхронный API для консистентности с другими Storage API:</p><h4>Promise-based обертка:</h4><p><code>const AsyncStorage = {</code><br><code>&nbsp;&nbsp;async getItem(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const value = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(value ? JSON.parse(value) : null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async setItem(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(e);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async removeItem(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>// Асинхронный стиль</code><br><code>await AsyncStorage.setItem('user', { name: 'John' });</code><br><code>const user = await AsyncStorage.getItem('user');</code></p><h4>Универсальный адаптер:</h4><p><code>class StorageAdapter {</code><br><code>&nbsp;&nbsp;constructor(storage = localStorage) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage = storage;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = this.storage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item ? JSON.parse(item) : null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.setItem(key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async delete(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.removeItem(key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async clear() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async keys() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return Object.keys(this.storage);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Зачем нужен асинхронный API:</h4><ul><li>Консистентность с IndexedDB и Cache API</li><li>Возможность будущей замены на асинхронное хранилище</li><li>Упрощение тестирования с моками</li><li>Единообразный код</li></ul><h4>Полифилл для React Native AsyncStorage:</h4><p><code>const AsyncStorage = {</code><br><code>&nbsp;&nbsp;getItem: (key) => Promise.resolve(localStorage.getItem(key)),</code><br><code>&nbsp;&nbsp;setItem: (key, value) => Promise.resolve(localStorage.setItem(key, value)),</code><br><code>&nbsp;&nbsp;removeItem: (key) => Promise.resolve(localStorage.removeItem(key)),</code><br><code>&nbsp;&nbsp;clear: () => Promise.resolve(localStorage.clear())</code><br><code>};</code></p><p><em>Применение:</em> Облегчает миграцию кода между web и React Native, создает единый API.</p>",
    difficulty: 'middle',
    tags: ['асинхронность', 'Promise', 'адаптер', 'API']
  },
  {
    id: 121,
    question: "Что такое requestAnimationFrame и для чего он используется?",
    answer: "<p><strong>requestAnimationFrame</strong> — это Web API для создания плавных анимаций, синхронизированных с частотой обновления экрана:</p><h4>Основное назначение:</h4><p>Позволяет браузеру оптимизировать анимации, вызывая callback перед следующей перерисовкой экрана, обычно 60 раз в секунду (60 FPS).</p><h4>Базовое использование:</h4><p><code>function animate() {</code><br><code>&nbsp;&nbsp;// Логика анимации</code><br><code>&nbsp;&nbsp;element.style.left = position + 'px';</code><br><code>&nbsp;&nbsp;position += 1;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Запрос следующего кадра</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code><br><code></code><br><code>// Запуск анимации</code><br><code>requestAnimationFrame(animate);</code></p><h4>Основные применения:</h4><ul><li><strong>Анимации элементов:</strong> Плавное перемещение, изменение размера</li><li><strong>Canvas/WebGL:</strong> Рендеринг графики</li><li><strong>Игры:</strong> Игровой цикл</li><li><strong>Параллакс эффекты:</strong> Скролл-анимации</li><li><strong>Визуализация данных:</strong> Графики в реальном времени</li></ul><h4>Возвращаемое значение:</h4><p><code>const requestId = requestAnimationFrame(callback);</code><br><code>// Можно отменить через:</code><br><code>cancelAnimationFrame(requestId);</code></p><p><em>Ключевое преимущество:</em> Автоматическая приостановка анимации в неактивных вкладках для экономии ресурсов.</p>",
    difficulty: 'junior',
    tags: ['requestAnimationFrame', 'основы', 'анимации', 'Web API']
  },

  {
    id: 122,
    question: "Какие преимущества имеет requestAnimationFrame по сравнению с setInterval/setTimeout?",
    answer: "<p>requestAnimationFrame (rAF) имеет существенные преимущества над таймерами для анимаций:</p><h4>1. Синхронизация с монитором:</h4><p><strong>rAF:</strong> Автоматически синхронизируется с частотой обновления экрана (обычно 60Hz)</p><p><strong>setInterval:</strong> Может вызываться чаще или реже, чем нужно, создавая рассинхронизацию</p><h4>2. Автоматическая приостановка:</h4><p><strong>rAF:</strong> Останавливается в неактивных вкладках</p><p><strong>setInterval:</strong> Продолжает работать в фоне, тратя ресурсы</p><h4>3. Оптимизация батчинга:</h4><p><strong>rAF:</strong> Все обновления группируются в один repaint</p><p><strong>setInterval:</strong> Может вызывать несколько reflow/repaint</p><h4>4. Точность тайминга:</h4><p><code>// ❌ setInterval - может накапливать задержки</code><br><code>setInterval(() => animate(), 16); // ~60fps</code></p><p><code>// ✅ rAF - всегда синхронизирован</code><br><code>function animate() {</code><br><code>&nbsp;&nbsp;// анимация</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><h4>5. Производительность:</h4><ul><li><strong>CPU:</strong> На 50-80% меньше нагрузки</li><li><strong>Батарея:</strong> Значительно экономнее</li><li><strong>Плавность:</strong> Никаких пропущенных кадров</li></ul><h4>6. API для timestamp:</h4><p>rAF передает высокоточный timestamp в callback, что упрощает создание time-based анимаций.</p><p><em>Вывод:</em> Всегда используйте requestAnimationFrame для визуальных анимаций вместо setInterval/setTimeout.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'производительность', 'сравнение', 'оптимизация']
  },

  {
    id: 123,
    question: "Как работает timestamp в requestAnimationFrame и зачем он нужен?",
    answer: "<p>Callback requestAnimationFrame получает высокоточный timestamp - время в миллисекундах с момента загрузки страницы:</p><h4>Базовое использование:</h4><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;console.log('Current time:', timestamp);</code><br><code>&nbsp;&nbsp;// timestamp ≈ 1234.567890123</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code><br><code></code><br><code>requestAnimationFrame(animate);</code></p><h4>Time-based анимации:</h4><p><code>let startTime = null;</code><br><code>const duration = 2000; // 2 секунды</code></p><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const elapsed = timestamp - startTime;</code><br><code>&nbsp;&nbsp;const progress = Math.min(elapsed / duration, 1);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Перемещение от 0 до 300px за 2 секунды</code><br><code>&nbsp;&nbsp;element.style.left = (progress * 300) + 'px';</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Зачем нужен timestamp:</h4><ul><li><strong>Независимость от FPS:</strong> Анимация одинакова на любой частоте</li><li><strong>Плавность:</strong> Компенсация пропущенных кадров</li><li><strong>Точность:</strong> Высокоточное время (DOMHighResTimeStamp)</li><li><strong>Синхронизация:</strong> Координация множества анимаций</li></ul><h4>Delta time паттерн:</h4><p><code>let lastTime = 0;</code></p><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Скорость независима от FPS</code><br><code>&nbsp;&nbsp;position += velocity * (deltaTime / 1000);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><p><em>Best practice:</em> Всегда используйте timestamp для расчета прогресса анимации вместо подсчета кадров.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'timestamp', 'time-based', 'delta time']
  },

  {
    id: 124,
    question: "Как отменить requestAnimationFrame?",
    answer: "<p>Отмена анимации критична для предотвращения утечек памяти и ненужных вычислений:</p><h4>Базовая отмена:</h4><p><code>let animationId;</code></p><p><code>function animate() {</code><br><code>&nbsp;&nbsp;// Логика анимации</code><br><code>&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>}</code></p><p><code>// Запуск</code><br><code>animationId = requestAnimationFrame(animate);</code></p><p><code>// Остановка</code><br><code>cancelAnimationFrame(animationId);</code></p><h4>Класс для управления анимацией:</h4><p><code>class Animation {</code><br><code>&nbsp;&nbsp;constructor(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animate();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;animate = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback(timestamp);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(this.animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.animationId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(this.animationId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React интеграция:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;let animationId;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function animate() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Логика анимации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;return () => cancelAnimationFrame(animationId);</code><br><code>}, []);</code></p><h4>Условная остановка:</h4><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;// Остановка по условию</code><br><code>&nbsp;&nbsp;if (position >= targetPosition) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return; // Просто не запрашиваем следующий кадр</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;position += velocity;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><p><em>Критично:</em> Всегда отменяйте анимацию при размонтировании компонента для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'cancelAnimationFrame', 'lifecycle', 'cleanup']
  },

  {
    id: 125,
    question: "Как реализовать easing функции с requestAnimationFrame?",
    answer: "<p>Easing функции делают анимации более естественными, изменяя скорость анимации во времени:</p><h4>Базовые easing функции:</h4><p><code>const Easing = {</code><br><code>&nbsp;&nbsp;linear: t => t,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInQuad: t => t * t,</code><br><code>&nbsp;&nbsp;easeOutQuad: t => t * (2 - t),</code><br><code>&nbsp;&nbsp;easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInCubic: t => t * t * t,</code><br><code>&nbsp;&nbsp;easeOutCubic: t => (--t) * t * t + 1,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInOutCubic: t => t < 0.5 </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;? 4 * t * t * t </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1</code><br><code>};</code></p><h4>Использование с анимацией:</h4><p><code>function animateWithEasing(from, to, duration, easingFn) {</code><br><code>&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function animate(timestamp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = timestamp - startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min(elapsed / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем easing</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const easedProgress = easingFn(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Интерполяция значения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const current = from + (to - from) * easedProgress;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.style.left = current + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><p><code>// Использование</code><br><code>animateWithEasing(0, 300, 1000, Easing.easeOutCubic);</code></p><h4>Класс Animator с easing:</h4><p><code>class Animator {</code><br><code>&nbsp;&nbsp;animate(element, property, from, to, duration, easing = 'linear') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const easingFn = Easing[easing];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;function step(timestamp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min((timestamp - startTime) / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const value = from + (to - from) * easingFn(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.style[property] = value + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const animator = new Animator();</code><br><code>animator.animate(element, 'left', 0, 300, 1000, 'easeOutCubic');</code></p><p><em>Совет:</em> Для сложных анимаций используйте готовые библиотеки типа GSAP или anime.js.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'easing', 'анимации', 'интерполяция']
  },

  {
    id: 126,
    question: "Как работает requestAnimationFrame с браузерным циклом событий?",
    answer: "<p>requestAnimationFrame тесно интегрирован с браузерным рендерингом и event loop:</p><h4>Порядок выполнения в event loop:</h4><ol><li>Выполняются синхронные задачи</li><li>Обрабатываются microtasks (Promises, queueMicrotask)</li><li>Выполняются rAF callbacks</li><li>Происходит layout/paint</li><li>Обрабатываются macrotasks (setTimeout, setInterval)</li></ol><h4>Пример порядка:</h4><p><code>console.log('1: sync');</code></p><p><code>setTimeout(() => console.log('2: setTimeout'), 0);</code></p><p><code>Promise.resolve().then(() => console.log('3: Promise'));</code></p><p><code>requestAnimationFrame(() => console.log('4: rAF'));</code></p><p><code>console.log('5: sync');</code></p><p><code>// Вывод:</code><br><code>// 1: sync</code><br><code>// 5: sync</code><br><code>// 3: Promise (microtask)</code><br><code>// 4: rAF (перед paint)</code><br><code>// 2: setTimeout (macrotask)</code></p><h4>Особенности:</h4><ul><li><strong>Timing:</strong> rAF вызывается перед paint, но после microtasks</li><li><strong>Batch:</strong> Все rAF callbacks выполняются за один проход</li><li><strong>Sync:</strong> Внутри rAF синхронное чтение layout данных не вызывает forced reflow</li></ul><h4>Оптимальное чтение/запись:</h4><p><code>// ✅ Правильно - read в rAF, write после</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;const height = element.offsetHeight; // read</code><br><code>&nbsp;&nbsp;element.style.width = height + 'px'; // write - будет в paint</code><br><code>});</code></p><p><code>// ❌ Плохо - read после write = forced reflow</code><br><code>element.style.width = '100px';</code><br><code>const height = element.offsetHeight; // forced reflow!</code></p><p><em>Ключевой момент:</em> rAF выполняется синхронно перед paint, что позволяет группировать все DOM изменения в один repaint.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'event loop', 'рендеринг', 'производительность']
  },

  {
    id: 127,
    question: "Как реализовать throttle анимаций до определенного FPS?",
    answer: "<p>Иногда нужно ограничить частоту анимации до определенного FPS (например, для экономии ресурсов):</p><h4>Throttle до 30 FPS:</h4><p><code>function createThrottledAnimation(fps) {</code><br><code>&nbsp;&nbsp;const interval = 1000 / fps;</code><br><code>&nbsp;&nbsp;let lastTime = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return function animate(timestamp, callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (elapsed > interval) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastTime = timestamp - (elapsed % interval);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(timestamp);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame((t) => animate(t, callback));</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>// Использование для 30 FPS</code><br><code>const animate30fps = createThrottledAnimation(30);</code><br><code></code><br><code>requestAnimationFrame((timestamp) => {</code><br><code>&nbsp;&nbsp;animate30fps(timestamp, (t) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Эта функция вызывается максимум 30 раз в секунду</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;updateAnimation();</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Класс с настраиваемым FPS:</h4><p><code>class ThrottledAnimator {</code><br><code>&nbsp;&nbsp;constructor(fps = 60) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.fps = fps;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.interval = 1000 / fps;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animate = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = timestamp - this.lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (elapsed > this.interval) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = timestamp - (elapsed % this.interval);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(timestamp, elapsed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.animationId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(this.animationId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const animator = new ThrottledAnimator(30);</code><br><code>animator.start((timestamp, deltaTime) => {</code><br><code>&nbsp;&nbsp;updateGame(deltaTime);</code><br><code>});</code></p><h4>Зачем нужно:</h4><ul><li>Экономия CPU на слабых устройствах</li><li>Совместимость со старыми мониторами</li><li>Ограничение нагрузки в фоновых вкладках</li><li>Тестирование на низком FPS</li></ul><p><em>Важно:</em> Используйте остаток времени (elapsed % interval) для точности следующего кадра.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'throttle', 'FPS', 'оптимизация']
  },

  {
    id: 128,
    question: "Как создать игровой цикл с requestAnimationFrame?",
    answer: "<p>Игровой цикл (game loop) — основа любой игры или интерактивной анимации:</p><h4>Базовый игровой цикл:</h4><p><code>class GameLoop {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = 0;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loop();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loop = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const deltaTime = timestamp - this.lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Update логика игры</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.update(deltaTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Render графика</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.render();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(this.loop);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;update(deltaTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Физика, коллизии, AI</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;player.x += player.velocityX * (deltaTime / 1000);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;render() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отрисовка на canvas</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ctx.clearRect(0, 0, canvas.width, canvas.height);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillRect(player.x, player.y, 50, 50);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>С фиксированным временным шагом (fixed timestep):</h4><p><code>class FixedStepGameLoop {</code><br><code>&nbsp;&nbsp;constructor(fps = 60) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.fixedDelta = 1000 / fps;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.accumulator = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = 0;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loop = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const frameTime = timestamp - this.lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.accumulator += frameTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Фиксированные обновления физики</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (this.accumulator >= this.fixedDelta) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.update(this.fixedDelta);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.accumulator -= this.fixedDelta;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Рендер с интерполяцией</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const alpha = this.accumulator / this.fixedDelta;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.render(alpha);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(this.loop);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Применения:</h4><ul><li>2D/3D игры</li><li>Физические симуляции</li><li>Интерактивные визуализации</li><li>Анимированные дашборды</li></ul><p><em>Best practice:</em> Разделяйте update (логику) и render (отрисовку) для чистоты кода и возможности оптимизации.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'game loop', 'игры', 'deltaTime']
  },

  {
    id: 129,
    question: "Как избежать layout thrashing при использовании requestAnimationFrame?",
    answer: "<p>Layout thrashing (принудительный пересчет layout) убивает производительность анимаций:</p><h4>Проблема — чередование read/write:</h4><p><code>// ❌ ПЛОХО - layout thrashing</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;elements.forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const height = el.offsetHeight; // READ - вызывает layout</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;el.style.width = height + 'px'; // WRITE</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// На каждой итерации браузер пересчитывает layout!</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Решение — батчинг read/write:</h4><p><code>// ✅ ХОРОШО - сначала все READ, потом все WRITE</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// READ phase</code><br><code>&nbsp;&nbsp;const heights = elements.map(el => el.offsetHeight);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// WRITE phase</code><br><code>&nbsp;&nbsp;elements.forEach((el, i) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;el.style.width = heights[i] + 'px';</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Класс для управления read/write:</h4><p><code>class LayoutManager {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reads = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.writes = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.scheduled = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;measure(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reads.push(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.schedule();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;mutate(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.writes.push(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.schedule();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;schedule() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.scheduled) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.scheduled = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Выполняем все reads</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reads.forEach(fn => fn());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reads = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Затем все writes</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.writes.forEach(fn => fn());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.writes = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.scheduled = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const layout = new LayoutManager();</code><br><code></code><br><code>// Использование</code><br><code>layout.measure(() => {</code><br><code>&nbsp;&nbsp;height = element.offsetHeight;</code><br><code>});</code><br><code></code><br><code>layout.mutate(() => {</code><br><code>&nbsp;&nbsp;element.style.width = height + 'px';</code><br><code>});</code></p><h4>Операции, вызывающие forced reflow:</h4><ul><li>offsetHeight, offsetWidth, offsetTop</li><li>clientHeight, clientWidth</li><li>scrollHeight, scrollWidth</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p><em>Золотое правило:</em> Группируйте все чтения DOM свойств вместе, затем все записи — в рамках одного requestAnimationFrame.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'layout thrashing', 'производительность', 'reflow']
  },

  {
    id: 130,
    question: "Как работает requestAnimationFrame в неактивных вкладках?",
    answer: "<p>Поведение requestAnimationFrame в фоновых вкладках критично для производительности:</p><h4>Базовое поведение:</h4><ul><li><strong>Активная вкладка:</strong> ~60 FPS (16.67ms между кадрами)</li><li><strong>Фоновая вкладка:</strong> Приостанавливается полностью или throttled до 1-2 FPS</li><li><strong>Минимизированное окно:</strong> Также throttled</li></ul><h4>Обработка фокуса вкладки:</h4><p><code>class AdaptiveAnimator {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isVisible = !document.hidden;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupVisibilityListener();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;setupVisibilityListener() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener('visibilitychange', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.isVisible = !document.hidden;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.isVisible) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.onVisible();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.onHidden();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onVisible() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Возобновить анимацию/игру</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resume();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onHidden() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Приостановить/сохранить состояние</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pause();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Проблемы при возврате на вкладку:</h4><p><code>// ❌ ПРОБЛЕМА - большой deltaTime</code><br><code>let lastTime = performance.now();</code><br><code></code><br><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;// Если вкладка была в фоне 10 секунд,</code><br><code>&nbsp;&nbsp;// deltaTime = 10000ms - персонаж телепортируется!</code><br><code>&nbsp;&nbsp;player.x += velocity * deltaTime;</code><br><code>}</code></p><p><code>// ✅ РЕШЕНИЕ - ограничение deltaTime</code><br><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = Math.min(timestamp - lastTime, 100);</code><br><code>&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;player.x += velocity * deltaTime;</code><br><code>}</code></p><h4>Сброс времени при возврате:</h4><p><code>let lastTime = performance.now();</code><br><code>let wasHidden = false;</code></p><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;// Сброс при возврате на вкладку</code><br><code>&nbsp;&nbsp;if (wasHidden && !document.hidden) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;wasHidden = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;wasHidden = document.hidden;</code><br><code>}</code></p><p><em>Best practice:</em> Всегда ограничивайте максимальный deltaTime и обрабатывайте visibilitychange для корректной работы в фоне.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'visibility', 'фоновые вкладки', 'deltaTime']
  },

  {
    id: 131,
    question: "Как создать систему анимаций с очередью и цепочками?",
    answer: "<p>Система управления последовательными и параллельными анимациями полезна для сложных UI:</p><h4>Базовая очередь анимаций:</h4><p><code>class AnimationQueue {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.queue = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;add(animation) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.queue.push({ animation, resolve });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isRunning) this.run();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async run() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (this.queue.length > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const { animation, resolve } = this.queue.shift();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await animation();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование с цепочками:</h4><p><code>const queue = new AnimationQueue();</code></p><p><code>queue</code><br><code>&nbsp;&nbsp;.add(() => animate(el1, { x: 100 }, 1000))</code><br><code>&nbsp;&nbsp;.then(() => queue.add(() => animate(el2, { y: 100 }, 500)))</code><br><code>&nbsp;&nbsp;.then(() => queue.add(() => animate(el3, { scale: 2 }, 800)));</code></p><h4>Система с параллельными анимациями:</h4><p><code>class AnimationSystem {</code><br><code>&nbsp;&nbsp;sequence(...animations) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return animations.reduce(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(promise, anim) => promise.then(() => anim()),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;parallel(...animations) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return Promise.all(animations.map(anim => anim()));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;animate(element, props, duration) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const startProps = {};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем начальные значения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(props).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startProps[key] = parseFloat(element.style[key]) || 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function step(timestamp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min((timestamp - startTime) / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(props).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const start = startProps[key];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const end = props[key];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.style[key] = (start + (end - start) * progress) + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const anim = new AnimationSystem();</code></p><p><code>// Последовательно</code><br><code>anim.sequence(</code><br><code>&nbsp;&nbsp;() => anim.animate(el1, { left: 100 }, 500),</code><br><code>&nbsp;&nbsp;() => anim.animate(el2, { top: 100 }, 500)</code><br><code>);</code></p><p><code>// Параллельно</code><br><code>anim.parallel(</code><br><code>&nbsp;&nbsp;() => anim.animate(el1, { left: 100 }, 500),</code><br><code>&nbsp;&nbsp;() => anim.animate(el2, { top: 100 }, 500)</code><br><code>);</code></p><p><em>Применение:</em> Сложные UI анимации, онбординг, переходы между экранами.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'очередь', 'цепочки', 'Promise']
  },

  {
    id: 132,
    question: "Как оптимизировать рендеринг большого количества элементов?",
    answer: "<p>При анимации множества элементов критична оптимизация для поддержания 60 FPS:</p><h4>1. Batch DOM операции:</h4><p><code>// ❌ ПЛОХО - множественные reflow</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;particles.forEach(p => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;p.element.style.transform = \`translate(\${p.x}px, \${p.y}px)\`;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>// ✅ ЛУЧШЕ - используйте CSS transform вместо left/top</code><br><code>// ✅ ЕЩЕ ЛУЧШЕ - используйте Canvas вместо DOM</code></p><h4>2. Canvas для множества объектов:</h4><p><code>class ParticleSystem {</code><br><code>&nbsp;&nbsp;constructor(canvas) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ctx = canvas.getContext('2d');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.particles = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;update(deltaTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.particles.forEach(p => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.x += p.vx * deltaTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.y += p.vy * deltaTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;render() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ctx.clearRect(0, 0, canvas.width, canvas.height);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Один draw call для всех частиц одного типа</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.particles.forEach(p => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ctx.fillStyle = p.color;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ctx.fillRect(p.x, p.y, 5, 5);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>3. Виртуализация (рендерить только видимое):</h4><p><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// Рендерим только элементы в viewport</code><br><code>&nbsp;&nbsp;const viewport = getViewport();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;elements.forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (isInViewport(el, viewport)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderElement(el);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>4. Object pooling:</h4><p><code>class ObjectPool {</code><br><code>&nbsp;&nbsp;constructor(createFn, resetFn) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pool = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.createFn = createFn;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resetFn = resetFn;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.pool.pop() || this.createFn();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;release(obj) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resetFn(obj);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pool.push(obj);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>5. requestIdleCallback для неприоритетных задач:</h4><p><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// Критичный рендеринг</code><br><code>&nbsp;&nbsp;renderVisibleElements();</code><br><code>});</code></p><p><code>requestIdleCallback(() => {</code><br><code>&nbsp;&nbsp;// Некритичные обновления в свободное время</code><br><code>&nbsp;&nbsp;updateStats();</code><br><code>});</code></p><p><em>Золотое правило:</em> Если >100 элементов анимируются - используйте Canvas. Если <100 - DOM с CSS transforms.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'оптимизация', 'производительность', 'Canvas']
  },

  {
    id: 133,
    question: "Как создать плавный скролл с requestAnimationFrame?",
    answer: "<p>Плавный скролл улучшает UX и позволяет контролировать скорость анимации:</p><h4>Базовая реализация:</h4><p><code>function smoothScrollTo(targetY, duration = 1000) {</code><br><code>&nbsp;&nbsp;const startY = window.pageYOffset;</code><br><code>&nbsp;&nbsp;const distance = targetY - startY;</code><br><code>&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function animation(currentTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = currentTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = currentTime - startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min(elapsed / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Easing функция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const easeProgress = easeInOutCubic(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;window.scrollTo(0, startY + distance * easeProgress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(animation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animation);</code><br><code>}</code></p><p><code>function easeInOutCubic(t) {</code><br><code>&nbsp;&nbsp;return t < 0.5 </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;? 4 * t * t * t </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;: 1 - Math.pow(-2 * t + 2, 3) / 2;</code><br><code>}</code></p><h4>Скролл к элементу:</h4><p><code>function scrollToElement(element, offset = 0, duration = 1000) {</code><br><code>&nbsp;&nbsp;const targetY = element.getBoundingClientRect().top + </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.pageYOffset + </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;smoothScrollTo(targetY, duration);</code><br><code>}</code></p><p><code>// Использование</code><br><code>const section = document.querySelector('#about');</code><br><code>scrollToElement(section, -100); // -100px от элемента</code></p><h4>С возможностью отмены:</h4><p><code>class SmoothScroller {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;scrollTo(targetY, duration = 1000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий скролл</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cancel();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const startY = window.pageYOffset;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const distance = targetY - startY;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animation = (currentTime) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = currentTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min((currentTime - startTime) / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const eased = this.easeInOutQuad(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.scrollTo(0, startY + distance * eased);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animation);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancel() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.animationId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(this.animationId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInOutQuad(t) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const scroller = new SmoothScroller();</code><br><code>scroller.scrollTo(1000, 800);</code></p><p><em>Альтернатива:</em> Современные браузеры поддерживают <code>element.scrollIntoView({ behavior: 'smooth' })</code>, но с меньшим контролем.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'скролл', 'smooth scroll', 'UX']
  },

  {
    id: 134,
    question: "Какие есть best practices при работе с requestAnimationFrame?",
    answer: "<p>Соблюдение best practices критично для плавных и эффективных анимаций:</p><h4>✅ Best Practices:</h4><p><strong>1. Используйте timestamp для расчетов:</strong></p><p><code>// ✅ Правильно</code><br><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;position += velocity * (deltaTime / 1000);</code><br><code>}</code></p><p><strong>2. Всегда отменяйте при cleanup:</strong></p><p><code>const animationId = requestAnimationFrame(animate);</code><br><code>// При размонтировании:</code><br><code>cancelAnimationFrame(animationId);</code></p><p><strong>3. Разделяйте update и render:</strong></p><p><code>function gameLoop(timestamp) {</code><br><code>&nbsp;&nbsp;update(deltaTime); // Логика</code><br><code>&nbsp;&nbsp;render();          // Отрисовка</code><br><code>}</code></p><p><strong>4. Группируйте DOM чтения и записи:</strong></p><p><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// READ phase</code><br><code>&nbsp;&nbsp;const heights = elements.map(el => el.offsetHeight);</code><br><code>&nbsp;&nbsp;// WRITE phase</code><br><code>&nbsp;&nbsp;elements.forEach((el, i) => el.style.width = heights[i] + 'px');</code><br><code>});</code></p><p><strong>5. Ограничивайте максимальный deltaTime:</strong></p><p><code>const deltaTime = Math.min(timestamp - lastTime, 100);</code></p><p><strong>6. Используйте CSS transforms вместо left/top:</strong></p><p><code>// ✅ GPU ускорение</code><br><code>element.style.transform = \`translate(\${x}px, \${y}px)\`;</code></p><h4>❌ Чего избегать:</h4><ul><li>Не модифицируйте DOM внутри обработчиков событий scroll/resize</li><li>Не создавайте объекты в hot path анимации</li><li>Не забывайте cancelAnimationFrame при удалении</li><li>Не используйте setInterval для анимаций</li><li>Не читайте layout свойства после записи в DOM</li></ul><h4>⚠️ Частые ошибки:</h4><ol><li>Забытый cancelAnimationFrame → утечка памяти</li><li>Layout thrashing → 10-100x медленнее</li><li>Анимация left/top вместо transform → нет GPU</li><li>Создание closure в каждом кадре → garbage collection</li><li>Не учитывать deltaTime → разная скорость на разном FPS</li></ol><p><em>Золотое правило:</em> Измеряйте производительность через Chrome DevTools Performance и держите кадры под 16ms для 60 FPS.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'best practices', 'производительность', 'оптимизация']
  },

  {
    id: 135,
    question: "Как интегрировать requestAnimationFrame с современными фреймворками?",
    answer: "<p>Интеграция requestAnimationFrame с React/Vue требует понимания lifecycle и cleanup:</p><h4>React хук useAnimationFrame:</h4><p><code>function useAnimationFrame(callback) {</code><br><code>&nbsp;&nbsp;const requestRef = useRef();</code><br><code>&nbsp;&nbsp;const previousTimeRef = useRef();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animate = (time) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (previousTimeRef.current !== undefined) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const deltaTime = time - previousTimeRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(deltaTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previousTimeRef.current = time;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => cancelAnimationFrame(requestRef.current);</code><br><code>&nbsp;&nbsp;}, [callback]);</code><br><code>}</code></p><p><code>// Использование</code><br><code>function AnimatedComponent() {</code><br><code>&nbsp;&nbsp;const [count, setCount] = useState(0);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useAnimationFrame((deltaTime) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setCount(prev => prev + deltaTime * 0.01);</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{count.toFixed(2)}&lt;/div&gt;;</code><br><code>}</code></p><h4>Vue 3 Composable:</h4><p><code>import { onMounted, onUnmounted, ref } from 'vue';</code></p><p><code>export function useAnimationFrame(callback) {</code><br><code>&nbsp;&nbsp;let animationId = null;</code><br><code>&nbsp;&nbsp;let previousTime = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const animate = (time) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const deltaTime = time - previousTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;previousTime = time;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;callback(deltaTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onUnmounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (animationId) cancelAnimationFrame(animationId);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>const rotation = ref(0);</code><br><code></code><br><code>useAnimationFrame((deltaTime) => {</code><br><code>&nbsp;&nbsp;rotation.value += deltaTime * 0.1;</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><h4>Контроль запуска/остановки:</h4><p><code>function useControllableAnimation() {</code><br><code>&nbsp;&nbsp;const [isRunning, setIsRunning] = useState(false);</code><br><code>&nbsp;&nbsp;const requestRef = useRef();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animate = (time) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// анимация</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => cancelAnimationFrame(requestRef.current);</code><br><code>&nbsp;&nbsp;}, [isRunning]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { isRunning, setIsRunning };</code><br><code>}</code></p><p><em>Критично:</em> Всегда возвращайте cleanup функцию с cancelAnimationFrame из useEffect/onUnmounted.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'React', 'Vue', 'hooks', 'composables']
  }
];
