export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webAPIInterviewQuestions: InterviewQuestion[] = [
  {
    id: 91,
    question: "Что такое AbortController и для чего он используется?",
    answer: "<p><strong>AbortController</strong> — это Web API для отмены асинхронных операций, таких как Fetch запросы, чтение файлов или другие длительные операции:</p><h4>Основное назначение:</h4><p>Позволяет программно прерывать операции, которые больше не нужны, экономя ресурсы и улучшая производительность.</p><h4>Создание и использование:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code><br><code></code><br><code>fetch('/api/data', { signal })</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code></code><br><code>// Отмена запроса</code><br><code>controller.abort();</code></p><h4>Основные применения:</h4><ul><li><strong>Отмена запросов:</strong> Прерывание Fetch при навигации</li><li><strong>Timeout:</strong> Автоматическая отмена по таймауту</li><li><strong>Debounce поиска:</strong> Отмена предыдущих запросов</li><li><strong>Отмена загрузки:</strong> Прерывание загрузки файлов</li><li><strong>Cleanup:</strong> Отмена операций при размонтировании</li></ul><h4>Основные компоненты:</h4><p><strong>AbortController:</strong> Контроллер для управления отменой</p><p><strong>AbortSignal:</strong> Сигнал, передаваемый в операции</p><p><strong>abort():</strong> Метод для отмены операций</p><p><em>Важно:</em> После вызова abort() signal становится aborted навсегда, нельзя переиспользовать.</p>",
    difficulty: 'junior',
    tags: ['AbortController', 'основы', 'отмена запросов', 'Web API']
  },
  {
    id: 92,
    question: "Как отменить Fetch запрос с помощью AbortController?",
    answer: "<p>AbortController — стандартный способ отмены Fetch запросов:</p><h4>Базовое использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>fetch('https://api.example.com/data', {</code><br><code>&nbsp;&nbsp;signal: controller.signal</code><br><code>})</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.then(data => console.log(data))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос был отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Ошибка:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить запрос</code><br><code>controller.abort();</code></p><h4>С async/await:</h4><p><code>async function fetchWithAbort() {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return data;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отмена по кнопке:</h4><p><code>let currentController;</code></p><p><code>async function loadData() {</code><br><code>&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;if (currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;currentController.abort();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;currentController = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;displayData(data);</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Ошибка загрузки:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// HTML</code><br><code>// &lt;button onclick=\"loadData()\"&gt;Загрузить&lt;/button&gt;</code><br><code>// &lt;button onclick=\"currentController?.abort()\"&gt;Отменить&lt;/button&gt;</code></p><h4>Проверка состояния signal:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code></p><p><code>console.log(signal.aborted); // false</code></p><p><code>controller.abort();</code></p><p><code>console.log(signal.aborted); // true</code></p><p><em>Важно:</em> Всегда проверяйте <code>error.name === 'AbortError'</code> для отличия отмены от реальных ошибок.</p>",
    difficulty: 'junior',
    tags: ['AbortController', 'Fetch', 'отмена запроса', 'базовое использование']
  },
  {
    id: 93,
    question: "Как реализовать timeout для Fetch запроса с помощью AbortController?",
    answer: "<p>AbortController идеален для реализации timeout'ов для Fetch запросов:</p><h4>Базовая реализация:</h4><p><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Автоматическая отмена через timeout</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем таймер при успехе</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Request timeout after \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>try {</code><br><code>&nbsp;&nbsp;const response = await fetchWithTimeout('/api/data', 3000);</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;console.log(data);</code><br><code>} catch (error) {</code><br><code>&nbsp;&nbsp;console.error(error.message); // 'Request timeout after 3000ms'</code><br><code>}</code></p><h4>С использованием AbortSignal.timeout() (современный подход):</h4><p><code>// Chrome 103+, Safari 16+, Firefox 100+</code><br><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: AbortSignal.timeout(timeout)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'TimeoutError' || error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Request timeout after \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Комбинирование нескольких сигналов:</h4><p><code>async function fetchWithTimeoutAndCancel(url, timeout, userController) {</code><br><code>&nbsp;&nbsp;const timeoutController = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => timeoutController.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Слушаем оба сигнала</code><br><code>&nbsp;&nbsp;userController.signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutController.abort();</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: timeoutController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Универсальная обертка:</h4><p><code>class FetchWithTimeout {</code><br><code>&nbsp;&nbsp;constructor(defaultTimeout = 10000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.defaultTimeout = defaultTimeout;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeout = options.timeout || this.defaultTimeout;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Timeout: Request exceeded \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const fetcher = new FetchWithTimeout(5000);</code><br><code>const response = await fetcher.fetch('/api/data', { timeout: 3000 });</code></p><p><em>Best practice:</em> Всегда очищайте timeout через clearTimeout() для избежания утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'timeout', 'Fetch', 'таймауты']
  },
  {
    id: 94,
    question: "Как отменить предыдущие запросы при быстрой печати в поиске (debounce с отменой)?",
    answer: "<p>AbortController позволяет отменять устаревшие поисковые запросы при быстрой печати:</p><h4>Базовая реализация:</h4><p><code>class SearchWithAbort {</code><br><code>&nbsp;&nbsp;constructor(searchCallback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback = searchCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async search(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentController.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем новый контроллер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/search?q=\${query}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback(results);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Search error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование с input:</h4><p><code>const search = new SearchWithAbort((results) => {</code><br><code>&nbsp;&nbsp;displaySearchResults(results);</code><br><code>});</code></p><p><code>const searchInput = document.querySelector('#search');</code><br><code>searchInput.addEventListener('input', (e) => {</code><br><code>&nbsp;&nbsp;search.search(e.target.value);</code><br><code>});</code></p><h4>С debounce:</h4><p><code>class DebouncedSearch {</code><br><code>&nbsp;&nbsp;constructor(searchCallback, delay = 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback = searchCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.debounceTimeout = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;search(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий таймер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.debounceTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentController.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Запускаем с задержкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.debounceTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.performSearch(query);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async performSearch(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/search?q=\${query}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback(results);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Search error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React хук:</h4><p><code>function useSearchWithAbort(searchFn, delay = 300) {</code><br><code>&nbsp;&nbsp;const [results, setResults] = useState([]);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;const timeoutRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const search = useCallback((query) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка предыдущих</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResults([]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutRef.current = setTimeout(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = await searchFn(query, controllerRef.current.signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResults(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;}, [searchFn, delay]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { results, loading, search };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function SearchComponent() {</code><br><code>&nbsp;&nbsp;const { results, loading, search } = useSearchWithAbort(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;async (query, signal) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const res = await fetch(\`/api/search?q=\${query}\`, { signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;input </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={(e) => search(e.target.value)}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder=\"Поиск...\"</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;/&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Преимущество:</em> Экономит bandwidth и ресурсы сервера, отменяя устаревшие запросы.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'поиск', 'debounce', 'оптимизация']
  },
  {
    id: 95,
    question: "Как использовать AbortSignal для прослушивания события отмены?",
    answer: "<p>AbortSignal предоставляет событие 'abort' для реагирования на отмену операций:</p><h4>Базовое прослушивание:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code></p><p><code>signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;console.log('Операция отменена!');</code><br><code>&nbsp;&nbsp;console.log('Причина:', signal.reason);</code><br><code>});</code></p><p><code>controller.abort('Отменено пользователем');</code></p><h4>Проверка состояния:</h4><p><code>const signal = controller.signal;</code></p><p><code>// Проверка до операции</code><br><code>if (signal.aborted) {</code><br><code>&nbsp;&nbsp;console.log('Уже отменено');</code><br><code>&nbsp;&nbsp;return;</code><br><code>}</code></p><p><code>// Реактивная проверка</code><br><code>signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;// Прерывание операции</code><br><code>});</code></p><h4>Использование в асинхронной функции:</h4><p><code>async function processWithAbort(signal) {</code><br><code>&nbsp;&nbsp;// Проверяем в начале</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Already aborted');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Прерываем обработку...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;cleanup();</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Длительная операция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < 1000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Периодическая проверка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Operation aborted');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка слушателя</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Создание Promise с отменой:</h4><p><code>function createAbortablePromise(signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем сразу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Aborted'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Слушаем отмену</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Aborted'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Асинхронная операция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;doAsyncWork()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Передача причины отмены:</h4><p><code>const controller = new AbortController();</code></p><p><code>controller.signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;const reason = controller.signal.reason;</code><br><code>&nbsp;&nbsp;console.log('Причина отмены:', reason);</code><br><code>});</code></p><p><code>// Отмена с причиной</code><br><code>controller.abort('Timeout exceeded');</code><br><code>// или</code><br><code>controller.abort(new Error('User cancelled'));</code></p><h4>Очистка ресурсов при отмене:</h4><p><code>class ResourceManager {</code><br><code>&nbsp;&nbsp;constructor(signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cleanup();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;allocate(resource) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources.push(resource);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cleanup() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Очистка ресурсов...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources.forEach(r => r.dispose());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Всегда удаляйте слушателей abort события для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortSignal', 'события', 'прослушивание', 'cleanup']
  },
  {
    id: 96,
    question: "Как комбинировать несколько AbortSignal (AbortSignal.any)?",
    answer: "<p>Иногда нужно отменить операцию по нескольким условиям — для этого используется <code>AbortSignal.any()</code>:</p><h4>Базовое использование AbortSignal.any():</h4><p><code>const userController = new AbortController();</code><br><code>const timeoutController = new AbortController();</code></p><p><code>// Комбинируем сигналы</code><br><code>const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;userController.signal,</code><br><code>&nbsp;&nbsp;timeoutController.signal</code><br><code>]);</code></p><p><code>fetch('/api/data', { signal: combinedSignal })</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Отменено (пользователем или таймаутом)');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отмена таймаутом через 5 секунд</code><br><code>setTimeout(() => timeoutController.abort(), 5000);</code></p><p><code>// Или пользователем</code><br><code>// userController.abort();</code></p><h4>Практический пример - запрос с таймаутом и ручной отменой:</h4><p><code>async function fetchWithTimeoutAndCancel(url, timeout, userSignal) {</code><br><code>&nbsp;&nbsp;// Создаем сигнал для таймаута</code><br><code>&nbsp;&nbsp;const timeoutSignal = AbortSignal.timeout(timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Комбинируем</code><br><code>&nbsp;&nbsp;const combinedSignal = AbortSignal.any([userSignal, timeoutSignal]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError' || error.name === 'TimeoutError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timeoutSignal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Timeout');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (userSignal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('User cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Polyfill для старых браузеров:</h4><p><code>if (!AbortSignal.any) {</code><br><code>&nbsp;&nbsp;AbortSignal.any = function(signals) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signals.forEach(signal => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort(signal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort(signal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, { once: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return controller.signal;</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><h4>Множественные условия отмены:</h4><p><code>async function complexFetch(url) {</code><br><code>&nbsp;&nbsp;const userController = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutSignal = AbortSignal.timeout(10000);</code><br><code>&nbsp;&nbsp;const networkController = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Отмена при потере сети</code><br><code>&nbsp;&nbsp;window.addEventListener('offline', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;networkController.abort('Network lost');</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;userController.signal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutSignal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;networkController.signal</code><br><code>&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Abort reason:', combinedSignal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React пример:</h4><p><code>function DataLoader() {</code><br><code>&nbsp;&nbsp;const userControllerRef = useRef(new AbortController());</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = userControllerRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отмена при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const loadData = async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userControllerRef.current.signal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbortSignal.timeout(5000)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// ...</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><em>Поддержка:</em> AbortSignal.any() доступен в Chrome 116+, Safari 17+, Firefox 115+. Используйте polyfill для старых браузеров.</p>",
    difficulty: 'senior',
    tags: ['AbortSignal', 'комбинирование', 'AbortSignal.any', 'продвинутое']
  },
  {
    id: 97,
    question: "Как использовать AbortController с XMLHttpRequest?",
    answer: "<p>XMLHttpRequest не поддерживает AbortSignal напрямую, но можно реализовать отмену вручную:</p><h4>Базовая реализация:</h4><p><code>function xhrWithAbort(url, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед запуском</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Слушатель отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(xhr.responseText);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Network error'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('GET', url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send();</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>xhrWithAbort('/api/data', controller.signal)</code><br><code>&nbsp;&nbsp;.then(data => console.log(data))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('XHR request aborted');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отмена</code><br><code>controller.abort();</code></p><h4>С upload progress:</h4><p><code>function uploadWithAbort(url, formData, signal, onProgress) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Upload progress</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onProgress?.(percent);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(xhr.responseText);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Upload failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('POST', url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(formData);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Класс-обертка:</h4><p><code>class XHRWithAbortSignal {</code><br><code>&nbsp;&nbsp;constructor(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.url = url;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.options = options;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async send(signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.onload = () => resolve(this.xhr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.onerror = () => reject(new Error('Network error'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.open(this.options.method || 'GET', this.url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Установка заголовков</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.options.headers) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.entries(this.options.headers).forEach(([key, value]) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.setRequestHeader(key, value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.send(this.options.body);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const controller = new AbortController();</code><br><code>const xhr = new XHRWithAbortSignal('/api/data');</code></p><p><code>xhr.send(controller.signal)</code><br><code>&nbsp;&nbsp;.then(xhr => console.log(xhr.responseText))</code><br><code>&nbsp;&nbsp;.catch(error => console.error(error));</code></p><p><em>Важно:</em> Всегда очищайте слушателей abort события для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'XMLHttpRequest', 'интеграция', 'upload']
  },
  {
    id: 98,
    question: "Как отменить чтение файла с FileReader?",
    answer: "<p>FileReader API не поддерживает AbortSignal напрямую, но можно реализовать отмену:</p><h4>Обертка с AbortController:</h4><p><code>function readFileWithAbort(file, signal, method = 'readAsText') {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const reader = new FileReader();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед началом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызов нужного метода</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader[method](file);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code><br><code>const fileInput = document.querySelector('input[type=\"file\"]');</code></p><p><code>fileInput.addEventListener('change', async (e) => {</code><br><code>&nbsp;&nbsp;const file = e.target.files[0];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const content = await readFileWithAbort(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.signal, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'readAsText'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('File content:', content);</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('File reading cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>// Отмена чтения</code><br><code>cancelButton.onclick = () => controller.abort();</code></p><h4>С прогрессом:</h4><p><code>function readFileWithProgress(file, signal, onProgress) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const reader = new FileReader();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Прогресс чтения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onProgress?.(percent);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.readAsDataURL(file);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Класс FileReaderWithAbort:</h4><p><code>class FileReaderWithAbort {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reader = new FileReader();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;read(file, method, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(this.reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(this.reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onabort = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader[method](file);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsText(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsText', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsDataURL(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsDataURL', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsArrayBuffer(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsArrayBuffer', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const reader = new FileReaderWithAbort();</code><br><code>const controller = new AbortController();</code></p><p><code>reader.readAsText(file, controller.signal)</code><br><code>&nbsp;&nbsp;.then(content => console.log(content))</code><br><code>&nbsp;&nbsp;.catch(err => console.error(err));</code></p><p><em>Применение:</em> Отмена чтения больших файлов, обработка изображений, парсинг CSV/JSON.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'FileReader', 'файлы', 'чтение']
  },
  {
    id: 99,
    question: "Как использовать AbortController в React для отмены запросов при размонтировании?",
    answer: "<p>AbortController критичен для предотвращения утечек памяти и ошибок при размонтировании компонентов:</p><h4>Базовая интеграция с useEffect:</h4><p><code>import { useEffect, useState } from 'react';</code></p><p><code>function DataComponent() {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/data', { signal: controller.signal })</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(setData)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;</code><br><code>}</code></p><h4>Переиспользуемый хук useFetch:</h4><p><code>function useFetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const [error, setError] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(url, { </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(data => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.finally(() => setLoading(false));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, [url]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function App() {</code><br><code>&nbsp;&nbsp;const { data, loading, error } = useFetch('/api/users');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;</code><br><code>&nbsp;&nbsp;if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;</code><br><code>}</code></p><h4>С ручной отменой:</h4><p><code>function useFetchWithManualAbort(url) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controllerRef.current.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, [url]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const cancel = useCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function DataLoader() {</code><br><code>&nbsp;&nbsp;const { data, loading, execute, cancel } = useFetchWithManualAbort('/api/data');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={execute}&gt;Загрузить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cancel}&gt;Отменить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{loading && &lt;div&gt;Loading...&lt;/div&gt;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{data && &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><h4>С зависимостями:</h4><p><code>function UserProfile({ userId }) {</code><br><code>&nbsp;&nbsp;const [user, setUser] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/users/\${userId}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(setUser)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем при изменении userId или размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, [userId]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{user?.name}&lt;/div&gt;;</code><br><code>}</code></p><p><em>Критически важно:</em> Всегда возвращайте cleanup функцию с abort() из useEffect для предотвращения ошибок \"Can't perform a React state update on an unmounted component\".</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'React', 'hooks', 'useEffect']
  },
  {
    id: 100,
    question: "Как использовать AbortController в Vue для отмены запросов?",
    answer: "<p>В Vue 3 AbortController интегрируется через lifecycle hooks и composables:</p><h4>Options API с lifecycle hooks:</h4><p><code>export default {</code><br><code>&nbsp;&nbsp;data() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: null,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller: null</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;mounted() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadData();</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;beforeUnmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем запрос при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controller?.abort();</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;methods: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;async loadData() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Composition API с onBeforeUnmount:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, onMounted, onBeforeUnmount } from 'vue';</code></p><p><code>const data = ref(null);</code><br><code>const controller = ref(null);</code></p><p><code>async function loadData() {</code><br><code>&nbsp;&nbsp;controller.value = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.value.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data.value = await response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>onMounted(() => loadData());</code></p><p><code>onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;controller.value?.abort();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><h4>Переиспользуемый composable useFetch:</h4><p><code>// composables/useFetch.js</code><br><code>import { ref, onBeforeUnmount } from 'vue';</code></p><p><code>export function useFetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;const data = ref(null);</code><br><code>&nbsp;&nbsp;const loading = ref(false);</code><br><code>&nbsp;&nbsp;const error = ref(null);</code><br><code>&nbsp;&nbsp;const controller = ref(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async function execute() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loading.value = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.value = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.value.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.value = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.value = err;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loading.value = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function cancel() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error, execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>import { useFetch } from '@/composables/useFetch';</code></p><p><code>const { data, loading, error, execute, cancel } = useFetch('/api/users');</code><br><code></code><br><code>// Автоматически загрузить при монтировании</code><br><code>onMounted(() => execute());</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click=\"execute\"&gt;Загрузить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click=\"cancel\"&gt;Отменить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-if=\"loading\"&gt;Загрузка...&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-else-if=\"error\"&gt;Ошибка: {{ error.message }}&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-else-if=\"data\"&gt;{{ data }}&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>С watch для реактивных зависимостей:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, watch, onBeforeUnmount } from 'vue';</code></p><p><code>const props = defineProps(['userId']);</code><br><code>const user = ref(null);</code><br><code>let controller = null;</code></p><p><code>async function loadUser(id) {</code><br><code>&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;controller?.abort();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/users/\${id}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;user.value = await response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Загружаем при изменении userId</code><br><code>watch(() => props.userId, (newId) => {</code><br><code>&nbsp;&nbsp;if (newId) loadUser(newId);</code><br><code>}, { immediate: true });</code></p><p><code>onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;controller?.abort();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><em>Best practice:</em> Создавайте переиспользуемые composables для логики с AbortController вместо дублирования кода в каждом компоненте.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'Vue', 'Composition API', 'composables']
  },
  {
    id: 101,
    question: "Как отменить загрузку изображений, скриптов и других ресурсов?",
    answer: "<p>Отмена загрузки ресурсов полезна для оптимизации и экономии трафика:</p><h4>Отмена загрузки изображений:</h4><p><code>function loadImageWithAbort(src, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед началом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const img = new Image();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Прерываем загрузку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.src = '';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(img);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Image load failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.src = src;</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>loadImageWithAbort('/image.jpg', controller.signal)</code><br><code>&nbsp;&nbsp;.then(img => document.body.appendChild(img))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Image loading cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить загрузку</code><br><code>controller.abort();</code></p><h4>Отмена загрузки скриптов:</h4><p><code>function loadScriptWithAbort(src, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const script = document.createElement('script');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.src = src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(script);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Script load failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.head.appendChild(script);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Менеджер загрузки ресурсов:</h4><p><code>class ResourceLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async loadImage(id, src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.set(id, controller);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const img = await loadImageWithAbort(src, controller.signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelLoad(id) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = this.controllers.get(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (controller) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelAll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.forEach(controller => controller.abort());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const loader = new ResourceLoader();</code></p><p><code>loader.loadImage('hero', '/hero.jpg')</code><br><code>&nbsp;&nbsp;.then(img => document.body.appendChild(img));</code></p><p><code>// Отменить конкретную загрузку</code><br><code>loader.cancelLoad('hero');</code></p><p><code>// Или все загрузки</code><br><code>loader.cancelAll();</code></p><p><em>Применение:</em> Карусели изображений, ленивая загрузка, отмена при смене роута, экономия трафика.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'изображения', 'ресурсы', 'загрузка']
  },
  {
    id: 102,
    question: "Какие есть best practices и подводные камни при работе с AbortController?",
    answer: "<p>При работе с AbortController важно следовать лучшим практикам и избегать распространенных ошибок:</p><h4>✅ Best Practices:</h4><p><strong>1. Всегда проверяйте signal.aborted:</strong></p><p><code>async function operation(signal) {</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Already aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Длительная операция...</code><br><code>}</code></p><p><strong>2. Очищайте слушателей событий:</strong></p><p><code>const abortHandler = () => cleanup();</code><br><code>signal.addEventListener('abort', abortHandler);</code><br><code></code><br><code>// В конце</code><br><code>signal.removeEventListener('abort', abortHandler);</code></p><p><strong>3. Используйте { once: true } для автоочистки:</strong></p><p><code>signal.addEventListener('abort', handler, { once: true });</code></p><p><strong>4. Проверяйте error.name === 'AbortError':</strong></p><p><code>catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Это нормальная отмена, не логируем как ошибку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;console.error('Реальная ошибка:', error);</code><br><code>}</code></p><p><strong>5. Создавайте новый контроллер для каждой операции:</strong></p><p><code>// ❌ Плохо - переиспользование</code><br><code>const controller = new AbortController();</code><br><code>controller.abort();</code><br><code>// Нельзя переиспользовать!</code></p><p><code>// ✅ Хорошо - новый контроллер</code><br><code>function makeRequest() {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;return { controller, promise: fetch(url, { signal: controller.signal }) };</code><br><code>}</code></p><p><strong>6. Передавайте причину отмены:</strong></p><p><code>controller.abort('User cancelled');</code><br><code>// или</code><br><code>controller.abort(new Error('Timeout exceeded'));</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Забытые cleanup:</strong></p><p><code>// ❌ Утечка памяти в React</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;// Забыли return cleanup!</code><br><code>}, []);</code></p><p><code>// ✅ Правильно</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;return () => controller.abort();</code><br><code>}, []);</code></p><p><strong>2. Переиспользование AbortSignal:</strong></p><p><code>// ❌ Нельзя переиспользовать</code><br><code>const signal = controller.signal;</code><br><code>controller.abort();</code><br><code>// signal.aborted === true навсегда!</code></p><p><strong>3. Игнорирование AbortError:</strong></p><p><code>// ❌ Плохо - логируем нормальную отмену</code><br><code>catch (error) {</code><br><code>&nbsp;&nbsp;console.error('Error:', error); // Логирует AbortError</code><br><code>}</code></p><p><code>// ✅ Хорошо</code><br><code>catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><strong>4. Забытые слушатели:</strong></p><p><code>// ❌ Слушатель не удален</code><br><code>signal.addEventListener('abort', handler);</code><br><code>// Работает постоянно!</code></p><p><code>// ✅ Используйте once или удаляйте</code><br><code>signal.addEventListener('abort', handler, { once: true });</code></p><p><strong>5. Неправильное использование в циклах:</strong></p><p><code>// ❌ Плохо - все запросы с одним signal</code><br><code>const controller = new AbortController();</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;fetch(item.url, { signal: controller.signal });</code><br><code>});</code><br><code>// abort() отменит ВСЕ запросы</code></p><p><strong>6. Отсутствие обработки в long operations:</strong></p><p><code>// ❌ Плохо - нет проверки abort</code><br><code>async function longOperation(signal) {</code><br><code>&nbsp;&nbsp;for (let i = 0; i < 10000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i); // Нельзя прервать!</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// ✅ Хорошо - периодическая проверка</code><br><code>async function longOperation(signal) {</code><br><code>&nbsp;&nbsp;for (let i = 0; i < 10000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не отменять запросы при размонтировании компонентов</li><li>Переиспользовать уже отмененный контроллер</li><li>Забывать проверять signal.aborted в длительных операциях</li><li>Не обрабатывать AbortError отдельно от других ошибок</li><li>Создавать глобальные контроллеры вместо локальных</li></ol><h4>🎯 Когда НЕ использовать:</h4><ul><li>Для простых синхронных операций</li><li>Когда запрос уже завершился</li><li>Для отмены setTimeout (используйте clearTimeout)</li><li>Для отмены setInterval (используйте clearInterval)</li></ul><p><em>Золотое правило:</em> Создавайте новый AbortController для каждой отменяемой операции, всегда очищайте ресурсы.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'best practices', 'подводные камни', 'ошибки']
  },
  {
    id: 103,
    question: "Как использовать AbortController для отмены нескольких связанных запросов?",
    answer: "<p>Часто нужно отменить группу связанных запросов одновременно:</p><h4>Базовый подход - один контроллер для всех:</h4><p><code>async function loadPageData(pageId) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;const signal = controller.signal;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Параллельные запросы с одним signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const [user, posts, comments] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/users/\${pageId}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/posts?userId=\${pageId}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/comments?userId=\${pageId}\`, { signal })</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: await user.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posts: await posts.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comments: await comments.json()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('All requests cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const controller = new AbortController();</code><br><code>loadPageData(123);</code><br><code></code><br><code>// Отменяет ВСЕ три запроса</code><br><code>controller.abort();</code></p><h4>Менеджер запросов с группировкой:</h4><p><code>class RequestManager {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;createGroup(groupId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.set(groupId, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests: []</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return controller.signal;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(groupId, url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const group = this.groups.get(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!group) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Group \${groupId} not found\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const promise = fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: group.controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;group.requests.push(promise);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return promise;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelGroup(groupId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const group = this.groups.get(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (group) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.groups.delete(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelAll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.forEach((group, groupId) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const manager = new RequestManager();</code></p><p><code>async function loadDashboard() {</code><br><code>&nbsp;&nbsp;const groupId = 'dashboard';</code><br><code>&nbsp;&nbsp;manager.createGroup(groupId);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const [users, stats, activities] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/users'),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/stats'),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/activities')</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return { users, stats, activities };</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Отменить группу запросов</code><br><code>manager.cancelGroup('dashboard');</code></p><h4>Последовательные запросы с общей отменой:</h4><p><code>async function loadWithDependencies(signal) {</code><br><code>&nbsp;&nbsp;// Шаг 1: Загружаем пользователя</code><br><code>&nbsp;&nbsp;const userRes = await fetch('/api/user', { signal });</code><br><code>&nbsp;&nbsp;const user = await userRes.json();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Проверка перед следующим шагом</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Шаг 2: Загружаем данные пользователя</code><br><code>&nbsp;&nbsp;const [posts, followers] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/posts?userId=\${user.id}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/followers?userId=\${user.id}\`, { signal })</code><br><code>&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;user,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;posts: await posts.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;followers: await followers.json()</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><h4>React хук для группы запросов:</h4><p><code>function useGroupedRequests() {</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async (requests) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущую группу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const signal = controllerRef.current.signal;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Выполняем все запросы с одним signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await Promise.all(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests.map(req => fetch(req.url, { ...req.options, signal }))</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Promise.all(results.map(r => r.json()));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const cancel = useCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function Dashboard() {</code><br><code>&nbsp;&nbsp;const { execute, cancel } = useGroupedRequests();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const loadData = async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await execute([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/users' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/stats' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/activities' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка данных</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cancel}&gt;Cancel All&lt;/button&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Применение:</em> Загрузка связанных данных, dashboard с множеством виджетов, отмена при смене роута.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'множественные запросы', 'группировка', 'Promise.all']
  },
  {
    id: 104,
    question: "Как реализовать retry механизм с поддержкой отмены через AbortController?",
    answer: "<p>Комбинирование retry логики с возможностью отмены повышает надежность приложения:</p><h4>Базовая реализация retry с abort:</h4><p><code>async function fetchWithRetry(url, options = {}, retries = 3, signal) {</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= retries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка отмены перед попыткой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Не retry при отмене</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Последняя попытка - выбрасываем ошибку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === retries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exponential backoff</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.pow(2, attempt) * 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${retries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Ожидание с проверкой отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await sleep(delay, signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Функция sleep с поддержкой abort</code><br><code>function sleep(ms, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeout = setTimeout(resolve, ms);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal?.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, { once: true });</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>try {</code><br><code>&nbsp;&nbsp;const response = await fetchWithRetry(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'/api/data',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;3, // 3 попытки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.signal</code><br><code>&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;console.log(data);</code><br><code>} catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Request cancelled during retry');</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('All retries failed:', error);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Отменить в любой момент (даже во время ожидания retry)</code><br><code>controller.abort();</code></p><h4>Класс с конфигурируемым retry:</h4><p><code>class RetryableFetch {</code><br><code>&nbsp;&nbsp;constructor(config = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxRetries = config.maxRetries || 3;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.retryDelay = config.retryDelay || 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.retryOn = config.retryOn || [500, 502, 503, 504];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.backoffMultiplier = config.backoffMultiplier || 2;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(url, options = {}, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let lastError;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let attempt = 0; attempt <= this.maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { ...options, signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Успех</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем, нужен ли retry для этого статуса</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.retryOn.includes(response.status)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response; // Не retry для 4xx ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastError = error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt < this.maxRetries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = this.retryDelay * Math.pow(this.backoffMultiplier, attempt);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${this.maxRetries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await sleep(delay, signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw lastError;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const fetcher = new RetryableFetch({</code><br><code>&nbsp;&nbsp;maxRetries: 5,</code><br><code>&nbsp;&nbsp;retryDelay: 1000,</code><br><code>&nbsp;&nbsp;retryOn: [500, 502, 503, 504],</code><br><code>&nbsp;&nbsp;backoffMultiplier: 2</code><br><code>});</code></p><p><code>const controller = new AbortController();</code></p><p><code>fetcher.fetch('/api/data', {}, controller.signal)</code><br><code>&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;.then(data => console.log(data));</code></p><p><code>// Отменить retry</code><br><code>setTimeout(() => controller.abort(), 5000);</code></p><h4>React хук с retry:</h4><p><code>function useFetchWithRetry(url, options = {}, retries = 3) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const [error, setError] = useState(null);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setError(null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetchWithRetry(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retries,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(err);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, [url, retries]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error, execute };</code><br><code>}</code></p><p><em>Применение:</em> Ненадежные API, временные проблемы с сетью, rate limiting, улучшение UX при проблемах соединения.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'retry', 'надежность', 'error handling']
  },
  {
    id: 105,
    question: "В чем разница между AbortController и другими методами отмены операций?",
    answer: "<p>Существует несколько способов отмены асинхронных операций, каждый со своими особенностями:</p><h4>AbortController (современный стандарт):</h4><p><strong>Преимущества:</strong></p><ul><li>Стандартизированный Web API</li><li>Работает с Fetch, ReadableStream, addEventListener</li><li>Поддержка причины отмены (signal.reason)</li><li>Можно комбинировать сигналы (AbortSignal.any)</li><li>Событие 'abort' для реактивной обработки</li><li>Встроенная поддержка в браузерах</li></ul><p><strong>Недостатки:</strong></p><ul><li>Нельзя переиспользовать после abort()</li><li>Не работает с setTimeout/setInterval напрямую</li><li>Требует ручной интеграции в старых API</li></ul><h4>Promise cancellation паттерны:</h4><p><code>// Старый подход - флаг отмены</code><br><code>let cancelled = false;</code><br><code></code><br><code>async function operation() {</code><br><code>&nbsp;&nbsp;if (cancelled) return;</code><br><code>&nbsp;&nbsp;await step1();</code><br><code>&nbsp;&nbsp;if (cancelled) return;</code><br><code>&nbsp;&nbsp;await step2();</code><br><code>}</code></p><p><strong>Проблемы:</strong></p><ul><li>Нет стандартизации</li><li>Нужно вручную проверять флаг</li><li>Сложно с вложенными операциями</li><li>Нет событий отмены</li></ul><h4>Библиотечные решения (Bluebird, Axios):</h4><p><code>// Bluebird cancellable promises</code><br><code>const promise = new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;// ...</code><br><code>}).cancellable();</code></p><p><code>promise.cancel();</code></p><p><code>// Axios CancelToken (устаревший)</code><br><code>const CancelToken = axios.CancelToken;</code><br><code>const source = CancelToken.source();</code><br><code></code><br><code>axios.get('/api/data', {</code><br><code>&nbsp;&nbsp;cancelToken: source.token</code><br><code>});</code><br><code></code><br><code>source.cancel('Cancelled');</code></p><p><strong>Проблемы:</strong></p><ul><li>Не стандарт, зависимость от библиотеки</li><li>Axios перешел на AbortController</li><li>Разные API в разных библиотеках</li></ul><h4>clearTimeout / clearInterval:</h4><p><code>const timeoutId = setTimeout(callback, 1000);</code><br><code>clearTimeout(timeoutId);</code></p><p><strong>Применение:</strong> Только для таймеров, не для fetch/promises</p><h4>removeEventListener:</h4><p><code>element.addEventListener('click', handler);</code><br><code>element.removeEventListener('click', handler);</code></p><p><strong>Применение:</strong> Только для DOM событий</p><h4>Сравнительная таблица:</h4><table><tr><th>Метод</th><th>Стандарт</th><th>Fetch</th><th>Универсальность</th><th>Причина отмены</th></tr><tr><td>AbortController</td><td>✅ Web API</td><td>✅</td><td>⭐⭐⭐⭐⭐</td><td>✅</td></tr><tr><td>Флаг cancelled</td><td>❌</td><td>❌</td><td>⭐⭐</td><td>❌</td></tr><tr><td>Bluebird</td><td>❌</td><td>❌</td><td>⭐⭐⭐</td><td>✅</td></tr><tr><td>Axios CancelToken</td><td>❌</td><td>N/A</td><td>⭐⭐⭐</td><td>✅</td></tr><tr><td>clearTimeout</td><td>✅</td><td>❌</td><td>⭐</td><td>❌</td></tr></table><h4>Миграция на AbortController:</h4><p><code>// ❌ Старый Axios</code><br><code>const source = axios.CancelToken.source();</code><br><code>axios.get(url, { cancelToken: source.token });</code><br><code>source.cancel();</code></p><p><code>// ✅ Новый Axios с AbortController</code><br><code>const controller = new AbortController();</code><br><code>axios.get(url, { signal: controller.signal });</code><br><code>controller.abort();</code></p><h4>Когда использовать что:</h4><ul><li><strong>AbortController:</strong> Fetch, потоки, современные async операции</li><li><strong>clearTimeout:</strong> Только для setTimeout/setInterval</li><li><strong>removeEventListener:</strong> Только для DOM событий</li><li><strong>Флаги:</strong> Простые внутренние операции (не рекомендуется)</li></ul><p><em>Вывод:</em> AbortController — современный стандарт для отмены асинхронных операций. Мигрируйте с устаревших подходов.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'сравнение', 'альтернативы', 'стандарты']
  },
  {
    id: 106,
    question: "Что такое Web Storage API и какие два типа хранилищ он предоставляет?",
    answer: "<p><strong>Web Storage API</strong> — это механизм для хранения пар ключ-значение в браузере на стороне клиента:</p><h4>Два типа хранилищ:</h4><p><strong>localStorage:</strong> Постоянное хранилище без срока действия. Данные сохраняются даже после закрытия браузера и перезагрузки компьютера.</p><p><strong>sessionStorage:</strong> Временное хранилище на время сессии. Данные удаляются при закрытии вкладки или браузера.</p><h4>Основные характеристики:</h4><ul><li>Синхронный API</li><li>Хранение только строк</li><li>Ограничение ~5-10 МБ на домен</li><li>Доступ только с того же origin</li><li>Не отправляются на сервер автоматически</li></ul><p><em>Ключевое отличие от cookies:</em> Web Storage не отправляется с каждым HTTP-запросом, что экономит bandwidth.</p>",
    difficulty: 'junior',
    tags: ['Web Storage', 'localStorage', 'sessionStorage', 'основы']
  },
  {
    id: 107,
    question: "В чем разница между localStorage и sessionStorage?",
    answer: "<p>localStorage и sessionStorage имеют одинаковый API, но разную область видимости и время жизни:</p><h4>localStorage:</h4><ul><li><strong>Время жизни:</strong> Постоянное, до явного удаления</li><li><strong>Область:</strong> Общий для всех вкладок и окон одного origin</li><li><strong>Сохранение:</strong> Остается после закрытия браузера</li><li><strong>Удаление:</strong> Только программно или через настройки браузера</li></ul><h4>sessionStorage:</h4><ul><li><strong>Время жизни:</strong> До закрытия вкладки/окна</li><li><strong>Область:</strong> Уникальный для каждой вкладки</li><li><strong>Сохранение:</strong> Удаляется при закрытии вкладки</li><li><strong>Удаление:</strong> Автоматически при закрытии</li></ul><h4>Когда использовать:</h4><p><strong>localStorage:</strong> Настройки темы, язык интерфейса, токены, preferences, кэш данных</p><p><strong>sessionStorage:</strong> Данные формы, состояние wizard'а, временные фильтры, одноразовые данные</p><p><em>Важно:</em> Даже дублирование вкладки (Ctrl+Shift+T) создает новый sessionStorage.</p>",
    difficulty: 'junior',
    tags: ['localStorage', 'sessionStorage', 'различия', 'область видимости']
  },
  {
    id: 108,
    question: "Какие типы данных можно сохранять в localStorage/sessionStorage?",
    answer: "<p>Web Storage может хранить <strong>только строки</strong>. Все остальные типы нужно преобразовывать:</p><h4>Строки — напрямую:</h4><p><code>localStorage.setItem('name', 'John');</code></p><h4>Числа — преобразуются в строку:</h4><p><code>localStorage.setItem('age', 25); // Сохранится как '25'</code><br><code>const age = Number(localStorage.getItem('age')); // Обратно в число</code></p><h4>Булевы значения — преобразуются в строку:</h4><p><code>localStorage.setItem('isActive', true); // Сохранится как 'true'</code><br><code>const isActive = localStorage.getItem('isActive') === 'true';</code></p><h4>Объекты и массивы — через JSON:</h4><p><code>const user = { name: 'John', age: 25 };</code><br><code>localStorage.setItem('user', JSON.stringify(user));</code><br><code></code><br><code>const savedUser = JSON.parse(localStorage.getItem('user'));</code></p><h4>Date — преобразование через ISO:</h4><p><code>const date = new Date();</code><br><code>localStorage.setItem('date', date.toISOString());</code><br><code></code><br><code>const savedDate = new Date(localStorage.getItem('date'));</code></p><h4>Что нельзя сохранить:</h4><ul><li>Функции (потеряются при JSON.stringify)</li><li>Symbol (не сериализуются)</li><li>undefined (превратится в строку 'undefined')</li><li>Циклические ссылки (ошибка при stringify)</li></ul><p><em>Best practice:</em> Всегда оборачивайте JSON.parse в try-catch для обработки невалидных данных.</p>",
    difficulty: 'junior',
    tags: ['localStorage', 'типы данных', 'JSON', 'сериализация']
  },
  {
    id: 109,
    question: "Как проверить доступность и размер Web Storage?",
    answer: "<p>Важно проверять доступность и ограничения Storage перед использованием:</p><h4>Проверка поддержки:</h4><p><code>function isStorageAvailable(type) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const storage = window[type];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const test = '__storage_test__';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;storage.setItem(test, test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;storage.removeItem(test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>if (isStorageAvailable('localStorage')) {</code><br><code>&nbsp;&nbsp;// Можно использовать</code><br><code>}</code></p><h4>Определение размера хранилища:</h4><p><code>function getStorageSize() {</code><br><code>&nbsp;&nbsp;let total = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;for (let key in localStorage) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (localStorage.hasOwnProperty(key)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total += localStorage[key].length + key.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (total / 1024).toFixed(2) + ' KB';</code><br><code>}</code></p><h4>Проверка лимита:</h4><p><code>function getStorageLimit() {</code><br><code>&nbsp;&nbsp;let max = 0;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const test = '0'.repeat(1024); // 1KB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let i = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (i < 10000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem('test' + i, test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;max = i;</code><br><code>&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let j = 0; j < i; j++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem('test' + j);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return max + ' KB примерно';</code><br><code>}</code></p><h4>Причины недоступности:</h4><ul><li>Режим приватного просмотра (некоторые браузеры)</li><li>Пользователь отключил Storage в настройках</li><li>Хранилище переполнено (QuotaExceededError)</li><li>Старые браузеры без поддержки</li></ul><p><em>Типичный лимит:</em> 5MB для localStorage и sessionStorage в большинстве браузеров.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'проверка доступности', 'размер', 'ограничения']
  },
  {
    id: 110,
    question: "Как обрабатывать ошибку QuotaExceededError при переполнении Storage?",
    answer: "<p>QuotaExceededError возникает когда Storage переполнен. Важно правильно обрабатывать эту ошибку:</p><h4>Базовая обработка:</h4><p><code>function safeSetItem(key, value) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Storage full');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw e;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Автоматическая очистка старых данных:</h4><p><code>function setItemWithExpiry(key, value, ttl) {</code><br><code>&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;value: value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttl</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Очищаем истекшие элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanupExpired();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Пробуем снова</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e2) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Storage still full');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>function cleanupExpired() {</code><br><code>&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.expiry && item.expiry < now) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Невалидные данные - можно удалить</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>LRU (Least Recently Used) стратегия:</h4><p><code>class LRUStorage {</code><br><code>&nbsp;&nbsp;set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastUsed: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeLeastRecentlyUsed();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;removeLeastRecentlyUsed() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let oldestKey = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let oldestTime = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.lastUsed < oldestTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldestTime = item.lastUsed;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldestKey = key;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (oldestKey) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(oldestKey);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Всегда оборачивайте setItem в try-catch и имейте стратегию очистки.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'QuotaExceededError', 'обработка ошибок', 'очистка']
  },
  {
    id: 111,
    question: "Как работать с событием storage для синхронизации между вкладками?",
    answer: "<p>Событие <code>storage</code> позволяет синхронизировать данные между вкладками одного origin:</p><h4>Базовое использование:</h4><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;console.log('Key:', e.key);</code><br><code>&nbsp;&nbsp;console.log('Old value:', e.oldValue);</code><br><code>&nbsp;&nbsp;console.log('New value:', e.newValue);</code><br><code>&nbsp;&nbsp;console.log('URL:', e.url);</code><br><code>&nbsp;&nbsp;console.log('Storage:', e.storageArea);</code><br><code>});</code></p><h4>Важные особенности:</h4><ul><li>Срабатывает ТОЛЬКО в других вкладках, не в той где произошло изменение</li><li>Работает только для localStorage, не для sessionStorage</li><li>e.key === null при вызове clear()</li><li>e.oldValue и e.newValue всегда строки</li></ul><h4>Синхронизация темы между вкладками:</h4><p><code>// Во вкладке 1</code><br><code>function setTheme(theme) {</code><br><code>&nbsp;&nbsp;localStorage.setItem('theme', theme);</code><br><code>&nbsp;&nbsp;applyTheme(theme);</code><br><code>}</code></p><p><code>// Во вкладке 2 - автообновление</code><br><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'theme' && e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;applyTheme(e.newValue);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Синхронизация состояния аутентификации:</h4><p><code>// Logout во всех вкладках</code><br><code>function logout() {</code><br><code>&nbsp;&nbsp;localStorage.removeItem('token');</code><br><code>&nbsp;&nbsp;redirectToLogin();</code><br><code>}</code></p><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'token' && !e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Токен удален в другой вкладке</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;redirectToLogin();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Broadcast сообщений между вкладками:</h4><p><code>function broadcastMessage(type, data) {</code><br><code>&nbsp;&nbsp;const message = { type, data, timestamp: Date.now() };</code><br><code>&nbsp;&nbsp;localStorage.setItem('broadcast', JSON.stringify(message));</code><br><code>&nbsp;&nbsp;localStorage.removeItem('broadcast'); // Триггер события</code><br><code>}</code></p><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'broadcast' && e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(e.newValue);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;handleMessage(message);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><em>Альтернатива:</em> Для более надежной коммуникации используйте BroadcastChannel API.</p>",
    difficulty: 'middle',
    tags: ['storage event', 'синхронизация', 'вкладки', 'коммуникация']
  },
  {
    id: 112,
    question: "Как реализовать хранение данных с TTL (временем жизни)?",
    answer: "<p>TTL (Time To Live) позволяет автоматически удалять устаревшие данные:</p><h4>Базовая реализация:</h4><p><code>const StorageWithTTL = {</code><br><code>&nbsp;&nbsp;set(key, value, ttlMinutes) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttlMinutes * 60 * 1000</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemStr = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!itemStr) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(itemStr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка истечения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (Date.now() > item.expiry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return item.value;</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>// Сохранить на 30 минут</code><br><code>StorageWithTTL.set('sessionData', userData, 30);</code></p><p><code>// Получить (вернет null если истекло)</code><br><code>const data = StorageWithTTL.get('sessionData');</code></p><h4>Класс с автоочисткой:</h4><p><code>class CacheStorage {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cleanup(); // Очистка при инициализации</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, value, ttlSeconds = 3600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttlSeconds * 1000</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemStr = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!itemStr) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(itemStr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Date.now() > item.expiry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;remove(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cleanup() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.expiry && item.expiry < now) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Игнорируем невалидные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Запускайте cleanup() при инициализации приложения для удаления истекших данных.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'TTL', 'кэширование', 'expiry']
  },
  {
    id: 113,
    question: "В чем разница между Web Storage и Cookies?",
    answer: "<p>Web Storage и Cookies решают похожие задачи, но имеют существенные различия:</p><h4>Web Storage (localStorage/sessionStorage):</h4><ul><li><strong>Размер:</strong> ~5-10 МБ</li><li><strong>Отправка на сервер:</strong> Никогда, только клиентская сторона</li><li><strong>API:</strong> Простой и синхронный</li><li><strong>Доступ:</strong> Только JavaScript</li><li><strong>Срок жизни:</strong> localStorage - постоянно, sessionStorage - до закрытия вкладки</li></ul><h4>Cookies:</h4><ul><li><strong>Размер:</strong> ~4 КБ</li><li><strong>Отправка на сервер:</strong> С каждым HTTP-запросом</li><li><strong>API:</strong> Строка document.cookie, неудобный</li><li><strong>Доступ:</strong> JavaScript и сервер</li><li><strong>Срок жизни:</strong> Настраивается через expires/max-age</li><li><strong>Безопасность:</strong> HttpOnly, Secure, SameSite флаги</li></ul><h4>Когда использовать:</h4><p><strong>Web Storage:</strong></p><ul><li>Настройки UI (тема, язык)</li><li>Кэширование данных</li><li>Временное состояние приложения</li><li>Большие объемы данных</li></ul><p><strong>Cookies:</strong></p><ul><li>Аутентификация (токены)</li><li>Сессии на сервере</li><li>Tracking и аналитика</li><li>Данные, нужные серверу</li></ul><h4>Производительность:</h4><p>Web Storage не увеличивает размер HTTP-запросов, в отличие от cookies которые отправляются с каждым запросом.</p><p><em>Вывод:</em> Используйте Web Storage для клиентских данных, cookies - для серверной коммуникации.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'Cookies', 'сравнение', 'различия']
  },
  {
    id: 114,
    question: "Какие существуют best practices при работе с Web Storage?",
    answer: "<p>Следование best practices критично для безопасности и производительности:</p><h4>1. Всегда оборачивайте в try-catch:</h4><p><code>try {</code><br><code>&nbsp;&nbsp;localStorage.setItem('key', 'value');</code><br><code>} catch (e) {</code><br><code>&nbsp;&nbsp;// QuotaExceededError или другие ошибки</code><br><code>}</code></p><h4>2. Проверяйте доступность:</h4><p><code>if (typeof Storage !== 'undefined') {</code><br><code>&nbsp;&nbsp;// Storage доступен</code><br><code>}</code></p><h4>3. Не храните чувствительные данные:</h4><p>❌ НЕ хранить: пароли, номера карт, SSN, приватные ключи</p><p>✅ Можно: публичные настройки, кэш, UI состояние</p><h4>4. Используйте префиксы для ключей:</h4><p><code>const APP_PREFIX = 'myapp_';</code><br><code>localStorage.setItem(APP_PREFIX + 'theme', 'dark');</code></p><h4>5. Валидируйте данные при чтении:</h4><p><code>function safeGetItem(key) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return item ? JSON.parse(item) : null;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key); // Удаляем невалидные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Ограничивайте размер данных:</h4><p><code>function setItemIfFits(key, value) {</code><br><code>&nbsp;&nbsp;const str = JSON.stringify(value);</code><br><code>&nbsp;&nbsp;if (str.length > 1024 * 1024) { // > 1MB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Data too large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;localStorage.setItem(key, str);</code><br><code>}</code></p><h4>7. Очищайте старые данные:</h4><p><code>// При инициализации приложения</code><br><code>function cleanupOldData() {</code><br><code>&nbsp;&nbsp;const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;</code><br><code>&nbsp;&nbsp;// Логика очистки...</code><br><code>}</code></p><h4>8. Используйте namespace:</h4><p><code>const storage = {</code><br><code>&nbsp;&nbsp;prefix: 'myapp_',</code><br><code>&nbsp;&nbsp;set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(this.prefix + key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(localStorage.getItem(this.prefix + key));</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>9. Минимизируйте частоту записи:</h4><p>Используйте debounce для частых обновлений, так как Storage операции синхронные.</p><h4>10. Документируйте структуру данных:</h4><p>Ведите документацию какие ключи используются и их формат.</p><p><em>Критично:</em> Storage доступен любому JavaScript на странице - не храните секреты!</p>",
    difficulty: 'senior',
    tags: ['Web Storage', 'best practices', 'безопасность', 'производительность']
  },
  {
    id: 115,
    question: "Какие существуют альтернативы Web Storage для хранения данных?",
    answer: "<p>Существует несколько альтернатив Web Storage для разных сценариев:</p><h4>1. IndexedDB:</h4><p><strong>Когда использовать:</strong> Большие объемы структурированных данных (>10MB), офлайн приложения</p><p><strong>Преимущества:</strong></p><ul><li>Практически неограниченный размер</li><li>Асинхронный API</li><li>Поддержка индексов и транзакций</li><li>Хранение объектов без сериализации</li></ul><p><strong>Недостатки:</strong> Сложный API</p><h4>2. Cache API:</h4><p><strong>Когда использовать:</strong> Кэширование HTTP-запросов, офлайн PWA</p><p><strong>Преимущества:</strong></p><ul><li>Оптимизирован для Response объектов</li><li>Работает с Service Workers</li><li>Большой размер</li></ul><h4>3. Cookies:</h4><p><strong>Когда использовать:</strong> Аутентификация, данные для сервера</p><p><strong>Преимущества:</strong></p><ul><li>Автоматическая отправка на сервер</li><li>HttpOnly для безопасности</li><li>Контроль срока жизни</li></ul><p><strong>Недостатки:</strong> Маленький размер (4KB)</p><h4>4. File System Access API:</h4><p><strong>Когда использовать:</strong> Работа с файловой системой, редакторы</p><p><strong>Преимущества:</strong> Доступ к реальным файлам пользователя</p><h4>5. WebSQL (устаревший):</h4><p><strong>Статус:</strong> Deprecated, не использовать</p><h4>6. Memory (переменные):</h4><p><strong>Когда использовать:</strong> Временные данные в рамках сессии</p><p><strong>Недостатки:</strong> Теряется при перезагрузке страницы</p><h4>Сравнительная таблица:</h4><table><tr><th>Технология</th><th>Размер</th><th>Асинхронность</th><th>Сложность</th></tr><tr><td>localStorage</td><td>~5MB</td><td>❌</td><td>⭐</td></tr><tr><td>IndexedDB</td><td>Большой</td><td>✅</td><td>⭐⭐⭐⭐</td></tr><tr><td>Cache API</td><td>Большой</td><td>✅</td><td>⭐⭐⭐</td></tr><tr><td>Cookies</td><td>4KB</td><td>❌</td><td>⭐⭐</td></tr></table><p><em>Выбор зависит:</em> от размера данных, нужны ли они серверу, требуется ли офлайн доступ.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'альтернативы', 'IndexedDB', 'Cache API']
  },
  {
    id: 116,
    question: "Как безопасно хранить токены аутентификации?",
    answer: "<p>Хранение токенов — критический вопрос безопасности приложения:</p><h4>Варианты хранения:</h4><p><strong>1. HttpOnly Cookies (РЕКОМЕНДУЕТСЯ):</strong></p><p>✅ Преимущества:</p><ul><li>Недоступны для JavaScript (защита от XSS)</li><li>Автоматически отправляются на сервер</li><li>Secure флаг для HTTPS only</li><li>SameSite защита от CSRF</li></ul><p>❌ Недостатки: Нужна настройка на сервере</p><p><strong>2. localStorage (НЕ РЕКОМЕНДУЕТСЯ):</strong></p><p>❌ Проблемы:</p><ul><li>Доступен любому JavaScript (уязвим к XSS)</li><li>Нет защиты от кражи токена</li><li>Постоянное хранение</li></ul><p>✅ Когда можно: SPA без серверного рендеринга, краткосрочные токены</p><p><strong>3. sessionStorage (КОМПРОМИСС):</strong></p><p>Чуть безопаснее localStorage, так как удаляется при закрытии вкладки, но все еще уязвим к XSS.</p><p><strong>4. Memory (в переменной):</strong></p><p>✅ Самое безопасное для клиента</p><p>❌ Теряется при перезагрузке страницы</p><h4>Best practices:</h4><p><code>// ❌ ПЛОХО - токен в localStorage</code><br><code>localStorage.setItem('token', token);</code></p><p><code>// ✅ ЛУЧШЕ - HttpOnly cookie (настраивается на сервере)</code><br><code>// Set-Cookie: token=xxx; HttpOnly; Secure; SameSite=Strict</code></p><p><code>// ✅ КОМПРОМИСС - короткоживущие токены</code><br><code>sessionStorage.setItem('token', token);</code><br><code>// + Refresh token в HttpOnly cookie</code></p><h4>Дополнительные меры безопасности:</h4><ul><li>Используйте короткие сроки жизни токенов</li><li>Implement token rotation</li><li>Проверяйте fingerprint браузера</li><li>Логируйте подозрительную активность</li><li>CSP заголовки для защиты от XSS</li></ul><p><em>Золотое правило:</em> Если возможно - используйте HttpOnly cookies. Если нет - sessionStorage с короткими токенами и refresh механизмом.</p>",
    difficulty: 'senior',
    tags: ['безопасность', 'токены', 'аутентификация', 'XSS']
  },
  {
    id: 117,
    question: "Как реализовать версионирование данных в Storage?",
    answer: "<p>Версионирование помогает избежать проблем при изменении структуры данных:</p><h4>Базовая схема версионирования:</h4><p><code>const STORAGE_VERSION = 2;</code></p><p><code>function saveData(key, data) {</code><br><code>&nbsp;&nbsp;const versioned = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;version: STORAGE_VERSION,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data: data</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(versioned));</code><br><code>}</code></p><p><code>function loadData(key) {</code><br><code>&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const parsed = JSON.parse(item);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Проверка версии</code><br><code>&nbsp;&nbsp;if (parsed.version !== STORAGE_VERSION) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return migrateData(parsed, key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return parsed.data;</code><br><code>}</code></p><h4>Миграция между версиями:</h4><p><code>function migrateData(oldData, key) {</code><br><code>&nbsp;&nbsp;const version = oldData.version || 1;</code><br><code>&nbsp;&nbsp;let data = oldData.data;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Миграция с версии 1 на 2</code><br><code>&nbsp;&nbsp;if (version === 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...data,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newField: 'defaultValue'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Сохраняем обновленные данные</code><br><code>&nbsp;&nbsp;saveData(key, data);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return data;</code><br><code>}</code></p><h4>Класс с автомиграцией:</h4><p><code>class VersionedStorage {</code><br><code>&nbsp;&nbsp;constructor(version, migrations = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.version = version;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.migrations = migrations;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version: this.version,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let parsed = JSON.parse(item);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemVersion = parsed.version || 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем все необходимые миграции</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let v = itemVersion; v < this.version; v++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const migration = this.migrations[v];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (migration) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsed.data = migration(parsed.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем мигрированные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (itemVersion < this.version) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.set(key, parsed.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return parsed.data;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const storage = new VersionedStorage(3, {</code><br><code>&nbsp;&nbsp;1: (data) => ({ ...data, newField: 'default' }),</code><br><code>&nbsp;&nbsp;2: (data) => ({ ...data, renamedField: data.oldField })</code><br><code>});</code></p><p><code>storage.set('userData', { name: 'John' });</code><br><code>const data = storage.get('userData'); // Автоматическая миграция</code></p><p><em>Best practice:</em> Всегда тестируйте миграции и сохраняйте backup перед применением.</p>",
    difficulty: 'senior',
    tags: ['версионирование', 'миграция', 'данные', 'архитектура']
  },
  {
    id: 118,
    question: "Как отладить проблемы с Web Storage в DevTools?",
    answer: "<p>Chrome DevTools предоставляют мощные инструменты для работы с Storage:</p><h4>Application Tab → Storage:</h4><p><strong>Просмотр данных:</strong></p><ul><li>Application → Local Storage / Session Storage</li><li>Видны все ключи и значения</li><li>Можно редактировать значения напрямую</li><li>Показывает размер каждого элемента</li></ul><p><strong>Очистка данных:</strong></p><ul><li>ПКМ на домене → Clear</li><li>Или кнопка «Clear All» для всего Storage</li></ul><h4>Console методы:</h4><p><code>// Просмотр всех ключей</code><br><code>console.table(localStorage);</code></p><p><code>// Размер Storage</code><br><code>let size = 0;</code><br><code>for (let key in localStorage) {</code><br><code>&nbsp;&nbsp;size += localStorage[key].length + key.length;</code><br><code>}</code><br><code>console.log(size / 1024 + ' KB');</code></p><p><code>// Поиск по ключам</code><br><code>Object.keys(localStorage).filter(key => key.includes('user'));</code></p><h4>Мониторинг изменений:</h4><p><code>// Перехват setItem</code><br><code>const originalSetItem = localStorage.setItem;</code><br><code>localStorage.setItem = function(key, value) {</code><br><code>&nbsp;&nbsp;console.log('Storage set:', key, value);</code><br><code>&nbsp;&nbsp;originalSetItem.apply(this, arguments);</code><br><code>};</code></p><h4>Breakpoints на Storage:</h4><ul><li>Sources → Event Listener Breakpoints</li><li>Выбрать «storage» для отслеживания изменений</li></ul><h4>Network Tab:</h4><p>Проверяйте размер cookies в заголовках запросов - иногда проблемы с Storage связаны с переполнением cookies.</p><h4>Частые проблемы и решения:</h4><p><strong>1. QuotaExceededError:</strong> Проверьте размер данных, очистите старые</p><p><strong>2. Данные не сохраняются:</strong> Проверьте режим инкогнито, настройки браузера</p><p><strong>3. Данные пропадают:</strong> Проверьте sessionStorage vs localStorage</p><p><strong>4. JSON.parse ошибка:</strong> Валидация данных перед парсингом</p><p><em>Совет:</em> Используйте console.table() для удобного просмотра всех данных Storage.</p>",
    difficulty: 'middle',
    tags: ['отладка', 'DevTools', 'Chrome', 'debugging']
  },
  {
    id: 119,
    question: "Как реализовать Storage с сжатием данных?",
    answer: "<p>Сжатие позволяет обойти ограничение размера Storage:</p><h4>Использование LZ-based алгоритмов:</h4><p><code>// Используем библиотеку lz-string</code><br><code>import LZString from 'lz-string';</code></p><p><code>const CompressedStorage = {</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, compressed);</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!compressed) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = LZString.decompress(compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(json);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Класс с автоматическим сжатием:</h4><p><code>class SmartStorage {</code><br><code>&nbsp;&nbsp;constructor(compressionThreshold = 1024) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.threshold = compressionThreshold;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сжимаем только если больше порога</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (json.length > this.threshold) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, 'compressed:' + compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем префикс сжатия</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (item.startsWith('compressed:')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const compressed = item.slice(11);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = LZString.decompress(compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(item);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Статистика сжатия:</h4><p><code>function compressionStats(data) {</code><br><code>&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const original = json.length;</code><br><code>&nbsp;&nbsp;const compressed = compressed.length;</code><br><code>&nbsp;&nbsp;const ratio = ((1 - compressed / original) * 100).toFixed(2);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;console.log(\`Original: \${original} bytes\`);</code><br><code>&nbsp;&nbsp;console.log(\`Compressed: \${compressed} bytes\`);</code><br><code>&nbsp;&nbsp;console.log(\`Saved: \${ratio}%\`);</code><br><code>}</code></p><h4>Преимущества:</h4><ul><li>Можно сохранить в 2-10 раз больше данных</li><li>Особенно эффективно для текста и JSON</li><li>Прозрачно для остального кода</li></ul><h4>Недостатки:</h4><ul><li>Дополнительное время на сжатие/распаковку</li><li>Нужна внешняя библиотека</li><li>Не все данные хорошо сжимаются</li></ul><p><em>Best practice:</em> Сжимайте только большие объекты (>1KB) для оптимального баланса производительности.</p>",
    difficulty: 'senior',
    tags: ['сжатие', 'оптимизация', 'производительность', 'размер']
  },
  {
    id: 120,
    question: "Как имитировать асинхронный API для Storage?",
    answer: "<p>Web Storage синхронен, но иногда нужен асинхронный API для консистентности с другими Storage API:</p><h4>Promise-based обертка:</h4><p><code>const AsyncStorage = {</code><br><code>&nbsp;&nbsp;async getItem(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const value = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(value ? JSON.parse(value) : null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async setItem(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(e);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async removeItem(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>// Асинхронный стиль</code><br><code>await AsyncStorage.setItem('user', { name: 'John' });</code><br><code>const user = await AsyncStorage.getItem('user');</code></p><h4>Универсальный адаптер:</h4><p><code>class StorageAdapter {</code><br><code>&nbsp;&nbsp;constructor(storage = localStorage) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage = storage;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = this.storage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item ? JSON.parse(item) : null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.setItem(key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async delete(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.removeItem(key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async clear() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async keys() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return Object.keys(this.storage);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Зачем нужен асинхронный API:</h4><ul><li>Консистентность с IndexedDB и Cache API</li><li>Возможность будущей замены на асинхронное хранилище</li><li>Упрощение тестирования с моками</li><li>Единообразный код</li></ul><h4>Полифилл для React Native AsyncStorage:</h4><p><code>const AsyncStorage = {</code><br><code>&nbsp;&nbsp;getItem: (key) => Promise.resolve(localStorage.getItem(key)),</code><br><code>&nbsp;&nbsp;setItem: (key, value) => Promise.resolve(localStorage.setItem(key, value)),</code><br><code>&nbsp;&nbsp;removeItem: (key) => Promise.resolve(localStorage.removeItem(key)),</code><br><code>&nbsp;&nbsp;clear: () => Promise.resolve(localStorage.clear())</code><br><code>};</code></p><p><em>Применение:</em> Облегчает миграцию кода между web и React Native, создает единый API.</p>",
    difficulty: 'middle',
    tags: ['асинхронность', 'Promise', 'адаптер', 'API']
  },
  {
    id: 121,
    question: "Что такое requestAnimationFrame и для чего он используется?",
    answer: "<p><strong>requestAnimationFrame</strong> — это Web API для создания плавных анимаций, синхронизированных с частотой обновления экрана:</p><h4>Основное назначение:</h4><p>Позволяет браузеру оптимизировать анимации, вызывая callback перед следующей перерисовкой экрана, обычно 60 раз в секунду (60 FPS).</p><h4>Базовое использование:</h4><p><code>function animate() {</code><br><code>&nbsp;&nbsp;// Логика анимации</code><br><code>&nbsp;&nbsp;element.style.left = position + 'px';</code><br><code>&nbsp;&nbsp;position += 1;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Запрос следующего кадра</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code><br><code></code><br><code>// Запуск анимации</code><br><code>requestAnimationFrame(animate);</code></p><h4>Основные применения:</h4><ul><li><strong>Анимации элементов:</strong> Плавное перемещение, изменение размера</li><li><strong>Canvas/WebGL:</strong> Рендеринг графики</li><li><strong>Игры:</strong> Игровой цикл</li><li><strong>Параллакс эффекты:</strong> Скролл-анимации</li><li><strong>Визуализация данных:</strong> Графики в реальном времени</li></ul><h4>Возвращаемое значение:</h4><p><code>const requestId = requestAnimationFrame(callback);</code><br><code>// Можно отменить через:</code><br><code>cancelAnimationFrame(requestId);</code></p><p><em>Ключевое преимущество:</em> Автоматическая приостановка анимации в неактивных вкладках для экономии ресурсов.</p>",
    difficulty: 'junior',
    tags: ['requestAnimationFrame', 'основы', 'анимации', 'Web API']
  },

  {
    id: 122,
    question: "Какие преимущества имеет requestAnimationFrame по сравнению с setInterval/setTimeout?",
    answer: "<p>requestAnimationFrame (rAF) имеет существенные преимущества над таймерами для анимаций:</p><h4>1. Синхронизация с монитором:</h4><p><strong>rAF:</strong> Автоматически синхронизируется с частотой обновления экрана (обычно 60Hz)</p><p><strong>setInterval:</strong> Может вызываться чаще или реже, чем нужно, создавая рассинхронизацию</p><h4>2. Автоматическая приостановка:</h4><p><strong>rAF:</strong> Останавливается в неактивных вкладках</p><p><strong>setInterval:</strong> Продолжает работать в фоне, тратя ресурсы</p><h4>3. Оптимизация батчинга:</h4><p><strong>rAF:</strong> Все обновления группируются в один repaint</p><p><strong>setInterval:</strong> Может вызывать несколько reflow/repaint</p><h4>4. Точность тайминга:</h4><p><code>// ❌ setInterval - может накапливать задержки</code><br><code>setInterval(() => animate(), 16); // ~60fps</code></p><p><code>// ✅ rAF - всегда синхронизирован</code><br><code>function animate() {</code><br><code>&nbsp;&nbsp;// анимация</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><h4>5. Производительность:</h4><ul><li><strong>CPU:</strong> На 50-80% меньше нагрузки</li><li><strong>Батарея:</strong> Значительно экономнее</li><li><strong>Плавность:</strong> Никаких пропущенных кадров</li></ul><h4>6. API для timestamp:</h4><p>rAF передает высокоточный timestamp в callback, что упрощает создание time-based анимаций.</p><p><em>Вывод:</em> Всегда используйте requestAnimationFrame для визуальных анимаций вместо setInterval/setTimeout.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'производительность', 'сравнение', 'оптимизация']
  },

  {
    id: 123,
    question: "Как работает timestamp в requestAnimationFrame и зачем он нужен?",
    answer: "<p>Callback requestAnimationFrame получает высокоточный timestamp - время в миллисекундах с момента загрузки страницы:</p><h4>Базовое использование:</h4><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;console.log('Current time:', timestamp);</code><br><code>&nbsp;&nbsp;// timestamp ≈ 1234.567890123</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code><br><code></code><br><code>requestAnimationFrame(animate);</code></p><h4>Time-based анимации:</h4><p><code>let startTime = null;</code><br><code>const duration = 2000; // 2 секунды</code></p><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const elapsed = timestamp - startTime;</code><br><code>&nbsp;&nbsp;const progress = Math.min(elapsed / duration, 1);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Перемещение от 0 до 300px за 2 секунды</code><br><code>&nbsp;&nbsp;element.style.left = (progress * 300) + 'px';</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Зачем нужен timestamp:</h4><ul><li><strong>Независимость от FPS:</strong> Анимация одинакова на любой частоте</li><li><strong>Плавность:</strong> Компенсация пропущенных кадров</li><li><strong>Точность:</strong> Высокоточное время (DOMHighResTimeStamp)</li><li><strong>Синхронизация:</strong> Координация множества анимаций</li></ul><h4>Delta time паттерн:</h4><p><code>let lastTime = 0;</code></p><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Скорость независима от FPS</code><br><code>&nbsp;&nbsp;position += velocity * (deltaTime / 1000);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><p><em>Best practice:</em> Всегда используйте timestamp для расчета прогресса анимации вместо подсчета кадров.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'timestamp', 'time-based', 'delta time']
  },

  {
    id: 124,
    question: "Как отменить requestAnimationFrame?",
    answer: "<p>Отмена анимации критична для предотвращения утечек памяти и ненужных вычислений:</p><h4>Базовая отмена:</h4><p><code>let animationId;</code></p><p><code>function animate() {</code><br><code>&nbsp;&nbsp;// Логика анимации</code><br><code>&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>}</code></p><p><code>// Запуск</code><br><code>animationId = requestAnimationFrame(animate);</code></p><p><code>// Остановка</code><br><code>cancelAnimationFrame(animationId);</code></p><h4>Класс для управления анимацией:</h4><p><code>class Animation {</code><br><code>&nbsp;&nbsp;constructor(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animate();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;animate = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback(timestamp);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(this.animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.animationId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(this.animationId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React интеграция:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;let animationId;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function animate() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Логика анимации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;return () => cancelAnimationFrame(animationId);</code><br><code>}, []);</code></p><h4>Условная остановка:</h4><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;// Остановка по условию</code><br><code>&nbsp;&nbsp;if (position >= targetPosition) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return; // Просто не запрашиваем следующий кадр</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;position += velocity;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><p><em>Критично:</em> Всегда отменяйте анимацию при размонтировании компонента для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'cancelAnimationFrame', 'lifecycle', 'cleanup']
  },

  {
    id: 125,
    question: "Как реализовать easing функции с requestAnimationFrame?",
    answer: "<p>Easing функции делают анимации более естественными, изменяя скорость анимации во времени:</p><h4>Базовые easing функции:</h4><p><code>const Easing = {</code><br><code>&nbsp;&nbsp;linear: t => t,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInQuad: t => t * t,</code><br><code>&nbsp;&nbsp;easeOutQuad: t => t * (2 - t),</code><br><code>&nbsp;&nbsp;easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInCubic: t => t * t * t,</code><br><code>&nbsp;&nbsp;easeOutCubic: t => (--t) * t * t + 1,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInOutCubic: t => t < 0.5 </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;? 4 * t * t * t </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1</code><br><code>};</code></p><h4>Использование с анимацией:</h4><p><code>function animateWithEasing(from, to, duration, easingFn) {</code><br><code>&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function animate(timestamp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = timestamp - startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min(elapsed / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем easing</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const easedProgress = easingFn(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Интерполяция значения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const current = from + (to - from) * easedProgress;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.style.left = current + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><p><code>// Использование</code><br><code>animateWithEasing(0, 300, 1000, Easing.easeOutCubic);</code></p><h4>Класс Animator с easing:</h4><p><code>class Animator {</code><br><code>&nbsp;&nbsp;animate(element, property, from, to, duration, easing = 'linear') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const easingFn = Easing[easing];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;function step(timestamp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min((timestamp - startTime) / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const value = from + (to - from) * easingFn(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.style[property] = value + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const animator = new Animator();</code><br><code>animator.animate(element, 'left', 0, 300, 1000, 'easeOutCubic');</code></p><p><em>Совет:</em> Для сложных анимаций используйте готовые библиотеки типа GSAP или anime.js.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'easing', 'анимации', 'интерполяция']
  },

  {
    id: 126,
    question: "Как работает requestAnimationFrame с браузерным циклом событий?",
    answer: "<p>requestAnimationFrame тесно интегрирован с браузерным рендерингом и event loop:</p><h4>Порядок выполнения в event loop:</h4><ol><li>Выполняются синхронные задачи</li><li>Обрабатываются microtasks (Promises, queueMicrotask)</li><li>Выполняются rAF callbacks</li><li>Происходит layout/paint</li><li>Обрабатываются macrotasks (setTimeout, setInterval)</li></ol><h4>Пример порядка:</h4><p><code>console.log('1: sync');</code></p><p><code>setTimeout(() => console.log('2: setTimeout'), 0);</code></p><p><code>Promise.resolve().then(() => console.log('3: Promise'));</code></p><p><code>requestAnimationFrame(() => console.log('4: rAF'));</code></p><p><code>console.log('5: sync');</code></p><p><code>// Вывод:</code><br><code>// 1: sync</code><br><code>// 5: sync</code><br><code>// 3: Promise (microtask)</code><br><code>// 4: rAF (перед paint)</code><br><code>// 2: setTimeout (macrotask)</code></p><h4>Особенности:</h4><ul><li><strong>Timing:</strong> rAF вызывается перед paint, но после microtasks</li><li><strong>Batch:</strong> Все rAF callbacks выполняются за один проход</li><li><strong>Sync:</strong> Внутри rAF синхронное чтение layout данных не вызывает forced reflow</li></ul><h4>Оптимальное чтение/запись:</h4><p><code>// ✅ Правильно - read в rAF, write после</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;const height = element.offsetHeight; // read</code><br><code>&nbsp;&nbsp;element.style.width = height + 'px'; // write - будет в paint</code><br><code>});</code></p><p><code>// ❌ Плохо - read после write = forced reflow</code><br><code>element.style.width = '100px';</code><br><code>const height = element.offsetHeight; // forced reflow!</code></p><p><em>Ключевой момент:</em> rAF выполняется синхронно перед paint, что позволяет группировать все DOM изменения в один repaint.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'event loop', 'рендеринг', 'производительность']
  },

  {
    id: 127,
    question: "Как реализовать throttle анимаций до определенного FPS?",
    answer: "<p>Иногда нужно ограничить частоту анимации до определенного FPS (например, для экономии ресурсов):</p><h4>Throttle до 30 FPS:</h4><p><code>function createThrottledAnimation(fps) {</code><br><code>&nbsp;&nbsp;const interval = 1000 / fps;</code><br><code>&nbsp;&nbsp;let lastTime = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return function animate(timestamp, callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (elapsed > interval) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastTime = timestamp - (elapsed % interval);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(timestamp);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame((t) => animate(t, callback));</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>// Использование для 30 FPS</code><br><code>const animate30fps = createThrottledAnimation(30);</code><br><code></code><br><code>requestAnimationFrame((timestamp) => {</code><br><code>&nbsp;&nbsp;animate30fps(timestamp, (t) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Эта функция вызывается максимум 30 раз в секунду</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;updateAnimation();</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Класс с настраиваемым FPS:</h4><p><code>class ThrottledAnimator {</code><br><code>&nbsp;&nbsp;constructor(fps = 60) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.fps = fps;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.interval = 1000 / fps;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animate = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = timestamp - this.lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (elapsed > this.interval) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = timestamp - (elapsed % this.interval);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(timestamp, elapsed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.animationId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(this.animationId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const animator = new ThrottledAnimator(30);</code><br><code>animator.start((timestamp, deltaTime) => {</code><br><code>&nbsp;&nbsp;updateGame(deltaTime);</code><br><code>});</code></p><h4>Зачем нужно:</h4><ul><li>Экономия CPU на слабых устройствах</li><li>Совместимость со старыми мониторами</li><li>Ограничение нагрузки в фоновых вкладках</li><li>Тестирование на низком FPS</li></ul><p><em>Важно:</em> Используйте остаток времени (elapsed % interval) для точности следующего кадра.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'throttle', 'FPS', 'оптимизация']
  },

  {
    id: 128,
    question: "Как создать игровой цикл с requestAnimationFrame?",
    answer: "<p>Игровой цикл (game loop) — основа любой игры или интерактивной анимации:</p><h4>Базовый игровой цикл:</h4><p><code>class GameLoop {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = 0;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loop();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loop = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const deltaTime = timestamp - this.lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Update логика игры</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.update(deltaTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Render графика</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.render();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(this.loop);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;update(deltaTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Физика, коллизии, AI</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;player.x += player.velocityX * (deltaTime / 1000);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;render() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отрисовка на canvas</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ctx.clearRect(0, 0, canvas.width, canvas.height);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillRect(player.x, player.y, 50, 50);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>С фиксированным временным шагом (fixed timestep):</h4><p><code>class FixedStepGameLoop {</code><br><code>&nbsp;&nbsp;constructor(fps = 60) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.fixedDelta = 1000 / fps;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.accumulator = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = 0;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loop = (timestamp) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const frameTime = timestamp - this.lastTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.accumulator += frameTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Фиксированные обновления физики</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (this.accumulator >= this.fixedDelta) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.update(this.fixedDelta);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.accumulator -= this.fixedDelta;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Рендер с интерполяцией</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const alpha = this.accumulator / this.fixedDelta;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.render(alpha);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(this.loop);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Применения:</h4><ul><li>2D/3D игры</li><li>Физические симуляции</li><li>Интерактивные визуализации</li><li>Анимированные дашборды</li></ul><p><em>Best practice:</em> Разделяйте update (логику) и render (отрисовку) для чистоты кода и возможности оптимизации.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'game loop', 'игры', 'deltaTime']
  },

  {
    id: 129,
    question: "Как избежать layout thrashing при использовании requestAnimationFrame?",
    answer: "<p>Layout thrashing (принудительный пересчет layout) убивает производительность анимаций:</p><h4>Проблема — чередование read/write:</h4><p><code>// ❌ ПЛОХО - layout thrashing</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;elements.forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const height = el.offsetHeight; // READ - вызывает layout</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;el.style.width = height + 'px'; // WRITE</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// На каждой итерации браузер пересчитывает layout!</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Решение — батчинг read/write:</h4><p><code>// ✅ ХОРОШО - сначала все READ, потом все WRITE</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// READ phase</code><br><code>&nbsp;&nbsp;const heights = elements.map(el => el.offsetHeight);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// WRITE phase</code><br><code>&nbsp;&nbsp;elements.forEach((el, i) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;el.style.width = heights[i] + 'px';</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Класс для управления read/write:</h4><p><code>class LayoutManager {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reads = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.writes = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.scheduled = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;measure(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reads.push(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.schedule();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;mutate(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.writes.push(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.schedule();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;schedule() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.scheduled) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.scheduled = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Выполняем все reads</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reads.forEach(fn => fn());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reads = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Затем все writes</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.writes.forEach(fn => fn());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.writes = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.scheduled = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const layout = new LayoutManager();</code><br><code></code><br><code>// Использование</code><br><code>layout.measure(() => {</code><br><code>&nbsp;&nbsp;height = element.offsetHeight;</code><br><code>});</code><br><code></code><br><code>layout.mutate(() => {</code><br><code>&nbsp;&nbsp;element.style.width = height + 'px';</code><br><code>});</code></p><h4>Операции, вызывающие forced reflow:</h4><ul><li>offsetHeight, offsetWidth, offsetTop</li><li>clientHeight, clientWidth</li><li>scrollHeight, scrollWidth</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p><em>Золотое правило:</em> Группируйте все чтения DOM свойств вместе, затем все записи — в рамках одного requestAnimationFrame.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'layout thrashing', 'производительность', 'reflow']
  },

  {
    id: 130,
    question: "Как работает requestAnimationFrame в неактивных вкладках?",
    answer: "<p>Поведение requestAnimationFrame в фоновых вкладках критично для производительности:</p><h4>Базовое поведение:</h4><ul><li><strong>Активная вкладка:</strong> ~60 FPS (16.67ms между кадрами)</li><li><strong>Фоновая вкладка:</strong> Приостанавливается полностью или throttled до 1-2 FPS</li><li><strong>Минимизированное окно:</strong> Также throttled</li></ul><h4>Обработка фокуса вкладки:</h4><p><code>class AdaptiveAnimator {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isVisible = !document.hidden;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupVisibilityListener();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;setupVisibilityListener() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener('visibilitychange', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.isVisible = !document.hidden;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.isVisible) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.onVisible();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.onHidden();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onVisible() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Возобновить анимацию/игру</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resume();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onHidden() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Приостановить/сохранить состояние</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pause();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Проблемы при возврате на вкладку:</h4><p><code>// ❌ ПРОБЛЕМА - большой deltaTime</code><br><code>let lastTime = performance.now();</code><br><code></code><br><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;// Если вкладка была в фоне 10 секунд,</code><br><code>&nbsp;&nbsp;// deltaTime = 10000ms - персонаж телепортируется!</code><br><code>&nbsp;&nbsp;player.x += velocity * deltaTime;</code><br><code>}</code></p><p><code>// ✅ РЕШЕНИЕ - ограничение deltaTime</code><br><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = Math.min(timestamp - lastTime, 100);</code><br><code>&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;player.x += velocity * deltaTime;</code><br><code>}</code></p><h4>Сброс времени при возврате:</h4><p><code>let lastTime = performance.now();</code><br><code>let wasHidden = false;</code></p><p><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;// Сброс при возврате на вкладку</code><br><code>&nbsp;&nbsp;if (wasHidden && !document.hidden) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;wasHidden = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;lastTime = timestamp;</code><br><code>&nbsp;&nbsp;wasHidden = document.hidden;</code><br><code>}</code></p><p><em>Best practice:</em> Всегда ограничивайте максимальный deltaTime и обрабатывайте visibilitychange для корректной работы в фоне.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'visibility', 'фоновые вкладки', 'deltaTime']
  },

  {
    id: 131,
    question: "Как создать систему анимаций с очередью и цепочками?",
    answer: "<p>Система управления последовательными и параллельными анимациями полезна для сложных UI:</p><h4>Базовая очередь анимаций:</h4><p><code>class AnimationQueue {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.queue = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;add(animation) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.queue.push({ animation, resolve });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isRunning) this.run();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async run() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (this.queue.length > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const { animation, resolve } = this.queue.shift();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await animation();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isRunning = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование с цепочками:</h4><p><code>const queue = new AnimationQueue();</code></p><p><code>queue</code><br><code>&nbsp;&nbsp;.add(() => animate(el1, { x: 100 }, 1000))</code><br><code>&nbsp;&nbsp;.then(() => queue.add(() => animate(el2, { y: 100 }, 500)))</code><br><code>&nbsp;&nbsp;.then(() => queue.add(() => animate(el3, { scale: 2 }, 800)));</code></p><h4>Система с параллельными анимациями:</h4><p><code>class AnimationSystem {</code><br><code>&nbsp;&nbsp;sequence(...animations) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return animations.reduce(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(promise, anim) => promise.then(() => anim()),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;parallel(...animations) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return Promise.all(animations.map(anim => anim()));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;animate(element, props, duration) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const startProps = {};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем начальные значения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(props).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startProps[key] = parseFloat(element.style[key]) || 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function step(timestamp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = timestamp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min((timestamp - startTime) / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(props).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const start = startProps[key];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const end = props[key];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.style[key] = (start + (end - start) * progress) + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(step);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const anim = new AnimationSystem();</code></p><p><code>// Последовательно</code><br><code>anim.sequence(</code><br><code>&nbsp;&nbsp;() => anim.animate(el1, { left: 100 }, 500),</code><br><code>&nbsp;&nbsp;() => anim.animate(el2, { top: 100 }, 500)</code><br><code>);</code></p><p><code>// Параллельно</code><br><code>anim.parallel(</code><br><code>&nbsp;&nbsp;() => anim.animate(el1, { left: 100 }, 500),</code><br><code>&nbsp;&nbsp;() => anim.animate(el2, { top: 100 }, 500)</code><br><code>);</code></p><p><em>Применение:</em> Сложные UI анимации, онбординг, переходы между экранами.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'очередь', 'цепочки', 'Promise']
  },

  {
    id: 132,
    question: "Как оптимизировать рендеринг большого количества элементов?",
    answer: "<p>При анимации множества элементов критична оптимизация для поддержания 60 FPS:</p><h4>1. Batch DOM операции:</h4><p><code>// ❌ ПЛОХО - множественные reflow</code><br><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;particles.forEach(p => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;p.element.style.transform = \`translate(\${p.x}px, \${p.y}px)\`;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>// ✅ ЛУЧШЕ - используйте CSS transform вместо left/top</code><br><code>// ✅ ЕЩЕ ЛУЧШЕ - используйте Canvas вместо DOM</code></p><h4>2. Canvas для множества объектов:</h4><p><code>class ParticleSystem {</code><br><code>&nbsp;&nbsp;constructor(canvas) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ctx = canvas.getContext('2d');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.particles = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;update(deltaTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.particles.forEach(p => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.x += p.vx * deltaTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.y += p.vy * deltaTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;render() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ctx.clearRect(0, 0, canvas.width, canvas.height);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Один draw call для всех частиц одного типа</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.particles.forEach(p => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ctx.fillStyle = p.color;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ctx.fillRect(p.x, p.y, 5, 5);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>3. Виртуализация (рендерить только видимое):</h4><p><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// Рендерим только элементы в viewport</code><br><code>&nbsp;&nbsp;const viewport = getViewport();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;elements.forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (isInViewport(el, viewport)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderElement(el);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>4. Object pooling:</h4><p><code>class ObjectPool {</code><br><code>&nbsp;&nbsp;constructor(createFn, resetFn) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pool = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.createFn = createFn;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resetFn = resetFn;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.pool.pop() || this.createFn();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;release(obj) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resetFn(obj);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pool.push(obj);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>5. requestIdleCallback для неприоритетных задач:</h4><p><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// Критичный рендеринг</code><br><code>&nbsp;&nbsp;renderVisibleElements();</code><br><code>});</code></p><p><code>requestIdleCallback(() => {</code><br><code>&nbsp;&nbsp;// Некритичные обновления в свободное время</code><br><code>&nbsp;&nbsp;updateStats();</code><br><code>});</code></p><p><em>Золотое правило:</em> Если >100 элементов анимируются - используйте Canvas. Если <100 - DOM с CSS transforms.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'оптимизация', 'производительность', 'Canvas']
  },

  {
    id: 133,
    question: "Как создать плавный скролл с requestAnimationFrame?",
    answer: "<p>Плавный скролл улучшает UX и позволяет контролировать скорость анимации:</p><h4>Базовая реализация:</h4><p><code>function smoothScrollTo(targetY, duration = 1000) {</code><br><code>&nbsp;&nbsp;const startY = window.pageYOffset;</code><br><code>&nbsp;&nbsp;const distance = targetY - startY;</code><br><code>&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function animation(currentTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = currentTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const elapsed = currentTime - startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min(elapsed / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Easing функция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const easeProgress = easeInOutCubic(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;window.scrollTo(0, startY + distance * easeProgress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestAnimationFrame(animation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animation);</code><br><code>}</code></p><p><code>function easeInOutCubic(t) {</code><br><code>&nbsp;&nbsp;return t < 0.5 </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;? 4 * t * t * t </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;: 1 - Math.pow(-2 * t + 2, 3) / 2;</code><br><code>}</code></p><h4>Скролл к элементу:</h4><p><code>function scrollToElement(element, offset = 0, duration = 1000) {</code><br><code>&nbsp;&nbsp;const targetY = element.getBoundingClientRect().top + </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.pageYOffset + </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;smoothScrollTo(targetY, duration);</code><br><code>}</code></p><p><code>// Использование</code><br><code>const section = document.querySelector('#about');</code><br><code>scrollToElement(section, -100); // -100px от элемента</code></p><h4>С возможностью отмены:</h4><p><code>class SmoothScroller {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;scrollTo(targetY, duration = 1000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий скролл</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cancel();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const startY = window.pageYOffset;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const distance = targetY - startY;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let startTime = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animation = (currentTime) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!startTime) startTime = currentTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const progress = Math.min((currentTime - startTime) / duration, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const eased = this.easeInOutQuad(progress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.scrollTo(0, startY + distance * eased);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress < 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = requestAnimationFrame(animation);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancel() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.animationId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(this.animationId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.animationId = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;easeInOutQuad(t) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const scroller = new SmoothScroller();</code><br><code>scroller.scrollTo(1000, 800);</code></p><p><em>Альтернатива:</em> Современные браузеры поддерживают <code>element.scrollIntoView({ behavior: 'smooth' })</code>, но с меньшим контролем.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'скролл', 'smooth scroll', 'UX']
  },

  {
    id: 134,
    question: "Какие есть best practices при работе с requestAnimationFrame?",
    answer: "<p>Соблюдение best practices критично для плавных и эффективных анимаций:</p><h4>✅ Best Practices:</h4><p><strong>1. Используйте timestamp для расчетов:</strong></p><p><code>// ✅ Правильно</code><br><code>function animate(timestamp) {</code><br><code>&nbsp;&nbsp;const deltaTime = timestamp - lastTime;</code><br><code>&nbsp;&nbsp;position += velocity * (deltaTime / 1000);</code><br><code>}</code></p><p><strong>2. Всегда отменяйте при cleanup:</strong></p><p><code>const animationId = requestAnimationFrame(animate);</code><br><code>// При размонтировании:</code><br><code>cancelAnimationFrame(animationId);</code></p><p><strong>3. Разделяйте update и render:</strong></p><p><code>function gameLoop(timestamp) {</code><br><code>&nbsp;&nbsp;update(deltaTime); // Логика</code><br><code>&nbsp;&nbsp;render();          // Отрисовка</code><br><code>}</code></p><p><strong>4. Группируйте DOM чтения и записи:</strong></p><p><code>requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;// READ phase</code><br><code>&nbsp;&nbsp;const heights = elements.map(el => el.offsetHeight);</code><br><code>&nbsp;&nbsp;// WRITE phase</code><br><code>&nbsp;&nbsp;elements.forEach((el, i) => el.style.width = heights[i] + 'px');</code><br><code>});</code></p><p><strong>5. Ограничивайте максимальный deltaTime:</strong></p><p><code>const deltaTime = Math.min(timestamp - lastTime, 100);</code></p><p><strong>6. Используйте CSS transforms вместо left/top:</strong></p><p><code>// ✅ GPU ускорение</code><br><code>element.style.transform = \`translate(\${x}px, \${y}px)\`;</code></p><h4>❌ Чего избегать:</h4><ul><li>Не модифицируйте DOM внутри обработчиков событий scroll/resize</li><li>Не создавайте объекты в hot path анимации</li><li>Не забывайте cancelAnimationFrame при удалении</li><li>Не используйте setInterval для анимаций</li><li>Не читайте layout свойства после записи в DOM</li></ul><h4>⚠️ Частые ошибки:</h4><ol><li>Забытый cancelAnimationFrame → утечка памяти</li><li>Layout thrashing → 10-100x медленнее</li><li>Анимация left/top вместо transform → нет GPU</li><li>Создание closure в каждом кадре → garbage collection</li><li>Не учитывать deltaTime → разная скорость на разном FPS</li></ol><p><em>Золотое правило:</em> Измеряйте производительность через Chrome DevTools Performance и держите кадры под 16ms для 60 FPS.</p>",
    difficulty: 'senior',
    tags: ['requestAnimationFrame', 'best practices', 'производительность', 'оптимизация']
  },

  {
    id: 135,
    question: "Как интегрировать requestAnimationFrame с современными фреймворками?",
    answer: "<p>Интеграция requestAnimationFrame с React/Vue требует понимания lifecycle и cleanup:</p><h4>React хук useAnimationFrame:</h4><p><code>function useAnimationFrame(callback) {</code><br><code>&nbsp;&nbsp;const requestRef = useRef();</code><br><code>&nbsp;&nbsp;const previousTimeRef = useRef();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animate = (time) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (previousTimeRef.current !== undefined) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const deltaTime = time - previousTimeRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(deltaTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previousTimeRef.current = time;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => cancelAnimationFrame(requestRef.current);</code><br><code>&nbsp;&nbsp;}, [callback]);</code><br><code>}</code></p><p><code>// Использование</code><br><code>function AnimatedComponent() {</code><br><code>&nbsp;&nbsp;const [count, setCount] = useState(0);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useAnimationFrame((deltaTime) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setCount(prev => prev + deltaTime * 0.01);</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{count.toFixed(2)}&lt;/div&gt;;</code><br><code>}</code></p><h4>Vue 3 Composable:</h4><p><code>import { onMounted, onUnmounted, ref } from 'vue';</code></p><p><code>export function useAnimationFrame(callback) {</code><br><code>&nbsp;&nbsp;let animationId = null;</code><br><code>&nbsp;&nbsp;let previousTime = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const animate = (time) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const deltaTime = time - previousTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;previousTime = time;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;callback(deltaTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animationId = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onUnmounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (animationId) cancelAnimationFrame(animationId);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>const rotation = ref(0);</code><br><code></code><br><code>useAnimationFrame((deltaTime) => {</code><br><code>&nbsp;&nbsp;rotation.value += deltaTime * 0.1;</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><h4>Контроль запуска/остановки:</h4><p><code>function useControllableAnimation() {</code><br><code>&nbsp;&nbsp;const [isRunning, setIsRunning] = useState(false);</code><br><code>&nbsp;&nbsp;const requestRef = useRef();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!isRunning) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const animate = (time) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// анимация</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;requestRef.current = requestAnimationFrame(animate);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => cancelAnimationFrame(requestRef.current);</code><br><code>&nbsp;&nbsp;}, [isRunning]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { isRunning, setIsRunning };</code><br><code>}</code></p><p><em>Критично:</em> Всегда возвращайте cleanup функцию с cancelAnimationFrame из useEffect/onUnmounted.</p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'React', 'Vue', 'hooks', 'composables']
  },
  {
    id: 136,
    question: "Что такое PerformanceObserver и для чего он используется?",
    answer: "<p><strong>PerformanceObserver</strong> — это Web API для асинхронного мониторинга производительности веб-приложений:</p><h4>Основное назначение:</h4><p>Позволяет отслеживать различные метрики производительности (timing events) без необходимости постоянного polling Performance API, предоставляя callback-based подход к получению данных о производительности.</p><h4>Создание и использование:</h4><p><code>const observer = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;const entries = list.getEntries();</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Name:', entry.name);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Duration:', entry.duration);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>observer.observe({ entryTypes: ['measure', 'navigation'] });</code></p><h4>Основные применения:</h4><ul><li><strong>Мониторинг производительности:</strong> Отслеживание метрик в production</li><li><strong>Real User Monitoring (RUM):</strong> Сбор реальных данных пользователей</li><li><strong>Автоматическая аналитика:</strong> Отправка метрик без ручного измерения</li><li><strong>Debugging:</strong> Выявление узких мест производительности</li><li><strong>Core Web Vitals:</strong> Мониторинг LCP, FID, CLS</li></ul><p><em>Ключевое отличие:</em> Асинхронный и эффективный по сравнению с polling performance.getEntries().</p>",
    difficulty: 'junior',
    tags: ['PerformanceObserver', 'основы', 'Web API', 'производительность']
  },

  {
    id: 137,
    question: "Какие типы performance entries можно отслеживать с PerformanceObserver?",
    answer: "<p>PerformanceObserver может отслеживать множество типов метрик производительности:</p><h4>Основные типы entryTypes:</h4><p><strong>navigation:</strong> Метрики загрузки страницы, включая DNS, TCP, время загрузки документа</p><p><strong>resource:</strong> Загрузка ресурсов (images, scripts, CSS, fetch)</p><p><strong>mark:</strong> Пользовательские метки через performance.mark()</p><p><strong>measure:</strong> Измерения между метками через performance.measure()</p><p><strong>paint:</strong> Метрики рендеринга (first-paint, first-contentful-paint)</p><p><strong>largest-contentful-paint:</strong> LCP - Core Web Vital</p><p><strong>first-input:</strong> FID - задержка первого взаимодействия</p><p><strong>layout-shift:</strong> CLS - стабильность визуального контента</p><p><strong>longtask:</strong> Задачи дольше 50ms, блокирующие main thread</p><p><strong>element:</strong> Время рендеринга конкретных элементов</p><h4>Проверка поддержки:</h4><p><code>if (PerformanceObserver.supportedEntryTypes) {</code><br><code>&nbsp;&nbsp;console.log(PerformanceObserver.supportedEntryTypes);</code><br><code>&nbsp;&nbsp;// ['navigation', 'resource', 'mark', 'measure', ...]</code><br><code>}</code></p><h4>Пример наблюдения за несколькими типами:</h4><p><code>observer.observe({ </code><br><code>&nbsp;&nbsp;entryTypes: ['navigation', 'resource', 'paint'] </code><br><code>});</code></p><p><em>Важно:</em> Разные браузеры поддерживают разные типы - всегда проверяйте supportedEntryTypes.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'entryTypes', 'метрики', 'типы']
  },

  {
    id: 138,
    question: "Как отслеживать Core Web Vitals с помощью PerformanceObserver?",
    answer: "<p>Core Web Vitals — ключевые метрики производительности от Google:</p><h4>1. Largest Contentful Paint (LCP):</h4><p><code>const lcpObserver = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;const entries = list.getEntries();</code><br><code>&nbsp;&nbsp;const lastEntry = entries[entries.length - 1];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);</code><br><code>&nbsp;&nbsp;// Хорошо: < 2.5s, Плохо: > 4s</code><br><code>});</code><br><code></code><br><code>lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });</code></p><h4>2. First Input Delay (FID):</h4><p><code>const fidObserver = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const fid = entry.processingStart - entry.startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('FID:', fid);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Хорошо: < 100ms, Плохо: > 300ms</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>fidObserver.observe({ entryTypes: ['first-input'] });</code></p><h4>3. Cumulative Layout Shift (CLS):</h4><p><code>let clsValue = 0;</code><br><code>const clsObserver = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!entry.hadRecentInput) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clsValue += entry.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;console.log('CLS:', clsValue);</code><br><code>&nbsp;&nbsp;// Хорошо: < 0.1, Плохо: > 0.25</code><br><code>});</code><br><code></code><br><code>clsObserver.observe({ entryTypes: ['layout-shift'] });</code></p><h4>Универсальный сборщик Web Vitals:</h4><p><code>function reportWebVitals() {</code><br><code>&nbsp;&nbsp;// LCP</code><br><code>&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const entry = list.getEntries()[list.getEntries().length - 1];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;sendToAnalytics('LCP', entry.renderTime || entry.loadTime);</code><br><code>&nbsp;&nbsp;}).observe({ entryTypes: ['largest-contentful-paint'] });</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// FID</code><br><code>&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const fid = list.getEntries()[0].processingStart - </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries()[0].startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;sendToAnalytics('FID', fid);</code><br><code>&nbsp;&nbsp;}).observe({ entryTypes: ['first-input'] });</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// CLS</code><br><code>&nbsp;&nbsp;let clsValue = 0;</code><br><code>&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!entry.hadRecentInput) clsValue += entry.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;sendToAnalytics('CLS', clsValue);</code><br><code>&nbsp;&nbsp;}).observe({ entryTypes: ['layout-shift'] });</code><br><code>}</code></p><p><em>Применение:</em> Мониторинг в production для оптимизации SEO и UX согласно стандартам Google.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'Core Web Vitals', 'LCP', 'FID', 'CLS']
  },

  {
    id: 139,
    question: "Как отслеживать медленные задачи (Long Tasks) с PerformanceObserver?",
    answer: "<p>Long Tasks — задачи, блокирующие main thread дольше 50ms, влияющие на отзывчивость приложения:</p><h4>Базовое отслеживание:</h4><p><code>const longTaskObserver = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Long task detected!');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Duration:', entry.duration); // > 50ms</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Start:', entry.startTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Attribution:', entry.attribution);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>longTaskObserver.observe({ entryTypes: ['longtask'] });</code></p><h4>Информация в Long Task entry:</h4><ul><li><strong>duration:</strong> Длительность задачи в миллисекундах</li><li><strong>startTime:</strong> Когда задача началась</li><li><strong>attribution:</strong> Какой скрипт/контейнер вызвал задачу</li><li><strong>name:</strong> Тип задачи (self, same-origin, cross-origin)</li></ul><h4>Детальный анализ с атрибуцией:</h4><p><code>const observer = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const attribution = entry.attribution[0];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duration: entry.duration,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerType: attribution?.containerType,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerName: attribution?.containerName,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerSrc: attribution?.containerSrc</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка в аналитику</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.duration > 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reportPerformanceIssue({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'long-task',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duration: entry.duration,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source: attribution?.containerSrc</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>observer.observe({ entryTypes: ['longtask'] });</code></p><h4>Подсчет Total Blocking Time (TBT):</h4><p><code>let totalBlockingTime = 0;</code><br><code></code><br><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// TBT = время задачи минус 50ms порог</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const blockingTime = entry.duration - 50;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (blockingTime > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalBlockingTime += blockingTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;console.log('Total Blocking Time:', totalBlockingTime);</code><br><code>}).observe({ entryTypes: ['longtask'] });</code></p><p><em>Почему важно:</em> Long Tasks напрямую влияют на FID и общую отзывчивость приложения, ухудшая UX.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'Long Tasks', 'TBT', 'производительность']
  },

  {
    id: 140,
    question: "Как мониторить загрузку ресурсов (images, scripts, CSS) с PerformanceObserver?",
    answer: "<p>Отслеживание загрузки ресурсов помогает выявить узкие места в производительности:</p><h4>Базовый мониторинг всех ресурсов:</h4><p><code>const resourceObserver = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Resource:', entry.name);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Type:', entry.initiatorType); // img, script, css, fetch</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Duration:', entry.duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Size:', entry.transferSize);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>resourceObserver.observe({ entryTypes: ['resource'] });</code></p><h4>Фильтрация по типу ресурса:</h4><p><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Только изображения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.initiatorType === 'img') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Image loaded:', entry.name);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Time:', entry.duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Size:', (entry.transferSize / 1024).toFixed(2) + 'KB');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Медленные ресурсы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.duration > 1000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Slow resource:', entry.name, entry.duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}).observe({ entryTypes: ['resource'] });</code></p><h4>Детальный анализ timing'ов:</h4><p><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timing = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dns: entry.domainLookupEnd - entry.domainLookupStart,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tcp: entry.connectEnd - entry.connectStart,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: entry.responseStart - entry.requestStart,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response: entry.responseEnd - entry.responseStart,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total: entry.duration</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(entry.name, timing);</code><br><code>&nbsp;&nbsp;});</code><br><code>}).observe({ entryTypes: ['resource'] });</code></p><h4>Обнаружение кэширования:</h4><p><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.transferSize === 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('From cache:', entry.name);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else if (entry.transferSize < entry.decodedBodySize) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Compressed:', entry.name);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Not compressed:', entry.name);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}).observe({ entryTypes: ['resource'] });</code></p><p><em>Применение:</em> Оптимизация bundle size, выявление медленных CDN, проверка кэширования.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'resources', 'загрузка', 'оптимизация']
  },

  {
    id: 141,
    question: "Как создавать пользовательские метки и измерения с performance.mark() и performance.measure()?",
    answer: "<p>User Timing API позволяет создавать свои метрики производительности:</p><h4>Создание меток (marks):</h4><p><code>// Установка метки начала</code><br><code>performance.mark('fetch-start');</code><br><code></code><br><code>// Выполнение операции</code><br><code>await fetchData();</code><br><code></code><br><code>// Установка метки конца</code><br><code>performance.mark('fetch-end');</code></p><h4>Создание измерений (measures):</h4><p><code>// Измерение между метками</code><br><code>performance.measure('fetch-duration', 'fetch-start', 'fetch-end');</code></p><h4>Отслеживание через PerformanceObserver:</h4><p><code>const observer = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${entry.name}: \${entry.duration}ms\`);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>observer.observe({ entryTypes: ['mark', 'measure'] });</code></p><h4>Реальный пример — измерение компонента:</h4><p><code>class PerformanceTracker {</code><br><code>&nbsp;&nbsp;startOperation(name) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;performance.mark(\`\${name}-start\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;endOperation(name) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;performance.mark(\`\${name}-end\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;performance.measure(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`\${name}-start\`, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`\${name}-end\`</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code><br><code></code><br><code>const tracker = new PerformanceTracker();</code><br><code></code><br><code>// Использование</code><br><code>tracker.startOperation('component-render');</code><br><code>renderComponent();</code><br><code>tracker.endOperation('component-render');</code></p><h4>Измерение от navigationStart:</h4><p><code>performance.mark('app-ready');</code><br><code>performance.measure('time-to-ready', 'navigationStart', 'app-ready');</code></p><h4>Очистка меток:</h4><p><code>// Удалить конкретную метку</code><br><code>performance.clearMarks('fetch-start');</code><br><code></code><br><code>// Удалить все метки</code><br><code>performance.clearMarks();</code><br><code></code><br><code>// Удалить измерения</code><br><code>performance.clearMeasures('fetch-duration');</code></p><p><em>Best practice:</em> Используйте осмысленные имена меток и группируйте связанные измерения префиксами.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'mark', 'measure', 'User Timing']
  },

  {
    id: 142,
    question: "В чем разница между observe({ entryTypes }) и observe({ type })?",
    answer: "<p>PerformanceObserver.observe() имеет два режима работы с разными возможностями:</p><h4>1. entryTypes — множественное наблюдение:</h4><p><code>observer.observe({ </code><br><code>&nbsp;&nbsp;entryTypes: ['navigation', 'resource', 'measure'] </code><br><code>});</code></p><p><strong>Особенности:</strong></p><ul><li>Может наблюдать за несколькими типами одновременно</li><li>Получает только новые entries после вызова observe()</li><li>Не имеет buffered опции</li><li>Старый API (но всё ещё используется)</li></ul><h4>2. type — одиночное наблюдение с buffered:</h4><p><code>observer.observe({ </code><br><code>&nbsp;&nbsp;type: 'navigation',</code><br><code>&nbsp;&nbsp;buffered: true </code><br><code>});</code></p><p><strong>Особенности:</strong></p><ul><li>Наблюдает только за одним типом</li><li>Поддерживает buffered: true для получения прошлых entries</li><li>Более гибкий для специфичных случаев</li><li>Новый рекомендуемый API</li></ul><h4>buffered: true — получение прошлых данных:</h4><p><code>// Получение уже произошедших navigation events</code><br><code>const observer = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Navigation timing:', entry);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>observer.observe({ </code><br><code>&nbsp;&nbsp;type: 'navigation', </code><br><code>&nbsp;&nbsp;buffered: true // Получит entries до вызова observe()</code><br><code>});</code></p><h4>Когда использовать что:</h4><p><strong>entryTypes:</strong> Когда нужно отслеживать несколько типов и важны только новые события</p><p><strong>type + buffered:</strong> Когда нужны исторические данные (например, navigation при инициализации)</p><h4>Практический пример:</h4><p><code>// Для RUM метрик - buffered важен</code><br><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;const lcp = list.getEntries()[list.getEntries().length - 1];</code><br><code>&nbsp;&nbsp;sendToAnalytics('LCP', lcp.renderTime);</code><br><code>}).observe({ type: 'largest-contentful-paint', buffered: true });</code><br><code></code><br><code>// Для мониторинга новых ресурсов - buffered не нужен</code><br><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;logResourceLoad(entry);</code><br><code>&nbsp;&nbsp;});</code><br><code>}).observe({ entryTypes: ['resource'] });</code></p><p><em>Важно:</em> buffered поддерживается не для всех типов entries, проверяйте документацию.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'observe', 'buffered', 'API']
  },

  {
    id: 143,
    question: "Как правильно отключать PerformanceObserver и избегать утечек памяти?",
    answer: "<p>Правильная очистка PerformanceObserver критична для производительности:</p><h4>Методы отключения:</h4><p><strong>disconnect():</strong> Полная остановка наблюдения</p><p><code>observer.disconnect();</code></p><p><strong>Нет unobserve():</strong> В отличие от других Observer API, нельзя отключить отдельный тип</p><h4>В vanilla JavaScript:</h4><p><code>class PerformanceMonitor {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new PerformanceObserver(this.handleEntries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe({ entryTypes: ['measure'] });</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleEntries = (list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>В React:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка entries</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;observer.observe({ entryTypes: ['measure'] });</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;};</code><br><code>}, []);</code></p><h4>В Vue:</h4><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;observer.value = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;observer.value.observe({ entryTypes: ['resource'] });</code><br><code>});</code><br><code></code><br><code>onUnmounted(() => {</code><br><code>&nbsp;&nbsp;observer.value?.disconnect();</code><br><code>&nbsp;&nbsp;observer.value = null;</code><br><code>});</code></p><h4>Условное отключение:</h4><p><code>class ConditionalMonitor {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new PerformanceObserver(this.handleEntries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isMonitoring = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isMonitoring) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe({ entryTypes: ['longtask'] });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.isMonitoring = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.isMonitoring) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.isMonitoring = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Критично:</em> Всегда вызывайте disconnect() при размонтировании компонента или закрытии мониторинга для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'cleanup', 'утечки памяти', 'lifecycle']
  },

  {
    id: 144,
    question: "Как реализовать Real User Monitoring (RUM) систему с PerformanceObserver?",
    answer: "<p>RUM собирает реальные метрики производительности от пользователей в production:</p><h4>Базовая RUM система:</h4><p><code>class RealUserMonitoring {</code><br><code>&nbsp;&nbsp;constructor(endpoint) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.endpoint = endpoint;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.metrics = {};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObservers();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;setupObservers() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Navigation timing</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nav = list.getEntries()[0];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.metrics.loadTime = nav.loadEventEnd - nav.fetchStart;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.metrics.domContentLoaded = nav.domContentLoadedEventEnd;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendMetrics();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ type: 'navigation', buffered: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// LCP</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const entries = list.getEntries();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const lcp = entries[entries.length - 1];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.metrics.lcp = lcp.renderTime || lcp.loadTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendMetrics();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ type: 'largest-contentful-paint', buffered: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// FID</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const entry = list.getEntries()[0];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.metrics.fid = entry.processingStart - entry.startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendMetrics();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ type: 'first-input', buffered: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// CLS</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let clsValue = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!entry.hadRecentInput) clsValue += entry.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.metrics.cls = clsValue;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ type: 'layout-shift', buffered: true });</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;sendMetrics() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка на сервер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (navigator.sendBeacon) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.sendBeacon(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.endpoint, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON.stringify(this.metrics)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const rum = new RealUserMonitoring('/api/metrics');</code></p><h4>С контекстом пользователя:</h4><p><code>sendMetrics() {</code><br><code>&nbsp;&nbsp;const data = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;...this.metrics,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;userAgent: navigator.userAgent,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;connection: navigator.connection?.effectiveType,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;url: window.location.href,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;navigator.sendBeacon(this.endpoint, JSON.stringify(data));</code><br><code>}</code></p><p><em>Применение:</em> Реальный мониторинг производительности для выявления проблем в production и оптимизации UX.</p>",
    difficulty: 'senior',
    tags: ['PerformanceObserver', 'RUM', 'мониторинг', 'production']
  },

  {
    id: 145,
    question: "Как отслеживать производительность конкретных элементов с Element Timing API?",
    answer: "<p>Element Timing API позволяет измерять время рендеринга важных элементов:</p><h4>Маркировка элементов в HTML:</h4><p><code>&lt;img src=\"hero.jpg\" elementtiming=\"hero-image\"&gt;</code><br><code>&lt;h1 elementtiming=\"main-heading\"&gt;Title&lt;/h1&gt;</code><br><code>&lt;div elementtiming=\"important-content\"&gt;Content&lt;/div&gt;</code></p><h4>Отслеживание через PerformanceObserver:</h4><p><code>const elementObserver = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Element:', entry.identifier);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Render time:', entry.renderTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Load time:', entry.loadTime);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Size:', entry.naturalWidth, 'x', entry.naturalHeight);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>elementObserver.observe({ type: 'element', buffered: true });</code></p><h4>Мониторинг критичных элементов:</h4><p><code>class CriticalElementMonitor {</code><br><code>&nbsp;&nbsp;constructor(criticalElements) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.criticalElements = criticalElements;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timings = {};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.criticalElements.includes(entry.identifier)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timings[entry.identifier] = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderTime: entry.renderTime,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadTime: entry.loadTime,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: entry.url</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkAllLoaded();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe({ type: 'element', buffered: true });</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;checkAllLoaded() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (Object.keys(this.timings).length === this.criticalElements.length) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('All critical elements loaded:', this.timings);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportMetrics();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const monitor = new CriticalElementMonitor([</code><br><code>&nbsp;&nbsp;'hero-image', </code><br><code>&nbsp;&nbsp;'main-heading', </code><br><code>&nbsp;&nbsp;'cta-button'</code><br><code>]);</code></p><p><em>Применение:</em> Оптимизация времени отображения критичных UI элементов, улучшение perceived performance.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'Element Timing', 'элементы', 'рендеринг']
  },

  {
    id: 146,
    question: "Как оптимизировать производительность при использовании PerformanceObserver?",
    answer: "<p>PerformanceObserver сам может влиять на производительность при неправильном использовании:</p><h4>1. Фильтруйте только нужные типы:</h4><p><code>// ❌ ПЛОХО - получаем всё</code><br><code>observer.observe({ entryTypes: ['resource', 'measure', 'mark', 'navigation'] });</code><br><code></code><br><code>// ✅ ХОРОШО - только нужное</code><br><code>observer.observe({ type: 'resource' });</code></p><h4>2. Используйте debounce для отправки данных:</h4><p><code>class OptimizedMonitor {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.buffer = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sendTimeout = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;addEntry(entry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.buffer.push(entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправляем батчем</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.sendTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sendTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendBatch();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 5000);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;sendBatch() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.buffer.length === 0) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;navigator.sendBeacon('/metrics', JSON.stringify(this.buffer));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.buffer = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>3. Ограничивайте размер данных:</h4><p><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправляем только важные поля</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const minimal = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: entry.name,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duration: entry.duration,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: entry.entryType</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;sendMetric(minimal);</code><br><code>&nbsp;&nbsp;});</code><br><code>}).observe({ entryTypes: ['measure'] });</code></p><h4>4. Сэмплирование для production:</h4><p><code>class SampledMonitor {</code><br><code>&nbsp;&nbsp;constructor(sampleRate = 0.1) { // 10% пользователей</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shouldMonitor = Math.random() < sampleRate;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.shouldMonitor) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setupObservers();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>5. Условный мониторинг:</h4><p><code>// Только в dev или для debug</code><br><code>if (process.env.NODE_ENV === 'development' || DEBUG_MODE) {</code><br><code>&nbsp;&nbsp;new PerformanceObserver(...).observe(...);</code><br><code>}</code></p><h4>6. Используйте requestIdleCallback:</h4><p><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;requestIdleCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка в свободное время</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;processEntries(list.getEntries());</code><br><code>&nbsp;&nbsp;});</code><br><code>}).observe({ entryTypes: ['resource'] });</code></p><p><em>Best practice:</em> В production используйте сэмплирование и батчинг для минимизации влияния на производительность.</p>",
    difficulty: 'senior',
    tags: ['PerformanceObserver', 'оптимизация', 'производительность', 'batching']
  },

  {
    id: 147,
    question: "Как обрабатывать кросс-браузерную совместимость PerformanceObserver?",
    answer: "<p>Поддержка PerformanceObserver и различных entryTypes отличается между браузерами:</p><h4>Проверка базовой поддержки:</h4><p><code>if ('PerformanceObserver' in window) {</code><br><code>&nbsp;&nbsp;// PerformanceObserver поддерживается</code><br><code>} else {</code><br><code>&nbsp;&nbsp;// Fallback на performance.getEntries()</code><br><code>}</code></p><h4>Проверка поддержки конкретных типов:</h4><p><code>function isEntryTypeSupported(type) {</code><br><code>&nbsp;&nbsp;if (!PerformanceObserver.supportedEntryTypes) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;return PerformanceObserver.supportedEntryTypes.includes(type);</code><br><code>}</code><br><code></code><br><code>// Использование</code><br><code>if (isEntryTypeSupported('largest-contentful-paint')) {</code><br><code>&nbsp;&nbsp;// Наблюдаем за LCP</code><br><code>}</code></p><h4>Универсальная обертка с fallback:</h4><p><code>class SafePerformanceObserver {</code><br><code>&nbsp;&nbsp;constructor(callback, types) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.types = types;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if ('PerformanceObserver' in window) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.useObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.useFallback();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const supportedTypes = this.types.filter(type => </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PerformanceObserver.supportedEntryTypes?.includes(type)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (supportedTypes.length > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new PerformanceObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe({ entryTypes: supportedTypes });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useFallback() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Polling для старых браузеров</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const entries = performance.getEntriesByType(this.types[0]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entries.length > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback({ getEntries: () => entries });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 1000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Полифил для старых браузеров:</h4><p><code>if (!('PerformanceObserver' in window)) {</code><br><code>&nbsp;&nbsp;// Используйте полифил</code><br><code>&nbsp;&nbsp;// https://github.com/GoogleChrome/web-vitals</code><br><code>&nbsp;&nbsp;import('web-vitals/polyfill');</code><br><code>}</code></p><h4>Поддержка браузеров:</h4><ul><li><strong>Chrome/Edge:</strong> Полная поддержка всех типов</li><li><strong>Firefox:</strong> Большинство типов, кроме element</li><li><strong>Safari:</strong> Базовая поддержка, ограниченные типы</li><li><strong>IE:</strong> Не поддерживается</li></ul><p><em>Best practice:</em> Всегда проверяйте supportedEntryTypes перед использованием и имейте fallback для критичной функциональности.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'совместимость', 'полифил', 'кросс-браузерность']
  },

  {
    id: 148,
    question: "Как интегрировать PerformanceObserver с современными фреймворками?",
    answer: "<p>Интеграция PerformanceObserver с React/Vue требует правильной обработки lifecycle:</p><h4>React хук usePerformanceObserver:</h4><p><code>function usePerformanceObserver(entryTypes, callback) {</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!('PerformanceObserver' in window)) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new PerformanceObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observer.observe({ entryTypes });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('PerformanceObserver error:', e);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, [entryTypes, callback]);</code><br><code>}</code></p><p><code>// Использование</code><br><code>function App() {</code><br><code>&nbsp;&nbsp;usePerformanceObserver(['measure'], (list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(entry.name, entry.duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Vue 3 Composable:</h4><p><code>export function usePerformanceObserver(entryTypes, callback) {</code><br><code>&nbsp;&nbsp;let observer = null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!('PerformanceObserver' in window)) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer = new PerformanceObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe({ entryTypes });</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;onUnmounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer?.disconnect();</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Мониторинг производительности компонента:</h4><p><code>function ComponentPerformanceTracker({ componentName, children }) {</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;performance.mark(\`\${componentName}-mount-start\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performance.mark(\`\${componentName}-unmount\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performance.measure(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`\${componentName}-lifetime\`,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`\${componentName}-mount-start\`,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`\${componentName}-unmount\`</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}, [componentName]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;usePerformanceObserver(['measure'], (list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.name.includes(componentName)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${componentName} performance:\`, entry.duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return children;</code><br><code>}</code></p><p><em>Критично:</em> Всегда отключайте observer в cleanup функции для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['PerformanceObserver', 'React', 'Vue', 'интеграция', 'hooks']
  },

  {
    id: 149,
    question: "Какие есть best practices и подводные камни при работе с PerformanceObserver?",
    answer: "<p>При работе с PerformanceObserver важно следовать лучшим практикам:</p><h4>✅ Best Practices:</h4><p><strong>1. Всегда отключайте observer:</strong></p><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new PerformanceObserver(callback);</code><br><code>&nbsp;&nbsp;observer.observe({ entryTypes: ['measure'] });</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return () => observer.disconnect(); // Обязательно!</code><br><code>}, []);</code></p><p><strong>2. Проверяйте поддержку типов:</strong></p><p><code>if (PerformanceObserver.supportedEntryTypes?.includes('longtask')) {</code><br><code>&nbsp;&nbsp;// Используем longtask</code><br><code>}</code></p><p><strong>3. Используйте buffered для исторических данных:</strong></p><p><code>observer.observe({ type: 'navigation', buffered: true });</code></p><p><strong>4. Минимизируйте обработку в callback:</strong></p><p><code>// ✅ Быстрая обработка</code><br><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;const entries = list.getEntries();</code><br><code>&nbsp;&nbsp;requestIdleCallback(() => processEntries(entries));</code><br><code>}).observe({ entryTypes: ['resource'] });</code></p><p><strong>5. Используйте сэмплирование в production:</strong></p><p><code>if (Math.random() < 0.1) { // 10% пользователей</code><br><code>&nbsp;&nbsp;setupPerformanceMonitoring();</code><br><code>}</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Забытый disconnect():</strong></p><p><code>// ❌ Утечка памяти</code><br><code>const observer = new PerformanceObserver(callback);</code><br><code>observer.observe({ entryTypes: ['measure'] });</code><br><code>// Никогда не вызывается disconnect()!</code></p><p><strong>2. Тяжелые операции в callback:</strong></p><p><code>// ❌ Блокирует main thread</code><br><code>new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Тяжелые вычисления</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;complexProcessing(entry);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><strong>3. Игнорирование совместимости:</strong></p><p><code>// ❌ Может упасть в старых браузерах</code><br><code>new PerformanceObserver(...).observe({ type: 'element' });</code></p><p><strong>4. Отправка больших объемов данных:</strong></p><p><code>// ❌ Плохо для performance</code><br><code>list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;fetch('/metrics', { method: 'POST', body: JSON.stringify(entry) });</code><br><code>});</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не вызывать disconnect() при размонтировании</li><li>Использовать неподдерживаемые entryTypes без проверки</li><li>Отправлять каждую метрику отдельным запросом</li><li>Не использовать buffered для начальных метрик</li><li>Мониторить в 100% случаев в production</li></ol><p><em>Золотое правило:</em> PerformanceObserver для сбора метрик, а не для бизнес-логики. Минимизируйте влияние на производительность.</p>",
    difficulty: 'senior',
    tags: ['PerformanceObserver', 'best practices', 'подводные камни', 'оптимизация']
  },

  {
    id: 150,
    question: "Как создать систему автоматического performance budget мониторинга?",
    answer: "<p>Performance Budget — установленные лимиты на метрики производительности:</p><h4>Определение бюджетов:</h4><p><code>const PERFORMANCE_BUDGETS = {</code><br><code>&nbsp;&nbsp;lcp: 2500,        // 2.5s для LCP</code><br><code>&nbsp;&nbsp;fid: 100,         // 100ms для FID</code><br><code>&nbsp;&nbsp;cls: 0.1,         // 0.1 для CLS</code><br><code>&nbsp;&nbsp;longTask: 50,     // Не больше 50ms</code><br><code>&nbsp;&nbsp;jsSize: 200 * 1024, // 200KB JS</code><br><code>&nbsp;&nbsp;imageSize: 500 * 1024 // 500KB images</code><br><code>};</code></p><h4>Система мониторинга бюджета:</h4><p><code>class PerformanceBudgetMonitor {</code><br><code>&nbsp;&nbsp;constructor(budgets) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.budgets = budgets;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.violations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupMonitoring();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;setupMonitoring() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// LCP мониторинг</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const lcp = list.getEntries()[list.getEntries().length - 1];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const value = lcp.renderTime || lcp.loadTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value > this.budgets.lcp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportViolation('LCP', value, this.budgets.lcp);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ type: 'largest-contentful-paint', buffered: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Long Tasks мониторинг</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.duration > this.budgets.longTask) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportViolation('Long Task', entry.duration, this.budgets.longTask);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ entryTypes: ['longtask'] });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Размер ресурсов</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;new PerformanceObserver((list) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.getEntries().forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.initiatorType === 'script' && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry.transferSize > this.budgets.jsSize) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportViolation('JS Bundle', entry.transferSize, this.budgets.jsSize);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).observe({ entryTypes: ['resource'] });</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;reportViolation(metric, actual, budget) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const violation = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metric,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;budget,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exceededBy: actual - budget,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.violations.push(violation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.warn('⚠️ Performance Budget Violation:', violation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка уведомления</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.notifyTeam(violation);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;notifyTeam(violation) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка в Slack/Email/etc</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/alert', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify(violation)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const monitor = new PerformanceBudgetMonitor(PERFORMANCE_BUDGETS);</code></p><p><em>Применение:</em> Автоматическое обнаружение деградации производительности в production, контроль качества.</p>",
    difficulty: 'senior',
    tags: ['PerformanceObserver', 'Performance Budget', 'мониторинг', 'автоматизация']
  },
  {
    id: 151,
    question: "Что такое Web Worker и для чего он используется?",
    answer: "<p><strong>Web Worker</strong> — это Web API для выполнения JavaScript в фоновых потоках, отдельно от основного потока браузера:</p><h4>Основное назначение:</h4><p>Позволяет выполнять тяжелые вычисления без блокировки UI, сохраняя отзывчивость приложения. Worker работает в отдельном глобальном контексте и не имеет доступа к DOM.</p><h4>Создание Worker:</h4><p><code>const worker = new Worker('worker.js');</code></p><h4>Основные применения:</h4><ul><li><strong>Вычисления:</strong> Сложные математические операции, обработка данных</li><li><strong>Обработка файлов:</strong> Парсинг больших JSON, обработка изображений</li><li><strong>Фоновая синхронизация:</strong> Периодическая отправка данных на сервер</li><li><strong>Криптография:</strong> Шифрование/дешифрование без блокировки UI</li><li><strong>Real-time обработка:</strong> Анализ аудио/видео потоков</li></ul><p><em>Ключевое преимущество:</em> Main thread остается свободным для обработки UI событий, анимаций и взаимодействия с пользователем.</p>",
    difficulty: 'junior',
    tags: ['Web Worker', 'основы', 'многопоточность', 'Web API']
  },

  {
    id: 152,
    question: "В каких сценариях использование Web Worker полезно и какие преимущества он дает?",
    answer: "<p>Web Worker решает конкретные проблемы производительности в веб-приложениях:</p><h4>Когда использовать:</h4><p><strong>1. Тяжелые вычисления:</strong> Обработка больших массивов данных, сложные алгоритмы, которые занимают >50ms</p><p><strong>2. Обработка больших файлов:</strong> Парсинг CSV/JSON файлов размером >1MB, компрессия/декомпрессия</p><p><strong>3. Криптографические операции:</strong> Хеширование, шифрование данных</p><p><strong>4. Обработка изображений:</strong> Фильтры, ресайз, конвертация форматов</p><p><strong>5. Real-time анализ:</strong> Обработка WebSocket данных, аудио/видео анализ</p><h4>Преимущества:</h4><ul><li><strong>Отзывчивость UI:</strong> Интерфейс остается плавным во время вычислений</li><li><strong>Параллелизм:</strong> Использование нескольких ядер процессора</li><li><strong>Изоляция:</strong> Ошибки в worker не крашат основной поток</li><li><strong>Производительность:</strong> Снижение нагрузки на main thread</li></ul><h4>Когда НЕ использовать:</h4><ul><li>Простые операции (<10ms)</li><li>Частые обращения к DOM</li><li>Небольшие вычисления с большим объемом передаваемых данных</li></ul><p><em>Правило:</em> Если операция блокирует UI больше чем на 50ms — используйте Web Worker.</p>",
    difficulty: 'junior',
    tags: ['Web Worker', 'применение', 'сценарии', 'производительность']
  },

  {
    id: 153,
    question: "Как Web Worker взаимодействует с основным потоком? Есть ли SharedMemory?",
    answer: "<p>Web Worker работает в полностью изолированном контексте с ограниченным взаимодействием:</p><h4>Взаимодействие через сообщения:</h4><p>Worker и main thread общаются только через систему сообщений (message passing) — данные копируются, а не передаются по ссылке.</p><p><code>// Main thread</code><br><code>worker.postMessage({ data: [1, 2, 3] });</code><br><code>worker.onmessage = (e) => console.log(e.data);</code></p><p><code>// Worker</code><br><code>self.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;const result = process(e.data);</code><br><code>&nbsp;&nbsp;self.postMessage(result);</code><br><code>};</code></p><h4>SharedArrayBuffer — общая память:</h4><p><strong>Да, есть SharedMemory!</strong> С помощью SharedArrayBuffer можно создать общую память между потоками:</p><p><code>const shared = new SharedArrayBuffer(1024);</code><br><code>const view = new Int32Array(shared);</code><br><code>worker.postMessage({ buffer: shared });</code></p><p><strong>Важно:</strong> SharedArrayBuffer требует специальных заголовков сервера для защиты от Spectre:</p><p><code>Cross-Origin-Opener-Policy: same-origin</code><br><code>Cross-Origin-Embedder-Policy: require-corp</code></p><h4>Ограничения доступа:</h4><ul><li><strong>Нет доступа к DOM:</strong> Worker не видит window, document</li><li><strong>Нет прямого доступа:</strong> Нельзя читать переменные main thread напрямую</li><li><strong>Изолированный scope:</strong> У Worker свой глобальный объект (self)</li></ul><p><em>Ключевой момент:</em> По умолчанию данные копируются (structured clone), что может быть медленно для больших объемов — используйте Transferable Objects или SharedArrayBuffer.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'взаимодействие', 'SharedArrayBuffer', 'изоляция']
  },

  {
    id: 154,
    question: "Как передавать данные между основным потоком и Web Worker?",
    answer: "<p>Существует три основных способа передачи данных:</p><h4>1. Structured Clone (копирование):</h4><p><code>// Main thread</code><br><code>worker.postMessage({ data: largeArray });</code></p><p><code>// Worker</code><br><code>self.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;const data = e.data; // Полная копия</code><br><code>};</code></p><p><strong>Особенности:</strong> Данные полностью копируются, что медленно для больших объемов (>1MB)</p><h4>2. Transferable Objects (передача владения):</h4><p><code>const buffer = new ArrayBuffer(1024 * 1024); // 1MB</code><br><code>worker.postMessage({ buffer }, [buffer]);</code><br><code>// buffer теперь недоступен в main thread!</code></p><p><strong>Что можно передавать:</strong></p><ul><li>ArrayBuffer</li><li>MessagePort</li><li>ImageBitmap</li><li>OffscreenCanvas</li></ul><p><strong>Преимущество:</strong> Мгновенная передача, данные перемещаются без копирования</p><h4>3. SharedArrayBuffer (общая память):</h4><p><code>const shared = new SharedArrayBuffer(1024);</code><br><code>const view = new Int32Array(shared);</code><br><code></code><br><code>worker.postMessage({ buffer: shared });</code><br><code>// Оба потока видят одну память</code><br><code>view[0] = 42; // Изменения видны в worker</code></p><p><strong>Синхронизация через Atomics:</strong></p><p><code>Atomics.store(view, 0, 123);</code><br><code>Atomics.wait(view, 0, 0); // Блокирующее ожидание</code></p><h4>Сравнение производительности:</h4><ul><li><strong>Structured Clone:</strong> Медленно для больших данных, безопасно</li><li><strong>Transferable:</strong> Мгновенно, но теряется доступ в исходном потоке</li><li><strong>SharedArrayBuffer:</strong> Мгновенно, общий доступ, требует синхронизации</li></ul><p><em>Best practice:</em> Используйте Transferable для больших одноразовых данных, SharedArrayBuffer для постоянного обмена.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'передача данных', 'Transferable', 'postMessage']
  },

  {
    id: 155,
    question: "Как использовать несколько Web Workers для распределения задач?",
    answer: "<p>Распределение задач на несколько workers позволяет максимально использовать многоядерные процессоры:</p><h4>Создание пула workers:</h4><p><code>class WorkerPool {</code><br><code>&nbsp;&nbsp;constructor(workerScript, size = 4) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.workers = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.taskQueue = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < size; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const worker = new Worker(workerScript);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.workers.push({ worker, busy: false });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async execute(data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const availableWorker = this.workers.find(w => !w.busy);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (availableWorker) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.runTask(availableWorker, data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Ждем освобождения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise(resolve => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.taskQueue.push({ data, resolve });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;runTask(workerInfo, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workerInfo.busy = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workerInfo.worker.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workerInfo.busy = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(e.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.processQueue();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workerInfo.worker.postMessage(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;processQueue() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.taskQueue.length === 0) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const worker = this.workers.find(w => !w.busy);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (worker) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const task = this.taskQueue.shift();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.runTask(worker, task.data).then(task.resolve);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование пула:</h4><p><code>const pool = new WorkerPool('worker.js', 4);</code><br><code></code><br><code>// Параллельная обработка массива</code><br><code>const tasks = items.map(item => pool.execute(item));</code><br><code>const results = await Promise.all(tasks);</code></p><h4>Автоопределение количества workers:</h4><p><code>const workerCount = navigator.hardwareConcurrency || 4;</code><br><code>const pool = new WorkerPool('worker.js', workerCount);</code></p><p><em>Best practice:</em> Количество workers ≈ количество ядер CPU минус 1-2 для main thread.</p>",
    difficulty: 'senior',
    tags: ['Web Worker', 'пул', 'параллелизм', 'масштабирование']
  },

  {
    id: 156,
    question: "В чем разница между Dedicated Worker, Shared Worker и Service Worker?",
    answer: "<p>Существует три типа Web Workers с разным назначением:</p><h4>1. Dedicated Worker:</h4><p><code>const worker = new Worker('worker.js');</code></p><p><strong>Особенности:</strong></p><ul><li>Привязан к одной вкладке/окну</li><li>Умирает при закрытии вкладки</li><li>Простой в использовании</li><li>Для вычислений в рамках одной страницы</li></ul><h4>2. Shared Worker:</h4><p><code>const worker = new SharedWorker('shared.js');</code><br><code>worker.port.postMessage('data');</code></p><p><strong>Особенности:</strong></p><ul><li>Общий для всех вкладок одного origin</li><li>Живет пока открыта хоть одна вкладка</li><li>Коммуникация через MessagePort</li><li>Для координации между вкладками</li></ul><h4>3. Service Worker:</h4><p><code>navigator.serviceWorker.register('sw.js');</code></p><p><strong>Особенности:</strong></p><ul><li>Работает как прокси между приложением и сетью</li><li>Может работать в фоне без открытых вкладок</li><li>Для кэширования, offline, push уведомлений</li><li>Более сложный lifecycle</li></ul><h4>Сравнительная таблица:</h4><table><tr><th>Тип</th><th>Scope</th><th>Жизнь</th><th>Применение</th></tr><tr><td>Dedicated</td><td>Одна вкладка</td><td>Пока открыта вкладка</td><td>Вычисления</td></tr><tr><td>Shared</td><td>Все вкладки</td><td>Пока открыта вкладка</td><td>Синхронизация</td></tr><tr><td>Service</td><td>Все вкладки + фон</td><td>Управляется браузером</td><td>Офлайн, кэш</td></tr></table><p><em>Выбор:</em> Dedicated для большинства задач, Shared для координации вкладок, Service Worker для PWA функциональности.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'типы', 'Shared Worker', 'Service Worker']
  },

  {
    id: 157,
    question: "Какие API доступны внутри Web Worker и какие ограничения существуют?",
    answer: "<p>Web Worker работает в ограниченном глобальном контексте без доступа к DOM:</p><h4>✅ Доступные API:</h4><ul><li><strong>Сеть:</strong> fetch, XMLHttpRequest, WebSocket</li><li><strong>Хранилище:</strong> IndexedDB, Cache API</li><li><strong>Таймеры:</strong> setTimeout, setInterval, requestAnimationFrame (не везде)</li><li><strong>Криптография:</strong> crypto, SubtleCrypto</li><li><strong>Данные:</strong> ArrayBuffer, TypedArrays, Blob, FileReader</li><li><strong>Утилиты:</strong> console, Performance API, Navigator (частично)</li><li><strong>Импорты:</strong> importScripts, ES modules (с type: 'module')</li></ul><h4>❌ Недоступные API:</h4><ul><li><strong>DOM:</strong> window, document, alert, confirm</li><li><strong>UI:</strong> Canvas (кроме OffscreenCanvas), localStorage</li><li><strong>Навигация:</strong> history, location (только чтение)</li><li><strong>Родитель:</strong> parent, opener</li></ul><h4>Глобальный объект:</h4><p>Вместо window доступен self:</p><p><code>// Worker scope</code><br><code>self.onmessage = (e) => { /* ... */ };</code><br><code>console.log(self.location.href); // ✅</code><br><code>console.log(window); // ❌ undefined</code></p><h4>Импорт скриптов:</h4><p><code>// Синхронный импорт</code><br><code>importScripts('lib1.js', 'lib2.js');</code></p><p><code>// ES modules</code><br><code>new Worker('worker.js', { type: 'module' });</code><br><code>// В worker.js:</code><br><code>import { helper } from './utils.js';</code></p><p><em>Важно:</em> Worker не блокирует UI, но сам по себе однопоточный внутри — тяжелые операции блокируют обработку сообщений.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'API', 'ограничения', 'scope']
  },

  {
    id: 158,
    question: "Как обрабатывать ошибки в Web Worker?",
    answer: "<p>Правильная обработка ошибок критична для стабильности приложения:</p><h4>В main thread:</h4><p><code>worker.onerror = (error) => {</code><br><code>&nbsp;&nbsp;console.error('Worker error:', error.message);</code><br><code>&nbsp;&nbsp;console.error('File:', error.filename);</code><br><code>&nbsp;&nbsp;console.error('Line:', error.lineno);</code><br><code>};</code></p><p><code>worker.onmessageerror = (error) => {</code><br><code>&nbsp;&nbsp;console.error('Message deserialization error:', error);</code><br><code>};</code></p><h4>Внутри worker:</h4><p><code>self.onerror = (error) => {</code><br><code>&nbsp;&nbsp;console.error('Error in worker:', error);</code><br><code>&nbsp;&nbsp;return true; // Предотвращает всплытие в main thread</code><br><code>};</code></p><p><code>self.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const result = heavyComputation(e.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage({ success: true, result });</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage({ </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Promise-based обертка:</h4><p><code>function executeInWorker(data) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const worker = new Worker('worker.js');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.terminate();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.data.success) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(e.data.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error(e.data.error));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.onerror = (error) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.terminate();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.postMessage(data);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Типы ошибок:</h4><ul><li><strong>Syntax Error:</strong> Ошибка в коде worker при загрузке</li><li><strong>Runtime Error:</strong> Ошибка выполнения внутри worker</li><li><strong>Message Error:</strong> Ошибка десериализации данных</li></ul><p><em>Best practice:</em> Всегда оборачивайте обработку сообщений в try-catch и возвращайте структурированные ответы с success флагом.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'ошибки', 'обработка', 'надежность']
  },

  {
    id: 159,
    question: "Как правильно завершать работу Web Worker и избегать утечек памяти?",
    answer: "<p>Корректное завершение worker критично для производительности:</p><h4>Методы завершения:</h4><p><strong>1. terminate() — из main thread:</strong></p><p><code>worker.terminate(); // Немедленное завершение</code></p><p>Убивает worker немедленно без возможности cleanup</p><p><strong>2. close() — изнутри worker:</strong></p><p><code>// Внутри worker</code><br><code>self.close(); // Graceful shutdown</code></p><p>Дает worker завершить текущую операцию</p><h4>Управление lifecycle:</h4><p><code>class ManagedWorker {</code><br><code>&nbsp;&nbsp;constructor(script) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.worker = new Worker(script);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isActive = true;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async execute(data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.isActive) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Worker terminated');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.worker.onmessage = (e) => resolve(e.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.worker.onerror = reject;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.worker.postMessage(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.isActive = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.worker.terminate();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.worker = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>В React:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const worker = new Worker('worker.js');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;worker.onmessage = handleMessage;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.terminate();</code><br><code>&nbsp;&nbsp;};</code><br><code>}, []);</code></p><h4>Graceful shutdown с timeout:</h4><p><code>async function shutdownWorker(worker, timeout = 5000) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Запрос на завершение</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.postMessage({ type: 'shutdown' });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Force terminate через timeout</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timer = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.terminate();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Graceful shutdown</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.data.type === 'shutdown_complete') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timer);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.terminate();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><p><em>Критично:</em> Всегда вызывайте terminate() при размонтировании компонента или завершении работы для предотвращения утечек.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'lifecycle', 'cleanup', 'утечки памяти']
  },

  {
    id: 160,
    question: "Как использовать Comlink для упрощения работы с Web Workers?",
    answer: "<p>Comlink — библиотека, делающая работу с Workers похожей на обычные функции:</p><h4>Без Comlink (традиционный способ):</h4><p><code>// Main thread</code><br><code>worker.postMessage({ method: 'calculate', data: 42 });</code><br><code>worker.onmessage = (e) => console.log(e.data);</code></p><p><code>// Worker</code><br><code>self.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;if (e.data.method === 'calculate') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const result = calculate(e.data.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage(result);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>С Comlink:</h4><p><code>// worker.js</code><br><code>import { expose } from 'comlink';</code><br><code></code><br><code>const api = {</code><br><code>&nbsp;&nbsp;async calculate(n) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return n * 2;</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;process(data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return heavyComputation(data);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code><br><code></code><br><code>expose(api);</code></p><p><code>// main.js</code><br><code>import { wrap } from 'comlink';</code><br><code></code><br><code>const worker = new Worker('worker.js');</code><br><code>const api = wrap(worker);</code><br><code></code><br><code>// Вызов как обычной функции!</code><br><code>const result = await api.calculate(42);</code><br><code>console.log(result); // 84</code></p><h4>Передача callback функций:</h4><p><code>import { wrap, proxy } from 'comlink';</code><br><code></code><br><code>const api = wrap(worker);</code><br><code></code><br><code>await api.processWithCallback(</code><br><code>&nbsp;&nbsp;data,</code><br><code>&nbsp;&nbsp;proxy((progress) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Progress:', progress);</code><br><code>&nbsp;&nbsp;})</code><br><code>);</code></p><h4>Преимущества Comlink:</h4><ul><li>Прозрачная работа с async/await</li><li>Автоматическая сериализация</li><li>Поддержка callback функций</li><li>Type-safe с TypeScript</li><li>Минимальный boilerplate</li></ul><p><em>Рекомендация:</em> Используйте Comlink для сложных взаимодействий с Workers — код становится значительно чище и понятнее.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'Comlink', 'библиотеки', 'упрощение']
  },

  {
    id: 161,
    question: "Как работает OffscreenCanvas с Web Workers?",
    answer: "<p>OffscreenCanvas позволяет рендерить графику в Worker без блокировки UI:</p><h4>Передача canvas в worker:</h4><p><code>// Main thread</code><br><code>const canvas = document.getElementById('canvas');</code><br><code>const offscreen = canvas.transferControlToOffscreen();</code><br><code></code><br><code>const worker = new Worker('worker.js');</code><br><code>worker.postMessage({ canvas: offscreen }, [offscreen]);</code></p><h4>Рендеринг в worker:</h4><p><code>// worker.js</code><br><code>let ctx;</code><br><code></code><br><code>self.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;if (e.data.canvas) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const canvas = e.data.canvas;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ctx = canvas.getContext('2d');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;animate();</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code><br><code></code><br><code>function animate() {</code><br><code>&nbsp;&nbsp;ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);</code><br><code>&nbsp;&nbsp;// Рендеринг без блокировки UI</code><br><code>&nbsp;&nbsp;ctx.fillRect(x, y, 50, 50);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;requestAnimationFrame(animate);</code><br><code>}</code></p><h4>Применения:</h4><ul><li><strong>Игры:</strong> Рендеринг игровой графики</li><li><strong>Визуализации:</strong> Сложные графики в реальном времени</li><li><strong>Обработка изображений:</strong> Фильтры, эффекты</li><li><strong>Видео:</strong> Обработка кадров видео</li></ul><h4>WebGL в worker:</h4><p><code>// worker.js</code><br><code>const gl = canvas.getContext('webgl');</code><br><code>// Полный доступ к WebGL API</code></p><p><em>Преимущество:</em> Тяжелый рендеринг не влияет на отзывчивость UI, используются дополнительные ядра CPU.</p>",
    difficulty: 'senior',
    tags: ['Web Worker', 'OffscreenCanvas', 'рендеринг', 'графика']
  },

  {
    id: 162,
    question: "Как организовать двустороннюю коммуникацию и RPC через Web Worker?",
    answer: "<p>Реализация Remote Procedure Call паттерна для удобной работы с Workers:</p><h4>Базовая RPC реализация:</h4><p><code>// Main thread</code><br><code>class WorkerRPC {</code><br><code>&nbsp;&nbsp;constructor(worker) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.worker = worker;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.messageId = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;worker.onmessage = (e) => this.handleMessage(e);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;call(method, ...args) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const id = this.messageId++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.set(id, { resolve, reject });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.worker.postMessage({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'call',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleMessage(e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const { id, error, result } = e.data;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const callback = this.callbacks.get(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error ? callback.reject(error) : callback.resolve(result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Worker side:</h4><p><code>// worker.js</code><br><code>const api = {</code><br><code>&nbsp;&nbsp;add: (a, b) => a + b,</code><br><code>&nbsp;&nbsp;multiply: (a, b) => a * b</code><br><code>};</code><br><code></code><br><code>self.onmessage = async (e) => {</code><br><code>&nbsp;&nbsp;const { id, method, args } = e.data;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const result = await api[method](...args);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage({ id, result });</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;self.postMessage({ id, error: error.message });</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>const worker = new Worker('worker.js');</code><br><code>const rpc = new WorkerRPC(worker);</code><br><code></code><br><code>const sum = await rpc.call('add', 5, 3);</code><br><code>const product = await rpc.call('multiply', 4, 7);</code></p><p><em>Преимущество:</em> Чистый API похожий на обычные функции, автоматическая обработка async операций.</p>",
    difficulty: 'senior',
    tags: ['Web Worker', 'RPC', 'коммуникация', 'паттерны']
  },

  {
    id: 163,
    question: "Как отлаживать Web Workers в DevTools?",
    answer: "<p>Chrome DevTools предоставляют инструменты для отладки Workers:</p><h4>В Chrome DevTools:</h4><p><strong>1. Sources Tab:</strong></p><ul><li>Workers отображаются отдельно в дереве источников</li><li>Можно ставить breakpoints</li><li>Step-by-step debugging работает</li></ul><p><strong>2. Application Tab:</strong></p><ul><li>Service Workers: статус, lifecycle, события</li><li>Shared Workers: список активных</li></ul><p><strong>3. Console:</strong></p><p><code>console.log</code> из worker отображается с префиксом Worker</p><h4>Логирование с контекстом:</h4><p><code>// worker.js</code><br><code>const log = (msg) => {</code><br><code>&nbsp;&nbsp;console.log('[Worker]', msg);</code><br><code>};</code><br><code></code><br><code>log('Processing started');</code></p><h4>Профилирование производительности:</h4><p><code>// В worker</code><br><code>performance.mark('compute-start');</code><br><code>heavyComputation();</code><br><code>performance.mark('compute-end');</code><br><code>performance.measure('compute', 'compute-start', 'compute-end');</code><br><code></code><br><code>// Отправка метрик в main thread</code><br><code>const entries = performance.getEntriesByType('measure');</code><br><code>self.postMessage({ type: 'perf', entries });</code></p><h4>Debugging tips:</h4><ul><li>Используйте <code>debugger;</code> statement в worker</li><li>Логируйте сообщения при postMessage</li><li>Проверяйте Console на ошибки загрузки worker</li><li>Используйте Performance tab для анализа</li></ul><p><em>Совет:</em> При ошибке загрузки worker проверьте путь к файлу и CORS заголовки.</p>",
    difficulty: 'middle',
    tags: ['Web Worker', 'отладка', 'DevTools', 'debugging']
  },

  {
    id: 164,
    question: "Какие есть best practices и подводные камни при работе с Web Workers?",
    answer: "<p>При работе с Web Workers важно следовать best practices:</p><h4>✅ Best Practices:</h4><p><strong>1. Используйте Transferable Objects:</strong></p><p><code>// ✅ Быстро</code><br><code>worker.postMessage({ buffer }, [buffer]);</code></p><p><strong>2. Переиспользуйте workers:</strong></p><p><code>// ✅ Создаем пул</code><br><code>const pool = new WorkerPool('worker.js', 4);</code></p><p><strong>3. Всегда terminate при cleanup:</strong></p><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const worker = new Worker('worker.js');</code><br><code>&nbsp;&nbsp;return () => worker.terminate();</code><br><code>}, []);</code></p><p><strong>4. Минимизируйте передачу данных:</strong></p><p><code>// ✅ Передаем только ID</code><br><code>worker.postMessage({ userId: 123 });</code><br><code>// Worker сам загрузит данные через fetch</code></p><p><strong>5. Обрабатывайте ошибки:</strong></p><p><code>worker.onerror = (e) => handleError(e);</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Overhead при частой коммуникации:</strong></p><p><code>// ❌ Плохо - много мелких сообщений</code><br><code>items.forEach(item => worker.postMessage(item));</code><br><code></code><br><code>// ✅ Лучше - батчинг</code><br><code>worker.postMessage(items);</code></p><p><strong>2. Копирование больших данных:</strong></p><p><code>// ❌ Медленно</code><br><code>worker.postMessage(largeArray);</code><br><code></code><br><code>// ✅ Быстро</code><br><code>const buffer = largeArray.buffer;</code><br><code>worker.postMessage({ buffer }, [buffer]);</code></p><p><strong>3. Забытый terminate:</strong></p><p><code>// ❌ Утечка памяти</code><br><code>const worker = new Worker('worker.js');</code><br><code>// Никогда не вызывается terminate!</code></p><p><strong>4. Блокирующие операции в worker:</strong></p><p><code>// ❌ Блокирует обработку сообщений</code><br><code>while (heavyLoop()) { /* ... */ }</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не terminate при размонтировании</li><li>Копирование вместо transfer</li><li>Частая коммуникация с маленькими данными</li><li>Игнорирование ошибок worker</li><li>Создание нового worker для каждой задачи</li></ol><p><em>Золотое правило:</em> Worker для CPU-тяжелых операций (>50ms), не для частой коммуникации.</p>",
    difficulty: 'senior',
    tags: ['Web Worker', 'best practices', 'подводные камни', 'оптимизация']
  },

  {
    id: 165,
    question: "Как измерить и оптимизировать производительность Web Workers?",
    answer: "<p>Правильное измерение помогает понять эффективность использования Workers:</p><h4>Измерение времени выполнения:</h4><p><code>// Main thread</code><br><code>const start = performance.now();</code><br><code></code><br><code>worker.postMessage(data);</code><br><code>worker.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;const total = performance.now() - start;</code><br><code>&nbsp;&nbsp;console.log('Total time:', total);</code><br><code>};</code></p><h4>Детальное профилирование:</h4><p><code>class WorkerProfiler {</code><br><code>&nbsp;&nbsp;async measure(worker, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const metrics = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializationTime: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transferTime: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computeTime: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalTime: 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const totalStart = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Измерение сериализации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const serStart = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const serialized = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;metrics.serializationTime = performance.now() - serStart;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.onmessage = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metrics.totalTime = performance.now() - totalStart;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metrics.computeTime = e.data.computeTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(metrics);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker.postMessage(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Оптимизация:</h4><p><strong>1. Минимизируйте передачу данных:</strong></p><p><code>// ❌ Плохо</code><br><code>worker.postMessage({ array: [1,2,3,...10000] });</code><br><code></code><br><code>// ✅ Лучше</code><br><code>worker.postMessage({ start: 1, end: 10000 });</code></p><p><strong>2. Используйте Worker pool:</strong></p><p>Переиспользование workers быстрее создания новых</p><p><strong>3. Батчинг задач:</strong></p><p><code>// ✅ Одна большая задача вместо многих маленьких</code><br><code>worker.postMessage({ tasks: [task1, task2, ...] });</code></p><p><strong>4. SharedArrayBuffer для частого обмена:</strong></p><p>Избегает копирования при частой коммуникации</p><h4>Когда worker не нужен:</h4><ul><li>Операция < 50ms</li><li>Overhead передачи > времени вычислений</li><li>Частая коммуникация с маленькими данными</li></ul><p><em>Правило:</em> Измеряйте всегда — иногда worker медленнее синхронного кода из-за overhead.</p>",
    difficulty: 'senior',
    tags: ['Web Worker', 'производительность', 'оптимизация', 'профилирование']
  }
];
