export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 50,
    question: "Как работают CSRF атаки и какой механизм они эксплуатируют?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> эксплуатирует доверие сервера к браузеру пользователя.</p><p><strong>Базовый принцип атаки:</strong></p><ol><li>Пользователь залогинен на сайте victim.com</li><li>Браузер хранит session cookie для victim.com</li><li>Пользователь посещает злонамеренный сайт evil.com</li><li>evil.com создает запрос к victim.com</li><li>Браузер автоматически прикрепляет cookies</li><li>victim.com думает что это легитимный запрос</li><li>Действие выполняется от имени пользователя</li></ol><p><strong>Почему это работает:</strong></p><ul><li>Браузер автоматически отправляет cookies с КАЖДЫМ запросом</li><li>Не важно откуда исходит запрос</li><li>Сервер видит валидную аутентификацию</li><li>Нет способа отличить источник запроса только по cookies</li></ul><p><strong>Типичный сценарий атаки:</strong></p><p><strong>Перевод денег:</strong></p><ol><li>Пользователь залогинен в банке (bank.com)</li><li>Открывает письмо со ссылкой на картинку</li><li>Картинка на самом деле: &lt;img src=\"https://bank.com/transfer?to=attacker&amount=5000\"&gt;</li><li>Браузер делает GET запрос для загрузки \"картинки\"</li><li>Cookies банка отправляются автоматически</li><li>Деньги переведены</li></ol><p><strong>Более сложная атака через форму:</strong></p><ol><li>evil.com содержит скрытую форму</li><li>&lt;form action=\"https://bank.com/transfer\" method=\"POST\"&gt;</li><li>&lt;input name=\"to\" value=\"attacker\"&gt;</li><li>&lt;input name=\"amount\" value=\"5000\"&gt;</li><li>&lt;/form&gt;</li><li>&lt;script&gt;document.forms[0].submit();&lt;/script&gt;</li><li>Форма отправляется автоматически при загрузке</li></ol><p><strong>Требования для успешной CSRF:</strong></p><ul><li>Жертва должна быть авторизована на целевом сайте</li><li>Атакующий должен знать структуру запроса</li><li>Сайт должен полагаться только на cookies для аутентификации</li><li>Запрос должен иметь побочные эффекты (изменение данных)</li></ul><p><strong>Что может сделать CSRF:</strong></p><ul><li>✅ Изменить пароль/email</li><li>✅ Совершить покупку/перевод</li><li>✅ Опубликовать контент</li><li>✅ Удалить данные</li><li>✅ Изменить настройки</li><li>❌ НЕ может читать ответ (Same-Origin Policy)</li><li>❌ НЕ может красть данные напрямую</li></ul><p><strong>Методы которые используют CSRF:</strong></p><p><strong>GET запросы:</strong></p><ul><li>Через img, script, link теги</li><li>Простейшая атака</li><li>Поэтому GET не должен изменять данные</li></ul><p><strong>POST запросы:</strong></p><ul><li>Через автоматически отправляемые формы</li><li>Более сложная но реалистичная</li></ul><p><strong>PUT/DELETE через XHR:</strong></p><ul><li>Требует CORS разрешений</li><li>Обычно блокируется браузером</li><li>Менее распространено</li></ul><p><strong>Почему CSRF опасен:</strong></p><ul><li>Скрытность — жертва не подозревает</li><li>Использует легитимную аутентификацию</li><li>Может привести к финансовым потерям</li><li>Компрометация аккаунтов</li><li>Публикация вредоносного контента</li></ul><p><strong>Факторы снижающие риск:</strong></p><ul><li>Same-Origin Policy — нельзя читать ответ</li><li>CORS — контролирует cross-origin запросы</li><li>SameSite cookies — современная защита</li><li>Preflight для сложных запросов</li></ul><p><strong>Отличие от XSS:</strong></p><ul><li>XSS выполняет код в контексте жертвы</li><li>CSRF заставляет выполнить действие</li><li>XSS может украсть данные</li><li>CSRF только изменяет состояние</li><li>XSS требует уязвимость в приложении</li><li>CSRF работает с любым приложением без защиты</li></ul>",
    difficulty: 'junior',
    tags: ['CSRF', 'атаки', 'механизм', 'cookies', 'безопасность']
  },

  {
    id: 51,
    question: "Какие методы защиты от CSRF существуют и как они работают?",
    answer: "<p><strong>Защита от CSRF</strong> требует проверки что запрос исходит от легитимного источника.</p><p><strong>1. CSRF Tokens (основной метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует уникальный токен для каждой сессии/формы</li><li>Токен вставляется в HTML форму как скрытое поле</li><li>При отправке формы токен проверяется</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li></ul><p><strong>Реализация:</strong></p><ul><li>Server генерирует: csrfToken = randomString()</li><li>HTML: &lt;input type=\"hidden\" name=\"_csrf\" value=\"token123\"&gt;</li><li>Server проверяет: if (req.body._csrf !== session.csrfToken) reject()</li></ul><p><strong>Преимущества:</strong></p><ul><li>Эффективная защита</li><li>Работает для любых запросов</li><li>Широко поддерживается фреймворками</li></ul><p><strong>2. SameSite Cookie атрибут (современный метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Браузер не отправляет cookie в cross-site запросах</li><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>Автоматическая защита на уровне браузера</li></ul><p><strong>Режимы SameSite:</strong></p><ul><li>Strict — максимальная защита, но хуже UX</li><li>Lax — баланс, защищает POST/PUT/DELETE</li><li>None — без защиты (требует Secure)</li></ul><p><strong>Преимущества:</strong></p><ul><li>Простота — один атрибут</li><li>Не требует изменений в коде</li><li>Защита из коробки</li></ul><p><strong>Недостатки:</strong></p><ul><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>3. Double Submit Cookie:</strong></p><p><strong>Как работает:</strong></p><ul><li>Токен хранится И в cookie, И в форме/заголовке</li><li>Server сравнивает оба значения</li><li>Злонамеренный сайт не может установить cookie для другого домена</li></ul><p><strong>Пример:</strong></p><ul><li>Cookie: csrfToken=abc123</li><li>Header: X-CSRF-Token: abc123</li><li>Server проверяет совпадение</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><p><strong>Как работает:</strong></p><ul><li>Origin заголовок содержит источник запроса</li><li>Server проверяет что Origin = ожидаемый домен</li><li>Referer как fallback (менее надежен)</li></ul><p><strong>Реализация:</strong></p><ul><li>const origin = req.headers.origin;</li><li>if (origin !== 'https://trusted-site.com') reject();</li></ul><p><strong>Недостатки:</strong></p><ul><li>Origin может отсутствовать</li><li>Referer может быть отключен пользователем</li><li>Дополнительный слой, не основная защита</li></ul><p><strong>5. Custom Headers для AJAX:</strong></p><p><strong>Как работает:</strong></p><ul><li>Обычные HTML формы не могут устанавливать кастомные заголовки</li><li>Только JavaScript с same-origin может</li><li>Наличие кастомного заголовка = легитимный запрос</li></ul><p><strong>Пример:</strong></p><ul><li>fetch('/api', { headers: { 'X-Requested-With': 'XMLHttpRequest' } })</li><li>Server проверяет наличие заголовка</li></ul><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Подтверждение по email/SMS</li><li>2FA для чувствительных операций</li></ul><p><strong>Комплексная защита (рекомендуется):</strong></p><ul><li>✅ SameSite=Lax для всех cookies</li><li>✅ CSRF токены для форм</li><li>✅ Проверка Origin для дополнительной защиты</li><li>✅ Custom headers для AJAX API</li><li>✅ Re-auth для критичных операций</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Используйте POST/PUT/DELETE для изменяющих операций</li><li>✅ GET запросы должны быть идемпотентными</li><li>✅ Не полагайтесь только на cookies</li><li>✅ Генерируйте криптографически стойкие токены</li><li>✅ Токены должны быть уникальны для каждой сессии</li><li>✅ Проверяйте токены на сервере ВСЕГДА</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'защита', 'токены', 'SameSite', 'безопасность']
  },

  {
    id: 52,
    question: "Что такое X-Frame-Options и как он помогает в безопасности?",
    answer: "<p><strong>X-Frame-Options</strong> — это HTTP заголовок, контролирующий может ли страница отображаться в iframe.</p><p><strong>Зачем нужен X-Frame-Options:</strong></p><ul><li>Защита от Clickjacking атак</li><li>Предотвращение встраивания вашего сайта в iframe</li><li>Контроль над тем, кто может фреймировать контент</li></ul><p><strong>Что такое Clickjacking:</strong></p><ol><li>Злонамеренный сайт встраивает ваш сайт в невидимый iframe</li><li>Накладывает свой контент поверх</li><li>Пользователь думает что кликает на кнопку evil.com</li><li>На самом деле кликает на банк.com в iframe</li><li>Выполняется нежелательное действие</li></ol><p><strong>Значения X-Frame-Options:</strong></p><p><strong>DENY:</strong></p><ul><li>X-Frame-Options: DENY</li><li>Страница не может быть во фрейме НИКОГДА</li><li>Даже на том же домене</li><li>Максимальная защита</li></ul><p><strong>SAMEORIGIN:</strong></p><ul><li>X-Frame-Options: SAMEORIGIN</li><li>Только страницы с того же origin могут фреймировать</li><li>Позволяет внутреннее использование iframe</li><li>Блокирует сторонние сайты</li></ul><p><strong>ALLOW-FROM uri (устарело):</strong></p><ul><li>X-Frame-Options: ALLOW-FROM https://trusted.com</li><li>Разрешить конкретному домену</li><li>❌ Не поддерживается большинством браузеров</li><li>Не рекомендуется использовать</li></ul><p><strong>Как это защищает:</strong></p><ul><li>Браузер проверяет заголовок</li><li>Если политика нарушена — не отображает фрейм</li><li>Показывает пустой фрейм или ошибку</li><li>Злонамеренный сайт не может встроить контент</li></ul><p><strong>Примеры атак которые предотвращает:</strong></p><p><strong>Clickjacking на банк:</strong></p><ul><li>evil.com встраивает bank.com/transfer</li><li>Накладывает кнопку \"Скачать бесплатно\"</li><li>Пользователь кликает думая что скачивает</li><li>На самом деле переводит деньги</li><li>X-Frame-Options блокирует встраивание</li></ul><p><strong>Кража лайков/подписок:</strong></p><ul><li>Социальная сеть во фрейме</li><li>Невидимая кнопка \"Подписаться\"</li><li>Пользователь думает что кликает на что-то другое</li><li>Подписывается на спам-аккаунт</li></ul><p><strong>Современная альтернатива — CSP frame-ancestors:</strong></p><p><strong>Content-Security-Policy:</strong></p><ul><li>Content-Security-Policy: frame-ancestors 'none'</li><li>Эквивалент X-Frame-Options: DENY</li><li>frame-ancestors 'self' — эквивалент SAMEORIGIN</li><li>frame-ancestors https://trusted.com — разрешить домен</li></ul><p><strong>Преимущества CSP frame-ancestors:</strong></p><ul><li>Более гибкий — можно указать несколько доменов</li><li>Лучше поддерживается</li><li>Часть общей CSP политики</li></ul><p><strong>Использовать оба заголовка:</strong></p><ul><li>X-Frame-Options для старых браузеров</li><li>CSP frame-ancestors для новых</li><li>Defense in depth</li></ul><p><strong>Когда НЕ использовать:</strong></p><ul><li>Сайты которые должны встраиваться (виджеты, OAuth)</li><li>Платежные формы которые используются в iframe</li><li>Встраиваемый контент как YouTube</li></ul><p><strong>Для таких случаев:</strong></p><ul><li>Использовать ALLOW-FROM (CSP) для конкретных партнеров</li><li>Или вообще не устанавливать заголовок</li><li>Но применить другие меры безопасности</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: X-Frame-Options: DENY</li><li>✅ Для внутренних iframe: SAMEORIGIN</li><li>✅ Добавить CSP frame-ancestors тоже</li><li>✅ Тестировать что легитимные iframe работают</li><li>✅ Применять на всех страницах</li></ul>",
    difficulty: 'middle',
    tags: ['X-Frame-Options', 'Clickjacking', 'безопасность', 'iframe', 'заголовки']
  },

  {
    id: 53,
    question: "Как работает защита от XSS во фреймворках (React, Vue, Angular)?",
    answer: "<p><strong>Современные фреймворки</strong> имеют встроенную защиту от XSS, но её нужно правильно использовать.</p><p><strong>React:</strong></p><p><strong>Автоматическое экранирование в JSX:</strong></p><ul><li>Все значения в {} автоматически экранируются</li><li>const name = '&lt;script&gt;alert()&lt;/script&gt;';</li><li>&lt;div&gt;{name}&lt;/div&gt; — безопасно, отобразится как текст</li><li>React преобразует в HTML entities</li></ul><p><strong>Опасность dangerouslySetInnerHTML:</strong></p><ul><li>❌ &lt;div dangerouslySetInnerHTML={{__html: userInput}} /&gt;</li><li>Полностью отключает защиту</li><li>Позволяет внедрить HTML и скрипты</li><li>Использовать только для доверенного контента</li></ul><p><strong>Безопасная альтернатива:</strong></p><ul><li>Использовать библиотеку DOMPurify</li><li>const clean = DOMPurify.sanitize(userInput);</li><li>&lt;div dangerouslySetInnerHTML={{__html: clean}} /&gt;</li></ul><p><strong>Безопасность атрибутов:</strong></p><ul><li>❌ &lt;div className={userInput}&gt; — может быть опасно</li><li>❌ &lt;a href={userInput}&gt; — javascript: URLs опасны</li><li>✅ Валидировать URL перед использованием</li></ul><p><strong>Vue:</strong></p><p><strong>Автоматическое экранирование в шаблонах:</strong></p><ul><li>{{ userInput }} — автоматически экранируется</li><li>Vue преобразует HTML в безопасный текст</li><li>Защита по умолчанию</li></ul><p><strong>v-html директива (опасно):</strong></p><ul><li>❌ &lt;div v-html=\"userInput\"&gt;&lt;/div&gt;</li><li>Рендерит HTML без экранирования</li><li>Уязвимо к XSS если userInput от пользователя</li><li>Только для доверенного контента</li></ul><p><strong>Безопасные практики Vue:</strong></p><ul><li>✅ Использовать {{ }} для текста</li><li>✅ v-text для текстового контента</li><li>✅ Санитизация перед v-html</li></ul><p><strong>Динамические атрибуты:</strong></p><ul><li>:href=\"userUrl\" — нужна валидация</li><li>Проверять на javascript: протокол</li></ul><p><strong>Angular:</strong></p><p><strong>Встроенный DomSanitizer:</strong></p><ul><li>Angular автоматически санитизирует значения</li><li>{{ userInput }} — безопасно</li><li>[innerHTML]=\"userInput\" — автоматически очищается</li></ul><p><strong>Контексты санитизации:</strong></p><ul><li>HTML — для innerHTML</li><li>Style — для [style]</li><li>URL — для [src], [href]</li><li>Resource URL — для &lt;script&gt;, &lt;iframe&gt;</li></ul><p><strong>Bypass санитизации (осторожно!):</strong></p><ul><li>this.sanitizer.bypassSecurityTrustHtml(value)</li><li>❌ Отключает защиту</li><li>Только для проверенного контента</li></ul><p><strong>Общие правила для всех фреймворков:</strong></p><p><strong>1. Доверяйте встроенной защите:</strong></p><ul><li>✅ Используйте стандартные способы вывода</li><li>✅ Не отключайте санитизацию без причины</li></ul><p><strong>2. Rich Text редакторы:</strong></p><ul><li>Используйте whitelist разрешенных тегов</li><li>Библиотеки: DOMPurify, sanitize-html</li><li>Серверная валидация тоже</li></ul><p><strong>3. Атрибуты требуют внимания:</strong></p><ul><li>href, src, style могут быть опасны</li><li>Валидировать URL (не javascript:, не data:)</li><li>Проверять на event handlers (onclick и т.д.)</li></ul><p><strong>4. Server-Side Rendering:</strong></p><ul><li>Те же правила применяются</li><li>Санитизация на сервере</li><li>Не доверять клиентским данным</li></ul><p><strong>Антипаттерны (избегать):</strong></p><ul><li>❌ eval() с пользовательским вводом</li><li>❌ new Function() с пользовательским кодом</li><li>❌ Отключение санитизации \"для удобства\"</li><li>❌ Доверие данным из URL параметров</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Понимать как работает защита фреймворка</li><li>✅ Не обходить защиту без веской причины</li><li>✅ Использовать DOMPurify для rich text</li><li>✅ Валидировать URLs и атрибуты</li><li>✅ CSP как дополнительный слой</li><li>✅ Code review на опасные паттерны</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'React', 'Vue', 'Angular', 'фреймворки']
  },

  {
    id: 54,
    question: "Какие инструменты существуют для обнаружения XSS и CSRF уязвимостей?",
    answer: "<p><strong>Инструменты для обнаружения уязвимостей</strong> делятся на автоматические сканеры, ручные инструменты и библиотеки.</p><p><strong>Автоматические сканеры безопасности:</strong></p><p><strong>1. OWASP ZAP (Zed Attack Proxy):</strong></p><ul><li>Бесплатный open-source сканер</li><li>Автоматическое сканирование на XSS, CSRF, SQL injection</li><li>Интерактивный прокси для ручного тестирования</li><li>Fuzzing для поиска уязвимостей</li><li>Интеграция в CI/CD</li></ul><p><strong>Использование:</strong></p><ul><li>Запустить прокси</li><li>Направить браузер через ZAP</li><li>Автоматическое сканирование или ручное тестирование</li><li>Отчет с найденными уязвимостями</li></ul><p><strong>2. Burp Suite:</strong></p><ul><li>Профессиональный инструмент (платная версия)</li><li>Community edition бесплатно</li><li>Интерцептор запросов</li><li>Сканер уязвимостей</li><li>Repeater для модификации запросов</li></ul><p><strong>3. Acunetix:</strong></p><ul><li>Коммерческий сканер</li><li>Автоматическое обнаружение XSS, CSRF</li><li>Deep scan для сложных приложений</li><li>Детальные отчеты</li></ul><p><strong>4. Netsparker:</strong></p><ul><li>Автоматический сканер</li><li>Proof-based сканирование</li><li>Минимум ложных срабатываний</li></ul><p><strong>Инструменты для разработки:</strong></p><p><strong>1. ESLint плагины для безопасности:</strong></p><ul><li>eslint-plugin-security</li><li>eslint-plugin-no-unsanitized</li><li>Обнаруживает опасные паттерны в коде</li><li>Предупреждает о dangerouslySetInnerHTML</li></ul><p><strong>Пример конфигурации:</strong></p><ul><li>rules: { 'no-unsanitized/method': 'error', 'no-unsanitized/property': 'error' }</li></ul><p><strong>2. SonarQube:</strong></p><ul><li>Статический анализ кода</li><li>Обнаружение security hotspots</li><li>Интеграция в CI/CD</li><li>Отчеты по качеству и безопасности</li></ul><p><strong>3. Snyk:</strong></p><ul><li>Сканирование зависимостей</li><li>Обнаружение уязвимостей в библиотеках</li><li>Автоматические PR с фиксами</li></ul><p><strong>Browser DevTools расширения:</strong></p><p><strong>1. XSS Hunter:</strong></p><ul><li>Обнаружение blind XSS</li><li>Callback когда payload сработал</li><li>Полезно для сложных сценариев</li></ul><p><strong>2. CSP Evaluator:</strong></p><ul><li>Проверка Content Security Policy</li><li>Рекомендации по улучшению</li><li>Обнаружение слабых мест в CSP</li></ul><p><strong>Ручное тестирование:</strong></p><p><strong>Payloads для XSS тестирования:</strong></p><ul><li>&lt;script&gt;alert('XSS')&lt;/script&gt;</li><li>&lt;img src=x onerror=alert('XSS')&gt;</li><li>&lt;svg onload=alert('XSS')&gt;</li><li>javascript:alert('XSS')</li></ul><p><strong>Тестирование различных контекстов:</strong></p><ul><li>HTML контекст</li><li>Атрибуты</li><li>JavaScript строки</li><li>CSS</li><li>URL параметры</li></ul><p><strong>CSRF тестирование:</strong></p><ul><li>Удалить CSRF токен и отправить запрос</li><li>Использовать токен из другой сессии</li><li>Проверить работает ли SameSite cookie</li><li>Изменить Origin заголовок</li></ul><p><strong>CI/CD интеграция:</strong></p><p><strong>GitHub Actions пример:</strong></p><ul><li>- uses: zaproxy/action-baseline@v0.4.0</li><li>with: target: https://your-app.com</li><li>Автоматический скан при каждом PR</li></ul><p><strong>Библиотеки для санитизации:</strong></p><p><strong>DOMPurify:</strong></p><ul><li>Очистка HTML от XSS</li><li>const clean = DOMPurify.sanitize(dirty);</li><li>Используется на клиенте</li></ul><p><strong>sanitize-html (Node.js):</strong></p><ul><li>Серверная санитизация</li><li>Whitelist тегов и атрибутов</li></ul><p><strong>Мониторинг в production:</strong></p><p><strong>1. Content Security Policy Reports:</strong></p><ul><li>CSP: report-uri /csp-violations</li><li>Браузер отправляет отчет при блокировке</li><li>Обнаружение атак в реальном времени</li></ul><p><strong>2. Web Application Firewall (WAF):</strong></p><ul><li>Cloudflare WAF</li><li>AWS WAF</li><li>Блокирует известные XSS паттерны</li><li>Логирование подозрительных запросов</li></ul><p><strong>3. Security Monitoring:</strong></p><ul><li>Sentry — отслеживание JS ошибок</li><li>LogRocket — session replay</li><li>Обнаружение аномального поведения</li></ul><p><strong>Best practices тестирования:</strong></p><ul><li>✅ Регулярные автоматические сканы</li><li>✅ Ручное penetration testing</li><li>✅ Code review с фокусом на безопасность</li><li>✅ Интеграция в CI/CD</li><li>✅ Тестирование всех user inputs</li><li>✅ Мониторинг CSP violations</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'CSRF', 'инструменты', 'тестирование', 'OWASP ZAP', 'безопасность']
  },

  {
    id: 55,
    question: "Что такое DOM-based XSS и чем он отличается от других типов?",
    answer: "<p><strong>DOM-based XSS</strong> — это тип XSS атаки, где уязвимость находится в клиентском JavaScript коде, а не на сервере.</p><p><strong>Ключевое отличие:</strong></p><ul><li>Вредоносный payload никогда не отправляется на сервер</li><li>Вся атака происходит в браузере</li><li>Уязвимость в коде который манипулирует DOM</li><li>Сервер может быть полностью безопасен</li></ul><p><strong>Как работает DOM-based XSS:</strong></p><ol><li>JavaScript читает данные из ненадежного источника</li><li>Например: URL, location.hash, document.referrer</li><li>Использует эти данные небезопасным способом</li><li>Например: innerHTML, eval(), document.write()</li><li>Вредоносный код выполняется</li></ol><p><strong>Источники ненадежных данных (Sources):</strong></p><ul><li>location.href — весь URL</li><li>location.search — query параметры</li><li>location.hash — fragment после #</li><li>document.referrer — откуда пришел пользователь</li><li>window.name — имя окна</li><li>document.cookie — cookies</li><li>localStorage/sessionStorage</li><li>postMessage данные</li></ul><p><strong>Опасные функции (Sinks):</strong></p><ul><li>element.innerHTML = source</li><li>element.outerHTML = source</li><li>document.write(source)</li><li>eval(source)</li><li>setTimeout(source, time)</li><li>setInterval(source, time)</li><li>new Function(source)</li><li>location = source (если source = 'javascript:...')</li></ul><p><strong>Примеры уязвимостей:</strong></p><p><strong>Пример 1 — location.hash:</strong></p><ul><li>// Уязвимый код</li><li>const name = location.hash.substring(1);</li><li>document.getElementById('welcome').innerHTML = 'Hello ' + name;</li><li>// Атака URL</li><li>site.com#&lt;img src=x onerror=alert()&gt;</li></ul><p><strong>Пример 2 — URL параметры:</strong></p><ul><li>// Уязвимый код</li><li>const urlParams = new URLSearchParams(window.location.search);</li><li>const msg = urlParams.get('message');</li><li>document.write(msg);</li><li>// Атака URL</li><li>site.com?message=&lt;script&gt;steal()&lt;/script&gt;</li></ul><p><strong>Пример 3 — eval():</strong></p><ul><li>// Уязвимый код</li><li>const data = location.hash.substring(1);</li><li>eval('var x = ' + data);</li><li>// Атака URL</li><li>site.com#'; maliciousCode(); '</li></ul><p><strong>Почему DOM-based XSS опасен:</strong></p><ul><li>Обходит серверные фильтры (данные не на сервере)</li><li>WAF не помогает</li><li>Сложнее обнаружить обычными сканерами</li><li>Payload может быть в fragment (#), который не отправляется серверу</li></ul><p><strong>Защита от DOM-based XSS:</strong></p><p><strong>1. Избегать опасных Sinks:</strong></p><ul><li>❌ element.innerHTML = userInput</li><li>✅ element.textContent = userInput</li><li>❌ eval(userInput)</li><li>✅ JSON.parse(userInput) для данных</li></ul><p><strong>2. Санитизация перед использованием:</strong></p><ul><li>const clean = DOMPurify.sanitize(location.hash);</li><li>element.innerHTML = clean;</li></ul><p><strong>3. Валидация данных:</strong></p><ul><li>Проверить что URL параметр содержит ожидаемые значения</li><li>Whitelist разрешенных значений</li><li>Reject неожиданные данные</li></ul><p><strong>4. Безопасные альтернативы:</strong></p><ul><li>createElement() вместо innerHTML</li><li>setAttribute() вместо прямой манипуляции</li><li>textContent вместо innerHTML для текста</li></ul><p><strong>5. Content Security Policy:</strong></p><ul><li>CSP: script-src 'self' 'nonce-...'</li><li>Блокирует eval(), inline событий</li><li>Дополнительный уровень защиты</li></ul><p><strong>Отличия от Stored/Reflected XSS:</strong></p><table><tr><th>Аспект</th><th>DOM-based</th><th>Stored/Reflected</th></tr><tr><td>Уязвимость</td><td>Клиентский JS</td><td>Серверный код</td></tr><tr><td>Payload хранение</td><td>URL, fragment</td><td>БД или URL</td></tr><tr><td>Серверная роль</td><td>Минимальная</td><td>Основная</td></tr><tr><td>WAF защита</td><td>Не помогает</td><td>Может помочь</td></tr><tr><td>Обнаружение</td><td>Сложнее</td><td>Проще</td></tr></table><p><strong>Best practices:</strong></p><ul><li>✅ Аудит клиентского JavaScript кода</li><li>✅ Избегать опасных функций</li><li>✅ Валидировать все source данные</li><li>✅ Использовать безопасные API</li><li>✅ CSP для дополнительной защиты</li><li>✅ Статический анализ кода</li></ul>",
    difficulty: 'senior',
    tags: ['XSS', 'DOM-based XSS', 'клиентская безопасность', 'JavaScript']
  },

  {
    id: 56,
    question: "Как работает защита SameSite для cookies и почему она важна для CSRF?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, контролирующий отправку в cross-site запросах.</p><p><strong>Три режима SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же registered domain</li><li>НЕ отправляется даже при клике по ссылке с другого сайта</li></ul><p><strong>Пример:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Strict</li><li>Пользователь на google.com</li><li>Кликает ссылку на bank.com</li><li>Cookie НЕ отправится при первом запросе</li><li>Пользователь увидит \"не залогинен\"</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы</li></ul><p><strong>2. SameSite=Lax (баланс, по умолчанию):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><p><strong>Отправляется:</strong></p><ul><li>✅ Клик по ссылке (GET)</li><li>✅ window.location = \"...\" (GET)</li><li>✅ &lt;form method=\"GET\"&gt;</li></ul><p><strong>НЕ отправляется:</strong></p><ul><li>❌ &lt;form method=\"POST\"&gt; с другого сайта</li><li>❌ fetch/XHR запросы cross-site</li><li>❌ &lt;img src=...&gt; на другом домене</li><li>❌ &lt;iframe&gt; с другого домена</li></ul><p><strong>Пример защиты от CSRF:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com пытается: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Cookie НЕ отправится</li><li>Запрос не авторизован</li><li>CSRF атака провалилась</li></ul><p><strong>3. SameSite=None (без защиты):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ВСЕГДА</li><li>В same-site и cross-site запросах</li><li>Как было до введения SameSite</li></ul><p><strong>Требования:</strong></p><ul><li>ОБЯЗАТЕЛЬНО нужен атрибут Secure</li><li>Set-Cookie: widget=xyz; SameSite=None; Secure</li><li>Только HTTPS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Встраиваемые виджеты (чаты, комментарии)</li><li>OAuth flows в iframe</li><li>Платежные формы third-party</li><li>Cross-site API с credentials</li></ul><p><strong>Как SameSite защищает от CSRF:</strong></p><p><strong>Традиционная CSRF атака:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc (без SameSite)</li><li>evil.com: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Браузер отправляет cookie</li><li>Деньги переведены ✗</li></ol><p><strong>С SameSite=Lax:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com: &lt;form method=\"POST\"&gt;</li><li>Браузер НЕ отправляет cookie (cross-site POST)</li><li>Запрос не авторизован ✓</li></ol><p><strong>Современные браузеры и SameSite:</strong></p><ul><li>Chrome 80+ (2020): SameSite=Lax по умолчанию</li><li>Firefox 69+: SameSite=Lax по умолчанию</li><li>Edge: следует за Chrome</li><li>Safari: свои правила ITP</li></ul><p><strong>Если не указан SameSite:</strong></p><ul><li>Современные браузеры: SameSite=Lax автоматически</li><li>Старые браузеры: нет защиты (как SameSite=None)</li></ul><p><strong>Миграция на SameSite:</strong></p><p><strong>Шаг 1 — Аудит cookies:</strong></p><ul><li>Какие cookies используются</li><li>Нужен ли cross-site доступ</li></ul><p><strong>Шаг 2 — Установить правильные значения:</strong></p><ul><li>Auth cookies: SameSite=Lax</li><li>Критичные: SameSite=Strict</li><li>Виджеты: SameSite=None; Secure</li></ul><p><strong>Шаг 3 — Тестирование:</strong></p><ul><li>Проверить функциональность</li><li>Особенно cross-site сценарии</li></ul><p><strong>Комбинация с другими методами:</strong></p><ul><li>SameSite — первая линия защиты от CSRF</li><li>CSRF токены — дополнительная защита</li><li>Origin проверка — еще один слой</li><li>Defense in depth подход</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: SameSite=Lax</li><li>✅ Критичные операции: SameSite=Strict</li><li>✅ Cross-site widgets: SameSite=None; Secure</li><li>✅ Всегда тестировать после изменений</li><li>✅ Использовать с CSRF токенами</li></ul>",
    difficulty: 'middle',
    tags: ['SameSite', 'cookies', 'CSRF', 'защита', 'безопасность']
  },

  {
    id: 57,
    question: "Что такое Trusted Types API и как он помогает предотвратить DOM-based XSS?",
    answer: "<p><strong>Trusted Types</strong> — это Web API для предотвращения DOM-based XSS атак путем контроля над опасными операциями с DOM.</p><p><strong>Основная идея:</strong></p><ul><li>Браузер блокирует опасные DOM операции по умолчанию</li><li>Разрешаются только \"trusted\" (доверенные) значения</li><li>Trusted значения создаются через специальные политики</li><li>Принудительная санитизация на уровне браузера</li></ul><p><strong>Проблема которую решает:</strong></p><ul><li>Разработчики забывают санитизировать данные</li><li>Случайное использование небезопасных API</li><li>innerHTML = userInput — часто встречающаяся ошибка</li><li>Trusted Types делает это невозможным</li></ul><p><strong>Как работает:</strong></p><p><strong>Шаг 1 — Включение через CSP:</strong></p><ul><li>Content-Security-Policy: require-trusted-types-for 'script'</li><li>Браузер начинает требовать Trusted Types</li><li>Опасные операции без trusted значений блокируются</li></ul><p><strong>Шаг 2 — Создание политики:</strong></p><ul><li>const policy = trustedTypes.createPolicy('myPolicy', {</li><li>  createHTML: (input) => DOMPurify.sanitize(input),</li><li>  createScriptURL: (input) => { /* валидация */ return input; }</li><li>});</li></ul><p><strong>Шаг 3 — Использование:</strong></p><ul><li>// ❌ Без Trusted Types — заблокировано</li><li>element.innerHTML = userInput; // TypeError!</li><li>// ✅ С Trusted Types — работает</li><li>element.innerHTML = policy.createHTML(userInput);</li></ul><p><strong>Типы Trusted объектов:</strong></p><p><strong>TrustedHTML:</strong></p><ul><li>Для innerHTML, outerHTML, insertAdjacentHTML</li><li>createHTML(input) — метод политики</li></ul><p><strong>TrustedScript:</strong></p><ul><li>Для eval(), setTimeout с кодом, new Function()</li><li>createScript(input) — метод политики</li></ul><p><strong>TrustedScriptURL:</strong></p><ul><li>Для &lt;script src=...&gt;, Worker, import()</li><li>createScriptURL(input) — метод политики</li></ul><p><strong>Опасные Sinks требующие Trusted Types:</strong></p><ul><li>Element.innerHTML</li><li>Element.outerHTML</li><li>Element.insertAdjacentHTML()</li><li>Element.setHTML() (новый API)</li><li>document.write()</li><li>document.writeln()</li><li>eval()</li><li>setTimeout() / setInterval() со строкой</li><li>new Function()</li></ul><p><strong>Пример политики с валидацией:</strong></p><ul><li>const policy = trustedTypes.createPolicy('sanitizer', {</li><li>  createHTML(input) {</li><li>    // Санитизация HTML</li><li>    return DOMPurify.sanitize(input, {</li><li>      ALLOWED_TAGS: ['b', 'i', 'p', 'br'],</li><li>      ALLOWED_ATTR: []</li><li>    });</li><li>  },</li><li>  createScriptURL(input) {</li><li>    // Только разрешенные домены</li><li>    const url = new URL(input, document.baseURI);</li><li>    if (url.origin === 'https://cdn.trusted.com') {</li><li>      return input;</li><li>    }</li><li>    throw new TypeError('Invalid script URL');</li><li>  }</li><li>});</li></ul><p><strong>Default Policy:</strong></p><ul><li>Политика по умолчанию если никакая не указана</li><li>trustedTypes.createPolicy('default', { ... })</li><li>Применяется ко всем операциям</li><li>Полезно для legacy кода</li></ul><p><strong>Enforcement режимы:</strong></p><p><strong>Enforcement (строгий):</strong></p><ul><li>CSP: require-trusted-types-for 'script'</li><li>Блокирует опасные операции</li><li>TypeError при нарушении</li></ul><p><strong>Report-Only:</strong></p><ul><li>CSP: require-trusted-types-for 'script'; report-uri /violations</li><li>Не блокирует, только отчитывает</li><li>Для тестирования перед полным включением</li></ul><p><strong>Преимущества Trusted Types:</strong></p><ul><li>✅ Принудительная защита на уровне платформы</li><li>✅ Невозможно забыть санитизировать</li><li>✅ Централизованная логика безопасности</li><li>✅ Обнаружение уязвимостей при разработке</li><li>✅ Защита от DOM-based XSS</li></ul><p><strong>Миграция на Trusted Types:</strong></p><p><strong>Шаг 1 — Report-Only:</strong></p><ul><li>Включить в режиме отчетов</li><li>Собрать все нарушения</li></ul><p><strong>Шаг 2 — Создать политики:</strong></p><ul><li>Написать sanitization логику</li><li>Покрыть все use cases</li></ul><p><strong>Шаг 3 — Рефакторинг кода:</strong></p><ul><li>Заменить опасные операции на политики</li><li>element.innerHTML = policy.createHTML(data)</li></ul><p><strong>Шаг 4 — Enforcement:</strong></p><ul><li>Включить строгий режим</li><li>Мониторить нарушения</li></ul><p><strong>Поддержка браузеров:</strong></p><ul><li>Chrome 83+</li><li>Edge 83+</li><li>Opera 69+</li><li>Нет в Firefox и Safari (пока)</li></ul><p><strong>Polyfill для других браузеров:</strong></p><ul><li>Существует polyfill</li><li>Эмулирует API для совместимости</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Начать с Report-Only режима</li><li>✅ Создать строгие политики санитизации</li><li>✅ Использовать DOMPurify в политиках</li><li>✅ Минимизировать количество политик</li><li>✅ Аудит и review политик</li><li>✅ Мониторинг violations</li></ul>",
    difficulty: 'senior',
    tags: ['Trusted Types', 'DOM-based XSS', 'защита', 'Web API', 'CSP']
  },

  {
    id: 58,
    question: "Какие best practices безопасности нужно соблюдать при работе с пользовательским вводом?",
    answer: "<p><strong>Работа с пользовательским вводом</strong> требует постоянной бдительности и применения принципа \"никогда не доверяй\".</p><p><strong>Принцип \"Never Trust User Input\":</strong></p><ul><li>Любые данные от пользователя потенциально опасны</li><li>Включая данные из URL, форм, cookies, headers</li><li>Даже от \"доверенных\" пользователей</li><li>Валидировать и санитизировать всегда</li></ul><p><strong>1. Input Validation (Валидация входных данных):</strong></p><p><strong>Whitelist подход (предпочтительно):</strong></p><ul><li>Определить что РАЗРЕШЕНО</li><li>Отклонять всё остальное</li><li>Примеры: только буквы, только цифры, конкретный формат</li></ul><p><strong>Типы валидации:</strong></p><ul><li>Тип данных: число, строка, boolean</li><li>Формат: email, URL, дата</li><li>Диапазон: min/max длина, числовые пределы</li><li>Паттерны: регулярные выражения</li></ul><p><strong>2. Output Encoding (Кодирование вывода):</strong></p><p><strong>Context-aware encoding:</strong></p><ul><li>HTML контекст: &lt; → &amp;lt;, &gt; → &amp;gt;</li><li>JavaScript строки: ' → \\', \" → \\\"</li><li>URL параметры: encodeURIComponent()</li><li>CSS: специфичное экранирование</li></ul><p><strong>Кодировать при выводе, не при вводе:</strong></p><ul><li>Хранить данные в оригинальном виде</li><li>Кодировать когда отображаете</li><li>Разное кодирование для разных контекстов</li></ul><p><strong>3. Санитизация (Очистка данных):</strong></p><p><strong>Для HTML:</strong></p><ul><li>Использовать DOMPurify или аналоги</li><li>Whitelist разрешенных тегов</li><li>Удалять опасные атрибуты (onclick, onerror)</li></ul><p><strong>Для других типов:</strong></p><ul><li>SQL: параметризованные запросы</li><li>Shell команды: избегать или тщательно экранировать</li><li>File paths: канонизация, проверка на path traversal</li></ul><p><strong>4. Безопасные API:</strong></p><p><strong>Предпочитать безопасные методы:</strong></p><ul><li>✅ textContent вместо innerHTML</li><li>✅ createElement() вместо innerHTML</li><li>✅ setAttribute() вместо прямой манипуляции</li><li>✅ Параметризованные запросы вместо конкатенации SQL</li></ul><p><strong>Избегать опасных функций:</strong></p><ul><li>❌ eval()</li><li>❌ new Function(userInput)</li><li>❌ innerHTML с неочищенными данными</li><li>❌ document.write()</li><li>❌ setTimeout(stringCode)</li></ul><p><strong>5. Валидация на клиенте И сервере:</strong></p><p><strong>Клиентская валидация:</strong></p><ul><li>Для UX — быстрый фидбек</li><li>НЕ для безопасности (может быть обойдена)</li></ul><p><strong>Серверная валидация:</strong></p><ul><li>ОБЯЗАТЕЛЬНА для безопасности</li><li>Финальная проверка перед обработкой</li><li>Не доверять клиентским данным</li></ul><p><strong>6. Content Security Policy:</strong></p><ul><li>Дополнительный уровень защиты</li><li>Ограничивает источники скриптов</li><li>Блокирует inline код без nonce</li></ul><p><strong>7. Принцип наименьших привилегий:</strong></p><ul><li>Пользователь может вводить только необходимое</li><li>Ограничения на длину, формат, тип</li><li>Дропдауны вместо свободного ввода где возможно</li></ul><p><strong>8. Логирование и мониторинг:</strong></p><ul><li>Логировать подозрительный ввод</li><li>Мониторить паттерны атак</li><li>Алерты на множественные попытки</li></ul><p><strong>9. Rate Limiting:</strong></p><ul><li>Ограничение частоты запросов</li><li>Защита от brute force</li><li>Предотвращение abuse</li></ul><p><strong>10. Обработка файлов:</strong></p><p><strong>Загрузка файлов:</strong></p><ul><li>Валидация типа файла (не только расширение)</li><li>Ограничение размера</li><li>Сканирование антивирусом</li><li>Хранение вне webroot</li><li>Случайные имена файлов</li></ul><p><strong>11. Специфичные типы данных:</strong></p><p><strong>Email:</strong></p><ul><li>Валидация формата</li><li>НО полная RFC валидация сложна</li><li>Лучше — confirmation email</li></ul><p><strong>URL:</strong></p><ul><li>Валидация протокола (http/https)</li><li>Проверка на javascript: и data:</li><li>Canonical форма для сравнения</li></ul><p><strong>Числа:</strong></p><ul><li>Парсинг parseInt/parseFloat</li><li>Проверка диапазона</li><li>Обработка NaN, Infinity</li></ul><p><strong>Checklist безопасности:</strong></p><ul><li>✅ Валидация типа и формата</li><li>✅ Санитизация/кодирование при выводе</li><li>✅ Использование безопасных API</li><li>✅ Серверная проверка обязательна</li><li>✅ CSP настроен</li><li>✅ Логирование подозрительных данных</li><li>✅ Rate limiting на endpoints</li><li>✅ Регулярные security аудиты</li></ul>",
    difficulty: 'middle',
    tags: ['безопасность', 'валидация', 'санитизация', 'user input', 'best practices']
  },

  {
    id: 59,
    question: "Как правильно хранить чувствительные данные в браузере? localStorage vs cookies vs sessionStorage.",
    answer: "<p><strong>Хранение чувствительных данных в браузере</strong> требует понимания рисков и особенностей каждого механизма.</p><p><strong>Типы хранилищ и их безопасность:</strong></p><p><strong>1. HTTP-Only Cookies (самое безопасное для auth):</strong></p><p><strong>Особенности:</strong></p><ul><li>Недоступны для JavaScript (document.cookie)</li><li>Автоматически отправляются с запросами</li><li>Защита от XSS через HttpOnly флаг</li></ul><p><strong>Безопасная конфигурация:</strong></p><ul><li>Set-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</li><li>HttpOnly — защита от XSS</li><li>Secure — только HTTPS</li><li>SameSite — защита от CSRF</li></ul><p><strong>Что хранить:</strong></p><ul><li>✅ Session tokens</li><li>✅ Authentication credentials</li><li>✅ CSRF tokens</li></ul><p><strong>2. localStorage (НЕ для чувствительных данных):</strong></p><p><strong>Риски:</strong></p><ul><li>❌ Доступен любому JavaScript на странице</li><li>❌ Уязвим к XSS атакам</li><li>❌ Нет автоматического истечения</li><li>❌ Нет защиты вроде HttpOnly</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Пользовательские настройки (тема, язык)</li><li>✅ Кэш некритичных данных</li><li>✅ Draft состояния форм</li><li>❌ НЕ для auth tokens</li><li>❌ НЕ для персональных данных</li></ul><p><strong>3. sessionStorage (чуть безопаснее localStorage):</strong></p><p><strong>Отличия от localStorage:</strong></p><ul><li>Удаляется при закрытии вкладки/окна</li><li>Не доступен другим вкладкам</li><li>Ограничен одной сессией браузера</li></ul><p><strong>Те же риски XSS:</strong></p><ul><li>❌ Доступен JavaScript</li><li>❌ Уязвим к XSS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Временное состояние UI</li><li>✅ Multi-step form данные</li><li>✅ Временный кэш</li></ul><p><strong>Сравнение механизмов:</strong></p><table><tr><th>Свойство</th><th>HttpOnly Cookie</th><th>localStorage</th><th>sessionStorage</th></tr><tr><td>XSS защита</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>JS доступ</td><td>❌ Нет</td><td>✅ Да</td><td>✅ Да</td></tr><tr><td>Автоотправка</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>Размер</td><td>~4KB</td><td>~5-10MB</td><td>~5-10MB</td></tr><tr><td>Время жизни</td><td>Настраиваемо</td><td>Постоянно</td><td>До закрытия</td></tr></table><p><strong>Рекомендации по хранению:</strong></p><p><strong>Authentication tokens:</strong></p><ul><li>✅ Лучший вариант: HttpOnly Secure cookies</li><li>❌ Плохой вариант: localStorage</li><li>Причина: защита от XSS критична</li></ul><p><strong>JWT токены:</strong></p><p><strong>Вариант 1 — HttpOnly cookie (рекомендуется):</strong></p><ul><li>Токен в cookie, сервер парсит</li><li>Защита от XSS</li></ul><p><strong>Вариант 2 — localStorage + Authorization header:</strong></p><ul><li>fetch('/api', { headers: { 'Authorization': 'Bearer ' + token } })</li><li>Уязвимо к XSS</li><li>НО не подвержено CSRF (токен не отправляется автоматически)</li></ul><p><strong>Hybrid подход:</strong></p><ul><li>Access token — короткоживущий, в памяти JS</li><li>Refresh token — HttpOnly cookie</li><li>Баланс удобства и безопасности</li></ul><p><strong>Шифрование в браузере:</strong></p><p><strong>Web Crypto API:</strong></p><ul><li>Шифрование чувствительных данных перед хранением</li><li>crypto.subtle.encrypt()</li><li>НО ключ всё равно в браузере</li><li>Защита не от XSS, но от физического доступа</li></ul><p><strong>Ограничения шифрования:</strong></p><ul><li>Если злонамеленный JS выполнился (XSS)</li><li>Он может перехватить данные ДО шифрования</li><li>Шифрование не заменяет другие меры</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ HttpOnly cookies для auth данных</li><li>✅ Минимизировать хранение чувствительного в браузере</li><li>✅ Короткое время жизни токенов</li><li>✅ Используйте SameSite для cookies</li><li>✅ HTTPS везде (Secure flag)</li><li>✅ CSP для защиты от XSS</li><li>✅ Регулярная ротация токенов</li><li>✅ Logout должен очищать ВСЕ данные</li><li>❌ Никогда пароли в браузере</li><li>❌ Никогда API ключи в localStorage</li></ul><p><strong>Альтернативы браузерному хранению:</strong></p><ul><li>Server-side sessions — данные на сервере, только ID в cookie</li><li>Stateless JWT — краткосрочные токены</li><li>OAuth tokens — делегированная авторизация</li></ul>",
    difficulty: 'middle',
    tags: ['хранение данных', 'localStorage', 'cookies', 'безопасность', 'auth']
  },
  {
    id: 60,
    question: "Какие существуют атаки на session management и как защититься?",
    answer: "<p><strong>Session management</strong> — критичная часть безопасности веб-приложений, которая часто становится целью атак.</p><p><strong>Типы атак на сессии:</strong></p><p><strong>1. Session Hijacking (перехват сессии):</strong></p><p><strong>Как работает:</strong></p><ul><li>Злонамеленник получает session ID жертвы</li><li>Использует его для доступа к аккаунту</li><li>Выдает себя за легитимного пользователя</li></ul><p><strong>Методы получения session ID:</strong></p><ul><li>XSS — кража через document.cookie</li><li>Network sniffing — перехват в незашифрованном трафике</li><li>Man-in-the-Middle — подмена в пути</li><li>Malware на устройстве жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HttpOnly cookies — защита от XSS</li><li>✅ Secure flag — только HTTPS</li><li>✅ HTTPS везде — защита от sniffing</li><li>✅ SameSite cookies — дополнительная защита</li><li>✅ Регенерация session ID после логина</li></ul><p><strong>2. Session Fixation (фиксация сессии):</strong></p><p><strong>Как работает:</strong></p><ol><li>Злонамеленник получает валидный session ID</li><li>Заставляет жертву использовать этот ID</li><li>Жертва логинится с известным ID</li><li>Злонамеленник использует тот же ID — авторизован</li></ol><p><strong>Пример атаки:</strong></p><ul><li>site.com?sessionId=attacker-known-id</li><li>Жертва логинится</li><li>Злонамеленник использует attacker-known-id</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Регенерация session ID при логине</li><li>✅ Отклонять session ID из URL параметров</li><li>✅ Использовать только server-generated session IDs</li><li>✅ Валидировать session при повышении привилегий</li></ul><p><strong>3. Session Prediction (предсказание сессии):</strong></p><p><strong>Проблема:</strong></p><ul><li>Слабый алгоритм генерации session ID</li><li>Предсказуемые паттерны (инкремент, timestamp)</li><li>Недостаточная энтропия</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Криптографически стойкие генераторы</li><li>✅ Достаточная длина ID (128+ бит)</li><li>✅ Использовать crypto.randomBytes()</li><li>✅ Избегать последовательных/предсказуемых ID</li></ul><p><strong>4. Cross-Site Request Forgery (CSRF):</strong></p><ul><li>Злонамеленный сайт использует сессию жертвы</li><li>Браузер автоматически отправляет session cookie</li><li>Действия выполняются от имени жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ CSRF токены</li><li>✅ SameSite cookies</li><li>✅ Проверка Origin/Referer</li><li>✅ Re-authentication для критичных операций</li></ul><p><strong>5. Session Timeout Issues:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Слишком длинные сессии</li><li>Отсутствие idle timeout</li><li>Сессия не завершается при logout</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Разумное время жизни (15-30 минут idle)</li><li>✅ Absolute timeout (например, 24 часа)</li><li>✅ Корректный logout — удаление session</li><li>✅ Sliding expiration при активности</li></ul><p><strong>6. Concurrent Session Attacks:</strong></p><p><strong>Проблема:</strong></p><ul><li>Множество активных сессий одного пользователя</li><li>Украденный токен используется параллельно</li><li>Сложно обнаружить компрометацию</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Ограничение числа активных сессий</li><li>✅ Logout из всех устройств при смене пароля</li><li>✅ Список активных сессий для пользователя</li><li>✅ Возможность terminate конкретную сессию</li></ul><p><strong>Best Practices для Session Management:</strong></p><p><strong>Генерация Session ID:</strong></p><ul><li>✅ Минимум 128 бит энтропии</li><li>✅ Криптографически стойкий RNG</li><li>✅ Без предсказуемых паттернов</li></ul><p><strong>Хранение на сервере:</strong></p><ul><li>✅ Хешировать session ID перед хранением</li><li>✅ Ассоциировать с IP, User-Agent (опционально)</li><li>✅ Хранить время создания и последней активности</li></ul><p><strong>Cookie конфигурация:</strong></p><ul><li>✅ HttpOnly — обязательно</li><li>✅ Secure — обязательно</li><li>✅ SameSite=Lax минимум, Strict лучше</li><li>✅ Правильный Path и Domain</li></ul><p><strong>Lifecycle управление:</strong></p><ul><li>✅ Регенерация при логине/logout</li><li>✅ Регенерация при изменении привилегий</li><li>✅ Автоматическое истечение</li><li>✅ Явное завершение при logout</li></ul><p><strong>Мониторинг и аудит:</strong></p><ul><li>✅ Логировать создание/удаление сессий</li><li>✅ Алерты на подозрительную активность</li><li>✅ Обнаружение множественных сессий</li><li>✅ Географические аномалии</li></ul><p><strong>Дополнительные меры:</strong></p><ul><li>✅ Двухфакторная аутентификация</li><li>✅ Device fingerprinting</li><li>✅ Behavioral analytics</li><li>✅ Rate limiting</li></ul>",
    difficulty: 'senior',
    tags: ['session management', 'безопасность', 'session hijacking', 'атаки', 'защита']
  }
];
