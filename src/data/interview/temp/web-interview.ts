export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 50,
    question: "Как работают CSRF атаки и какой механизм они эксплуатируют?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> эксплуатирует доверие сервера к браузеру пользователя.</p><p><strong>Базовый принцип атаки:</strong></p><ol><li>Пользователь залогинен на сайте victim.com</li><li>Браузер хранит session cookie для victim.com</li><li>Пользователь посещает злонамеренный сайт evil.com</li><li>evil.com создает запрос к victim.com</li><li>Браузер автоматически прикрепляет cookies</li><li>victim.com думает что это легитимный запрос</li><li>Действие выполняется от имени пользователя</li></ol><p><strong>Почему это работает:</strong></p><ul><li>Браузер автоматически отправляет cookies с КАЖДЫМ запросом</li><li>Не важно откуда исходит запрос</li><li>Сервер видит валидную аутентификацию</li><li>Нет способа отличить источник запроса только по cookies</li></ul><p><strong>Типичный сценарий атаки:</strong></p><p><strong>Перевод денег:</strong></p><ol><li>Пользователь залогинен в банке (bank.com)</li><li>Открывает письмо со ссылкой на картинку</li><li>Картинка на самом деле: &lt;img src=\"https://bank.com/transfer?to=attacker&amount=5000\"&gt;</li><li>Браузер делает GET запрос для загрузки \"картинки\"</li><li>Cookies банка отправляются автоматически</li><li>Деньги переведены</li></ol><p><strong>Более сложная атака через форму:</strong></p><ol><li>evil.com содержит скрытую форму</li><li>&lt;form action=\"https://bank.com/transfer\" method=\"POST\"&gt;</li><li>&lt;input name=\"to\" value=\"attacker\"&gt;</li><li>&lt;input name=\"amount\" value=\"5000\"&gt;</li><li>&lt;/form&gt;</li><li>&lt;script&gt;document.forms[0].submit();&lt;/script&gt;</li><li>Форма отправляется автоматически при загрузке</li></ol><p><strong>Требования для успешной CSRF:</strong></p><ul><li>Жертва должна быть авторизована на целевом сайте</li><li>Атакующий должен знать структуру запроса</li><li>Сайт должен полагаться только на cookies для аутентификации</li><li>Запрос должен иметь побочные эффекты (изменение данных)</li></ul><p><strong>Что может сделать CSRF:</strong></p><ul><li>✅ Изменить пароль/email</li><li>✅ Совершить покупку/перевод</li><li>✅ Опубликовать контент</li><li>✅ Удалить данные</li><li>✅ Изменить настройки</li><li>❌ НЕ может читать ответ (Same-Origin Policy)</li><li>❌ НЕ может красть данные напрямую</li></ul><p><strong>Методы которые используют CSRF:</strong></p><p><strong>GET запросы:</strong></p><ul><li>Через img, script, link теги</li><li>Простейшая атака</li><li>Поэтому GET не должен изменять данные</li></ul><p><strong>POST запросы:</strong></p><ul><li>Через автоматически отправляемые формы</li><li>Более сложная но реалистичная</li></ul><p><strong>PUT/DELETE через XHR:</strong></p><ul><li>Требует CORS разрешений</li><li>Обычно блокируется браузером</li><li>Менее распространено</li></ul><p><strong>Почему CSRF опасен:</strong></p><ul><li>Скрытность — жертва не подозревает</li><li>Использует легитимную аутентификацию</li><li>Может привести к финансовым потерям</li><li>Компрометация аккаунтов</li><li>Публикация вредоносного контента</li></ul><p><strong>Факторы снижающие риск:</strong></p><ul><li>Same-Origin Policy — нельзя читать ответ</li><li>CORS — контролирует cross-origin запросы</li><li>SameSite cookies — современная защита</li><li>Preflight для сложных запросов</li></ul><p><strong>Отличие от XSS:</strong></p><ul><li>XSS выполняет код в контексте жертвы</li><li>CSRF заставляет выполнить действие</li><li>XSS может украсть данные</li><li>CSRF только изменяет состояние</li><li>XSS требует уязвимость в приложении</li><li>CSRF работает с любым приложением без защиты</li></ul>",
    difficulty: 'junior',
    tags: ['CSRF', 'атаки', 'механизм', 'cookies', 'безопасность']
  },

  {
    id: 51,
    question: "Какие методы защиты от CSRF существуют и как они работают?",
    answer: "<p><strong>Защита от CSRF</strong> требует проверки что запрос исходит от легитимного источника.</p><p><strong>1. CSRF Tokens (основной метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует уникальный токен для каждой сессии/формы</li><li>Токен вставляется в HTML форму как скрытое поле</li><li>При отправке формы токен проверяется</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li></ul><p><strong>Реализация:</strong></p><ul><li>Server генерирует: csrfToken = randomString()</li><li>HTML: &lt;input type=\"hidden\" name=\"_csrf\" value=\"token123\"&gt;</li><li>Server проверяет: if (req.body._csrf !== session.csrfToken) reject()</li></ul><p><strong>Преимущества:</strong></p><ul><li>Эффективная защита</li><li>Работает для любых запросов</li><li>Широко поддерживается фреймворками</li></ul><p><strong>2. SameSite Cookie атрибут (современный метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Браузер не отправляет cookie в cross-site запросах</li><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>Автоматическая защита на уровне браузера</li></ul><p><strong>Режимы SameSite:</strong></p><ul><li>Strict — максимальная защита, но хуже UX</li><li>Lax — баланс, защищает POST/PUT/DELETE</li><li>None — без защиты (требует Secure)</li></ul><p><strong>Преимущества:</strong></p><ul><li>Простота — один атрибут</li><li>Не требует изменений в коде</li><li>Защита из коробки</li></ul><p><strong>Недостатки:</strong></p><ul><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>3. Double Submit Cookie:</strong></p><p><strong>Как работает:</strong></p><ul><li>Токен хранится И в cookie, И в форме/заголовке</li><li>Server сравнивает оба значения</li><li>Злонамеренный сайт не может установить cookie для другого домена</li></ul><p><strong>Пример:</strong></p><ul><li>Cookie: csrfToken=abc123</li><li>Header: X-CSRF-Token: abc123</li><li>Server проверяет совпадение</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><p><strong>Как работает:</strong></p><ul><li>Origin заголовок содержит источник запроса</li><li>Server проверяет что Origin = ожидаемый домен</li><li>Referer как fallback (менее надежен)</li></ul><p><strong>Реализация:</strong></p><ul><li>const origin = req.headers.origin;</li><li>if (origin !== 'https://trusted-site.com') reject();</li></ul><p><strong>Недостатки:</strong></p><ul><li>Origin может отсутствовать</li><li>Referer может быть отключен пользователем</li><li>Дополнительный слой, не основная защита</li></ul><p><strong>5. Custom Headers для AJAX:</strong></p><p><strong>Как работает:</strong></p><ul><li>Обычные HTML формы не могут устанавливать кастомные заголовки</li><li>Только JavaScript с same-origin может</li><li>Наличие кастомного заголовка = легитимный запрос</li></ul><p><strong>Пример:</strong></p><ul><li>fetch('/api', { headers: { 'X-Requested-With': 'XMLHttpRequest' } })</li><li>Server проверяет наличие заголовка</li></ul><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Подтверждение по email/SMS</li><li>2FA для чувствительных операций</li></ul><p><strong>Комплексная защита (рекомендуется):</strong></p><ul><li>✅ SameSite=Lax для всех cookies</li><li>✅ CSRF токены для форм</li><li>✅ Проверка Origin для дополнительной защиты</li><li>✅ Custom headers для AJAX API</li><li>✅ Re-auth для критичных операций</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Используйте POST/PUT/DELETE для изменяющих операций</li><li>✅ GET запросы должны быть идемпотентными</li><li>✅ Не полагайтесь только на cookies</li><li>✅ Генерируйте криптографически стойкие токены</li><li>✅ Токены должны быть уникальны для каждой сессии</li><li>✅ Проверяйте токены на сервере ВСЕГДА</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'защита', 'токены', 'SameSite', 'безопасность']
  },

  {
    id: 52,
    question: "Что такое X-Frame-Options и как он помогает в безопасности?",
    answer: "<p><strong>X-Frame-Options</strong> — это HTTP заголовок, контролирующий может ли страница отображаться в iframe.</p><p><strong>Зачем нужен X-Frame-Options:</strong></p><ul><li>Защита от Clickjacking атак</li><li>Предотвращение встраивания вашего сайта в iframe</li><li>Контроль над тем, кто может фреймировать контент</li></ul><p><strong>Что такое Clickjacking:</strong></p><ol><li>Злонамеренный сайт встраивает ваш сайт в невидимый iframe</li><li>Накладывает свой контент поверх</li><li>Пользователь думает что кликает на кнопку evil.com</li><li>На самом деле кликает на банк.com в iframe</li><li>Выполняется нежелательное действие</li></ol><p><strong>Значения X-Frame-Options:</strong></p><p><strong>DENY:</strong></p><ul><li>X-Frame-Options: DENY</li><li>Страница не может быть во фрейме НИКОГДА</li><li>Даже на том же домене</li><li>Максимальная защита</li></ul><p><strong>SAMEORIGIN:</strong></p><ul><li>X-Frame-Options: SAMEORIGIN</li><li>Только страницы с того же origin могут фреймировать</li><li>Позволяет внутреннее использование iframe</li><li>Блокирует сторонние сайты</li></ul><p><strong>ALLOW-FROM uri (устарело):</strong></p><ul><li>X-Frame-Options: ALLOW-FROM https://trusted.com</li><li>Разрешить конкретному домену</li><li>❌ Не поддерживается большинством браузеров</li><li>Не рекомендуется использовать</li></ul><p><strong>Как это защищает:</strong></p><ul><li>Браузер проверяет заголовок</li><li>Если политика нарушена — не отображает фрейм</li><li>Показывает пустой фрейм или ошибку</li><li>Злонамеренный сайт не может встроить контент</li></ul><p><strong>Примеры атак которые предотвращает:</strong></p><p><strong>Clickjacking на банк:</strong></p><ul><li>evil.com встраивает bank.com/transfer</li><li>Накладывает кнопку \"Скачать бесплатно\"</li><li>Пользователь кликает думая что скачивает</li><li>На самом деле переводит деньги</li><li>X-Frame-Options блокирует встраивание</li></ul><p><strong>Кража лайков/подписок:</strong></p><ul><li>Социальная сеть во фрейме</li><li>Невидимая кнопка \"Подписаться\"</li><li>Пользователь думает что кликает на что-то другое</li><li>Подписывается на спам-аккаунт</li></ul><p><strong>Современная альтернатива — CSP frame-ancestors:</strong></p><p><strong>Content-Security-Policy:</strong></p><ul><li>Content-Security-Policy: frame-ancestors 'none'</li><li>Эквивалент X-Frame-Options: DENY</li><li>frame-ancestors 'self' — эквивалент SAMEORIGIN</li><li>frame-ancestors https://trusted.com — разрешить домен</li></ul><p><strong>Преимущества CSP frame-ancestors:</strong></p><ul><li>Более гибкий — можно указать несколько доменов</li><li>Лучше поддерживается</li><li>Часть общей CSP политики</li></ul><p><strong>Использовать оба заголовка:</strong></p><ul><li>X-Frame-Options для старых браузеров</li><li>CSP frame-ancestors для новых</li><li>Defense in depth</li></ul><p><strong>Когда НЕ использовать:</strong></p><ul><li>Сайты которые должны встраиваться (виджеты, OAuth)</li><li>Платежные формы которые используются в iframe</li><li>Встраиваемый контент как YouTube</li></ul><p><strong>Для таких случаев:</strong></p><ul><li>Использовать ALLOW-FROM (CSP) для конкретных партнеров</li><li>Или вообще не устанавливать заголовок</li><li>Но применить другие меры безопасности</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: X-Frame-Options: DENY</li><li>✅ Для внутренних iframe: SAMEORIGIN</li><li>✅ Добавить CSP frame-ancestors тоже</li><li>✅ Тестировать что легитимные iframe работают</li><li>✅ Применять на всех страницах</li></ul>",
    difficulty: 'middle',
    tags: ['X-Frame-Options', 'Clickjacking', 'безопасность', 'iframe', 'заголовки']
  },

  {
    id: 53,
    question: "Как работает защита от XSS во фреймворках (React, Vue, Angular)?",
    answer: "<p><strong>Современные фреймворки</strong> имеют встроенную защиту от XSS, но её нужно правильно использовать.</p><p><strong>React:</strong></p><p><strong>Автоматическое экранирование в JSX:</strong></p><ul><li>Все значения в {} автоматически экранируются</li><li>const name = '&lt;script&gt;alert()&lt;/script&gt;';</li><li>&lt;div&gt;{name}&lt;/div&gt; — безопасно, отобразится как текст</li><li>React преобразует в HTML entities</li></ul><p><strong>Опасность dangerouslySetInnerHTML:</strong></p><ul><li>❌ &lt;div dangerouslySetInnerHTML={{__html: userInput}} /&gt;</li><li>Полностью отключает защиту</li><li>Позволяет внедрить HTML и скрипты</li><li>Использовать только для доверенного контента</li></ul><p><strong>Безопасная альтернатива:</strong></p><ul><li>Использовать библиотеку DOMPurify</li><li>const clean = DOMPurify.sanitize(userInput);</li><li>&lt;div dangerouslySetInnerHTML={{__html: clean}} /&gt;</li></ul><p><strong>Безопасность атрибутов:</strong></p><ul><li>❌ &lt;div className={userInput}&gt; — может быть опасно</li><li>❌ &lt;a href={userInput}&gt; — javascript: URLs опасны</li><li>✅ Валидировать URL перед использованием</li></ul><p><strong>Vue:</strong></p><p><strong>Автоматическое экранирование в шаблонах:</strong></p><ul><li>{{ userInput }} — автоматически экранируется</li><li>Vue преобразует HTML в безопасный текст</li><li>Защита по умолчанию</li></ul><p><strong>v-html директива (опасно):</strong></p><ul><li>❌ &lt;div v-html=\"userInput\"&gt;&lt;/div&gt;</li><li>Рендерит HTML без экранирования</li><li>Уязвимо к XSS если userInput от пользователя</li><li>Только для доверенного контента</li></ul><p><strong>Безопасные практики Vue:</strong></p><ul><li>✅ Использовать {{ }} для текста</li><li>✅ v-text для текстового контента</li><li>✅ Санитизация перед v-html</li></ul><p><strong>Динамические атрибуты:</strong></p><ul><li>:href=\"userUrl\" — нужна валидация</li><li>Проверять на javascript: протокол</li></ul><p><strong>Angular:</strong></p><p><strong>Встроенный DomSanitizer:</strong></p><ul><li>Angular автоматически санитизирует значения</li><li>{{ userInput }} — безопасно</li><li>[innerHTML]=\"userInput\" — автоматически очищается</li></ul><p><strong>Контексты санитизации:</strong></p><ul><li>HTML — для innerHTML</li><li>Style — для [style]</li><li>URL — для [src], [href]</li><li>Resource URL — для &lt;script&gt;, &lt;iframe&gt;</li></ul><p><strong>Bypass санитизации (осторожно!):</strong></p><ul><li>this.sanitizer.bypassSecurityTrustHtml(value)</li><li>❌ Отключает защиту</li><li>Только для проверенного контента</li></ul><p><strong>Общие правила для всех фреймворков:</strong></p><p><strong>1. Доверяйте встроенной защите:</strong></p><ul><li>✅ Используйте стандартные способы вывода</li><li>✅ Не отключайте санитизацию без причины</li></ul><p><strong>2. Rich Text редакторы:</strong></p><ul><li>Используйте whitelist разрешенных тегов</li><li>Библиотеки: DOMPurify, sanitize-html</li><li>Серверная валидация тоже</li></ul><p><strong>3. Атрибуты требуют внимания:</strong></p><ul><li>href, src, style могут быть опасны</li><li>Валидировать URL (не javascript:, не data:)</li><li>Проверять на event handlers (onclick и т.д.)</li></ul><p><strong>4. Server-Side Rendering:</strong></p><ul><li>Те же правила применяются</li><li>Санитизация на сервере</li><li>Не доверять клиентским данным</li></ul><p><strong>Антипаттерны (избегать):</strong></p><ul><li>❌ eval() с пользовательским вводом</li><li>❌ new Function() с пользовательским кодом</li><li>❌ Отключение санитизации \"для удобства\"</li><li>❌ Доверие данным из URL параметров</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Понимать как работает защита фреймворка</li><li>✅ Не обходить защиту без веской причины</li><li>✅ Использовать DOMPurify для rich text</li><li>✅ Валидировать URLs и атрибуты</li><li>✅ CSP как дополнительный слой</li><li>✅ Code review на опасные паттерны</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'React', 'Vue', 'Angular', 'фреймворки']
  },

  {
    id: 54,
    question: "Какие инструменты существуют для обнаружения XSS и CSRF уязвимостей?",
    answer: "<p><strong>Инструменты для обнаружения уязвимостей</strong> делятся на автоматические сканеры, ручные инструменты и библиотеки.</p><p><strong>Автоматические сканеры безопасности:</strong></p><p><strong>1. OWASP ZAP (Zed Attack Proxy):</strong></p><ul><li>Бесплатный open-source сканер</li><li>Автоматическое сканирование на XSS, CSRF, SQL injection</li><li>Интерактивный прокси для ручного тестирования</li><li>Fuzzing для поиска уязвимостей</li><li>Интеграция в CI/CD</li></ul><p><strong>Использование:</strong></p><ul><li>Запустить прокси</li><li>Направить браузер через ZAP</li><li>Автоматическое сканирование или ручное тестирование</li><li>Отчет с найденными уязвимостями</li></ul><p><strong>2. Burp Suite:</strong></p><ul><li>Профессиональный инструмент (платная версия)</li><li>Community edition бесплатно</li><li>Интерцептор запросов</li><li>Сканер уязвимостей</li><li>Repeater для модификации запросов</li></ul><p><strong>3. Acunetix:</strong></p><ul><li>Коммерческий сканер</li><li>Автоматическое обнаружение XSS, CSRF</li><li>Deep scan для сложных приложений</li><li>Детальные отчеты</li></ul><p><strong>4. Netsparker:</strong></p><ul><li>Автоматический сканер</li><li>Proof-based сканирование</li><li>Минимум ложных срабатываний</li></ul><p><strong>Инструменты для разработки:</strong></p><p><strong>1. ESLint плагины для безопасности:</strong></p><ul><li>eslint-plugin-security</li><li>eslint-plugin-no-unsanitized</li><li>Обнаруживает опасные паттерны в коде</li><li>Предупреждает о dangerouslySetInnerHTML</li></ul><p><strong>Пример конфигурации:</strong></p><ul><li>rules: { 'no-unsanitized/method': 'error', 'no-unsanitized/property': 'error' }</li></ul><p><strong>2. SonarQube:</strong></p><ul><li>Статический анализ кода</li><li>Обнаружение security hotspots</li><li>Интеграция в CI/CD</li><li>Отчеты по качеству и безопасности</li></ul><p><strong>3. Snyk:</strong></p><ul><li>Сканирование зависимостей</li><li>Обнаружение уязвимостей в библиотеках</li><li>Автоматические PR с фиксами</li></ul><p><strong>Browser DevTools расширения:</strong></p><p><strong>1. XSS Hunter:</strong></p><ul><li>Обнаружение blind XSS</li><li>Callback когда payload сработал</li><li>Полезно для сложных сценариев</li></ul><p><strong>2. CSP Evaluator:</strong></p><ul><li>Проверка Content Security Policy</li><li>Рекомендации по улучшению</li><li>Обнаружение слабых мест в CSP</li></ul><p><strong>Ручное тестирование:</strong></p><p><strong>Payloads для XSS тестирования:</strong></p><ul><li>&lt;script&gt;alert('XSS')&lt;/script&gt;</li><li>&lt;img src=x onerror=alert('XSS')&gt;</li><li>&lt;svg onload=alert('XSS')&gt;</li><li>javascript:alert('XSS')</li></ul><p><strong>Тестирование различных контекстов:</strong></p><ul><li>HTML контекст</li><li>Атрибуты</li><li>JavaScript строки</li><li>CSS</li><li>URL параметры</li></ul><p><strong>CSRF тестирование:</strong></p><ul><li>Удалить CSRF токен и отправить запрос</li><li>Использовать токен из другой сессии</li><li>Проверить работает ли SameSite cookie</li><li>Изменить Origin заголовок</li></ul><p><strong>CI/CD интеграция:</strong></p><p><strong>GitHub Actions пример:</strong></p><ul><li>- uses: zaproxy/action-baseline@v0.4.0</li><li>with: target: https://your-app.com</li><li>Автоматический скан при каждом PR</li></ul><p><strong>Библиотеки для санитизации:</strong></p><p><strong>DOMPurify:</strong></p><ul><li>Очистка HTML от XSS</li><li>const clean = DOMPurify.sanitize(dirty);</li><li>Используется на клиенте</li></ul><p><strong>sanitize-html (Node.js):</strong></p><ul><li>Серверная санитизация</li><li>Whitelist тегов и атрибутов</li></ul><p><strong>Мониторинг в production:</strong></p><p><strong>1. Content Security Policy Reports:</strong></p><ul><li>CSP: report-uri /csp-violations</li><li>Браузер отправляет отчет при блокировке</li><li>Обнаружение атак в реальном времени</li></ul><p><strong>2. Web Application Firewall (WAF):</strong></p><ul><li>Cloudflare WAF</li><li>AWS WAF</li><li>Блокирует известные XSS паттерны</li><li>Логирование подозрительных запросов</li></ul><p><strong>3. Security Monitoring:</strong></p><ul><li>Sentry — отслеживание JS ошибок</li><li>LogRocket — session replay</li><li>Обнаружение аномального поведения</li></ul><p><strong>Best practices тестирования:</strong></p><ul><li>✅ Регулярные автоматические сканы</li><li>✅ Ручное penetration testing</li><li>✅ Code review с фокусом на безопасность</li><li>✅ Интеграция в CI/CD</li><li>✅ Тестирование всех user inputs</li><li>✅ Мониторинг CSP violations</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'CSRF', 'инструменты', 'тестирование', 'OWASP ZAP', 'безопасность']
  },

  {
    id: 55,
    question: "Что такое DOM-based XSS и чем он отличается от других типов?",
    answer: "<p><strong>DOM-based XSS</strong> — это тип XSS атаки, где уязвимость находится в клиентском JavaScript коде, а не на сервере.</p><p><strong>Ключевое отличие:</strong></p><ul><li>Вредоносный payload никогда не отправляется на сервер</li><li>Вся атака происходит в браузере</li><li>Уязвимость в коде который манипулирует DOM</li><li>Сервер может быть полностью безопасен</li></ul><p><strong>Как работает DOM-based XSS:</strong></p><ol><li>JavaScript читает данные из ненадежного источника</li><li>Например: URL, location.hash, document.referrer</li><li>Использует эти данные небезопасным способом</li><li>Например: innerHTML, eval(), document.write()</li><li>Вредоносный код выполняется</li></ol><p><strong>Источники ненадежных данных (Sources):</strong></p><ul><li>location.href — весь URL</li><li>location.search — query параметры</li><li>location.hash — fragment после #</li><li>document.referrer — откуда пришел пользователь</li><li>window.name — имя окна</li><li>document.cookie — cookies</li><li>localStorage/sessionStorage</li><li>postMessage данные</li></ul><p><strong>Опасные функции (Sinks):</strong></p><ul><li>element.innerHTML = source</li><li>element.outerHTML = source</li><li>document.write(source)</li><li>eval(source)</li><li>setTimeout(source, time)</li><li>setInterval(source, time)</li><li>new Function(source)</li><li>location = source (если source = 'javascript:...')</li></ul><p><strong>Примеры уязвимостей:</strong></p><p><strong>Пример 1 — location.hash:</strong></p><ul><li>// Уязвимый код</li><li>const name = location.hash.substring(1);</li><li>document.getElementById('welcome').innerHTML = 'Hello ' + name;</li><li>// Атака URL</li><li>site.com#&lt;img src=x onerror=alert()&gt;</li></ul><p><strong>Пример 2 — URL параметры:</strong></p><ul><li>// Уязвимый код</li><li>const urlParams = new URLSearchParams(window.location.search);</li><li>const msg = urlParams.get('message');</li><li>document.write(msg);</li><li>// Атака URL</li><li>site.com?message=&lt;script&gt;steal()&lt;/script&gt;</li></ul><p><strong>Пример 3 — eval():</strong></p><ul><li>// Уязвимый код</li><li>const data = location.hash.substring(1);</li><li>eval('var x = ' + data);</li><li>// Атака URL</li><li>site.com#'; maliciousCode(); '</li></ul><p><strong>Почему DOM-based XSS опасен:</strong></p><ul><li>Обходит серверные фильтры (данные не на сервере)</li><li>WAF не помогает</li><li>Сложнее обнаружить обычными сканерами</li><li>Payload может быть в fragment (#), который не отправляется серверу</li></ul><p><strong>Защита от DOM-based XSS:</strong></p><p><strong>1. Избегать опасных Sinks:</strong></p><ul><li>❌ element.innerHTML = userInput</li><li>✅ element.textContent = userInput</li><li>❌ eval(userInput)</li><li>✅ JSON.parse(userInput) для данных</li></ul><p><strong>2. Санитизация перед использованием:</strong></p><ul><li>const clean = DOMPurify.sanitize(location.hash);</li><li>element.innerHTML = clean;</li></ul><p><strong>3. Валидация данных:</strong></p><ul><li>Проверить что URL параметр содержит ожидаемые значения</li><li>Whitelist разрешенных значений</li><li>Reject неожиданные данные</li></ul><p><strong>4. Безопасные альтернативы:</strong></p><ul><li>createElement() вместо innerHTML</li><li>setAttribute() вместо прямой манипуляции</li><li>textContent вместо innerHTML для текста</li></ul><p><strong>5. Content Security Policy:</strong></p><ul><li>CSP: script-src 'self' 'nonce-...'</li><li>Блокирует eval(), inline событий</li><li>Дополнительный уровень защиты</li></ul><p><strong>Отличия от Stored/Reflected XSS:</strong></p><table><tr><th>Аспект</th><th>DOM-based</th><th>Stored/Reflected</th></tr><tr><td>Уязвимость</td><td>Клиентский JS</td><td>Серверный код</td></tr><tr><td>Payload хранение</td><td>URL, fragment</td><td>БД или URL</td></tr><tr><td>Серверная роль</td><td>Минимальная</td><td>Основная</td></tr><tr><td>WAF защита</td><td>Не помогает</td><td>Может помочь</td></tr><tr><td>Обнаружение</td><td>Сложнее</td><td>Проще</td></tr></table><p><strong>Best practices:</strong></p><ul><li>✅ Аудит клиентского JavaScript кода</li><li>✅ Избегать опасных функций</li><li>✅ Валидировать все source данные</li><li>✅ Использовать безопасные API</li><li>✅ CSP для дополнительной защиты</li><li>✅ Статический анализ кода</li></ul>",
    difficulty: 'senior',
    tags: ['XSS', 'DOM-based XSS', 'клиентская безопасность', 'JavaScript']
  },

  {
    id: 56,
    question: "Как работает защита SameSite для cookies и почему она важна для CSRF?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, контролирующий отправку в cross-site запросах.</p><p><strong>Три режима SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же registered domain</li><li>НЕ отправляется даже при клике по ссылке с другого сайта</li></ul><p><strong>Пример:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Strict</li><li>Пользователь на google.com</li><li>Кликает ссылку на bank.com</li><li>Cookie НЕ отправится при первом запросе</li><li>Пользователь увидит \"не залогинен\"</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы</li></ul><p><strong>2. SameSite=Lax (баланс, по умолчанию):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><p><strong>Отправляется:</strong></p><ul><li>✅ Клик по ссылке (GET)</li><li>✅ window.location = \"...\" (GET)</li><li>✅ &lt;form method=\"GET\"&gt;</li></ul><p><strong>НЕ отправляется:</strong></p><ul><li>❌ &lt;form method=\"POST\"&gt; с другого сайта</li><li>❌ fetch/XHR запросы cross-site</li><li>❌ &lt;img src=...&gt; на другом домене</li><li>❌ &lt;iframe&gt; с другого домена</li></ul><p><strong>Пример защиты от CSRF:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com пытается: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Cookie НЕ отправится</li><li>Запрос не авторизован</li><li>CSRF атака провалилась</li></ul><p><strong>3. SameSite=None (без защиты):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ВСЕГДА</li><li>В same-site и cross-site запросах</li><li>Как было до введения SameSite</li></ul><p><strong>Требования:</strong></p><ul><li>ОБЯЗАТЕЛЬНО нужен атрибут Secure</li><li>Set-Cookie: widget=xyz; SameSite=None; Secure</li><li>Только HTTPS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Встраиваемые виджеты (чаты, комментарии)</li><li>OAuth flows в iframe</li><li>Платежные формы third-party</li><li>Cross-site API с credentials</li></ul><p><strong>Как SameSite защищает от CSRF:</strong></p><p><strong>Традиционная CSRF атака:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc (без SameSite)</li><li>evil.com: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Браузер отправляет cookie</li><li>Деньги переведены ✗</li></ol><p><strong>С SameSite=Lax:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com: &lt;form method=\"POST\"&gt;</li><li>Браузер НЕ отправляет cookie (cross-site POST)</li><li>Запрос не авторизован ✓</li></ol><p><strong>Современные браузеры и SameSite:</strong></p><ul><li>Chrome 80+ (2020): SameSite=Lax по умолчанию</li><li>Firefox 69+: SameSite=Lax по умолчанию</li><li>Edge: следует за Chrome</li><li>Safari: свои правила ITP</li></ul><p><strong>Если не указан SameSite:</strong></p><ul><li>Современные браузеры: SameSite=Lax автоматически</li><li>Старые браузеры: нет защиты (как SameSite=None)</li></ul><p><strong>Миграция на SameSite:</strong></p><p><strong>Шаг 1 — Аудит cookies:</strong></p><ul><li>Какие cookies используются</li><li>Нужен ли cross-site доступ</li></ul><p><strong>Шаг 2 — Установить правильные значения:</strong></p><ul><li>Auth cookies: SameSite=Lax</li><li>Критичные: SameSite=Strict</li><li>Виджеты: SameSite=None; Secure</li></ul><p><strong>Шаг 3 — Тестирование:</strong></p><ul><li>Проверить функциональность</li><li>Особенно cross-site сценарии</li></ul><p><strong>Комбинация с другими методами:</strong></p><ul><li>SameSite — первая линия защиты от CSRF</li><li>CSRF токены — дополнительная защита</li><li>Origin проверка — еще один слой</li><li>Defense in depth подход</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: SameSite=Lax</li><li>✅ Критичные операции: SameSite=Strict</li><li>✅ Cross-site widgets: SameSite=None; Secure</li><li>✅ Всегда тестировать после изменений</li><li>✅ Использовать с CSRF токенами</li></ul>",
    difficulty: 'middle',
    tags: ['SameSite', 'cookies', 'CSRF', 'защита', 'безопасность']
  },

  {
    id: 57,
    question: "Что такое Trusted Types API и как он помогает предотвратить DOM-based XSS?",
    answer: "<p><strong>Trusted Types</strong> — это Web API для предотвращения DOM-based XSS атак путем контроля над опасными операциями с DOM.</p><p><strong>Основная идея:</strong></p><ul><li>Браузер блокирует опасные DOM операции по умолчанию</li><li>Разрешаются только \"trusted\" (доверенные) значения</li><li>Trusted значения создаются через специальные политики</li><li>Принудительная санитизация на уровне браузера</li></ul><p><strong>Проблема которую решает:</strong></p><ul><li>Разработчики забывают санитизировать данные</li><li>Случайное использование небезопасных API</li><li>innerHTML = userInput — часто встречающаяся ошибка</li><li>Trusted Types делает это невозможным</li></ul><p><strong>Как работает:</strong></p><p><strong>Шаг 1 — Включение через CSP:</strong></p><ul><li>Content-Security-Policy: require-trusted-types-for 'script'</li><li>Браузер начинает требовать Trusted Types</li><li>Опасные операции без trusted значений блокируются</li></ul><p><strong>Шаг 2 — Создание политики:</strong></p><ul><li>const policy = trustedTypes.createPolicy('myPolicy', {</li><li>  createHTML: (input) => DOMPurify.sanitize(input),</li><li>  createScriptURL: (input) => { /* валидация */ return input; }</li><li>});</li></ul><p><strong>Шаг 3 — Использование:</strong></p><ul><li>// ❌ Без Trusted Types — заблокировано</li><li>element.innerHTML = userInput; // TypeError!</li><li>// ✅ С Trusted Types — работает</li><li>element.innerHTML = policy.createHTML(userInput);</li></ul><p><strong>Типы Trusted объектов:</strong></p><p><strong>TrustedHTML:</strong></p><ul><li>Для innerHTML, outerHTML, insertAdjacentHTML</li><li>createHTML(input) — метод политики</li></ul><p><strong>TrustedScript:</strong></p><ul><li>Для eval(), setTimeout с кодом, new Function()</li><li>createScript(input) — метод политики</li></ul><p><strong>TrustedScriptURL:</strong></p><ul><li>Для &lt;script src=...&gt;, Worker, import()</li><li>createScriptURL(input) — метод политики</li></ul><p><strong>Опасные Sinks требующие Trusted Types:</strong></p><ul><li>Element.innerHTML</li><li>Element.outerHTML</li><li>Element.insertAdjacentHTML()</li><li>Element.setHTML() (новый API)</li><li>document.write()</li><li>document.writeln()</li><li>eval()</li><li>setTimeout() / setInterval() со строкой</li><li>new Function()</li></ul><p><strong>Пример политики с валидацией:</strong></p><ul><li>const policy = trustedTypes.createPolicy('sanitizer', {</li><li>  createHTML(input) {</li><li>    // Санитизация HTML</li><li>    return DOMPurify.sanitize(input, {</li><li>      ALLOWED_TAGS: ['b', 'i', 'p', 'br'],</li><li>      ALLOWED_ATTR: []</li><li>    });</li><li>  },</li><li>  createScriptURL(input) {</li><li>    // Только разрешенные домены</li><li>    const url = new URL(input, document.baseURI);</li><li>    if (url.origin === 'https://cdn.trusted.com') {</li><li>      return input;</li><li>    }</li><li>    throw new TypeError('Invalid script URL');</li><li>  }</li><li>});</li></ul><p><strong>Default Policy:</strong></p><ul><li>Политика по умолчанию если никакая не указана</li><li>trustedTypes.createPolicy('default', { ... })</li><li>Применяется ко всем операциям</li><li>Полезно для legacy кода</li></ul><p><strong>Enforcement режимы:</strong></p><p><strong>Enforcement (строгий):</strong></p><ul><li>CSP: require-trusted-types-for 'script'</li><li>Блокирует опасные операции</li><li>TypeError при нарушении</li></ul><p><strong>Report-Only:</strong></p><ul><li>CSP: require-trusted-types-for 'script'; report-uri /violations</li><li>Не блокирует, только отчитывает</li><li>Для тестирования перед полным включением</li></ul><p><strong>Преимущества Trusted Types:</strong></p><ul><li>✅ Принудительная защита на уровне платформы</li><li>✅ Невозможно забыть санитизировать</li><li>✅ Централизованная логика безопасности</li><li>✅ Обнаружение уязвимостей при разработке</li><li>✅ Защита от DOM-based XSS</li></ul><p><strong>Миграция на Trusted Types:</strong></p><p><strong>Шаг 1 — Report-Only:</strong></p><ul><li>Включить в режиме отчетов</li><li>Собрать все нарушения</li></ul><p><strong>Шаг 2 — Создать политики:</strong></p><ul><li>Написать sanitization логику</li><li>Покрыть все use cases</li></ul><p><strong>Шаг 3 — Рефакторинг кода:</strong></p><ul><li>Заменить опасные операции на политики</li><li>element.innerHTML = policy.createHTML(data)</li></ul><p><strong>Шаг 4 — Enforcement:</strong></p><ul><li>Включить строгий режим</li><li>Мониторить нарушения</li></ul><p><strong>Поддержка браузеров:</strong></p><ul><li>Chrome 83+</li><li>Edge 83+</li><li>Opera 69+</li><li>Нет в Firefox и Safari (пока)</li></ul><p><strong>Polyfill для других браузеров:</strong></p><ul><li>Существует polyfill</li><li>Эмулирует API для совместимости</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Начать с Report-Only режима</li><li>✅ Создать строгие политики санитизации</li><li>✅ Использовать DOMPurify в политиках</li><li>✅ Минимизировать количество политик</li><li>✅ Аудит и review политик</li><li>✅ Мониторинг violations</li></ul>",
    difficulty: 'senior',
    tags: ['Trusted Types', 'DOM-based XSS', 'защита', 'Web API', 'CSP']
  },

  {
    id: 58,
    question: "Какие best practices безопасности нужно соблюдать при работе с пользовательским вводом?",
    answer: "<p><strong>Работа с пользовательским вводом</strong> требует постоянной бдительности и применения принципа \"никогда не доверяй\".</p><p><strong>Принцип \"Never Trust User Input\":</strong></p><ul><li>Любые данные от пользователя потенциально опасны</li><li>Включая данные из URL, форм, cookies, headers</li><li>Даже от \"доверенных\" пользователей</li><li>Валидировать и санитизировать всегда</li></ul><p><strong>1. Input Validation (Валидация входных данных):</strong></p><p><strong>Whitelist подход (предпочтительно):</strong></p><ul><li>Определить что РАЗРЕШЕНО</li><li>Отклонять всё остальное</li><li>Примеры: только буквы, только цифры, конкретный формат</li></ul><p><strong>Типы валидации:</strong></p><ul><li>Тип данных: число, строка, boolean</li><li>Формат: email, URL, дата</li><li>Диапазон: min/max длина, числовые пределы</li><li>Паттерны: регулярные выражения</li></ul><p><strong>2. Output Encoding (Кодирование вывода):</strong></p><p><strong>Context-aware encoding:</strong></p><ul><li>HTML контекст: &lt; → &amp;lt;, &gt; → &amp;gt;</li><li>JavaScript строки: ' → \\', \" → \\\"</li><li>URL параметры: encodeURIComponent()</li><li>CSS: специфичное экранирование</li></ul><p><strong>Кодировать при выводе, не при вводе:</strong></p><ul><li>Хранить данные в оригинальном виде</li><li>Кодировать когда отображаете</li><li>Разное кодирование для разных контекстов</li></ul><p><strong>3. Санитизация (Очистка данных):</strong></p><p><strong>Для HTML:</strong></p><ul><li>Использовать DOMPurify или аналоги</li><li>Whitelist разрешенных тегов</li><li>Удалять опасные атрибуты (onclick, onerror)</li></ul><p><strong>Для других типов:</strong></p><ul><li>SQL: параметризованные запросы</li><li>Shell команды: избегать или тщательно экранировать</li><li>File paths: канонизация, проверка на path traversal</li></ul><p><strong>4. Безопасные API:</strong></p><p><strong>Предпочитать безопасные методы:</strong></p><ul><li>✅ textContent вместо innerHTML</li><li>✅ createElement() вместо innerHTML</li><li>✅ setAttribute() вместо прямой манипуляции</li><li>✅ Параметризованные запросы вместо конкатенации SQL</li></ul><p><strong>Избегать опасных функций:</strong></p><ul><li>❌ eval()</li><li>❌ new Function(userInput)</li><li>❌ innerHTML с неочищенными данными</li><li>❌ document.write()</li><li>❌ setTimeout(stringCode)</li></ul><p><strong>5. Валидация на клиенте И сервере:</strong></p><p><strong>Клиентская валидация:</strong></p><ul><li>Для UX — быстрый фидбек</li><li>НЕ для безопасности (может быть обойдена)</li></ul><p><strong>Серверная валидация:</strong></p><ul><li>ОБЯЗАТЕЛЬНА для безопасности</li><li>Финальная проверка перед обработкой</li><li>Не доверять клиентским данным</li></ul><p><strong>6. Content Security Policy:</strong></p><ul><li>Дополнительный уровень защиты</li><li>Ограничивает источники скриптов</li><li>Блокирует inline код без nonce</li></ul><p><strong>7. Принцип наименьших привилегий:</strong></p><ul><li>Пользователь может вводить только необходимое</li><li>Ограничения на длину, формат, тип</li><li>Дропдауны вместо свободного ввода где возможно</li></ul><p><strong>8. Логирование и мониторинг:</strong></p><ul><li>Логировать подозрительный ввод</li><li>Мониторить паттерны атак</li><li>Алерты на множественные попытки</li></ul><p><strong>9. Rate Limiting:</strong></p><ul><li>Ограничение частоты запросов</li><li>Защита от brute force</li><li>Предотвращение abuse</li></ul><p><strong>10. Обработка файлов:</strong></p><p><strong>Загрузка файлов:</strong></p><ul><li>Валидация типа файла (не только расширение)</li><li>Ограничение размера</li><li>Сканирование антивирусом</li><li>Хранение вне webroot</li><li>Случайные имена файлов</li></ul><p><strong>11. Специфичные типы данных:</strong></p><p><strong>Email:</strong></p><ul><li>Валидация формата</li><li>НО полная RFC валидация сложна</li><li>Лучше — confirmation email</li></ul><p><strong>URL:</strong></p><ul><li>Валидация протокола (http/https)</li><li>Проверка на javascript: и data:</li><li>Canonical форма для сравнения</li></ul><p><strong>Числа:</strong></p><ul><li>Парсинг parseInt/parseFloat</li><li>Проверка диапазона</li><li>Обработка NaN, Infinity</li></ul><p><strong>Checklist безопасности:</strong></p><ul><li>✅ Валидация типа и формата</li><li>✅ Санитизация/кодирование при выводе</li><li>✅ Использование безопасных API</li><li>✅ Серверная проверка обязательна</li><li>✅ CSP настроен</li><li>✅ Логирование подозрительных данных</li><li>✅ Rate limiting на endpoints</li><li>✅ Регулярные security аудиты</li></ul>",
    difficulty: 'middle',
    tags: ['безопасность', 'валидация', 'санитизация', 'user input', 'best practices']
  },

  {
    id: 59,
    question: "Как правильно хранить чувствительные данные в браузере? localStorage vs cookies vs sessionStorage.",
    answer: "<p><strong>Хранение чувствительных данных в браузере</strong> требует понимания рисков и особенностей каждого механизма.</p><p><strong>Типы хранилищ и их безопасность:</strong></p><p><strong>1. HTTP-Only Cookies (самое безопасное для auth):</strong></p><p><strong>Особенности:</strong></p><ul><li>Недоступны для JavaScript (document.cookie)</li><li>Автоматически отправляются с запросами</li><li>Защита от XSS через HttpOnly флаг</li></ul><p><strong>Безопасная конфигурация:</strong></p><ul><li>Set-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</li><li>HttpOnly — защита от XSS</li><li>Secure — только HTTPS</li><li>SameSite — защита от CSRF</li></ul><p><strong>Что хранить:</strong></p><ul><li>✅ Session tokens</li><li>✅ Authentication credentials</li><li>✅ CSRF tokens</li></ul><p><strong>2. localStorage (НЕ для чувствительных данных):</strong></p><p><strong>Риски:</strong></p><ul><li>❌ Доступен любому JavaScript на странице</li><li>❌ Уязвим к XSS атакам</li><li>❌ Нет автоматического истечения</li><li>❌ Нет защиты вроде HttpOnly</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Пользовательские настройки (тема, язык)</li><li>✅ Кэш некритичных данных</li><li>✅ Draft состояния форм</li><li>❌ НЕ для auth tokens</li><li>❌ НЕ для персональных данных</li></ul><p><strong>3. sessionStorage (чуть безопаснее localStorage):</strong></p><p><strong>Отличия от localStorage:</strong></p><ul><li>Удаляется при закрытии вкладки/окна</li><li>Не доступен другим вкладкам</li><li>Ограничен одной сессией браузера</li></ul><p><strong>Те же риски XSS:</strong></p><ul><li>❌ Доступен JavaScript</li><li>❌ Уязвим к XSS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Временное состояние UI</li><li>✅ Multi-step form данные</li><li>✅ Временный кэш</li></ul><p><strong>Сравнение механизмов:</strong></p><table><tr><th>Свойство</th><th>HttpOnly Cookie</th><th>localStorage</th><th>sessionStorage</th></tr><tr><td>XSS защита</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>JS доступ</td><td>❌ Нет</td><td>✅ Да</td><td>✅ Да</td></tr><tr><td>Автоотправка</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>Размер</td><td>~4KB</td><td>~5-10MB</td><td>~5-10MB</td></tr><tr><td>Время жизни</td><td>Настраиваемо</td><td>Постоянно</td><td>До закрытия</td></tr></table><p><strong>Рекомендации по хранению:</strong></p><p><strong>Authentication tokens:</strong></p><ul><li>✅ Лучший вариант: HttpOnly Secure cookies</li><li>❌ Плохой вариант: localStorage</li><li>Причина: защита от XSS критична</li></ul><p><strong>JWT токены:</strong></p><p><strong>Вариант 1 — HttpOnly cookie (рекомендуется):</strong></p><ul><li>Токен в cookie, сервер парсит</li><li>Защита от XSS</li></ul><p><strong>Вариант 2 — localStorage + Authorization header:</strong></p><ul><li>fetch('/api', { headers: { 'Authorization': 'Bearer ' + token } })</li><li>Уязвимо к XSS</li><li>НО не подвержено CSRF (токен не отправляется автоматически)</li></ul><p><strong>Hybrid подход:</strong></p><ul><li>Access token — короткоживущий, в памяти JS</li><li>Refresh token — HttpOnly cookie</li><li>Баланс удобства и безопасности</li></ul><p><strong>Шифрование в браузере:</strong></p><p><strong>Web Crypto API:</strong></p><ul><li>Шифрование чувствительных данных перед хранением</li><li>crypto.subtle.encrypt()</li><li>НО ключ всё равно в браузере</li><li>Защита не от XSS, но от физического доступа</li></ul><p><strong>Ограничения шифрования:</strong></p><ul><li>Если злонамеленный JS выполнился (XSS)</li><li>Он может перехватить данные ДО шифрования</li><li>Шифрование не заменяет другие меры</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ HttpOnly cookies для auth данных</li><li>✅ Минимизировать хранение чувствительного в браузере</li><li>✅ Короткое время жизни токенов</li><li>✅ Используйте SameSite для cookies</li><li>✅ HTTPS везде (Secure flag)</li><li>✅ CSP для защиты от XSS</li><li>✅ Регулярная ротация токенов</li><li>✅ Logout должен очищать ВСЕ данные</li><li>❌ Никогда пароли в браузере</li><li>❌ Никогда API ключи в localStorage</li></ul><p><strong>Альтернативы браузерному хранению:</strong></p><ul><li>Server-side sessions — данные на сервере, только ID в cookie</li><li>Stateless JWT — краткосрочные токены</li><li>OAuth tokens — делегированная авторизация</li></ul>",
    difficulty: 'middle',
    tags: ['хранение данных', 'localStorage', 'cookies', 'безопасность', 'auth']
  },
  {
    id: 60,
    question: "Какие существуют атаки на session management и как защититься?",
    answer: "<p><strong>Session management</strong> — критичная часть безопасности веб-приложений, которая часто становится целью атак.</p><p><strong>Типы атак на сессии:</strong></p><p><strong>1. Session Hijacking (перехват сессии):</strong></p><p><strong>Как работает:</strong></p><ul><li>Злонамеленник получает session ID жертвы</li><li>Использует его для доступа к аккаунту</li><li>Выдает себя за легитимного пользователя</li></ul><p><strong>Методы получения session ID:</strong></p><ul><li>XSS — кража через document.cookie</li><li>Network sniffing — перехват в незашифрованном трафике</li><li>Man-in-the-Middle — подмена в пути</li><li>Malware на устройстве жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HttpOnly cookies — защита от XSS</li><li>✅ Secure flag — только HTTPS</li><li>✅ HTTPS везде — защита от sniffing</li><li>✅ SameSite cookies — дополнительная защита</li><li>✅ Регенерация session ID после логина</li></ul><p><strong>2. Session Fixation (фиксация сессии):</strong></p><p><strong>Как работает:</strong></p><ol><li>Злонамеленник получает валидный session ID</li><li>Заставляет жертву использовать этот ID</li><li>Жертва логинится с известным ID</li><li>Злонамеленник использует тот же ID — авторизован</li></ol><p><strong>Пример атаки:</strong></p><ul><li>site.com?sessionId=attacker-known-id</li><li>Жертва логинится</li><li>Злонамеленник использует attacker-known-id</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Регенерация session ID при логине</li><li>✅ Отклонять session ID из URL параметров</li><li>✅ Использовать только server-generated session IDs</li><li>✅ Валидировать session при повышении привилегий</li></ul><p><strong>3. Session Prediction (предсказание сессии):</strong></p><p><strong>Проблема:</strong></p><ul><li>Слабый алгоритм генерации session ID</li><li>Предсказуемые паттерны (инкремент, timestamp)</li><li>Недостаточная энтропия</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Криптографически стойкие генераторы</li><li>✅ Достаточная длина ID (128+ бит)</li><li>✅ Использовать crypto.randomBytes()</li><li>✅ Избегать последовательных/предсказуемых ID</li></ul><p><strong>4. Cross-Site Request Forgery (CSRF):</strong></p><ul><li>Злонамеленный сайт использует сессию жертвы</li><li>Браузер автоматически отправляет session cookie</li><li>Действия выполняются от имени жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ CSRF токены</li><li>✅ SameSite cookies</li><li>✅ Проверка Origin/Referer</li><li>✅ Re-authentication для критичных операций</li></ul><p><strong>5. Session Timeout Issues:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Слишком длинные сессии</li><li>Отсутствие idle timeout</li><li>Сессия не завершается при logout</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Разумное время жизни (15-30 минут idle)</li><li>✅ Absolute timeout (например, 24 часа)</li><li>✅ Корректный logout — удаление session</li><li>✅ Sliding expiration при активности</li></ul><p><strong>6. Concurrent Session Attacks:</strong></p><p><strong>Проблема:</strong></p><ul><li>Множество активных сессий одного пользователя</li><li>Украденный токен используется параллельно</li><li>Сложно обнаружить компрометацию</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Ограничение числа активных сессий</li><li>✅ Logout из всех устройств при смене пароля</li><li>✅ Список активных сессий для пользователя</li><li>✅ Возможность terminate конкретную сессию</li></ul><p><strong>Best Practices для Session Management:</strong></p><p><strong>Генерация Session ID:</strong></p><ul><li>✅ Минимум 128 бит энтропии</li><li>✅ Криптографически стойкий RNG</li><li>✅ Без предсказуемых паттернов</li></ul><p><strong>Хранение на сервере:</strong></p><ul><li>✅ Хешировать session ID перед хранением</li><li>✅ Ассоциировать с IP, User-Agent (опционально)</li><li>✅ Хранить время создания и последней активности</li></ul><p><strong>Cookie конфигурация:</strong></p><ul><li>✅ HttpOnly — обязательно</li><li>✅ Secure — обязательно</li><li>✅ SameSite=Lax минимум, Strict лучше</li><li>✅ Правильный Path и Domain</li></ul><p><strong>Lifecycle управление:</strong></p><ul><li>✅ Регенерация при логине/logout</li><li>✅ Регенерация при изменении привилегий</li><li>✅ Автоматическое истечение</li><li>✅ Явное завершение при logout</li></ul><p><strong>Мониторинг и аудит:</strong></p><ul><li>✅ Логировать создание/удаление сессий</li><li>✅ Алерты на подозрительную активность</li><li>✅ Обнаружение множественных сессий</li><li>✅ Географические аномалии</li></ul><p><strong>Дополнительные меры:</strong></p><ul><li>✅ Двухфакторная аутентификация</li><li>✅ Device fingerprinting</li><li>✅ Behavioral analytics</li><li>✅ Rate limiting</li></ul>",
    difficulty: 'senior',
    tags: ['session management', 'безопасность', 'session hijacking', 'атаки', 'защита']
  },
  {
    id: 61,
    question: "Что такое JWT (JSON Web Token) и для каких целей он используется?",
    answer: "<p><strong>JWT (JSON Web Token)</strong> — это открытый стандарт (RFC 7519) для создания токенов доступа, которые позволяют передавать информацию между сторонами в компактном и безопасном виде.</p><p><strong>Основная идея JWT:</strong></p><ul><li>Самодостаточный токен, содержащий всю необходимую информацию</li><li>Не требует хранения состояния на сервере (stateless)</li><li>Подписан цифровой подписью для проверки подлинности</li><li>Компактный формат для передачи в HTTP заголовках</li></ul><p><strong>Основные цели использования:</strong></p><p><strong>1. Аутентификация:</strong></p><ul><li>После успешного логина сервер выдает JWT</li><li>Клиент отправляет токен с каждым запросом</li><li>Сервер проверяет подпись и извлекает данные пользователя</li><li>Не нужно обращаться к БД для проверки сессии</li></ul><p><strong>2. Обмен информацией:</strong></p><ul><li>Безопасная передача данных между сторонами</li><li>Подпись гарантирует, что данные не изменены</li><li>Можно проверить отправителя</li></ul><p><strong>3. Авторизация:</strong></p><ul><li>Токен содержит роли и права пользователя</li><li>Сервер проверяет разрешения без запроса к БД</li><li>Decentralized авторизация в микросервисах</li></ul><p><strong>Преимущества JWT:</strong></p><ul><li>✅ Stateless — сервер не хранит сессии</li><li>✅ Масштабируемость — любой сервер может валидировать</li><li>✅ Подходит для микросервисов и API</li><li>✅ Cross-domain — работает между доменами</li><li>✅ Мобильные приложения — удобная авторизация</li></ul><p><strong>Типичные сценарии использования:</strong></p><ul><li>Single Sign-On (SSO) — один токен для многих сервисов</li><li>Мобильные API — нет cookies, только токены</li><li>Микросервисная архитектура — независимая верификация</li><li>SPA приложения — хранение в localStorage/memory</li></ul>",
    difficulty: 'junior',
    tags: ['JWT', 'аутентификация', 'токены', 'безопасность']
  },

  {
    id: 62,
    question: "Какова структура JWT и какие компоненты входят в его состав?",
    answer: "<p><strong>JWT состоит из трёх частей</strong>, разделённых точками: Header.Payload.Signature</p><p><strong>1. Header (заголовок):</strong></p><p>Содержит метаданные о токене:</p><ul><li><strong>typ</strong> — тип токена, обычно 'JWT'</li><li><strong>alg</strong> — алгоритм подписи (HS256, RS256, ES256)</li></ul><p><strong>Пример:</strong></p><ul><li>{ \"alg\": \"HS256\", \"typ\": \"JWT\" }</li><li>Кодируется в Base64Url</li><li>Результат: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</li></ul><p><strong>2. Payload (полезная нагрузка):</strong></p><p>Содержит claims — утверждения о пользователе и данные:</p><p><strong>Стандартные claims (registered):</strong></p><ul><li><strong>iss</strong> (issuer) — кто выпустил токен</li><li><strong>sub</strong> (subject) — о ком токен (обычно user ID)</li><li><strong>aud</strong> (audience) — для кого предназначен</li><li><strong>exp</strong> (expiration) — время истечения (timestamp)</li><li><strong>nbf</strong> (not before) — не использовать до этого времени</li><li><strong>iat</strong> (issued at) — время создания</li><li><strong>jti</strong> (JWT ID) — уникальный ID токена</li></ul><p><strong>Пользовательские claims:</strong></p><ul><li>Любые данные: { \"userId\": 123, \"role\": \"admin\", \"email\": \"user@example.com\" }</li></ul><p><strong>Пример Payload:</strong></p><ul><li>{ \"sub\": \"1234567890\", \"name\": \"John Doe\", \"role\": \"admin\", \"iat\": 1516239022, \"exp\": 1516242622 }</li><li>Кодируется в Base64Url</li></ul><p><strong>⚠️ Важно:</strong> Payload НЕ зашифрован, только закодирован Base64. Любой может декодировать и прочитать. Не храните секреты в JWT!</p><p><strong>3. Signature (подпись):</strong></p><p>Обеспечивает целостность и подлинность:</p><p><strong>Как создаётся:</strong></p><ul><li>Берём закодированные Header и Payload</li><li>Объединяем через точку: encodedHeader.encodedPayload</li><li>Подписываем секретным ключом с указанным алгоритмом</li><li>HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)</li></ul><p><strong>Назначение подписи:</strong></p><ul><li>✅ Проверяет что токен не изменён</li><li>✅ Подтверждает что токен создан доверенным сервером</li><li>❌ НЕ шифрует данные (данные видны всем)</li></ul><p><strong>Полный токен выглядит так:</strong></p><ul><li>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</li></ul><p><strong>Процесс декодирования:</strong></p><ol><li>Разделить по точкам на 3 части</li><li>Base64Url декодировать Header и Payload</li><li>Проверить подпись используя секретный ключ</li><li>Если подпись валидна — токен подлинный</li></ol><p><strong>Base64Url кодирование:</strong></p><ul><li>Похоже на обычный Base64</li><li>НО: + заменяется на -, / на _, убираются =</li><li>Безопасно для URL и HTTP заголовков</li></ul>",
    difficulty: 'junior',
    tags: ['JWT', 'структура', 'Header', 'Payload', 'Signature']
  },

  {
    id: 63,
    question: "Опишите механизм работы аутентификации с помощью JWT",
    answer: "<p><strong>Процесс аутентификации с JWT</strong> состоит из нескольких этапов:</p><p><strong>Шаг 1 — Логин (получение токена):</strong></p><ol><li>Пользователь отправляет credentials (email, пароль)</li><li>Сервер проверяет данные в БД</li><li>Если верно — сервер создаёт JWT с данными пользователя</li><li>Сервер отправляет JWT клиенту</li></ol><p><strong>Пример ответа:</strong></p><ul><li>{ \"accessToken\": \"eyJhbGc...\", \"tokenType\": \"Bearer\", \"expiresIn\": 3600 }</li></ul><p><strong>Шаг 2 — Хранение токена на клиенте:</strong></p><p><strong>Варианты хранения:</strong></p><ul><li>В памяти JavaScript (переменная) — самое безопасное, но теряется при перезагрузке</li><li>localStorage — удобно, но уязвимо к XSS</li><li>sessionStorage — удаляется при закрытии вкладки</li><li>HttpOnly cookie — защита от XSS, но нужна защита от CSRF</li></ul><p><strong>Шаг 3 — Отправка токена с запросами:</strong></p><p><strong>Стандартный способ — Authorization заголовок:</strong></p><ul><li>Authorization: Bearer eyJhbGciOiJIUzI1NiIs...</li><li>\"Bearer\" — тип токена (схема аутентификации)</li><li>Отправляется с каждым API запросом</li></ul><p><strong>Пример fetch запроса:</strong></p><ul><li>fetch('/api/data', { headers: { 'Authorization': `Bearer ${token}` } })</li></ul><p><strong>Шаг 4 — Верификация на сервере:</strong></p><ol><li>Сервер извлекает токен из заголовка</li><li>Проверяет подпись с помощью секретного ключа</li><li>Если подпись валидна — токен подлинный</li><li>Проверяет exp (время истечения)</li><li>Извлекает данные из payload (userId, role)</li><li>Выполняет запрос с правами пользователя</li></ol><p><strong>Псевдокод верификации:</strong></p><ul><li>const token = req.headers.authorization?.split(' ')[1];</li><li>const decoded = jwt.verify(token, SECRET_KEY);</li><li>if (decoded.exp < Date.now() / 1000) throw 'expired';</li><li>req.user = decoded; // userId, role и т.д.</li></ul><p><strong>Шаг 5 — Обработка истечения токена:</strong></p><p><strong>Access Token истёк:</strong></p><ul><li>Сервер возвращает 401 Unauthorized</li><li>Клиент пытается обновить токен</li></ul><p><strong>Refresh Token механизм:</strong></p><ol><li>Access token — короткий (15 минут), для API запросов</li><li>Refresh token — длинный (7 дней), для обновления access token</li><li>Когда access истёк — отправляем refresh token</li><li>Сервер выдаёт новый access token</li><li>Если refresh истёк — требуется повторный логин</li></ol><p><strong>Шаг 6 — Logout:</strong></p><p><strong>На клиенте:</strong></p><ul><li>Удалить токен из хранилища</li><li>localStorage.removeItem('token')</li><li>Очистить состояние приложения</li></ul><p><strong>На сервере (опционально):</strong></p><ul><li>JWT stateless, но можно добавить blacklist</li><li>Сохранить jti (token ID) в Redis с TTL = exp</li><li>При верификации проверять не в blacklist ли</li></ul><p><strong>Полный flow:</strong></p><ol><li>👤 POST /auth/login { email, password }</li><li>🔐 Сервер проверяет, создаёт JWT</li><li>← { accessToken, refreshToken }</li><li>💾 Клиент сохраняет токены</li><li>🔄 GET /api/data + Authorization: Bearer token</li><li>✅ Сервер верифицирует и отвечает</li><li>⏰ Access token истёк → 401</li><li>🔄 POST /auth/refresh { refreshToken }</li><li>← { accessToken }</li><li>🚪 Logout — удаление токенов</li></ol><p><strong>Важные детали:</strong></p><ul><li>✅ Токен передаётся в каждом запросе</li><li>✅ Сервер не хранит сессии (stateless)</li><li>✅ Любой сервер может валидировать токен</li><li>✅ Масштабируемость из коробки</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'аутентификация', 'flow', 'механизм работы']
  },

  {
    id: 64,
    question: "Как JWT отличается от традиционных методов аутентификации, таких как использование сессий?",
    answer: "<p><strong>Сравнение JWT и Session-based аутентификации</strong> показывает фундаментальные различия в подходах.</p><p><strong>Session-based аутентификация:</strong></p><p><strong>Как работает:</strong></p><ol><li>Пользователь логинится</li><li>Сервер создаёт session в БД/памяти</li><li>Клиенту отправляется session ID в cookie</li><li>Cookie автоматически отправляется с каждым запросом</li><li>Сервер находит session по ID и проверяет</li></ol><p><strong>JWT аутентификация:</strong></p><p><strong>Как работает:</strong></p><ol><li>Пользователь логинится</li><li>Сервер создаёт JWT с данными пользователя</li><li>JWT отправляется клиенту</li><li>Клиент сохраняет и отправляет в заголовке</li><li>Сервер верифицирует подпись без обращения к БД</li></ol><p><strong>Ключевые отличия:</strong></p><table><tr><th>Аспект</th><th>Sessions</th><th>JWT</th></tr><tr><td>Хранение состояния</td><td>Stateful (сервер хранит)</td><td>Stateless (всё в токене)</td></tr><tr><td>Хранилище</td><td>БД/Redis/память сервера</td><td>Клиент хранит токен</td></tr><tr><td>Масштабируемость</td><td>Сложнее (нужна синхронизация)</td><td>Легко (любой сервер валидирует)</td></tr><tr><td>Размер данных</td><td>Только ID (~20 байт)</td><td>Полные данные (~200-500 байт)</td></tr><tr><td>База данных</td><td>Запрос при каждой проверке</td><td>Нет запросов</td></tr><tr><td>Отзыв токена</td><td>Просто (удалить session)</td><td>Сложно (нужен blacklist)</td></tr><tr><td>Время жизни</td><td>Гибкое управление</td><td>Фиксировано при создании</td></tr></table><p><strong>Преимущества Sessions:</strong></p><ul><li>✅ Мгновенный logout — удалил session</li><li>✅ Полный контроль на сервере</li><li>✅ Можно обновлять права без relogin</li><li>✅ Меньше трафика (только ID)</li><li>✅ Легче управлять активными сессиями</li></ul><p><strong>Недостатки Sessions:</strong></p><ul><li>❌ Stateful — нужно хранить на сервере</li><li>❌ Масштабирование — нужна синхронизация или sticky sessions</li><li>❌ Запросы к БД для каждой проверки</li><li>❌ CORS сложности с cookies</li><li>❌ Мобильные приложения — cookies неудобны</li></ul><p><strong>Преимущества JWT:</strong></p><ul><li>✅ Stateless — сервер не хранит</li><li>✅ Горизонтальное масштабирование без проблем</li><li>✅ Нет запросов к БД для верификации</li><li>✅ Работает везде (mobile, SPA, API)</li><li>✅ Микросервисы — каждый сервис валидирует</li><li>✅ Cross-domain — легко передавать</li></ul><p><strong>Недостатки JWT:</strong></p><ul><li>❌ Невозможно отозвать до истечения (нужен blacklist)</li><li>❌ Больше трафика (полные данные)</li><li>❌ Данные в токене могут устареть</li><li>❌ XSS уязвимость если в localStorage</li><li>❌ Сложнее обновлять права пользователя</li></ul><p><strong>Когда использовать Sessions:</strong></p><ul><li>Монолитные приложения</li><li>Когда нужен строгий контроль сессий</li><li>Важен мгновенный logout</li><li>Данные пользователя часто меняются</li><li>Нет проблем с масштабированием</li></ul><p><strong>Когда использовать JWT:</strong></p><ul><li>Микросервисная архитектура</li><li>Мобильные приложения</li><li>SPA с отдельным API</li><li>Горизонтальное масштабирование</li><li>Cross-domain сценарии</li><li>Stateless API</li></ul><p><strong>Гибридный подход (лучшее из обоих):</strong></p><ul><li>JWT для access token (короткоживущий, 15 мин)</li><li>Session для refresh token (хранится на сервере)</li><li>Баланс между производительностью и контролем</li></ul><p><strong>Практические различия:</strong></p><p><strong>Logout в Sessions:</strong></p><ul><li>DELETE /sessions/current → удалить из БД → мгновенный эффект</li></ul><p><strong>Logout в JWT:</strong></p><ul><li>Удалить токен на клиенте</li><li>Токен всё ещё валиден до exp</li><li>Нужен blacklist для \"реального\" logout</li></ul><p><strong>Обновление прав в Sessions:</strong></p><ul><li>Обновить данные в session store → эффект сразу</li></ul><p><strong>Обновление прав в JWT:</strong></p><ul><li>Токен содержит старые права до exp</li><li>Нужно ждать истечения или принудительно обновлять</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'sessions', 'сравнение', 'аутентификация', 'stateless']
  },

  {
    id: 65,
    question: "Как обрабатывать и обеспечивать безопасность JWT на стороне сервера и клиента?",
    answer: "<p><strong>Безопасность JWT</strong> требует правильной реализации на обеих сторонах.</p><p><strong>Безопасность на стороне сервера:</strong></p><p><strong>1. Выбор сильного алгоритма подписи:</strong></p><ul><li>✅ RS256 (RSA) — асимметричное шифрование, публичный ключ для проверки</li><li>✅ ES256 (ECDSA) — быстрее RSA, хорошая безопасность</li><li>✅ HS256 (HMAC) — симметричное, требует защиты секрета</li><li>❌ Избегать 'none' алгоритм (без подписи!)</li></ul><p><strong>2. Безопасное хранение секретного ключа:</strong></p><ul><li>❌ НЕ хардкодить в коде</li><li>✅ Переменные окружения (process.env.JWT_SECRET)</li><li>✅ Secrets management (AWS Secrets Manager, HashiCorp Vault)</li><li>✅ Минимум 256 бит случайности</li><li>✅ Регулярная ротация ключей</li></ul><p><strong>3. Установка правильного exp (expiration):</strong></p><ul><li>Access token — короткий срок (15 минут)</li><li>Refresh token — дольше (7 дней, но с ротацией)</li><li>Баланс между UX и безопасностью</li></ul><p><strong>4. Валидация всех claims:</strong></p><ul><li>✅ Проверять exp — токен не истёк</li><li>✅ Проверять nbf — не используется раньше времени</li><li>✅ Проверять iss — правильный issuer</li><li>✅ Проверять aud — токен для нас</li></ul><p><strong>5. Защита от подмены алгоритма:</strong></p><ul><li>❌ Уязвимость: сменить alg на 'none'</li><li>✅ Явно указывать ожидаемый алгоритм при верификации</li><li>✅ jwt.verify(token, secret, { algorithms: ['HS256'] })</li><li>❌ НЕ доверять alg из заголовка безусловно</li></ul><p><strong>6. Реализация Refresh Token механизма:</strong></p><ul><li>Refresh token хранится в БД</li><li>Возможность отозвать (удалить из БД)</li><li>Rotation — новый refresh при каждом использовании</li><li>Reuse detection — если старый refresh использован, отозвать все</li></ul><p><strong>7. Blacklist для отозванных токенов:</strong></p><ul><li>Redis с TTL = время до exp</li><li>Сохранять jti (token ID) при logout</li><li>Проверять при каждой валидации</li></ul><p><strong>8. Rate Limiting:</strong></p><ul><li>Ограничение попыток refresh</li><li>Защита от brute force</li></ul><p><strong>Безопасность на стороне клиента:</strong></p><p><strong>1. Безопасное хранение токена:</strong></p><p><strong>Варианты и риски:</strong></p><table><tr><th>Способ</th><th>XSS риск</th><th>CSRF риск</th><th>Рекомендация</th></tr><tr><td>localStorage</td><td>❌ Высокий</td><td>✅ Низкий</td><td>Избегать для auth</td></tr><tr><td>sessionStorage</td><td>❌ Высокий</td><td>✅ Низкий</td><td>Лучше localStorage</td></tr><tr><td>Memory (JS переменная)</td><td>⚠️ Средний</td><td>✅ Низкий</td><td>✅ Лучший</td></tr><tr><td>HttpOnly Cookie</td><td>✅ Низкий</td><td>❌ Высокий</td><td>С CSRF защитой</td></tr></table><p><strong>Рекомендуемый подход:</strong></p><ul><li>Access token — в памяти JS (переменная)</li><li>Refresh token — HttpOnly cookie</li><li>При перезагрузке — refresh для нового access</li></ul><p><strong>2. Защита от XSS:</strong></p><ul><li>✅ Content Security Policy (CSP)</li><li>✅ Санитизация пользовательского ввода</li><li>✅ Избегать innerHTML с user data</li><li>✅ Использовать фреймворки с auto-escaping</li><li>✅ Не хранить токен в localStorage если возможна XSS</li></ul><p><strong>3. Защита от CSRF (если токен в cookie):</strong></p><ul><li>✅ SameSite=Strict для cookie</li><li>✅ CSRF токены для state-changing операций</li><li>✅ Проверка Origin/Referer заголовков</li></ul><p><strong>4. HTTPS обязательно:</strong></p><ul><li>Токен передаётся в каждом запросе</li><li>HTTP — токен в plain text</li><li>Man-in-the-middle может украсть</li></ul><p><strong>5. Обработка истечения:</strong></p><ul><li>Отлавливать 401 ошибки</li><li>Автоматический refresh</li><li>Redirect на login если refresh тоже истёк</li></ul><p><strong>6. Не хранить чувствительные данные в JWT:</strong></p><ul><li>JWT можно декодировать без ключа</li><li>❌ НЕ хранить: пароли, кредитки, секреты</li><li>✅ Хранить: userId, role, email</li></ul><p><strong>Best Practices:</strong></p><p><strong>Сервер:</strong></p><ul><li>✅ Короткий exp для access token</li><li>✅ Сильный секретный ключ (256+ бит)</li><li>✅ Явная проверка алгоритма</li><li>✅ Валидация всех claims</li><li>✅ Refresh token механизм</li><li>✅ Логирование подозрительной активности</li></ul><p><strong>Клиент:</strong></p><ul><li>✅ Токен в памяти, не в localStorage</li><li>✅ HTTPS везде</li><li>✅ CSP для защиты от XSS</li><li>✅ Автоматический refresh</li><li>✅ Очистка токена при logout</li><li>✅ Проверка exp перед отправкой</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'безопасность', 'защита', 'хранение', 'клиент-сервер']
  },

  {
    id: 66,
    question: "Какую роль играют алгоритмы подписи (signature algorithms) при использовании JWT?",
    answer: "<p><strong>Алгоритмы подписи</strong> — это криптографические методы, обеспечивающие целостность и подлинность JWT.</p><p><strong>Основные типы алгоритмов:</strong></p><p><strong>1. Симметричные алгоритмы (HMAC):</strong></p><p><strong>HS256 (HMAC-SHA256):</strong></p><ul><li>Один секретный ключ для подписи И проверки</li><li>Быстрый и простой</li><li>Ключ должен быть на всех серверах</li></ul><p><strong>Как работает:</strong></p><ul><li>signature = HMAC-SHA256(header + payload, secret)</li><li>Тот же секрет для создания и проверки</li></ul><p><strong>HS384, HS512:</strong></p><ul><li>Та же идея, но SHA-384 и SHA-512</li><li>Более длинный hash</li></ul><p><strong>Преимущества HMAC:</strong></p><ul><li>✅ Быстрая работа</li><li>✅ Простая реализация</li><li>✅ Меньше вычислительных ресурсов</li></ul><p><strong>Недостатки HMAC:</strong></p><ul><li>❌ Секрет должен быть везде</li><li>❌ Любой с секретом может создавать токены</li><li>❌ Сложнее для микросервисов</li><li>❌ Риск компрометации если секрет утёк</li></ul><p><strong>2. Асимметричные алгоритмы (RSA, ECDSA):</strong></p><p><strong>RS256 (RSA-SHA256):</strong></p><ul><li>Пара ключей: приватный и публичный</li><li>Приватный — для подписи (только auth сервер)</li><li>Публичный — для проверки (любой сервер)</li></ul><p><strong>Как работает:</strong></p><ul><li>Подпись: RSA-sign(hash(header + payload), privateKey)</li><li>Проверка: RSA-verify(signature, hash(header + payload), publicKey)</li></ul><p><strong>RS384, RS512:</strong></p><ul><li>RSA с SHA-384 и SHA-512</li></ul><p><strong>ES256 (ECDSA-SHA256):</strong></p><ul><li>Эллиптические кривые</li><li>Быстрее RSA при той же безопасности</li><li>Меньший размер ключей</li></ul><p><strong>ES384, ES512:</strong></p><ul><li>ECDSA с разными кривыми</li></ul><p><strong>Преимущества асимметричных:</strong></p><ul><li>✅ Публичный ключ можно раздавать всем</li><li>✅ Только auth сервер может создавать токены</li><li>✅ Идеально для микросервисов</li><li>✅ Компрометация публичного ключа не критична</li></ul><p><strong>Недостатки асимметричных:</strong></p><ul><li>❌ Медленнее симметричных</li><li>❌ Больший размер подписи</li><li>❌ Сложнее настройка</li></ul><p><strong>3. Алгоритм 'none' (без подписи):</strong></p><ul><li>❌ НЕТ подписи вообще</li><li>❌ Любой может создать токен</li><li>❌ НИКОГДА не использовать в production</li><li>❌ Существует для тестирования</li></ul><p><strong>Критическая уязвимость:</strong></p><ul><li>Атакующий меняет alg на 'none'</li><li>Удаляет подпись</li><li>Сервер принимает если не проверяет alg</li><li>✅ Защита: явно указывать algorithms: ['RS256']</li></ul><p><strong>Выбор алгоритма:</strong></p><table><tr><th>Сценарий</th><th>Рекомендация</th><th>Причина</th></tr><tr><td>Монолит</td><td>HS256</td><td>Простота, скорость</td></tr><tr><td>Микросервисы</td><td>RS256 или ES256</td><td>Раздача публичного ключа</td></tr><tr><td>Высокая нагрузка</td><td>ES256</td><td>Быстрее RSA</td></tr><tr><td>Legacy системы</td><td>RS256</td><td>Широкая поддержка</td></tr></table><p><strong>Практические примеры:</strong></p><p><strong>HS256 использование:</strong></p><ul><li>const token = jwt.sign(payload, 'secret', { algorithm: 'HS256' });</li><li>const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256'] });</li></ul><p><strong>RS256 использование:</strong></p><ul><li>Создание: jwt.sign(payload, privateKey, { algorithm: 'RS256' });</li><li>Проверка: jwt.verify(token, publicKey, { algorithms: ['RS256'] });</li></ul><p><strong>Роль алгоритма подписи:</strong></p><p><strong>1. Обеспечение целостности:</strong></p><ul><li>Любое изменение header или payload → подпись не совпадёт</li><li>Невозможно подделать без ключа</li></ul><p><strong>2. Аутентификация источника:</strong></p><ul><li>Только тот, у кого есть ключ, создал токен</li><li>Гарантия что токен от доверенного сервера</li></ul><p><strong>3. НЕ обеспечивает конфиденциальность:</strong></p><ul><li>❌ Payload не зашифрован</li><li>✅ Любой может декодировать и прочитать</li><li>Для секретности нужен JWE (JSON Web Encryption)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Явно указывать ожидаемый алгоритм при проверке</li><li>✅ Микросервисы — асимметричные алгоритмы</li><li>✅ Монолит/простой API — HMAC</li><li>✅ Минимум SHA-256 (не SHA-1)</li><li>✅ Никогда не использовать 'none'</li><li>✅ Проверять alg перед верификацией</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'алгоритмы подписи', 'криптография', 'HMAC', 'RSA', 'ECDSA']
  },

  {
    id: 67,
    question: "Как реализовать Refresh Token механизм для JWT и почему он важен?",
    answer: "<p><strong>Refresh Token механизм</strong> решает проблему баланса между безопасностью и удобством пользователя.</p><p><strong>Проблема без Refresh Token:</strong></p><ul><li>Короткий срок жизни access token (15 мин) → частые логины → плохой UX</li><li>Длинный срок жизни access token (30 дней) → больший риск при краже</li><li>Невозможно отозвать JWT до истечения</li></ul><p><strong>Решение — два типа токенов:</strong></p><p><strong>Access Token:</strong></p><ul><li>Короткий срок жизни (15-30 минут)</li><li>Используется для API запросов</li><li>Хранится в памяти или sessionStorage</li><li>НЕ хранится на сервере (stateless)</li></ul><p><strong>Refresh Token:</strong></p><ul><li>Длинный срок жизни (7-30 дней)</li><li>Используется ТОЛЬКО для получения нового access token</li><li>Хранится в БД на сервере (stateful)</li><li>Можно отозвать в любой момент</li></ul><p><strong>Flow работы:</strong></p><ol><li>👤 Пользователь логинится</li><li>← { accessToken (15 мин), refreshToken (7 дней) }</li><li>💾 Клиент: accessToken в памяти, refreshToken в HttpOnly cookie</li><li>🔄 API запросы с accessToken</li><li>⏰ Access token истёк → 401</li><li>🔄 POST /auth/refresh с refreshToken</li><li>✅ Сервер проверяет refresh в БД</li><li>← { accessToken (новый), refreshToken (опционально новый) }</li><li>🔁 Продолжение работы</li></ol><p><strong>Реализация на сервере:</strong></p><p><strong>При логине:</strong></p><ul><li>1. Создать access token: jwt.sign({ userId }, secret, { expiresIn: '15m' })</li><li>2. Создать refresh token: crypto.randomBytes(64).toString('hex')</li><li>3. Сохранить refresh в БД: { token, userId, expiresAt, createdAt }</li><li>4. Вернуть оба токена</li></ul><p><strong>При refresh запросе:</strong></p><ul><li>1. Получить refreshToken из запроса</li><li>2. Найти в БД: findOne({ token: refreshToken })</li><li>3. Проверки: существует? не истёк? не отозван?</li><li>4. Создать новый access token</li><li>5. (Опционально) Создать новый refresh token и удалить старый (rotation)</li><li>6. Вернуть новый access token</li></ul><p><strong>Refresh Token Rotation (повышенная безопасность):</strong></p><p><strong>Принцип:</strong></p><ul><li>При каждом использовании refresh token</li><li>Старый удаляется, создаётся новый</li><li>Один refresh token = одноразовый</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Обнаружение кражи токена</li><li>✅ Меньшее окно компрометации</li></ul><p><strong>Reuse Detection:</strong></p><ul><li>Если использован уже использованный refresh token</li><li>Это признак кражи!</li><li>→ Отозвать ВСЕ refresh tokens пользователя</li><li>→ Требовать повторный логин</li></ul><p><strong>Хранение Refresh Token на клиенте:</strong></p><p><strong>Вариант 1 — HttpOnly Cookie (рекомендуется):</strong></p><ul><li>✅ Защита от XSS</li><li>✅ Автоматическая отправка</li><li>❌ Нужна CSRF защита</li><li>Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict</li></ul><p><strong>Вариант 2 — localStorage (НЕ рекомендуется):</strong></p><ul><li>❌ Уязвимо к XSS</li><li>✅ Нет CSRF проблем</li><li>Только если XSS защита очень сильная</li></ul><p><strong>Отзыв Refresh Tokens:</strong></p><p><strong>При logout:</strong></p><ul><li>DELETE FROM refresh_tokens WHERE token = ?</li><li>Сразу становится невалидным</li></ul><p><strong>При смене пароля:</strong></p><ul><li>DELETE FROM refresh_tokens WHERE userId = ?</li><li>Все устройства разлогинены</li></ul><p><strong>При подозрении на взлом:</strong></p><ul><li>DELETE FROM refresh_tokens WHERE userId = ? AND deviceId != current</li><li>Удалить все кроме текущего устройства</li></ul><p><strong>Структура БД для refresh tokens:</strong></p><ul><li>Table: refresh_tokens</li><li>- id</li><li>- token (уникальный, индексированный)</li><li>- userId</li><li>- expiresAt</li><li>- createdAt</li><li>- deviceInfo (User-Agent, IP)</li><li>- isRevoked (для soft delete)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Access token — короткий (15-30 мин)</li><li>✅ Refresh token — средний (7-30 дней)</li><li>✅ Rotation при каждом использовании</li><li>✅ Reuse detection и отзыв при атаке</li><li>✅ Хранение refresh в HttpOnly cookie</li><li>✅ Логирование всех refresh операций</li><li>✅ Rate limiting на /refresh endpoint</li><li>✅ Отзыв при logout и смене пароля</li></ul><p><strong>Почему это важно:</strong></p><ul><li>✅ Баланс безопасности и UX</li><li>✅ Возможность отзыва доступа</li><li>✅ Обнаружение компрометации</li><li>✅ Контроль активных сессий</li><li>✅ Защита от длительной эксплуатации украденного токена</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'Refresh Token', 'безопасность', 'аутентификация', 'rotation']
  },

  {
    id: 68,
    question: "Какие уязвимости существуют при работе с JWT и как их предотвратить?",
    answer: "<p><strong>JWT имеет специфичные уязвимости</strong>, которые нужно знать и предотвращать.</p><p><strong>1. Algorithm Confusion Attack (подмена алгоритма):</strong></p><p><strong>Суть атаки:</strong></p><ul><li>JWT подписан RS256 (асимметричный)</li><li>Атакующий меняет alg на HS256 (симметричный)</li><li>Использует публичный ключ как секрет для HMAC</li><li>Публичный ключ известен всем!</li><li>Создаёт валидную подпись если сервер не проверяет alg</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Явно указывать ожидаемый алгоритм</li><li>✅ jwt.verify(token, key, { algorithms: ['RS256'] })</li><li>❌ НЕ доверять alg из header безусловно</li></ul><p><strong>2. 'None' Algorithm Attack:</strong></p><p><strong>Суть атаки:</strong></p><ul><li>Изменить alg на 'none'</li><li>Удалить подпись</li><li>Токен без проверки целостности</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Запретить 'none' в production</li><li>✅ algorithms: ['HS256', 'RS256'] — whitelist без 'none'</li></ul><p><strong>3. Слабый секретный ключ (для HMAC):</strong></p><p><strong>Проблема:</strong></p><ul><li>Простые секреты типа 'secret', '12345'</li><li>Brute force атака на подпись</li><li>Перебор популярных секретов</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Минимум 256 бит случайности</li><li>✅ crypto.randomBytes(32).toString('hex')</li><li>✅ Хранить в secrets manager</li><li>✅ Регулярная ротация</li></ul><p><strong>4. Отсутствие проверки exp (expiration):</strong></p><p><strong>Проблема:</strong></p><ul><li>Истёкший токен всё ещё принимается</li><li>Украденный токен работает вечно</li></ul><p><strong>Защита:</strong></p><ul><li>✅ ВСЕГДА проверять exp</li><li>✅ Библиотеки делают это по умолчанию</li><li>✅ НЕ отключать проверку</li></ul><p><strong>5. Чувствительные данные в Payload:</strong></p><p><strong>Проблема:</strong></p><ul><li>Payload не зашифрован, только закодирован</li><li>Любой может декодировать Base64</li><li>Пароли, номера карт, секреты видны всем</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Хранить только неконфиденциальные данные</li><li>✅ userId, role, email — OK</li><li>❌ password, creditCard, SSN — НЕТ</li><li>Или использовать JWE для шифрования</li></ul><p><strong>6. XSS атака при хранении в localStorage:</strong></p><p><strong>Проблема:</strong></p><ul><li>JWT в localStorage доступен JavaScript</li><li>XSS может украсть токен</li><li>localStorage.getItem('token')</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Хранить в памяти (переменная)</li><li>✅ Или HttpOnly cookie</li><li>✅ CSP для предотвращения XSS</li><li>✅ Санитизация user input</li></ul><p><strong>7. CSRF при хранении в cookie:</strong></p><p><strong>Проблема:</strong></p><ul><li>Cookie автоматически отправляется</li><li>Cross-site запрос включает токен</li></ul><p><strong>Защита:</strong></p><ul><li>✅ SameSite=Strict для cookie</li><li>✅ CSRF токены</li><li>✅ Проверка Origin заголовка</li></ul><p><strong>8. Невозможность отзыва (по умолчанию):</strong></p><p><strong>Проблема:</strong></p><ul><li>JWT stateless</li><li>Нельзя отозвать до истечения exp</li><li>Украденный токен валиден до exp</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Короткий exp для access token</li><li>✅ Refresh token с хранением в БД</li><li>✅ Blacklist для отозванных (jti в Redis)</li></ul><p><strong>9. JWT в URL параметрах:</strong></p><p><strong>Проблема:</strong></p><ul><li>URL логируются сервером, прокси, браузером</li><li>История браузера содержит токен</li><li>Referer header может утечь токен</li></ul><p><strong>Защита:</strong></p><ul><li>❌ НИКОГДА не передавать в URL</li><li>✅ Только в Authorization заголовке</li><li>✅ Или в HttpOnly cookie</li></ul><p><strong>10. Replay Attack:</strong></p><p><strong>Проблема:</strong></p><ul><li>Перехваченный токен переиспользуется</li><li>До истечения exp токен валиден</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HTTPS (защита от перехвата)</li><li>✅ Короткий exp</li><li>✅ Одноразовые токены для критичных операций</li><li>✅ Device fingerprinting</li></ul><p><strong>11. Массовое присвоение (Mass Assignment):</strong></p><p><strong>Проблема:</strong></p><ul><li>Злонамеренный пользователь добавляет claims</li><li>{ userId: 1, role: 'user' } → { userId: 1, role: 'admin' }</li><li>Сервер доверяет всем claims</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Проверять критичные claims на сервере</li><li>✅ Не доверять role из токена безусловно</li><li>✅ Сверять с БД для важных операций</li></ul><p><strong>Комплексная защита:</strong></p><ul><li>✅ Правильная конфигурация алгоритма</li><li>✅ Сильный секретный ключ</li><li>✅ Короткий exp + refresh механизм</li><li>✅ Безопасное хранение на клиенте</li><li>✅ HTTPS везде</li><li>✅ CSP против XSS</li><li>✅ SameSite против CSRF</li><li>✅ Логирование и мониторинг</li><li>✅ Rate limiting</li><li>✅ Регулярные security аудиты</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'уязвимости', 'безопасность', 'атаки', 'защита']
  },

  {
    id: 69,
    question: "Как работает JWT в микросервисной архитектуре и какие паттерны применяются?",
    answer: "<p><strong>JWT идеально подходит для микросервисов</strong> благодаря stateless природе и возможности независимой верификации.</p><p><strong>Базовая схема в микросервисах:</strong></p><ol><li>🔐 <strong>Authentication Service</strong> — выдаёт JWT</li><li>🌐 <strong>API Gateway</strong> — первичная верификация</li><li>⚙️ <strong>Микросервисы</strong> — вторичная верификация (опционально)</li></ol><p><strong>Паттерн 1 — Централизованная аутентификация:</strong></p><p><strong>Архитектура:</strong></p><ul><li>Один Auth Service для всех сервисов</li><li>Асимметричная криптография (RS256/ES256)</li><li>Auth Service имеет приватный ключ</li><li>Все сервисы имеют публичный ключ</li></ul><p><strong>Flow:</strong></p><ol><li>👤 Client → Auth Service: login</li><li>← JWT (подписан приватным ключом)</li><li>🔄 Client → API Gateway: request + JWT</li><li>✅ Gateway проверяет JWT (публичный ключ)</li><li>→ Микросервис: request + JWT (или только данные из JWT)</li><li>Микросервис обрабатывает запрос</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Каждый сервис может валидировать независимо</li><li>✅ Нет единой точки отказа при проверке</li><li>✅ Масштабируемость</li></ul><p><strong>Паттерн 2 — JWT с claims для авторизации:</strong></p><p><strong>Структура токена:</strong></p><ul><li>{ userId: 123, role: 'admin', permissions: ['read:users', 'write:orders'], tenantId: 'company-a' }</li></ul><p><strong>Использование:</strong></p><ul><li>Каждый микросервис проверяет необходимые claims</li><li>Order Service: проверяет permissions.includes('write:orders')</li><li>User Service: проверяет permissions.includes('read:users')</li><li>Multi-tenancy: проверяет tenantId</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Нет запросов к Auth Service для проверки прав</li><li>✅ Decentralized авторизация</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Права в токене могут устареть</li><li>❌ Нужно ждать exp для обновления прав</li></ul><p><strong>Паттерн 3 — Gateway-level проверка:</strong></p><p><strong>Архитектура:</strong></p><ul><li>API Gateway проверяет JWT</li><li>Извлекает данные пользователя</li><li>Передаёт в микросервисы через внутренние headers</li></ul><p><strong>Flow:</strong></p><ol><li>Client → Gateway: JWT</li><li>Gateway проверяет, декодирует</li><li>Gateway → Service: X-User-Id: 123, X-User-Role: admin</li><li>Микросервис доверяет headers от Gateway</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Микросервисы не думают о JWT</li><li>✅ Централизованная логика проверки</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Gateway — критичный компонент</li><li>❌ Нужна защита внутренних headers</li></ul><p><strong>Паттерн 4 — Token Exchange (OAuth2 Token Exchange):</strong></p><p><strong>Сценарий:</strong></p><ul><li>Service A нужно вызвать Service B от имени пользователя</li></ul><p><strong>Flow:</strong></p><ol><li>Service A имеет user JWT</li><li>Service A → Auth Service: обмен токена</li><li>← JWT для Service B (специфичный scope)</li><li>Service A → Service B: новый JWT</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Principle of least privilege</li><li>✅ Service B получает минимальные права</li></ul><p><strong>Паттерн 5 — Service-to-Service JWT:</strong></p><p><strong>Проблема:</strong></p><ul><li>Сервисы общаются между собой</li><li>Нужна аутентификация сервиса, не пользователя</li></ul><p><strong>Решение:</strong></p><ul><li>Отдельные JWT для межсервисного общения</li><li>{ serviceId: 'order-service', scope: 'read:inventory' }</li><li>Выдаются при старте сервиса или по запросу</li></ul><p><strong>Управление публичными ключами:</strong></p><p><strong>JWKS (JSON Web Key Set) endpoint:</strong></p><ul><li>Auth Service публикует публичные ключи</li><li>GET /auth/.well-known/jwks.json</li><li>Микросервисы загружают при старте или кэшируют</li></ul><p><strong>Ротация ключей:</strong></p><ul><li>Периодическая смена ключей для безопасности</li><li>Старые ключи в JWKS для переходного периода</li><li>kid (key ID) в JWT header для выбора ключа</li></ul><p><strong>Best Practices для микросервисов:</strong></p><ul><li>✅ Асимметричная криптография (RS256/ES256)</li><li>✅ JWKS endpoint для раздачи публичных ключей</li><li>✅ Короткий exp для access token (5-15 мин)</li><li>✅ Gateway проверяет + сервисы могут перепроверить</li><li>✅ Claims для авторизации в токене</li><li>✅ Service mesh для внутреннего общения (mTLS)</li><li>✅ Логирование всех верификаций</li><li>✅ Correlation ID для трейсинга</li></ul><p><strong>Проблемы и решения:</strong></p><p><strong>Устаревшие данные в токене:</strong></p><ul><li>Проблема: права изменились, но токен старый</li><li>Решение: короткий exp или проверка критичных прав в БД</li></ul><p><strong>Отзыв токенов:</strong></p><ul><li>Проблема: stateless = нельзя отозвать</li><li>Решение: короткий exp + refresh mechanism + blacklist в Redis</li></ul><p><strong>Network latency:</strong></p><ul><li>Проблема: каждый сервис проверяет сам</li><li>Решение: Gateway проверяет, сервисы доверяют или кэшируют результат</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'микросервисы', 'архитектура', 'паттерны', 'distributed systems']
  },

  {
    id: 70,
    question: "В чём разница между JWT, OAuth2 и OpenID Connect?",
    answer: "<p><strong>JWT, OAuth2 и OpenID Connect</strong> — это разные вещи, которые часто используются вместе, но решают разные задачи.</p><p><strong>JWT (JSON Web Token):</strong></p><p><strong>Что это:</strong></p><ul><li>Формат для передачи информации</li><li>Технология кодирования и подписи</li><li>НЕ протокол аутентификации/авторизации</li></ul><p><strong>Назначение:</strong></p><ul><li>Компактный способ передать claims</li><li>Self-contained — всё внутри токена</li><li>Может использоваться где угодно</li></ul><p><strong>Аналогия:</strong></p><ul><li>JWT — это конверт с информацией</li><li>Может содержать любые данные</li><li>Подпись гарантирует подлинность</li></ul><p><strong>OAuth2:</strong></p><p><strong>Что это:</strong></p><ul><li>Протокол авторизации (НЕ аутентификации!)</li><li>Делегирование доступа третьим приложениям</li><li>Framework, описывающий flows</li></ul><p><strong>Назначение:</strong></p><ul><li>Получить ограниченный доступ без пароля</li><li>\"Приложение X хочет читать ваши email\"</li><li>Выдача access tokens третьим приложениям</li></ul><p><strong>Основные роли:</strong></p><ul><li>Resource Owner — пользователь (владелец данных)</li><li>Client — приложение (запрашивает доступ)</li><li>Authorization Server — выдаёт токены</li><li>Resource Server — API с защищёнными ресурсами</li></ul><p><strong>OAuth2 flows:</strong></p><ul><li>Authorization Code — для веб/мобильных приложений</li><li>Implicit — устаревший, для SPA</li><li>Client Credentials — для сервис-к-сервису</li><li>Resource Owner Password — для доверенных приложений</li></ul><p><strong>Важно:</strong></p><ul><li>OAuth2 НЕ говорит формат токена</li><li>Может быть JWT, может быть opaque token</li><li>OAuth2 — про авторизацию, НЕ про \"кто ты\"</li></ul><p><strong>OpenID Connect (OIDC):</strong></p><p><strong>Что это:</strong></p><ul><li>Надстройка над OAuth2</li><li>Добавляет аутентификацию к авторизации</li><li>Протокол для \"единого входа\" (SSO)</li></ul><p><strong>Назначение:</strong></p><ul><li>Узнать \"кто пользователь\"</li><li>Получить профиль пользователя</li><li>Single Sign-On между приложениями</li></ul><p><strong>Что добавляет к OAuth2:</strong></p><ul><li><strong>ID Token</strong> — JWT с информацией о пользователе</li><li><strong>UserInfo endpoint</strong> — получить полный профиль</li><li><strong>Стандартные claims</strong> — sub, name, email, picture</li><li><strong>Authentication flows</strong> — поверх OAuth2</li></ul><p><strong>ID Token структура:</strong></p><ul><li>{ sub: 'user-id', name: 'John Doe', email: 'john@example.com', iss: 'https://auth.example.com', aud: 'client-id', exp: 1234567890 }</li></ul><p><strong>Разница между Access Token и ID Token:</strong></p><table><tr><th>Аспект</th><th>Access Token</th><th>ID Token</th></tr><tr><td>Протокол</td><td>OAuth2</td><td>OIDC</td></tr><tr><td>Назначение</td><td>Доступ к API</td><td>Информация о пользователе</td></tr><tr><td>Для кого</td><td>Resource Server</td><td>Client приложение</td></tr><tr><td>Формат</td><td>Любой (часто JWT)</td><td>Всегда JWT</td></tr><tr><td>Содержимое</td><td>Scopes, permissions</td><td>User identity claims</td></tr></table><p><strong>Сравнение всех трёх:</strong></p><table><tr><th>Вопрос</th><th>JWT</th><th>OAuth2</th><th>OIDC</th></tr><tr><td>Что это?</td><td>Формат токена</td><td>Протокол авторизации</td><td>Протокол аутентификации</td></tr><tr><td>Решает</td><td>Как передать данные</td><td>Как дать доступ</td><td>Кто пользователь</td></tr><tr><td>Уровень</td><td>Технология</td><td>Framework</td><td>Надстройка над OAuth2</td></tr></table><p><strong>Как они работают вместе:</strong></p><p><strong>Типичный сценарий (OIDC + JWT):</strong></p><ol><li>👤 Пользователь логинится через OIDC provider</li><li>← ID Token (JWT) — кто пользователь</li><li>← Access Token (JWT) — для API доступа</li><li>← Refresh Token — для обновления</li><li>Client сохраняет ID Token для профиля</li><li>Client использует Access Token для API</li></ol><p><strong>Практические примеры:</strong></p><p><strong>\"Войти через Google\":</strong></p><ul><li>Это OIDC (аутентификация)</li><li>Использует OAuth2 flows</li><li>Возвращает ID Token (JWT формат)</li></ul><p><strong>\"Дать доступ к Google Drive\":</strong></p><ul><li>Это OAuth2 (авторизация)</li><li>НЕ OIDC (не про \"кто ты\")</li><li>Access Token (может быть JWT)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Используйте OIDC для аутентификации пользователей</li><li>✅ OAuth2 для делегирования доступа к API</li><li>✅ JWT как формат для токенов</li><li>✅ ID Token — только для клиента, не для API</li><li>✅ Access Token — для доступа к защищённым ресурсам</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'OAuth2', 'OpenID Connect', 'аутентификация', 'авторизация', 'протоколы']
  }
];
