export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 106,
    question: "Что такое Core Web Vitals и почему они важны?",
    answer: "<p><strong>Core Web Vitals</strong> — это набор метрик производительности, которые Google использует для оценки пользовательского опыта на веб-страницах и влияют на SEO-рейтинг.</p><p><strong>Три основные метрики:</strong></p><ul><li><strong>LCP (Largest Contentful Paint)</strong> — скорость загрузки основного контента</li><li><strong>FID (First Input Delay)</strong> — время отклика на первое взаимодействие пользователя</li><li><strong>CLS (Cumulative Layout Shift)</strong> — визуальная стабильность страницы</li></ul><p><strong>Почему важны:</strong></p><ul><li>Напрямую влияют на ранжирование в поисковой выдаче Google</li><li>Отражают реальный опыт пользователей</li><li>Коррелируют с бизнес-метриками (конверсия, отказы)</li><li>Измеряются на реальных устройствах пользователей</li></ul><p>Core Web Vitals — это мост между техническими метриками и бизнес-результатами, помогающий понять, где именно страница теряет пользователей.</p>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'производительность', 'SEO', 'метрики']
  },
  {
    id: 107,
    question: "Что измеряет LCP (Largest Contentful Paint) и какие значения считаются хорошими?",
    answer: "<p><strong>LCP</strong> измеряет время, за которое самый большой видимый элемент контента появляется в области просмотра.</p><p><strong>Что считается за LCP:</strong></p><ul><li>Изображения (img, picture, svg)</li><li>Видео с постером</li><li>Фоновые изображения через CSS</li><li>Блоки текста (параграфы, заголовки)</li></ul><p><strong>Целевые показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 2.5 секунд</li><li><strong>Требует улучшения:</strong> 2.5-4 секунды</li><li><strong>Плохо:</strong> более 4 секунд</li></ul><p><strong>Почему важен:</strong></p><ul><li>Показывает, когда пользователь видит основной контент</li><li>Отражает воспринимаемую скорость загрузки</li><li>Прямо влияет на первое впечатление</li><li>Коррелирует с показателем отказов</li></ul><p>LCP — это не просто техническая метрика, это момент, когда пользователь получает ценность от вашей страницы.</p>",
    difficulty: 'middle',
    tags: ['LCP', 'Web Vitals', 'производительность', 'загрузка']
  },
  {
    id: 108,
    question: "Какие факторы влияют на LCP и как его оптимизировать?",
    answer: "<p><strong>Основные факторы, влияющие на LCP:</strong></p><p><strong>1. Медленный сервер:</strong></p><ul><li>Долгий TTFB (Time to First Byte)</li><li>Неоптимизированный серверный рендеринг</li><li>Отсутствие CDN</li></ul><p><strong>2. Блокирующие ресурсы:</strong></p><ul><li>Render-blocking CSS и JavaScript</li><li>Большие файлы стилей</li><li>Синхронные скрипты в head</li></ul><p><strong>3. Медленная загрузка ресурсов:</strong></p><ul><li>Большие несжатые изображения</li><li>Неоптимальные форматы</li><li>Отсутствие кэширования</li></ul><p><strong>4. Клиентский рендеринг:</strong></p><ul><li>JavaScript-heavy приложения</li><li>Отсутствие SSR/SSG</li><li>Большие бандлы</li></ul><p><strong>Стратегии оптимизации:</strong></p><ul><li>Использовать современные форматы изображений (WebP, AVIF)</li><li>Применять preload для критических ресурсов</li><li>Оптимизировать серверное время ответа</li><li>Минимизировать render-blocking ресурсы</li><li>Использовать CDN для статики</li><li>Внедрить code splitting и lazy loading</li></ul>",
    difficulty: 'senior',
    tags: ['LCP', 'оптимизация', 'производительность', 'Web Vitals']
  },
  {
    id: 109,
    question: "Объясните FID (First Input Delay) и его связь с INP",
    answer: "<p><strong>FID (First Input Delay)</strong> измеряет время между первым взаимодействием пользователя со страницей и моментом, когда браузер может обработать это взаимодействие.</p><p><strong>Что измеряет FID:</strong></p><ul><li>Клики по кнопкам и ссылкам</li><li>Нажатия клавиш в формах</li><li>Выбор элементов в dropdown</li><li>Не измеряет: скроллинг, зум, hover</li></ul><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 100 мс</li><li><strong>Требует улучшения:</strong> 100-300 мс</li><li><strong>Плохо:</strong> более 300 мс</li></ul><p><strong>INP (Interaction to Next Paint):</strong></p><p>Новая метрика, которая заменяет FID. INP измеряет <em>все</em> взаимодействия на странице, а не только первое, и отслеживает полный цикл до отрисовки результата.</p><p><strong>Ключевые различия:</strong></p><ul><li>FID — только первое взаимодействие, INP — все взаимодействия</li><li>FID — до начала обработки, INP — до визуального отклика</li><li>INP более полно отражает интерактивность страницы</li></ul>",
    difficulty: 'middle',
    tags: ['FID', 'INP', 'интерактивность', 'Web Vitals']
  },
  {
    id: 110,
    question: "Как улучшить FID и что вызывает длительные задержки?",
    answer: "<p><strong>Основные причины плохого FID:</strong></p><p><strong>1. Долгие JavaScript-задачи:</strong></p><ul><li>Тяжелые вычисления блокируют главный поток</li><li>Парсинг и выполнение больших скриптов</li><li>Синхронные операции</li></ul><p><strong>2. Блокировка главного потока:</strong></p><ul><li>Обработка событий занимает много времени</li><li>Layout thrashing</li><li>Принудительные reflow</li></ul><p><strong>3. Большие бандлы JavaScript:</strong></p><ul><li>Долгий парсинг и компиляция</li><li>Много неиспользуемого кода</li><li>Отсутствие code splitting</li></ul><p><strong>Методы улучшения:</strong></p><ul><li><strong>Разбивайте длинные задачи:</strong> используйте requestIdleCallback, web workers</li><li><strong>Оптимизируйте JavaScript:</strong> code splitting, tree shaking, defer/async</li><li><strong>Минимизируйте сторонние скрипты:</strong> особенно analytics и widgets</li><li><strong>Используйте web workers:</strong> для тяжелых вычислений</li><li><strong>Оптимизируйте event handlers:</strong> debounce, throttle, passive listeners</li></ul><p>Главный принцип: освобождайте главный поток для быстрой реакции на действия пользователя.</p>",
    difficulty: 'senior',
    tags: ['FID', 'оптимизация', 'JavaScript', 'производительность']
  },
  {
    id: 111,
    question: "Что такое CLS (Cumulative Layout Shift) и как он рассчитывается?",
    answer: "<p><strong>CLS</strong> измеряет визуальную стабильность страницы, суммируя все неожиданные смещения контента во время загрузки.</p><p><strong>Как рассчитывается:</strong></p><p>CLS = Impact Fraction × Distance Fraction</p><ul><li><strong>Impact Fraction</strong> — какая часть viewport затронута смещением</li><li><strong>Distance Fraction</strong> — на какое расстояние сместился элемент</li></ul><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 0.1</li><li><strong>Требует улучшения:</strong> 0.1-0.25</li><li><strong>Плохо:</strong> более 0.25</li></ul><p><strong>Когда происходят смещения:</strong></p><ul><li>Изображения без размеров загружаются</li><li>Динамический контент добавляется сверху</li><li>Веб-шрифты загружаются (FOUT)</li><li>Баннеры и виджеты появляются неожиданно</li><li>Анимации изменяют размеры элементов</li></ul><p><strong>Пользовательский опыт:</strong></p><p>Плохой CLS раздражает пользователей — они нажимают на кнопку, но в последний момент контент смещается и клик попадает не туда. Это особенно критично для мобильных устройств.</p>",
    difficulty: 'middle',
    tags: ['CLS', 'Web Vitals', 'layout shift', 'визуальная стабильность']
  },
  {
    id: 112,
    question: "Какие техники помогают избежать layout shifts?",
    answer: "<p><strong>Превентивные меры для стабильного макета:</strong></p><p><strong>1. Резервирование места для изображений:</strong></p><ul><li>Всегда указывайте width и height атрибуты</li><li>Используйте aspect-ratio в CSS</li><li>Применяйте placeholder'ы с правильными пропорциями</li></ul><p><strong>2. Резервирование места для рекламы:</strong></p><ul><li>Создавайте контейнеры фиксированного размера</li><li>Используйте min-height для блоков</li><li>Показывайте placeholder до загрузки</li></ul><p><strong>3. Управление шрифтами:</strong></p><ul><li>Используйте font-display: optional или swap</li><li>Preload критичных шрифтов</li><li>Подбирайте fallback-шрифты с похожими метриками</li><li>Применяйте size-adjust для выравнивания размеров</li></ul><p><strong>4. Динамический контент:</strong></p><ul><li>Добавляйте новый контент снизу или по клику</li><li>Используйте transform вместо изменения размеров</li><li>Анимируйте через CSS transitions, а не изменение layout</li></ul><p><strong>5. Embeds и iframes:</strong></p><ul><li>Устанавливайте размеры заранее</li><li>Используйте aspect-ratio</li><li>Применяйте contain: layout для изоляции</li></ul><p>Золотое правило: никогда не вставляйте контент выше существующего без взаимодействия пользователя.</p>",
    difficulty: 'senior',
    tags: ['CLS', 'оптимизация', 'layout', 'стабильность']
  },
  {
    id: 113,
    question: "Что такое TTFB и как он влияет на Core Web Vitals?",
    answer: "<p><strong>TTFB (Time to First Byte)</strong> — это время от начала запроса страницы до получения первого байта ответа от сервера.</p><p><strong>Компоненты TTFB:</strong></p><ul><li>Время DNS lookup</li><li>Время установки соединения</li><li>TLS handshake (для HTTPS)</li><li>Время обработки на сервере</li></ul><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 800 мс</li><li><strong>Требует улучшения:</strong> 800-1800 мс</li><li><strong>Плохо:</strong> более 1800 мс</li></ul><p><strong>Влияние на Core Web Vitals:</strong></p><ul><li><strong>На LCP:</strong> медленный TTFB задерживает начало загрузки ресурсов</li><li><strong>На FID:</strong> косвенно — если страница долго грузится, JavaScript загружается позже</li><li><strong>На CLS:</strong> медленная загрузка может увеличить вероятность layout shifts</li></ul><p><strong>Оптимизация TTFB:</strong></p><ul><li>Использовать CDN для статического контента</li><li>Оптимизировать серверную обработку</li><li>Внедрить кэширование на разных уровнях</li><li>Использовать HTTP/2 или HTTP/3</li><li>Минимизировать редиректы</li></ul><p>TTFB — это фундамент: если сервер отвечает медленно, все остальные оптимизации теряют эффективность.</p>",
    difficulty: 'middle',
    tags: ['TTFB', 'производительность', 'серверная оптимизация', 'Web Vitals']
  },
  {
    id: 114,
    question: "Как измерять Web Vitals в реальных условиях?",
    answer: "<p><strong>Два подхода к измерению:</strong></p><p><strong>Lab Data (синтетические данные):</strong></p><ul><li><strong>Lighthouse:</strong> в Chrome DevTools или CI/CD</li><li><strong>WebPageTest:</strong> детальный анализ с разных локаций</li><li><strong>Chrome UX Report:</strong> агрегированные данные от реальных пользователей</li></ul><p><strong>Преимущества lab data:</strong> контролируемые условия, воспроизводимость, детальная диагностика</p><p><strong>Недостатки:</strong> не отражают реальный опыт пользователей</p><p><strong>Field Data (реальные пользователи):</strong></p><ul><li><strong>Web Vitals JavaScript library:</strong> для сбора метрик</li><li><strong>Google Analytics 4:</strong> автоматический сбор Web Vitals</li><li><strong>RUM (Real User Monitoring):</strong> специализированные сервисы</li><li><strong>Chrome User Experience Report:</strong> публичный датасет от Google</li></ul><p><strong>Преимущества field data:</strong> реальные устройства, сети, поведение пользователей</p><p><strong>Недостатки:</strong> сложнее диагностировать проблемы</p><p><strong>Лучшая практика:</strong></p><p>Используйте оба подхода — lab data для быстрой итерации и диагностики, field data для понимания реального опыта и приоритизации работы.</p>",
    difficulty: 'senior',
    tags: ['измерение', 'Web Vitals', 'мониторинг', 'инструменты']
  },
  {
    id: 115,
    question: "Что такое TBT (Total Blocking Time) и как он связан с FID?",
    answer: "<p><strong>TBT (Total Blocking Time)</strong> — это сумма всех периодов между FCP и TTI, когда главный поток был заблокирован достаточно долго, чтобы помешать отклику на ввод.</p><p><strong>Как рассчитывается:</strong></p><ul><li>Измеряется время между First Contentful Paint и Time to Interactive</li><li>Любая задача, занимающая более 50 мс, считается блокирующей</li><li>TBT = сумма времени выше 50 мс для всех длинных задач</li></ul><p><strong>Связь с FID:</strong></p><ul><li>TBT — это lab метрика, которая предсказывает FID</li><li>FID измеряет одно конкретное взаимодействие в реальности</li><li>Улучшение TBT обычно улучшает FID</li><li>TBT помогает диагностировать проблемы FID в lab условиях</li></ul><p><strong>Хорошие показатели TBT:</strong></p><ul><li><strong>Хорошо:</strong> менее 200 мс</li><li><strong>Требует улучшения:</strong> 200-600 мс</li><li><strong>Плохо:</strong> более 600 мс</li></ul><p><strong>Почему важен:</strong></p><p>TBT — это практичная метрика для разработки, потому что её легко измерить в Lighthouse, и она напрямую указывает на проблемы с JavaScript, которые будут влиять на интерактивность в продакшене.</p>",
    difficulty: 'middle',
    tags: ['TBT', 'FID', 'блокировка потока', 'lab metrics']
  },
  {
    id: 116,
    question: "Объясните концепцию Performance Budget и как её применять к Web Vitals",
    answer: "<p><strong>Performance Budget</strong> — это набор ограничений на метрики производительности, который команда обязуется не превышать.</p><p><strong>Типы бюджетов для Web Vitals:</strong></p><p><strong>1. Milestone-based:</strong></p><ul><li>LCP должен быть менее 2.5 секунд</li><li>FID менее 100 мс</li><li>CLS менее 0.1</li></ul><p><strong>2. Quantity-based:</strong></p><ul><li>Максимальный размер JavaScript: 300 KB</li><li>Максимальный размер изображений: 1 MB</li><li>Максимум 10 сторонних скриптов</li></ul><p><strong>3. Rule-based:</strong></p><ul><li>Все изображения должны иметь width/height</li><li>Критические ресурсы должны быть preloaded</li><li>Никакого render-blocking CSS</li></ul><p><strong>Внедрение в workflow:</strong></p><ul><li><strong>CI/CD интеграция:</strong> автоматические проверки при каждом PR</li><li><strong>Lighthouse CI:</strong> fail билда при превышении бюджетов</li><li><strong>Мониторинг:</strong> алерты при деградации метрик в продакшене</li><li><strong>Документация:</strong> четкие правила для всей команды</li></ul><p><strong>Преимущества:</strong></p><p>Performance Budget делает производительность измеримой целью, предотвращает регрессии и помогает команде принимать осознанные решения о trade-offs.</p>",
    difficulty: 'senior',
    tags: ['Performance Budget', 'Web Vitals', 'оптимизация', 'процессы']
  },
  {
    id: 117,
    question: "Как работает метрика INP и почему она заменяет FID?",
    answer: "<p><strong>INP (Interaction to Next Paint)</strong> — это метрика, которая измеряет общую отзывчивость страницы на взаимодействия пользователя в течение всего времени посещения.</p><p><strong>Ключевые отличия от FID:</strong></p><ul><li><strong>Все взаимодействия vs первое:</strong> INP учитывает все клики, нажатия клавиш, тапы, а FID только первое</li><li><strong>Полный цикл:</strong> INP измеряет от input до visual update, FID только до начала обработки</li><li><strong>Репрезентативность:</strong> INP берет p75 (75-й перцентиль) всех взаимодействий</li></ul><p><strong>Что измеряет INP:</strong></p><ol><li>Input delay — задержка до начала обработки</li><li>Processing time — время обработки event handler</li><li>Presentation delay — время до отрисовки результата</li></ol><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 200 мс</li><li><strong>Требует улучшения:</strong> 200-500 мс</li><li><strong>Плохо:</strong> более 500 мс</li></ul><p><strong>Почему заменяет FID:</strong></p><ul><li>Более полно отражает интерактивность</li><li>Учитывает поведение после загрузки</li><li>Ловит проблемы с event handlers</li><li>Отражает весь пользовательский опыт</li></ul><p>INP — это эволюция метрик интерактивности, фокусирующаяся на общем опыте, а не на единичном моменте.</p>",
    difficulty: 'senior',
    tags: ['INP', 'FID', 'интерактивность', 'новые метрики']
  },
  {
    id: 118,
    question: "Какие инструменты помогают диагностировать проблемы с Web Vitals?",
    answer: "<p><strong>Браузерные инструменты:</strong></p><p><strong>Chrome DevTools:</strong></p><ul><li><strong>Lighthouse:</strong> комплексный аудит с рекомендациями</li><li><strong>Performance panel:</strong> детальная временная шкала загрузки</li><li><strong>Coverage:</strong> неиспользуемый CSS и JavaScript</li><li><strong>Network panel:</strong> анализ загрузки ресурсов</li></ul><p><strong>Онлайн-инструменты:</strong></p><ul><li><strong>PageSpeed Insights:</strong> lab и field data, рекомендации</li><li><strong>WebPageTest:</strong> детальный анализ водопада загрузки</li><li><strong>Chrome UX Report:</strong> агрегированные данные реальных пользователей</li></ul><p><strong>Библиотеки и мониторинг:</strong></p><ul><li><strong>web-vitals library:</strong> JavaScript библиотека от Google</li><li><strong>Sentry, DataDog, New Relic:</strong> RUM с Web Vitals</li><li><strong>Google Analytics 4:</strong> автоматический сбор метрик</li></ul><p><strong>CI/CD инструменты:</strong></p><ul><li><strong>Lighthouse CI:</strong> автоматизация проверок</li><li><strong>SpeedCurve:</strong> мониторинг регрессий</li><li><strong>Calibre:</strong> непрерывный мониторинг производительности</li></ul><p><strong>Диагностический workflow:</strong></p><ol><li>PageSpeed Insights — быстрая оценка</li><li>Lighthouse — детальный аудит</li><li>Performance panel — глубокая диагностика</li><li>Field data — валидация в реальности</li></ol>",
    difficulty: 'middle',
    tags: ['инструменты', 'диагностика', 'Web Vitals', 'DevTools']
  },
  {
    id: 119,
    question: "Как приоритизировать оптимизации Web Vitals?",
    answer: "<p><strong>Фреймворк приоритизации:</strong></p><p><strong>1. Анализ текущего состояния:</strong></p><ul><li>Соберите field data от реальных пользователей</li><li>Определите, какие метрики в красной зоне</li><li>Проанализируйте распределение по устройствам, регионам</li></ul><p><strong>2. Оценка влияния на бизнес:</strong></p><ul><li>Какие страницы генерируют больше конверсий?</li><li>Где пользователи чаще всего отваливаются?</li><li>Какие сегменты пользователей критичны?</li></ul><p><strong>3. Быстрые победы vs долгосрочные улучшения:</strong></p><p><strong>Быстрые победы (low-hanging fruit):</strong></p><ul><li>Добавить width/height к изображениям (CLS)</li><li>Оптимизировать изображения (LCP)</li><li>Добавить preload для критических ресурсов (LCP)</li><li>Отложить сторонние скрипты (FID/INP)</li></ul><p><strong>Долгосрочные:</strong></p><ul><li>Внедрить SSR/SSG</li><li>Рефакторинг архитектуры JavaScript</li><li>Миграция на CDN</li><li>Оптимизация бэкенда</li></ul><p><strong>4. ICE-скоринг:</strong></p><ul><li><strong>Impact:</strong> насколько улучшится метрика</li><li><strong>Confidence:</strong> уверенность в результате</li><li><strong>Ease:</strong> простота реализации</li></ul><p>Начинайте с метрик, которые влияют на бизнес-KPI, и с оптимизаций, дающих максимальный результат при минимальных усилиях.</p>",
    difficulty: 'senior',
    tags: ['приоритизация', 'оптимизация', 'стратегия', 'Web Vitals']
  },
  {
    id: 120,
    question: "Как Web Vitals влияют на SEO и бизнес-метрики?",
    answer: "<p><strong>Прямое влияние на SEO:</strong></p><ul><li>Core Web Vitals — официальный ranking factor Google с 2021 года</li><li>Плохие метрики могут снизить позиции в поиске</li><li>Особенно важно для мобильной выдачи</li><li>Влияние усиливается при прочих равных факторах</li></ul><p><strong>Корреляция с бизнес-метриками:</strong></p><p><strong>Конверсии:</strong></p><ul><li>Улучшение LCP на 0.1с может увеличить конверсию на 8%</li><li>53% мобильных пользователей покидают сайт, если загрузка длится более 3 секунд</li></ul><p><strong>Показатель отказов:</strong></p><ul><li>Плохой CLS раздражает пользователей и увеличивает bounce rate</li><li>Каждая секунда задержки FID коррелирует с ростом отказов</li></ul><p><strong>Вовлеченность:</strong></p><ul><li>Быстрые сайты показывают больше просмотров страниц</li><li>Лучше metrics вовлеченности (time on site, pages per session)</li></ul><p><strong>Документированные кейсы:</strong></p><ul><li>Vodafone: улучшение LCP на 31% → рост продаж на 8%</li><li>Tokopedia: улучшение всех Core Web Vitals → +35% органического трафика</li><li>Redbus: улучшение INP → +7% продаж</li></ul><p><strong>ROI оптимизации:</strong></p><p>Инвестиции в Web Vitals окупаются через улучшение органического трафика, конверсий и удержания пользователей.</p>",
    difficulty: 'middle',
    tags: ['SEO', 'бизнес-метрики', 'конверсии', 'ROI']
  },
  {
    id: 121,
    question: "Какие основные панели Chrome DevTools вы используете чаще всего и для каких задач?",
    answer: "<p><strong>Основные панели DevTools и их назначение:</strong></p><p><strong>Elements:</strong></p><ul><li>Инспекция и редактирование DOM в реальном времени</li><li>Просмотр и изменение CSS-стилей</li><li>Анализ computed styles и специфичности</li><li>Отладка layout и box model</li></ul><p><strong>Console:</strong></p><ul><li>Выполнение JavaScript-кода в контексте страницы</li><li>Просмотр логов, ошибок, предупреждений</li><li>Отладка через console.log, console.table</li><li>Работа с API браузера</li></ul><p><strong>Sources:</strong></p><ul><li>Отладка JavaScript с breakpoints</li><li>Просмотр исходного кода и sourcemaps</li><li>Step-by-step выполнение кода</li><li>Watch expressions и call stack</li></ul><p><strong>Network:</strong></p><ul><li>Анализ всех сетевых запросов</li><li>Отладка API-вызовов</li><li>Проверка размеров и времени загрузки</li><li>Throttling для тестирования медленных соединений</li></ul><p><strong>Performance:</strong></p><ul><li>Профилирование производительности</li><li>Анализ FPS и памяти</li><li>Поиск узких мест в коде</li></ul><p>Каждая панель решает специфические задачи — правильный выбор инструмента ускоряет отладку в разы.</p>",
    difficulty: 'junior',
    tags: ['DevTools', 'панели', 'отладка', 'инструменты']
  },
  {
    id: 122,
    question: "Как использовать breakpoints для отладки JavaScript?",
    answer: "<p><strong>Типы breakpoints в DevTools:</strong></p><p><strong>1. Line breakpoints:</strong></p><ul><li>Останавливают выполнение на конкретной строке</li><li>Самый простой и часто используемый тип</li><li>Кликаете на номер строки в Sources</li></ul><p><strong>2. Conditional breakpoints:</strong></p><ul><li>Срабатывают только при выполнении условия</li><li>Полезны в циклах: останавливаться только когда i === 5</li><li>Правый клик на номер строки → Add conditional breakpoint</li></ul><p><strong>3. Logpoints:</strong></p><ul><li>Вместо остановки выводят сообщение в консоль</li><li>Не требуют изменения исходного кода</li><li>Альтернатива console.log без модификации файлов</li></ul><p><strong>4. DOM breakpoints:</strong></p><ul><li>Subtree modifications — при изменении дочерних элементов</li><li>Attribute modifications — при изменении атрибутов</li><li>Node removal — при удалении элемента</li></ul><p><strong>5. Event listener breakpoints:</strong></p><ul><li>Останавливаются при срабатывании событий</li><li>Например, pause on all click events</li><li>Помогают отследить, где обрабатывается событие</li></ul><p><strong>Управление выполнением:</strong></p><ul><li><strong>Step over (F10):</strong> следующая строка</li><li><strong>Step into (F11):</strong> зайти внутрь функции</li><li><strong>Step out (Shift+F11):</strong> выйти из функции</li><li><strong>Continue (F8):</strong> продолжить до следующего breakpoint</li></ul>",
    difficulty: 'middle',
    tags: ['отладка', 'breakpoints', 'JavaScript', 'DevTools']
  },
  {
    id: 123,
    question: "Объясните, как работает Network панель и что означают различные цвета в waterfall?",
    answer: "<p><strong>Network панель показывает все сетевые запросы</strong> и позволяет анализировать загрузку ресурсов.</p><p><strong>Основные колонки:</strong></p><ul><li><strong>Name:</strong> имя и путь к ресурсу</li><li><strong>Status:</strong> HTTP-статус ответа</li><li><strong>Type:</strong> тип ресурса (document, script, stylesheet, xhr)</li><li><strong>Initiator:</strong> что инициировало запрос</li><li><strong>Size:</strong> размер ресурса (transferred vs resource)</li><li><strong>Time:</strong> время загрузки</li><li><strong>Waterfall:</strong> визуальная временная шкала</li></ul><p><strong>Цвета в waterfall диаграмме:</strong></p><p><strong>Светлые оттенки (queuing):</strong></p><ul><li>Запрос ждет в очереди</li><li>Браузер имеет лимит параллельных соединений</li></ul><p><strong>Оранжевый (Initial connection/SSL):</strong></p><ul><li>DNS lookup</li><li>Установка TCP соединения</li><li>SSL/TLS handshake</li></ul><p><strong>Зеленый (Waiting - TTFB):</strong></p><ul><li>Ожидание первого байта от сервера</li><li>Серверная обработка запроса</li></ul><p><strong>Синий (Content Download):</strong></p><ul><li>Получение содержимого</li><li>Зависит от размера файла и скорости соединения</li></ul><p><strong>Полезные фичи:</strong></p><ul><li>Throttling — эмуляция медленной сети</li><li>Disable cache — тестирование без кэша</li><li>Preserve log — сохранять логи при переходах</li><li>Filter — фильтрация по типу ресурсов</li></ul>",
    difficulty: 'middle',
    tags: ['Network', 'waterfall', 'загрузка', 'производительность']
  },
  {
    id: 124,
    question: "Как использовать Performance панель для анализа производительности?",
    answer: "<p><strong>Performance панель</strong> позволяет записать и проанализировать все, что происходит во время загрузки или взаимодействия с страницей.</p><p><strong>Процесс анализа:</strong></p><p><strong>1. Запись профиля:</strong></p><ul><li>Кнопка Record → выполнить действия → Stop</li><li>Или Reload с записью для анализа загрузки</li><li>Старайтесь делать короткие записи (5-10 секунд)</li></ul><p><strong>2. Основные секции профиля:</strong></p><p><strong>Summary (круговая диаграмма):</strong></p><ul><li>Loading — парсинг HTML, CSS</li><li>Scripting — выполнение JavaScript</li><li>Rendering — расчет стилей, layout</li><li>Painting — отрисовка пикселей</li><li>System — прочие операции браузера</li></ul><p><strong>Main thread (временная шкала):</strong></p><ul><li>Показывает все задачи главного потока</li><li>Длинные задачи (>50ms) — проблемы для интерактивности</li><li>Можно зумить и кликать на задачи для деталей</li></ul><p><strong>Frames:</strong></p><ul><li>Зеленые полоски — 60 FPS достигнуто</li><li>Красные — dropped frames, лаги</li></ul><p><strong>3. Что искать:</strong></p><ul><li>Длинные JavaScript-задачи (желтые блоки)</li><li>Частые layout thrashing (фиолетовые всплески)</li><li>Принудительные reflow</li><li>Много времени на idle</li></ul><p><strong>4. Bottom-Up / Call Tree:</strong></p><ul><li>Какие функции заняли больше всего времени</li><li>Где находятся узкие места</li></ul>",
    difficulty: 'senior',
    tags: ['Performance', 'профилирование', 'оптимизация', 'анализ']
  },
  {
    id: 125,
    question: "Что такое Coverage панель и как она помогает оптимизировать код?",
    answer: "<p><strong>Coverage панель</strong> показывает, какой процент загруженного CSS и JavaScript кода фактически используется на странице.</p><p><strong>Как использовать:</strong></p><ol><li>Открыть через Cmd+Shift+P → Show Coverage</li><li>Нажать кнопку Record</li><li>Взаимодействовать со страницей</li><li>Остановить запись</li></ol><p><strong>Что показывает:</strong></p><ul><li><strong>Красные полосы:</strong> неиспользуемый код</li><li><strong>Синие полосы:</strong> использованный код</li><li><strong>Процент использования:</strong> для каждого файла</li><li><strong>Unused Bytes:</strong> сколько байт не используется</li></ul><p><strong>Типичные проблемы:</strong></p><p><strong>CSS:</strong></p><ul><li>Библиотеки типа Bootstrap — используете 20%, загружаете 100%</li><li>Устаревшие стили для старых компонентов</li><li>Медиа-запросы для неактуальных breakpoints</li></ul><p><strong>JavaScript:</strong></p><ul><li>Большие библиотеки, где нужна лишь часть функционала</li><li>Polyfills для старых браузеров в современных</li><li>Неиспользуемые зависимости</li></ul><p><strong>Стратегии оптимизации:</strong></p><ul><li><strong>Code splitting:</strong> загружать код по требованию</li><li><strong>Tree shaking:</strong> удалить неиспользуемые exports</li><li><strong>Critical CSS:</strong> inline только нужные стили</li><li><strong>Lazy loading:</strong> отложенная загрузка модулей</li><li><strong>PurgeCSS:</strong> удаление неиспользуемого CSS</li></ul><p>Coverage помогает найти низко висящие фрукты — код, который можно удалить или отложить без потери функциональности.</p>",
    difficulty: 'middle',
    tags: ['Coverage', 'оптимизация', 'bundle size', 'неиспользуемый код']
  },
  {
    id: 126,
    question: "Как отлаживать CSS в Elements панели? Какие возможности есть для работы со стилями?",
    answer: "<p><strong>Elements панель предоставляет мощные инструменты для работы с CSS:</strong></p><p><strong>1. Styles панель:</strong></p><ul><li>Показывает все CSS-правила, применяемые к элементу</li><li>Можно изменять значения в реальном времени</li><li>Перечеркнутые свойства — переопределены другими правилами</li><li>Можно добавлять новые свойства через клик</li></ul><p><strong>2. Computed панель:</strong></p><ul><li>Итоговые значения всех CSS-свойств</li><li>Show All — полный список даже дефолтных значений</li><li>Клик на значение показывает, откуда оно взялось</li><li>Полезно для понимания каскада и наследования</li></ul><p><strong>3. Box Model:</strong></p><ul><li>Визуализация margin, border, padding, content</li><li>Можно кликнуть на значения и изменить их</li><li>Наглядно показывает размеры элемента</li></ul><p><strong>4. Специальные возможности:</strong></p><p><strong>Color Picker:</strong></p><ul><li>Клик на цвет открывает пикер</li><li>Можно менять формат (hex, rgb, hsl)</li><li>Проверка контраста для доступности</li></ul><p><strong>CSS classes:</strong></p><ul><li>.cls — добавление/удаление классов</li><li>Быстрое тестирование состояний</li></ul><p><strong>Force state:</strong></p><ul><li>:hover, :active, :focus, :visited</li><li>Тестирование псевдоклассов без физического взаимодействия</li></ul><p><strong>Copy styles:</strong></p><ul><li>Copy all declarations</li><li>Copy rule — скопировать весь селектор</li></ul><p><strong>5. Layout панель:</strong></p><ul><li>Визуализация Grid и Flexbox</li><li>Overlays для понимания структуры</li><li>Инструменты для отладки выравнивания</li></ul>",
    difficulty: 'middle',
    tags: ['CSS', 'Elements', 'стили', 'отладка']
  },
  {
    id: 127,
    question: "Объясните, как использовать Memory панель для поиска утечек памяти",
    answer: "<p><strong>Memory панель</strong> помогает найти и исправить утечки памяти — ситуации, когда приложение потребляет все больше памяти и не освобождает её.</p><p><strong>Типы профилей памяти:</strong></p><p><strong>1. Heap snapshot:</strong></p><ul><li>Снимок состояния памяти в конкретный момент</li><li>Показывает все объекты в памяти</li><li>Можно сравнивать снимки для поиска роста</li></ul><p><strong>2. Allocation instrumentation on timeline:</strong></p><ul><li>Запись выделения памяти во времени</li><li>Показывает, когда и где выделяется память</li><li>Синие полоски — выделенная память</li><li>Серые — освобожденная память</li></ul><p><strong>3. Allocation sampling:</strong></p><ul><li>Менее детальный, но легковесный профиль</li><li>Показывает call stacks выделений памяти</li></ul><p><strong>Процесс поиска утечек:</strong></p><ol><li><strong>Baseline snapshot:</strong> снять начальный snapshot</li><li><strong>Выполнить действия:</strong> сделать то, что подозревается в утечке</li><li><strong>Force GC:</strong> принудительно запустить garbage collector</li><li><strong>Второй snapshot:</strong> снять еще один snapshot</li><li><strong>Сравнить:</strong> переключиться в режим Comparison</li></ol><p><strong>Что искать:</strong></p><ul><li><strong>Detached DOM nodes:</strong> элементы удалены из DOM, но остались в памяти</li><li><strong>Event listeners:</strong> забытые подписки на события</li><li><strong>Closures:</strong> замыкания, держащие большие объекты</li><li><strong>Globals:</strong> глобальные переменные, которые растут</li><li><strong>Timers:</strong> не очищенные setInterval/setTimeout</li></ul><p><strong>Типичные паттерны утечек:</strong></p><ul><li>Забыли removeEventListener</li><li>Держим ссылки на удаленные DOM-элементы</li><li>Бесконечные массивы/кэши без ограничений</li><li>Неочищенные subscriptions в SPA</li></ul>",
    difficulty: 'senior',
    tags: ['Memory', 'утечки памяти', 'профилирование', 'оптимизация']
  },
  {
    id: 128,
    question: "Как работает Lighthouse в DevTools и какие метрики он проверяет?",
    answer: "<p><strong>Lighthouse</strong> — это автоматизированный инструмент для аудита веб-страниц по нескольким категориям качества.</p><p><strong>Категории аудита:</strong></p><p><strong>1. Performance (Производительность):</strong></p><ul><li>Core Web Vitals: LCP, FID, CLS</li><li>First Contentful Paint</li><li>Speed Index</li><li>Time to Interactive</li><li>Total Blocking Time</li></ul><p><strong>2. Accessibility (Доступность):</strong></p><ul><li>Правильность alt-атрибутов</li><li>Контрастность текста</li><li>ARIA-атрибуты</li><li>Семантическая разметка</li><li>Клавиатурная навигация</li></ul><p><strong>3. Best Practices (Лучшие практики):</strong></p><ul><li>HTTPS использование</li><li>Безопасность</li><li>Современные API</li><li>Отсутствие ошибок в консоли</li><li>Правильные размеры изображений</li></ul><p><strong>4. SEO:</strong></p><ul><li>Наличие meta-тегов</li><li>Правильные заголовки</li><li>Валидный robots.txt</li><li>Мобильная оптимизация</li><li>Структурированные данные</li></ul><p><strong>5. Progressive Web App:</strong></p><ul><li>Наличие manifest</li><li>Service Worker</li><li>Offline функциональность</li><li>Installability</li></ul><p><strong>Как использовать:</strong></p><ol><li>Открыть Lighthouse панель</li><li>Выбрать категории для проверки</li><li>Выбрать устройство (Mobile/Desktop)</li><li>Generate report</li></ol><p><strong>Интерпретация результатов:</strong></p><ul><li><strong>Зеленый (90-100):</strong> отлично</li><li><strong>Оранжевый (50-89):</strong> требует улучшения</li><li><strong>Красный (0-49):</strong> плохо</li></ul><p>Каждая проблема содержит описание и ссылку на документацию с решением.</p>",
    difficulty: 'middle',
    tags: ['Lighthouse', 'аудит', 'производительность', 'качество']
  },
  {
    id: 129,
    question: "Что такое Source Maps и как они помогают в отладке?",
    answer: "<p><strong>Source Maps</strong> — это файлы, которые связывают минифицированный/транспилированный код с оригинальным исходным кодом.</p><p><strong>Зачем нужны:</strong></p><ul><li>Продакшен-код минифицирован и нечитаем</li><li>TypeScript/Babel/webpack преобразуют код</li><li>Без source maps отладка превращается в кошмар</li><li>Source maps позволяют видеть оригинальный код в DevTools</li></ul><p><strong>Как работают:</strong></p><ol><li>Бандлер генерирует .map файл рядом с bundle</li><li>В bundle добавляется комментарий: //# sourceMappingURL=bundle.js.map</li><li>DevTools загружает и парсит .map файл</li><li>Показывает оригинальный код вместо минифицированного</li></ol><p><strong>Что позволяют в DevTools:</strong></p><p><strong>Sources панель:</strong></p><ul><li>Видеть оригинальные имена файлов и структуру проекта</li><li>Ставить breakpoints в TypeScript/JSX коде</li><li>Видеть оригинальные имена переменных</li><li>Нормальный stack traces в ошибках</li></ul><p><strong>Console:</strong></p><ul><li>Ошибки ссылаются на оригинальные строки кода</li><li>Stack traces показывают реальные файлы</li></ul><p><strong>Типы source maps:</strong></p><ul><li><strong>Inline:</strong> встроены в bundle (большой размер)</li><li><strong>External:</strong> отдельный .map файл (рекомендуется)</li><li><strong>eval-source-map:</strong> быстрая пересборка для разработки</li></ul><p><strong>Продакшен considerations:</strong></p><ul><li>Source maps могут раскрыть исходный код</li><li>Можно не публиковать .map файлы</li><li>Или использовать их только для error tracking сервисов</li><li>Некоторые используют private source maps на CDN</li></ul>",
    difficulty: 'middle',
    tags: ['Source Maps', 'отладка', 'минификация', 'транспиляция']
  },
  {
    id: 130,
    question: "Как использовать Local Overrides для тестирования изменений без деплоя?",
    answer: "<p><strong>Local Overrides</strong> позволяют сохранить изменения, сделанные в DevTools, и применять их при каждой перезагрузке страницы.</p><p><strong>Зачем это нужно:</strong></p><ul><li>Тестировать исправления без деплоя</li><li>Экспериментировать с чужими сайтами</li><li>Быстро проверять гипотезы</li><li>Отладка на production без доступа к коду</li></ul><p><strong>Как настроить:</strong></p><ol><li>Sources → Overrides tab</li><li>Enable Local Overrides</li><li>Выбрать папку на диске для хранения изменений</li><li>Разрешить доступ браузеру к папке</li></ol><p><strong>Что можно override:</strong></p><p><strong>JavaScript:</strong></p><ul><li>Изменить логику функций</li><li>Добавить console.log для отладки</li><li>Исправить баги временно</li></ul><p><strong>CSS:</strong></p><ul><li>Изменить стили</li><li>Тестировать дизайн-изменения</li><li>Исправить проблемы с layout</li></ul><p><strong>HTML:</strong></p><ul><li>Изменить структуру страницы</li><li>Добавить новые элементы</li></ul><p><strong>Network responses:</strong></p><ul><li>Подменить ответы API</li><li>Тестировать с mock данными</li><li>Симулировать ошибки</li></ul><p><strong>Workflow:</strong></p><ol><li>Открыть файл в Sources</li><li>Сделать изменения в коде</li><li>Ctrl+S для сохранения</li><li>Перезагрузить страницу — изменения применятся</li><li>Фиолетовая точка на вкладке означает override активен</li></ol><p><strong>Полезные сценарии:</strong></p><ul><li>Тестировать фикс бага на проде перед деплоем</li><li>Отладка багов, которые сложно воспроизвести локально</li><li>Тестирование на реальном окружении с реальными данными</li><li>A/B тестирование дизайна</li></ul>",
    difficulty: 'middle',
    tags: ['Local Overrides', 'отладка', 'тестирование', 'workflow']
  },
  {
    id: 131,
    question: "Объясните разницу между Throttling и Emulation в DevTools",
    answer: "<p><strong>Throttling</strong> и <strong>Emulation</strong> — это разные способы симуляции условий для тестирования.</p><p><strong>Network Throttling (сеть):</strong></p><p><strong>Что делает:</strong></p><ul><li>Искусственно замедляет сетевые запросы</li><li>Симулирует медленное соединение</li><li>Добавляет latency (задержку)</li><li>Ограничивает bandwidth (пропускную способность)</li></ul><p><strong>Пресеты:</strong></p><ul><li><strong>Fast 3G:</strong> 1.6 Mbps, 150ms latency</li><li><strong>Slow 3G:</strong> 400 Kbps, 400ms latency</li><li><strong>Offline:</strong> полное отсутствие сети</li><li><strong>Custom:</strong> свои настройки</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Тестировать загрузку на медленном интернете</li><li>Проверять offline-функциональность</li><li>Оптимизировать критический путь рендеринга</li></ul><p><strong>CPU Throttling (процессор):</strong></p><p><strong>Что делает:</strong></p><ul><li>Замедляет выполнение JavaScript</li><li>Симулирует слабое устройство</li><li>Множители: 4x slowdown, 6x slowdown</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Тестировать на слабых мобильных устройствах</li><li>Находить проблемы производительности JavaScript</li><li>Проверять, что приложение отзывчиво на слабом железе</li></ul><p><strong>Device Emulation (устройство):</strong></p><p><strong>Что эмулирует:</strong></p><ul><li>Размер экрана и viewport</li><li>Device pixel ratio (Retina)</li><li>Touch events вместо mouse</li><li>User agent строку</li><li>Geolocation</li><li>Ориентацию (portrait/landscape)</li></ul><p><strong>Важно понимать:</strong></p><ul><li><strong>Эмуляция ≠ реальное устройство</strong></li><li>DevTools не может симулировать GPU, RAM</li><li>Рендеринг все равно происходит на вашем ПК</li><li>Для точного тестирования нужны реальные устройства</li></ul>",
    difficulty: 'middle',
    tags: ['Throttling', 'Emulation', 'тестирование', 'производительность']
  },
  {
    id: 132,
    question: "Как использовать Command Menu (Cmd+Shift+P) для быстрого доступа к функциям?",
    answer: "<p><strong>Command Menu</strong> — это мощный инструмент для быстрого доступа ко всем функциям DevTools без поиска в меню.</p><p><strong>Как открыть:</strong></p><ul><li>Mac: Cmd + Shift + P</li><li>Windows/Linux: Ctrl + Shift + P</li></ul><p><strong>Популярные команды:</strong></p><p><strong>Панели и инструменты:</strong></p><ul><li><code>Show Coverage</code> — анализ неиспользуемого кода</li><li><code>Show Network conditions</code> — настройки сети</li><li><code>Show Rendering</code> — настройки рендеринга</li><li><code>Show Sensors</code> — эмуляция датчиков</li><li><code>Show Performance monitor</code> — реалтайм метрики</li></ul><p><strong>Скриншоты:</strong></p><ul><li><code>Capture full size screenshot</code> — скриншот всей страницы</li><li><code>Capture node screenshot</code> — скриншот выбранного элемента</li><li><code>Capture area screenshot</code> — выделить область</li><li><code>Capture screenshot</code> — видимая область</li></ul><p><strong>JavaScript и отладка:</strong></p><ul><li><code>Disable JavaScript</code> — отключить JS</li><li><code>Do not capture async stack traces</code></li><li><code>Show JavaScript profiler</code></li></ul><p><strong>Производительность:</strong></p><ul><li><code>Enable paint flashing</code> — подсветка перерисовок</li><li><code>Enable layer borders</code> — границы композитных слоев</li><li><code>Show frames per second (FPS) meter</code></li><li><code>Emulate CSS media type print</code> — печать</li></ul><p><strong>Accessibility:</strong></p><ul><li><code>Show Accessibility</code> — панель доступности</li><li><code>Emulate vision deficiencies</strong> — симуляция нарушений зрения</li></ul><p><strong>Network:</strong></p><ul><li><code>Block request URL</code> — блокировка запросов</li><li><code>Enable request blocking</code></li></ul><p><strong>Tips:</strong></p><ul><li>Начните печатать — появится автодополнение</li><li>Недавние команды показываются сверху</li><li>Можно искать по части названия</li></ul>",
    difficulty: 'junior',
    tags: ['Command Menu', 'shortcuts', 'productivity', 'DevTools']
  },
  {
    id: 133,
    question: "Как отлаживать проблемы с CORS в DevTools?",
    answer: "<p><strong>CORS-ошибки</strong> — одна из частых проблем при разработке, и DevTools помогает их диагностировать.</p><p><strong>Где видны CORS-ошибки:</strong></p><p><strong>Console:</strong></p><ul><li>Красная ошибка с текстом 'CORS policy'</li><li>Точное описание проблемы</li><li>Например: 'No Access-Control-Allow-Origin header is present'</li></ul><p><strong>Network панель:</strong></p><ul><li>Запрос может быть красным (failed)</li><li>Статус может быть (failed) или CORS error</li><li>Во вкладке Headers видны отсутствующие заголовки</li></ul><p><strong>Типичные CORS-проблемы:</strong></p><p><strong>1. Отсутствие Access-Control-Allow-Origin:</strong></p><ul><li>Сервер не разрешает запросы с вашего origin</li><li>Нужно добавить заголовок на сервере</li><li>Или использовать proxy</li></ul><p><strong>2. Preflight запрос провалился:</strong></p><ul><li>OPTIONS-запрос перед основным</li><li>Сервер должен отвечать на OPTIONS</li><li>Нужны заголовки: Access-Control-Allow-Methods, Access-Control-Allow-Headers</li></ul><p><strong>3. Credentials не разрешены:</strong></p><ul><li>Используете cookies/auth, но заголовок Access-Control-Allow-Credentials: true отсутствует</li><li>Origin не может быть * при credentials: true</li></ul><p><strong>Как отлаживать:</strong></p><ol><li><strong>Network → Headers:</strong> проверить Response Headers</li><li><strong>Искать:</strong> Access-Control-Allow-* заголовки</li><li><strong>Console:</strong> читать точное описание ошибки</li><li><strong>OPTIONS запрос:</strong> проверить preflight</li></ol><p><strong>Workarounds для разработки:</strong></p><ul><li>CORS-расширения для браузера (НЕ для продакшена!)</li><li>Proxy в webpack dev server</li><li>Локальный прокси-сервер</li><li>Отключить CORS в Chrome (небезопасно!)</li></ul><p>Правильное решение — всегда настроить CORS на сервере.</p>",
    difficulty: 'middle',
    tags: ['CORS', 'отладка', 'Network', 'безопасность']
  },
  {
    id: 134,
    question: "Объясните, как использовать Rendering панель для отладки визуальных проблем",
    answer: "<p><strong>Rendering панель</strong> предоставляет инструменты для визуализации и отладки рендеринга страницы.</p><p><strong>Основные инструменты:</strong></p><p><strong>1. Paint flashing:</strong></p><ul><li>Подсвечивает зеленым цветом области, которые перерисовываются</li><li>Помогает найти избыточные repaint'ы</li><li>Если вся страница мигает зеленым — проблема производительности</li></ul><p><strong>2. Layout Shift Regions:</strong></p><ul><li>Синим подсвечивает области layout shift</li><li>Помогает визуализировать CLS</li><li>Видно, какие элементы прыгают</li></ul><p><strong>3. Layer borders:</strong></p><ul><li>Показывает границы композитных слоев</li><li>Оранжевый — обычные слои</li><li>Синий — tiles (части больших слоев)</li><li>Помогает понять, сколько слоев создается</li></ul><p><strong>4. Frame Rendering Stats:</strong></p><ul><li>Реалтайм FPS метр</li><li>GPU memory использование</li><li>Dropped frames counter</li></ul><p><strong>5. Scrolling performance issues:</strong></p><ul><li>Подсвечивает элементы, замедляющие скролл</li><li>Touch event handlers без passive: true</li><li>Wheel event handlers</li></ul><p><strong>6. Core Web Vitals overlay:</strong></p><ul><li>Показывает LCP элемент</li><li>Layout shift areas</li><li>Помогает визуально определить проблемы</li></ul><p><strong>7. Emulate CSS media features:</strong></p><ul><li><code>prefers-color-scheme</code> — темная/светлая тема</li><li><code>prefers-reduced-motion</code> — уменьшенная анимация</li><li><code>prefers-contrast</code> — повышенная контрастность</li></ul><p><strong>Типичные use cases:</strong></p><ul><li>Найти элементы, вызывающие постоянные repaint</li><li>Оптимизировать количество композитных слоев</li><li>Отладить CLS проблемы визуально</li><li>Проверить accessibility preferences</li></ul>",
    difficulty: 'senior',
    tags: ['Rendering', 'визуализация', 'производительность', 'отладка']
  },
  {
    id: 135,
    question: "Какие полезные snippets и shortcuts вы используете в DevTools?",
    answer: "<p><strong>Snippets</strong> — это сохраненные JavaScript-скрипты, которые можно запускать на любой странице.</p><p><strong>Где находятся:</strong></p><ul><li>Sources → Snippets tab</li><li>New snippet → написать код → Ctrl+Enter для запуска</li></ul><p><strong>Полезные snippets:</strong></p><p><strong>1. Найти все изображения без alt:</strong></p><ul><li>Проверка accessibility</li><li>Перебор всех img на странице</li><li>Вывод списка проблемных изображений</li></ul><p><strong>2. Подсчет элементов по селектору:</strong></p><ul><li>Сколько div'ов, button'ов и т.д.</li><li>Анализ структуры DOM</li></ul><p><strong>3. Измерение производительности функций:</strong></p><ul><li>console.time/timeEnd обертки</li><li>Бенчмарки прямо в браузере</li></ul><p><strong>4. Очистка localStorage/cookies:</strong></p><ul><li>Быстрый сброс состояния для тестирования</li></ul><p><strong>5. Dump page info:</strong></p><ul><li>Извлечение meta-тегов, заголовков</li><li>Анализ SEO</li></ul><p><strong>Полезные shortcuts:</strong></p><p><strong>Общие:</strong></p><ul><li><code>Cmd/Ctrl + Shift + P</code> — Command menu</li><li><code>Cmd/Ctrl + P</code> — быстрый поиск файлов</li><li><code>Cmd/Ctrl + Shift + O</code> — поиск функций в файле</li><li><code>Cmd/Ctrl + F</code> — поиск в текущей панели</li></ul><p><strong>Elements:</strong></p><ul><li><code>H</code> — скрыть элемент (visibility: hidden)</li><li><code>Delete</code> — удалить элемент</li><li><code>F2</code> — редактировать HTML</li><li><code>Ctrl + Z</code> — отменить изменения</li></ul><p><strong>Console:</strong></p><ul><li><code>$0</code> — последний выбранный элемент в Elements</li><li><code>$_</code> — результат последнего выражения</li><li><code>$$()</code> — querySelectorAll shorthand</li><li><code>copy()</code> — скопировать в буфер</li></ul><p><strong>Sources:</strong></p><ul><li><code>Ctrl + G</code> — перейти к строке</li><li><code>Ctrl + Shift + E</code> — выполнить выделенный код</li></ul>",
    difficulty: 'middle',
    tags: ['snippets', 'shortcuts', 'productivity', 'automation']
  },
  {
    id: 136,
    question: "Что такое SSR (Server-Side Rendering) и в чем его основные преимущества перед CSR?",
    answer: "<p><strong>SSR (Server-Side Rendering)</strong> — это подход, при котором HTML-страница генерируется на сервере для каждого запроса, а не в браузере клиента.</p><p><strong>Основные преимущества SSR:</strong></p><p><strong>1. Улучшенное SEO:</strong></p><ul><li>Поисковые роботы получают полностью отрендеренный HTML</li><li>Не нужно ждать выполнения JavaScript</li><li>Лучшая индексация динамического контента</li><li>Meta-теги доступны сразу для социальных сетей</li></ul><p><strong>2. Быстрый First Contentful Paint:</strong></p><ul><li>Пользователь видит контент быстрее</li><li>Не нужно ждать загрузки и выполнения JS-бандла</li><li>Особенно важно на медленных соединениях</li></ul><p><strong>3. Производительность на слабых устройствах:</strong></p><ul><li>Меньше работы для процессора клиента</li><li>Парсинг HTML быстрее выполнения JavaScript</li><li>Критично для мобильных устройств</li></ul><p><strong>Недостатки CSR:</strong></p><ul><li>Пустой HTML пока не загрузится JavaScript</li><li>Плохое SEO без дополнительных решений</li><li>Медленный FCP на слабых устройствах</li><li>Высокая нагрузка на клиент</li></ul><p>SSR — это баланс между производительностью, SEO и пользовательским опытом.</p>",
    difficulty: 'middle',
    tags: ['SSR', 'рендеринг', 'производительность', 'SEO']
  },
  {
    id: 137,
    question: "Объясните разницу между SSR, SSG и ISR",
    answer: "<p>Это три разных стратегии рендеринга, каждая со своими применениями:</p><p><strong>SSR (Server-Side Rendering):</strong></p><ul><li><strong>Когда:</strong> HTML генерируется для каждого запроса</li><li><strong>Преимущества:</strong> всегда свежие данные, персонализация</li><li><strong>Недостатки:</strong> нагрузка на сервер, медленнее чем SSG</li><li><strong>Использование:</strong> dashboard'ы, личные кабинеты, динамический контент</li></ul><p><strong>SSG (Static Site Generation):</strong></p><ul><li><strong>Когда:</strong> HTML генерируется один раз на этапе сборки</li><li><strong>Преимущества:</strong> максимальная скорость, можно отдавать через CDN</li><li><strong>Недостатки:</strong> данные статичны до следующей сборки</li><li><strong>Использование:</strong> блоги, документация, маркетинговые страницы</li></ul><p><strong>ISR (Incremental Static Regeneration):</strong></p><ul><li><strong>Когда:</strong> статическая генерация + обновление в фоне</li><li><strong>Как работает:</strong> отдается закешированная версия, но периодически регенерируется</li><li><strong>Преимущества:</strong> скорость SSG + свежесть данных SSR</li><li><strong>Недостатки:</strong> сложнее инвалидация кэша</li><li><strong>Использование:</strong> новости, e-commerce каталоги, контент с умеренной частотой обновлений</li></ul><p><strong>Выбор стратегии:</strong></p><p>Зависит от частоты обновления данных и требований к персонализации.</p>",
    difficulty: 'middle',
    tags: ['SSR', 'SSG', 'ISR', 'стратегии рендеринга']
  },
  {
    id: 138,
    question: "Что такое гидратация (hydration) и какие проблемы с ней связаны?",
    answer: "<p><strong>Гидратация (hydration)</strong> — это процесс, когда React/Vue/другой фреймворк на клиенте «оживляет» статический HTML, полученный с сервера, добавляя интерактивность.</p><p><strong>Как работает:</strong></p><ol><li>Сервер отправляет готовый HTML</li><li>Браузер показывает статический контент</li><li>Загружается JavaScript</li><li>Фреймворк сопоставляет DOM с виртуальным DOM</li><li>Привязывает event handlers и делает страницу интерактивной</li></ol><p><strong>Типичные проблемы:</strong></p><p><strong>1. Hydration mismatch:</strong></p><ul><li>HTML с сервера не совпадает с клиентским рендером</li><li>Причины: разное время на сервере/клиенте, случайные значения, browser-only API</li><li>Результат: ошибки в консоли, некорректный UI</li></ul><p><strong>2. Медленная гидратация:</strong></p><ul><li>Большой JavaScript bundle замедляет процесс</li><li>Страница выглядит интерактивной, но не реагирует</li><li>Плохой показатель TTI (Time to Interactive)</li></ul><p><strong>3. Double rendering:</strong></p><ul><li>Компонент рендерится дважды: на сервере и клиенте</li><li>Лишняя работа, может вызвать мерцание</li></ul><p><strong>Решения:</strong></p><ul><li>Использовать одинаковые данные на сервере и клиенте</li><li>Избегать browser-only API в SSR-компонентах</li><li>Progressive hydration — гидрация по частям</li><li>Lazy hydration — гидрация по требованию</li></ul>",
    difficulty: 'senior',
    tags: ['hydration', 'SSR', 'проблемы', 'производительность']
  },
  {
    id: 139,
    question: "Какие данные можно безопасно рендерить на сервере, а какие нельзя?",
    answer: "<p>При SSR важно понимать, что можно безопасно отрендерить на сервере:</p><p><strong>Можно и нужно рендерить:</strong></p><p><strong>Публичные данные:</strong></p><ul><li>Контент статей, продуктов</li><li>Метаинформация для SEO</li><li>Структурированные данные Schema.org</li><li>Публичные комментарии, отзывы</li></ul><p><strong>Кэшируемые данные:</strong></p><ul><li>Списки категорий</li><li>Статические настройки</li><li>Данные, одинаковые для всех пользователей</li></ul><p><strong>Нельзя или опасно рендерить:</strong></p><p><strong>1. Чувствительные данные пользователя:</strong></p><ul><li>Токены аутентификации</li><li>API ключи</li><li>Персональная информация других пользователей</li><li>Финансовые данные</li></ul><p><strong>2. Секреты приложения:</strong></p><ul><li>Приватные конфиги</li><li>Database credentials</li><li>Internal API endpoints</li></ul><p><strong>3. Browser-specific API:</strong></p><ul><li>localStorage, sessionStorage</li><li>window, document объекты</li><li>геолокация, медиа-устройства</li></ul><p><strong>Лучшие практики:</strong></p><ul><li><strong>Разделяйте данные:</strong> публичные для SSR, приватные для клиента</li><li><strong>Используйте environment variables:</strong> для конфигурации сервера/клиента</li><li><strong>Проверяйте окружение:</strong> typeof window !== 'undefined'</li><li><strong>Сериализация:</strong> передавайте только необходимые данные в __NEXT_DATA__ или аналоги</li></ul><p>Золотое правило: если данные не должны быть в HTML-исходнике — не рендерьте их на сервере.</p>",
    difficulty: 'senior',
    tags: ['SSR', 'безопасность', 'данные', 'best practices']
  },
  {
    id: 140,
    question: "Как работает SSR в Next.js? Объясните getServerSideProps",
    answer: "<p>Next.js предоставляет встроенную поддержку SSR через специальные функции получения данных.</p><p><strong>getServerSideProps:</strong></p><p><strong>Основная концепция:</strong></p><ul><li>Функция выполняется на сервере при каждом запросе</li><li>Возвращает props, которые передаются в компонент страницы</li><li>HTML генерируется с этими данными</li><li>Отправляется клиенту уже готовым</li></ul><p><strong>Когда выполняется:</strong></p><ul><li>При прямом запросе страницы (URL в браузере)</li><li>При client-side навигации через next/link или router</li><li>При предзагрузке страницы</li></ul><p><strong>Что доступно в контексте:</strong></p><ul><li><strong>params:</strong> динамические параметры роута</li><li><strong>req/res:</strong> HTTP request и response объекты</li><li><strong>query:</strong> query string параметры</li><li><strong>preview:</strong> режим предпросмотра</li><li><strong>resolvedUrl:</strong> нормализованный URL</li></ul><p><strong>Типичные use cases:</strong></p><ul><li>Получение данных из API</li><li>Проверка аутентификации</li><li>A/B тестирование на сервере</li><li>Персонализированный контент</li><li>Геолокация по IP</li></ul><p><strong>Важные особенности:</strong></p><ul><li>Только для pages, не для компонентов</li><li>Код не попадает в клиентский bundle</li><li>Можно безопасно использовать серверные библиотеки</li><li>Блокирует рендеринг пока не вернутся данные</li></ul><p><strong>Performance considerations:</strong></p><p>Каждый запрос ждет выполнения функции — важно оптимизировать запросы к БД/API.</p>",
    difficulty: 'middle',
    tags: ['Next.js', 'getServerSideProps', 'SSR', 'React']
  },
  {
    id: 141,
    question: "В чем разница между getServerSideProps и getStaticProps в Next.js?",
    answer: "<p>Эти две функции представляют разные стратегии получения и рендеринга данных:</p><p><strong>getServerSideProps (SSR):</strong></p><p><strong>Время выполнения:</strong></p><ul><li>При каждом запросе страницы</li><li>На сервере в runtime</li></ul><p><strong>Характеристики:</strong></p><ul><li>Всегда свежие данные</li><li>Медленнее — требует серверной обработки</li><li>Нагрузка на сервер при каждом визите</li><li>Можно использовать req/res для персонализации</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Данные часто меняются</li><li>Нужна персонализация по cookies/headers</li><li>Динамический контент зависит от запроса</li></ul><p><strong>getStaticProps (SSG):</strong></p><p><strong>Время выполнения:</strong></p><ul><li>Один раз во время build</li><li>Или периодически при ISR (revalidate)</li></ul><p><strong>Характеристики:</strong></p><ul><li>Максимальная скорость — статический HTML</li><li>Можно кэшировать на CDN</li><li>Данные статичны между сборками</li><li>Нет доступа к req/res</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Данные редко меняются</li><li>Контент одинаков для всех пользователей</li><li>Можно сгенерировать заранее</li><li>Блоги, документация, маркетинг</li></ul><p><strong>Комбинирование:</strong></p><p>С ISR можно получить преимущества обоих подходов — скорость SSG с относительной свежестью данных через периодическую регенерацию.</p><p><strong>Выбор стратегии:</strong></p><p>Спросите себя: <em>Могут ли данные быть закэшированы хотя бы на минуту?</em> Если да — используйте getStaticProps с revalidate.</p>",
    difficulty: 'middle',
    tags: ['Next.js', 'SSR vs SSG', 'getStaticProps', 'стратегии рендеринга']
  },
  {
    id: 142,
    question: "Какие проблемы производительности характерны для SSR и как их решать?",
    answer: "<p>SSR может вводить специфические проблемы производительности:</p><p><strong>1. Медленный TTFB (Time to First Byte):</strong></p><p><strong>Причины:</strong></p><ul><li>Долгие запросы к базе данных</li><li>Медленные external API</li><li>Тяжелые вычисления на сервере</li><li>Отсутствие кэширования</li></ul><p><strong>Решения:</strong></p><ul><li>Кэшировать данные (Redis, in-memory)</li><li>Оптимизировать DB-запросы</li><li>Использовать параллельные запросы</li><li>Edge SSR — рендеринг ближе к пользователю</li><li>Таймауты на API-запросы</li></ul><p><strong>2. Высокая нагрузка на сервер:</strong></p><p><strong>Проблема:</strong></p><ul><li>Каждый визит требует серверных ресурсов</li><li>CPU/Memory нагрузка при высоком трафике</li></ul><p><strong>Решения:</strong></p><ul><li>Горизонтальное масштабирование</li><li>Кэширование на уровне CDN</li><li>ISR вместо полного SSR где возможно</li><li>Streaming SSR — частичная отправка HTML</li></ul><p><strong>3. Медленная гидратация:</strong></p><p><strong>Проблема:</strong></p><ul><li>Большой JavaScript bundle</li><li>Страница выглядит готовой, но не интерактивна</li></ul><p><strong>Решения:</strong></p><ul><li>Code splitting агрессивнее</li><li>Progressive hydration</li><li>Partial hydration — гидрировать только интерактивные части</li><li>Islands architecture</li></ul><p><strong>4. Memory leaks на сервере:</strong></p><p><strong>Проблема:</strong></p><ul><li>Забытые subscriptions</li><li>Кэши без ограничений</li><li>Globals не очищаются</li></ul><p><strong>Решения:</strong></p><ul><li>Чистить state между рендерами</li><li>LRU-кэши с ограничениями</li><li>Мониторинг памяти</li></ul>",
    difficulty: 'senior',
    tags: ['производительность', 'SSR', 'оптимизация', 'проблемы']
  },
  {
    id: 143,
    question: "Что такое Streaming SSR и в чем его преимущества?",
    answer: "<p><strong>Streaming SSR</strong> — это техника, при которой HTML отправляется клиенту частями по мере готовности, а не целиком в конце рендеринга.</p><p><strong>Как работает традиционный SSR:</strong></p><ol><li>Сервер ждет все данные</li><li>Рендерит весь HTML</li><li>Отправляет готовую страницу</li><li>Клиент ждет весь HTML перед отображением</li></ol><p><strong>Как работает Streaming SSR:</strong></p><ol><li>Сервер начинает отправлять HTML сразу</li><li>Shell (оболочка) приходит первой</li><li>Контент стримится по мере готовности</li><li>Браузер начинает рендерить раньше</li></ol><p><strong>Основные преимущества:</strong></p><p><strong>1. Быстрый First Contentful Paint:</strong></p><ul><li>Пользователь видит что-то моментально</li><li>Не нужно ждать медленные данные</li><li>Shell загружается первым</li></ul><p><strong>2. Лучшая воспринимаемая производительность:</strong></p><ul><li>Прогрессивная загрузка контента</li><li>Пользователь видит прогресс</li><li>Меньше ощущение ожидания</li></ul><p><strong>3. Параллелизация:</strong></p><ul><li>Браузер начинает парсить и выполнять ранние части</li><li>Может начать загружать ресурсы раньше</li><li>Гидратация может начаться до полной загрузки</li></ul><p><strong>Реализация:</strong></p><p><strong>React 18:</strong></p><ul><li>renderToPipeableStream для Node.js</li><li>Suspense boundaries для определения chunk'ов</li><li>Автоматический streaming</li></ul><p><strong>Use cases:</strong></p><ul><li>Страницы с медленными данными в некритичных частях</li><li>Dashboard'ы с множеством виджетов</li><li>E-commerce с рекомендациями</li></ul><p>Streaming SSR — это эволюция SSR, улучшающая UX при сохранении преимуществ серверного рендеринга.</p>",
    difficulty: 'senior',
    tags: ['Streaming SSR', 'React 18', 'производительность', 'UX']
  },
  {
    id: 144,
    question: "Как обрабатывать ошибки при SSR?",
    answer: "<p>Обработка ошибок в SSR критична, так как ошибка на сервере может сломать весь рендеринг:</p><p><strong>Типы ошибок в SSR:</strong></p><p><strong>1. Ошибки получения данных:</strong></p><ul><li>API недоступен</li><li>Таймаут запроса</li><li>Невалидные данные</li></ul><p><strong>Стратегии:</strong></p><ul><li>Try-catch в getServerSideProps</li><li>Возвращать fallback данные</li><li>Показывать error state</li><li>Логировать для мониторинга</li></ul><p><strong>2. Ошибки рендеринга:</strong></p><ul><li>Исключения в компонентах</li><li>Hydration mismatches</li><li>Отсутствующие зависимости</li></ul><p><strong>Стратегии:</strong></p><ul><li>Error Boundaries (React)</li><li>Fallback UI для проблемных компонентов</li><li>Graceful degradation</li></ul><p><strong>3. Инфраструктурные ошибки:</strong></p><ul><li>Out of memory</li><li>Database недоступна</li><li>Перегрузка сервера</li></ul><p><strong>Стратегии:</strong></p><ul><li>Health checks</li><li>Circuit breakers</li><li>Fallback на статический контент</li></ul><p><strong>Best practices:</strong></p><p><strong>Таймауты:</strong></p><ul><li>Устанавливайте разумные таймауты на все запросы</li><li>Лучше показать partial content, чем ждать бесконечно</li></ul><p><strong>Логирование:</strong></p><ul><li>Логируйте все ошибки SSR</li><li>Отправляйте в monitoring (Sentry, DataDog)</li><li>Сохраняйте контекст запроса</li></ul><p><strong>Fallbacks:</strong></p><ul><li>Всегда имейте план B</li><li>Кэшированная версия страницы</li><li>Минимальный working UI</li></ul><p><strong>Custom error pages:</strong></p><ul><li>500 для серверных ошибок</li><li>404 для несуществующих страниц</li><li>Полезная информация для пользователя</li></ul>",
    difficulty: 'senior',
    tags: ['обработка ошибок', 'SSR', 'reliability', 'мониторинг']
  },
  {
    id: 145,
    question: "Объясните концепцию Islands Architecture и как она связана с SSR",
    answer: "<p><strong>Islands Architecture</strong> — это паттерн, где страница состоит из «островов» интерактивности в море статического HTML.</p><p><strong>Основная идея:</strong></p><ul><li>Большая часть страницы — статический HTML</li><li>Отдельные компоненты (islands) — интерактивны</li><li>JavaScript загружается только для islands</li><li>Гидратация происходит выборочно</li></ul><p><strong>Как работает:</strong></p><p><strong>Традиционный SSR:</strong></p><ul><li>Весь HTML генерируется на сервере</li><li>Весь JavaScript загружается</li><li>Вся страница гидратируется</li><li>Даже статические части требуют JS</li></ul><p><strong>Islands Architecture:</strong></p><ul><li>Статический контент остается статическим</li><li>Только интерактивные компоненты помечаются как islands</li><li>Для каждого island загружается минимальный JS</li><li>Остальное — просто HTML</li></ul><p><strong>Преимущества:</strong></p><p><strong>1. Меньше JavaScript:</strong></p><ul><li>Загружается только необходимый код</li><li>Быстрее TTI (Time to Interactive)</li><li>Лучше на медленных соединениях</li></ul><p><strong>2. Лучшая производительность:</strong></p><ul><li>Меньше гидратации</li><li>Меньше работы для CPU</li><li>Быстрее на слабых устройствах</li></ul><p><strong>3. Гибкость:</strong></p><ul><li>Можно использовать разные фреймворки для разных islands</li><li>React для одного, Vue для другого</li></ul><p><strong>Примеры фреймворков:</strong></p><ul><li><strong>Astro:</strong> пионер islands architecture</li><li><strong>Fresh (Deno):</strong> islands by default</li><li><strong>Qwik:</strong> resumability вместо hydration</li></ul><p><strong>Use cases:</strong></p><ul><li>Content-heavy сайты (блоги, новости)</li><li>Маркетинговые страницы с интерактивными виджетами</li><li>Документация с интерактивными примерами</li></ul><p>Islands Architecture — это эволюция SSR, оптимизирующая баланс между статикой и интерактивностью.</p>",
    difficulty: 'senior',
    tags: ['Islands Architecture', 'SSR', 'производительность', 'архитектура']
  },
  {
    id: 146,
    question: "Как работает кэширование при SSR? Какие уровни кэширования существуют?",
    answer: "<p>Кэширование в SSR — ключ к производительности и масштабируемости:</p><p><strong>Уровни кэширования:</strong></p><p><strong>1. Browser cache:</strong></p><ul><li>Cache-Control headers</li><li>ETag для валидации</li><li>Кэширование статических ресурсов</li><li>Service Worker для offline</li></ul><p><strong>2. CDN cache:</strong></p><ul><li>Кэширование на edge серверах</li><li>Ближе к пользователю</li><li>Stale-while-revalidate</li><li>Гео-распределенные копии</li></ul><p><strong>3. Application cache:</strong></p><ul><li>In-memory кэш (Redis, Memcached)</li><li>Кэширование результатов рендеринга</li><li>Кэширование данных из БД/API</li><li>LRU eviction policy</li></ul><p><strong>4. Data cache:</strong></p><ul><li>Database query cache</li><li>API response cache</li><li>Computed values cache</li></ul><p><strong>Стратегии кэширования SSR:</strong></p><p><strong>Full page cache:</strong></p><ul><li>Кэшируем весь HTML целиком</li><li>Быстрее всего</li><li>Проблемы с персонализацией</li><li>Инвалидация по времени или событиям</li></ul><p><strong>Partial page cache:</strong></p><ul><li>Кэшируем фрагменты страницы</li><li>Собираем из частей при запросе</li><li>Баланс между свежестью и скоростью</li></ul><p><strong>Data-level cache:</strong></p><ul><li>Кэшируем только данные</li><li>Рендеринг каждый раз</li><li>Гибкость персонализации</li></ul><p><strong>Cache invalidation patterns:</strong></p><p><strong>Time-based (TTL):</strong></p><ul><li>Кэш живет фиксированное время</li><li>Простой, но может показывать устаревшие данные</li></ul><p><strong>Event-based:</strong></p><ul><li>Инвалидация при изменении данных</li><li>Webhook, message queue</li><li>Более сложно, но точнее</li></ul><p><strong>Stale-while-revalidate:</strong></p><ul><li>Отдаем кэш, обновляем в фоне</li><li>Баланс свежести и скорости</li></ul>",
    difficulty: 'senior',
    tags: ['кэширование', 'SSR', 'производительность', 'масштабируемость']
  },
  {
    id: 147,
    question: "Какие SEO-преимущества дает SSR и как их максимизировать?",
    answer: "<p>SSR предоставляет значительные SEO-преимущества:</p><p><strong>Основные SEO-выгоды SSR:</strong></p><p><strong>1. Полный HTML для ботов:</strong></p><ul><li>Поисковые роботы видят готовый контент</li><li>Не нужно выполнять JavaScript</li><li>Быстрая индексация</li><li>Меньше ресурсов требуется от бота</li></ul><p><strong>2. Meta-теги доступны сразу:</strong></p><ul><li>Title, description для поисковиков</li><li>Open Graph для социальных сетей</li><li>Twitter Cards</li><li>Canonical URLs</li></ul><p><strong>3. Быстрая загрузка:</strong></p><ul><li>Core Web Vitals важны для ранжирования</li><li>SSR улучшает LCP</li><li>Лучше FCP (First Contentful Paint)</li></ul><p><strong>4. Динамический контент индексируется:</strong></p><ul><li>Контент из API доступен ботам</li><li>Персонализированные URL с уникальным контентом</li><li>Фильтры, пагинация работают для SEO</li></ul><p><strong>Максимизация SEO с SSR:</strong></p><p><strong>Структурированные данные:</strong></p><ul><li>Добавляйте Schema.org разметку на сервере</li><li>JSON-LD для статей, продуктов, событий</li><li>Rich snippets в выдаче</li></ul><p><strong>Правильные заголовки:</strong></p><ul><li>Уникальные title для каждой страницы</li><li>Описательные meta descriptions</li><li>Правильная иерархия H1-H6</li></ul><p><strong>Canonical URLs:</strong></p><ul><li>Избегайте дублирования контента</li><li>Правильные canonical-теги</li><li>Консистентные URL структуры</li></ul><p><strong>XML Sitemap:</strong></p><ul><li>Генерируйте динамически</li><li>Включайте все SSR страницы</li><li>Правильные priority и changefreq</li></ul><p><strong>Performance:</strong></p><ul><li>Оптимизируйте TTFB</li><li>Минимизируйте CLS</li><li>Быстрый FCP критичен</li></ul><p>SSR дает foundation для отличного SEO, но требует правильной реализации.</p>",
    difficulty: 'middle',
    tags: ['SEO', 'SSR', 'оптимизация', 'индексация']
  },
  {
    id: 148,
    question: "Как тестировать SSR-приложения? Какие специфические проблемы нужно учитывать?",
    answer: "<p>Тестирование SSR требует учета особенностей как серверного, так и клиентского окружения:</p><p><strong>Типы тестов для SSR:</strong></p><p><strong>1. Unit тесты:</strong></p><p><strong>Серверные функции:</strong></p><ul><li>Тестировать getServerSideProps изолированно</li><li>Мокировать API и database</li><li>Проверять edge cases (ошибки, таймауты)</li></ul><p><strong>Компоненты:</strong></p><ul><li>Тестировать с React Testing Library</li><li>Мокировать browser API</li><li>Проверять SSR/CSR консистентность</li></ul><p><strong>2. Integration тесты:</strong></p><ul><li>Полный цикл: данные → рендеринг → HTML</li><li>Проверка hydration</li><li>Корректность передачи props</li></ul><p><strong>3. E2E тесты:</strong></p><ul><li>Playwright/Cypress для проверки полного flow</li><li>Тестирование с JavaScript и без него</li><li>Проверка интерактивности после гидратации</li></ul><p><strong>Специфические проблемы SSR:</strong></p><p><strong>Hydration mismatches:</strong></p><ul><li>Проверять консоль на ошибки гидратации</li><li>Сравнивать SSR HTML с клиентским</li><li>Автоматические тесты на consistency</li></ul><p><strong>Browser API в тестах:</strong></p><ul><li>Мокировать window, document, localStorage</li><li>JSDOM имеет ограничения</li><li>Conditional rendering в зависимости от окружения</li></ul><p><strong>Async data fetching:</strong></p><ul><li>Мокировать async запросы правильно</li><li>Тестировать loading states</li><li>Проверять error handling</li></ul><p><strong>Best practices:</strong></p><ul><li>Тестировать SSR и CSR paths отдельно</li><li>Проверять performance metrics</li><li>Использовать snapshot тесты для HTML</li><li>Автоматические Lighthouse проверки</li><li>Visual regression тесты</li></ul><p><strong>Инструменты:</strong></p><ul><li>Jest с JSDOM</li><li>Testing Library</li><li>Playwright для E2E</li><li>Percy для visual тестов</li></ul>",
    difficulty: 'senior',
    tags: ['тестирование', 'SSR', 'QA', 'automation']
  },
  {
    id: 149,
    question: "Что такое Edge SSR и чем он отличается от традиционного SSR?",
    answer: "<p><strong>Edge SSR</strong> — это рендеринг на edge-серверах CDN, распределенных географически близко к пользователям.</p><p><strong>Традиционный SSR:</strong></p><ul><li>Рендеринг на централизованных серверах</li><li>Все запросы идут в один регион</li><li>Высокая latency для удаленных пользователей</li><li>Масштабирование через добавление серверов</li></ul><p><strong>Edge SSR:</strong></p><ul><li>Рендеринг на edge locations CDN</li><li>Сотни точек присутствия по всему миру</li><li>Низкая latency независимо от локации пользователя</li><li>Автоматическое масштабирование</li></ul><p><strong>Ключевые преимущества:</strong></p><p><strong>1. Минимальная latency:</strong></p><ul><li>Рендеринг происходит ближе к пользователю</li><li>Быстрый TTFB глобально</li><li>Меньше network hops</li></ul><p><strong>2. Глобальное масштабирование:</strong></p><ul><li>Автоматическое распределение нагрузки</li><li>Нет проблем с regional outages</li><li>Pay-per-use модель</li></ul><p><strong>3. Упрощенная инфраструктура:</strong></p><ul><li>Не нужно управлять серверами</li><li>Автоматические обновления</li><li>Встроенный DDoS protection</li></ul><p><strong>Ограничения Edge:</strong></p><p><strong>Runtime ограничения:</strong></p><ul><li>Лимиты на CPU time (обычно 50-200ms)</li><li>Ограниченная память</li><li>Нельзя использовать Node.js специфичные API</li><li>Ограниченный доступ к файловой системе</li></ul><p><strong>Cold start:</strong></p><ul><li>Первый запрос может быть медленнее</li><li>Но меньше чем у традиционных serverless</li></ul><p><strong>Стоимость:</strong></p><ul><li>Дороже за запрос чем традиционный хостинг</li><li>Но дешевле при спайках трафика</li></ul><p><strong>Платформы для Edge SSR:</strong></p><ul><li>Cloudflare Workers</li><li>Vercel Edge Functions</li><li>Deno Deploy</li><li>Netlify Edge Functions</li></ul><p>Edge SSR — это следующая эволюция SSR для глобальных приложений с требованиями к low latency.</p>",
    difficulty: 'senior',
    tags: ['Edge SSR', 'CDN', 'производительность', 'масштабирование']
  },
  {
    id: 150,
    question: "Как организовать мониторинг и observability для SSR-приложений?",
    answer: "<p>Monitoring SSR требует отслеживания метрик как на сервере, так и на клиенте:</p><p><strong>Серверные метрики:</strong></p><p><strong>Performance метрики:</strong></p><ul><li><strong>TTFB:</strong> время до первого байта</li><li><strong>Server render time:</strong> время рендеринга на сервере</li><li><strong>Data fetching time:</strong> время получения данных</li><li><strong>Memory usage:</strong> потребление памяти</li><li><strong>CPU usage:</strong> загрузка процессора</li></ul><p><strong>Reliability метрики:</strong></p><ul><li><strong>Error rate:</strong> процент ошибок рендеринга</li><li><strong>Timeout rate:</strong> запросы с таймаутом</li><li><strong>5xx responses:</strong> серверные ошибки</li><li><strong>Availability:</strong> uptime сервиса</li></ul><p><strong>Клиентские метрики:</strong></p><p><strong>Core Web Vitals:</strong></p><ul><li>LCP, FID/INP, CLS</li><li>Отслеживать для SSR страниц отдельно</li><li>Сравнивать с CSR</li></ul><p><strong>Hydration метрики:</strong></p><ul><li>Время до интерактивности</li><li>Hydration errors frequency</li><li>JavaScript bundle size</li></ul><p><strong>Инструменты monitoring:</strong></p><p><strong>APM (Application Performance Monitoring):</strong></p><ul><li><strong>DataDog:</strong> full-stack observability</li><li><strong>New Relic:</strong> детальные traces</li><li><strong>Dynatrace:</strong> автоматическая инструментация</li></ul><p><strong>Error tracking:</strong></p><ul><li><strong>Sentry:</strong> ошибки и performance</li><li><strong>Bugsnag:</strong> error monitoring</li><li><strong>Rollbar:</strong> real-time errors</li></ul><p><strong>Логирование:</strong></p><ul><li>Structured logging (JSON)</li><li>Контекст запроса (trace ID, user ID)</li><li>Centralized logs (CloudWatch, Datadog)</li></ul><p><strong>Distributed tracing:</strong></p><ul><li>Отслеживать полный путь запроса</li><li>От клиента через сервер к БД/API</li><li>Находить bottlenecks</li></ul><p><strong>Алерты:</strong></p><ul><li>Высокий error rate</li><li>Деградация performance</li><li>Аномалии в метриках</li><li>Memory leaks</li></ul>",
    difficulty: 'senior',
    tags: ['мониторинг', 'observability', 'SSR', 'production']
  }
];
