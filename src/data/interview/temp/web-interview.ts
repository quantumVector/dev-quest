export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 75,
    question: "Как JWT работает с микросервисной архитектурой? Какие паттерны использовать?",
    answer: "<p>JWT идеально подходит для микросервисов благодаря <strong>stateless природе</strong>, но требует правильных паттернов:</p><h4>Преимущества JWT для микросервисов:</h4><ul><li>Каждый сервис может проверять токен независимо</li><li>Не нужен centralized session storage</li><li>Service-to-service auth через те же токены</li><li>Горизонтальное масштабирование без координации</li></ul><h4>Паттерн 1: API Gateway Pattern:</h4><p><strong>Архитектура:</strong></p><ul><li>Gateway — единая точка входа</li><li>Gateway проверяет JWT</li><li>Передает claims в downstream сервисы</li><li>Микросервисы trust gateway</li></ul><p><strong>Реализация:</strong></p><ol><li>Client → Gateway с JWT в Authorization header</li><li>Gateway валидирует signature, exp, aud</li><li>Gateway извлекает claims (userId, roles)</li><li>Gateway forwarding с claims в headers:<ul><li>X-User-Id: user_id</li><li>X-User-Roles: admin,moderator</li></ul></li><li>Микросервисы читают headers, не проверяют JWT</li></ol><p><strong>Преимущества:</strong></p><ul><li>Централизованная авторизация</li><li>Микросервисы упрощены</li><li>Единая точка для auth логики</li><li>Легко добавить rate limiting, logging</li></ul><p><strong>Недостатки:</strong></p><ul><li>Gateway — single point of failure</li><li>Требует trust между gateway и services</li><li>Internal network должна быть защищена</li></ul><h4>Паттерн 2: Distributed Validation:</h4><p><strong>Архитектура:</strong></p><ul><li>Каждый микросервис проверяет JWT самостоятельно</li><li>Shared public key или JWKS endpoint</li><li>Полная независимость сервисов</li></ul><p><strong>Реализация:</strong></p><ol><li>Client → Микросервис с JWT</li><li>Каждый сервис:<ul><li>Fetches public keys из JWKS</li><li>Кэширует ключи локально</li><li>Проверяет signature</li><li>Валидирует claims</li></ul></li><li>Сервисы делают business logic decisions</li></ol><p><strong>Преимущества:</strong></p><ul><li>Полная независимость</li><li>Нет single point of failure</li><li>Каждый сервис контролирует auth</li></ul><p><strong>Недостатки:</strong></p><ul><li>Дублирование auth кода</li><li>Каждый сервис должен handle JWKS</li><li>Сложнее обновить auth логику</li></ul><h4>Паттерн 3: Token Exchange:</h4><p><strong>Архитектура:</strong></p><ul><li>External JWT обменивается на internal</li><li>Gateway или auth service делает exchange</li><li>Internal токены с другими claims/scope</li></ul><p><strong>Когда использовать:</strong></p><ul><li>External и internal auth отличаются</li><li>Нужны разные permissions по сервисам</li><li>Security boundary между external/internal</li></ul><p><strong>Реализация:</strong></p><ol><li>Client → Gateway с external JWT</li><li>Gateway валидирует external JWT</li><li>Gateway создает internal JWT с:<ul><li>Specific scope для каждого сервиса</li><li>Internal user ID mapping</li><li>Additional internal claims</li></ul></li><li>Микросервисы работают с internal JWT</li></ol><h4>Паттерн 4: Service Mesh Integration:</h4><p><strong>Архитектура:</strong></p><ul><li>Service mesh (Istio, Linkerd) handles JWT</li><li>Sidecar proxy проверяет токены</li><li>Centralized policy management</li></ul><p><strong>Преимущества:</strong></p><ul><li>Auth отделена от application code</li><li>Централизованные policies</li><li>Automatic mTLS между сервисами</li><li>Rich observability</li></ul><h4>Key Management для микросервисов:</h4><p><strong>Асимметричные ключи (рекомендуется):</strong></p><ul><li>Auth service — private key (подпись)</li><li>Микросервисы — public key (проверка)</li><li>Public key безопасно распространяется</li></ul><p><strong>JWKS Endpoint:</strong></p><ul><li>Auth service публикует /.well-known/jwks.json</li><li>Микросервисы fetch keys при старте</li><li>Периодическое обновление или cache invalidation</li><li>kid (key ID) для key rotation</li></ul><p><strong>Key Rotation:</strong></p><ol><li>Publish новый ключ в JWKS (с новым kid)</li><li>Начать подпись новым ключом</li><li>Старый ключ остается для валидации</li><li>Grace period (например, 24 часа)</li><li>Удалить старый ключ из JWKS</li></ol><h4>Service-to-Service Auth:</h4><p><strong>Паттерн 1: Forwarding user JWT:</strong></p><ul><li>Просто forward токен пользователя</li><li>Service B знает кто real user</li><li>Audit trail сохранен</li></ul><p><strong>Паттерн 2: Service account tokens:</strong></p><ul><li>Service A получает свой токен</li><li>Identifies Service A, не пользователя</li><li>Для background jobs</li></ul><p><strong>Паттерн 3: Token chaining:</strong></p><ul><li>Service A получает токен от пользователя</li><li>Создает derived token для Service B</li><li>Includes both user и service identity</li></ul><h4>Claims Design для микросервисов:</h4><p><strong>Global claims (все сервисы):</strong></p><ul><li>sub: userId</li><li>iss: auth service</li><li>exp, iat: timestamps</li></ul><p><strong>Service-specific claims:</strong></p><ul><li>aud: specific service или array</li><li>scope: permissions для конкретного сервиса</li><li>roles: могут отличаться по сервисам</li></ul><h4>Distributed Tracing:</h4><ul><li>Включайте trace_id в JWT claims</li><li>Propagate через микросервисы</li><li>Correlate requests в логах</li><li>Observability across services</li></ul><h4>Error Handling:</h4><p><strong>Централизованное:</strong></p><ul><li>Gateway возвращает 401 unauthorized</li><li>Consistent error responses</li></ul><p><strong>Distributed:</strong></p><ul><li>Каждый сервис может вернуть 401/403</li><li>Нужна консистентность error format</li></ul><h4>Best Practices:</h4><ul><li>Используйте RS256/ES256 для микросервисов</li><li>JWKS endpoint для key distribution</li><li>Короткий exp, refresh через gateway</li><li>Audit logging всех auth events</li><li>Rate limiting на auth endpoints</li><li>Мониторинг failed validations</li><li>Distributed tracing для debugging</li></ul><p><em>Ключевой момент:</em> Выбор паттерна зависит от требований: Gateway для централизации, Distributed для autonomy, Service Mesh для infrastructure-level решения.</p>",
    difficulty: 'senior',
    tags: ['JWT', 'микросервисы', 'архитектура', 'паттерны', 'масштабирование']
  },

  {
    id: 76,
    question: "Что такое OAuth 2.0 и для чего он используется? В чем отличие от обычной аутентификации?",
    answer: "<p><strong>OAuth 2.0</strong> — это протокол авторизации, который позволяет приложениям получать ограниченный доступ к ресурсам пользователя без передачи пароля.</p><h4>Основное назначение:</h4><ul><li>Делегирование доступа к ресурсам</li><li>Авторизация сторонних приложений</li><li>Защита учетных данных пользователя</li><li>Гранулярный контроль доступа через scopes</li></ul><h4>Отличия от обычной аутентификации:</h4><p><strong>Обычная аутентификация:</strong></p><ul><li>Пользователь передает логин и пароль напрямую приложению</li><li>Приложение получает полный доступ к аккаунту</li><li>Нет способа ограничить доступ</li><li>Сложно отозвать доступ без смены пароля</li></ul><p><strong>OAuth 2.0:</strong></p><ul><li>Пользователь авторизуется на сервере провайдера</li><li>Приложение получает токен доступа, не видя пароль</li><li>Доступ ограничен определенными разрешениями (scopes)</li><li>Можно отозвать доступ отдельного приложения</li></ul><h4>Типичные use cases:</h4><ul><li>'Войти через Google/Facebook' — Single Sign-On</li><li>Доступ к Google Drive из стороннего приложения</li><li>Публикация в Twitter из другого сервиса</li><li>API авторизация для mobile и SPA</li></ul><p><em>Важно:</em> OAuth 2.0 — это протокол авторизации, не аутентификации. Для аутентификации используется OpenID Connect поверх OAuth 2.0.</p>",
    difficulty: 'junior',
    tags: ['OAuth', 'авторизация', 'безопасность', 'основы']
  },
  {
    id: 77,
    question: "Объясните основные роли (roles) в OAuth 2.0 и как они взаимодействуют",
    answer: "<p>OAuth 2.0 определяет <strong>четыре основные роли</strong>, каждая с определенной ответственностью:</p><h4>1. Resource Owner (Владелец ресурса):</h4><ul><li>Обычно это конечный пользователь</li><li>Владеет данными/ресурсами, к которым запрашивается доступ</li><li>Может предоставить или отклонить доступ</li><li>Пример: пользователь с аккаунтом Google</li></ul><h4>2. Resource Server (Сервер ресурсов):</h4><ul><li>Хранит защищенные ресурсы</li><li>Принимает и отвечает на запросы с access tokens</li><li>Проверяет валидность токенов</li><li>Обеспечивает доступ согласно scopes</li><li>Пример: Google Drive API, GitHub API</li></ul><h4>3. Client (Клиент):</h4><ul><li>Приложение, запрашивающее доступ к ресурсам</li><li>Действует от имени Resource Owner</li><li>Получает и использует access tokens</li><li>Может быть веб-приложением, мобильным, SPA, сервисом</li><li>Пример: сторонний фото-редактор, использующий Google Drive</li></ul><h4>4. Authorization Server (Сервер авторизации):</h4><ul><li>Аутентифицирует Resource Owner</li><li>Выдает access tokens клиенту после авторизации</li><li>Управляет процессом получения согласия (consent)</li><li>Может быть тем же сервером, что и Resource Server</li><li>Пример: accounts.google.com, oauth.vk.com</li></ul><h4>Типичный flow взаимодействия:</h4><ol><li>Client запрашивает авторизацию у Resource Owner</li><li>Resource Owner перенаправляется на Authorization Server</li><li>Resource Owner аутентифицируется и дает согласие</li><li>Authorization Server выдает токен Client</li><li>Client использует токен для доступа к Resource Server</li><li>Resource Server проверяет токен и возвращает данные</li></ol><p><em>Важно:</em> Разделение ролей позволяет безопасно делегировать доступ без раскрытия учетных данных.</p>",
    difficulty: 'middle',
    tags: ['OAuth', 'роли', 'архитектура', 'компоненты']
  },
  {
    id: 78,
    question: "Какие типы grant types существуют в OAuth 2.0 и когда каждый используется?",
    answer: "<p>OAuth 2.0 определяет несколько <strong>механизмов получения токенов</strong> (grant types) для разных сценариев:</p><h4>1. Authorization Code Grant:</h4><p><strong>Описание:</strong></p><ul><li>Наиболее безопасный и распространенный flow</li><li>Двухэтапный процесс: код → токен</li><li>Токен никогда не проходит через браузер</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Server-side веб-приложения</li><li>Приложения, способные хранить client_secret</li><li>Когда нужна максимальная безопасность</li></ul><p><strong>Этапы:</strong></p><ol><li>Redirect на authorization endpoint</li><li>Пользователь авторизуется</li><li>Redirect обратно с authorization code</li><li>Обмен кода на access token (server-side)</li></ol><h4>2. Implicit Grant (устарел):</h4><p><strong>Описание:</strong></p><ul><li>Токен возвращается сразу в URL fragment</li><li>Одноэтапный процесс</li><li>Не использует client_secret</li></ul><p><strong>Проблемы:</strong></p><ul><li>Токен виден в URL</li><li>Нет refresh tokens</li><li>Менее безопасен</li></ul><p><strong>Статус:</strong> Не рекомендуется, заменен на Authorization Code + PKCE</p><h4>3. Resource Owner Password Credentials:</h4><p><strong>Описание:</strong></p><ul><li>Пользователь передает логин и пароль напрямую</li><li>Клиент обменивает их на токен</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Только для доверенных first-party приложений</li><li>Миграция с legacy систем</li><li>Не для third-party приложений</li></ul><p><strong>Недостатки:</strong> Клиент видит пароль, нарушает основную идею OAuth</p><h4>4. Client Credentials Grant:</h4><p><strong>Описание:</strong></p><ul><li>Аутентификация самого приложения, не пользователя</li><li>Использует client_id и client_secret</li><li>Без участия пользователя</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Machine-to-machine коммуникация</li><li>Microservices авторизация</li><li>Backend сервисы</li><li>CLI инструменты</li></ul><h4>5. Device Authorization Grant:</h4><p><strong>Описание:</strong></p><ul><li>Для устройств с ограниченным вводом</li><li>Пользователь авторизуется на другом устройстве</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Smart TV, игровые консоли</li><li>IoT устройства</li><li>CLI tools без браузера</li></ul><h4>6. Refresh Token Grant:</h4><p><strong>Описание:</strong></p><ul><li>Обмен refresh token на новый access token</li><li>Продление сессии без повторной авторизации</li></ul><p><em>Рекомендация:</em> Для SPA и mobile используйте Authorization Code + PKCE. Для server-side — Authorization Code. Для API — Client Credentials.</p>",
    difficulty: 'middle',
    tags: ['OAuth', 'grant types', 'flows', 'authorization']
  },
  {
    id: 79,
    question: "Что такое PKCE и почему он необходим для Single Page Applications?",
    answer: "<p><strong>PKCE (Proof Key for Code Exchange)</strong> — это расширение OAuth 2.0, добавляющее дополнительный уровень безопасности для публичных клиентов.</p><h4>Проблема, которую решает PKCE:</h4><p><strong>Атака перехвата authorization code:</strong></p><ul><li>Вредоносное приложение регистрируется с тем же redirect URI</li><li>Перехватывает authorization code из callback</li><li>Обменивает код на токен раньше легитимного приложения</li><li>Особенно опасно для mobile apps с custom URL schemes</li></ul><h4>Как работает PKCE:</h4><p><strong>1. Code Verifier (секретный):</strong></p><ul><li>Случайная строка, генерируется клиентом</li><li>Минимум 43 символа, максимум 128</li><li>Сохраняется в приложении, никуда не передается</li></ul><p><strong>2. Code Challenge (публичный):</strong></p><ul><li>Вычисляется из code verifier</li><li>Два метода: plain или S256 (SHA256)</li><li>Отправляется в authorization request</li></ul><p><strong>3. Процесс авторизации:</strong></p><ol><li>Клиент генерирует code_verifier</li><li>Вычисляет code_challenge = SHA256(code_verifier)</li><li>Отправляет code_challenge в authorization request</li><li>Получает authorization code</li><li>При обмене кода на токен отправляет code_verifier</li><li>Сервер проверяет: SHA256(code_verifier) == code_challenge</li></ol><h4>Почему необходим для SPA:</h4><p><strong>1. Публичный клиент:</strong></p><ul><li>SPA не может безопасно хранить client_secret</li><li>Весь код доступен в браузере</li><li>PKCE заменяет client_secret</li></ul><p><strong>2. Защита от перехвата:</strong></p><ul><li>Даже если authorization code перехвачен</li><li>Атакующий не знает code_verifier</li><li>Не может обменять код на токен</li></ul><p><strong>3. No redirect URI validation issues:</strong></p><ul><li>PKCE не зависит от точности redirect URI</li><li>Дополнительный уровень защиты</li></ul><h4>Code Challenge методы:</h4><p><strong>plain (не рекомендуется):</strong></p><ul><li>code_challenge = code_verifier</li><li>Используется только если S256 не поддерживается</li></ul><p><strong>S256 (рекомендуется):</strong></p><ul><li>code_challenge = base64url(SHA256(code_verifier))</li><li>Более безопасен</li><li>Стандарт для современных приложений</li></ul><h4>Когда использовать:</h4><ul><li>Обязательно для SPA (Single Page Applications)</li><li>Обязательно для mobile applications</li><li>Рекомендуется для всех публичных клиентов</li><li>Даже для confidential clients как дополнительная защита</li></ul><p><em>Важно:</em> PKCE стал стандартом де-факто для всех типов приложений, не только публичных. OAuth 2.1 делает его обязательным.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'PKCE', 'безопасность', 'SPA']
  },
  {
    id: 80,
    question: "Объясните разницу между Access Token и Refresh Token. Зачем нужны оба?",
    answer: "<p>Access Token и Refresh Token служат <strong>разным целям</strong> в OAuth 2.0:</p><h4>Access Token:</h4><p><strong>Назначение:</strong></p><ul><li>Предоставляет доступ к защищенным ресурсам</li><li>Передается с каждым API запросом</li><li>Подтверждает право на доступ</li></ul><p><strong>Характеристики:</strong></p><ul><li>Короткое время жизни (обычно 15 минут - 1 час)</li><li>Может быть JWT (самодостаточный) или opaque (reference token)</li><li>Содержит scopes и информацию о пользователе</li><li>Передается в Authorization header</li><li>Должен быть защищен от утечки</li></ul><p><strong>Формат:</strong> Bearer token в заголовке Authorization: Bearer {token}</p><h4>Refresh Token:</h4><p><strong>Назначение:</strong></p><ul><li>Получение нового access token без повторной авторизации</li><li>Продление сессии пользователя</li><li>Не используется для доступа к API</li></ul><p><strong>Характеристики:</strong></p><ul><li>Длительное время жизни (дни, недели, месяцы)</li><li>Всегда opaque (только для authorization server)</li><li>Используется редко (только для обновления)</li><li>Хранится максимально безопасно</li><li>Может быть одноразовым (rotation)</li></ul><h4>Зачем нужны оба:</h4><p><strong>1. Безопасность:</strong></p><ul><li>Access token живет недолго → меньше окно для атаки</li><li>Если access token украден, ущерб ограничен временем жизни</li><li>Refresh token редко используется → меньше шансов перехвата</li></ul><p><strong>2. Производительность:</strong></p><ul><li>Access token самодостаточный (JWT) → нет обращений к БД</li><li>Resource server не проверяет токен на authorization server</li><li>Refresh token используется редко → меньше нагрузки</li></ul><p><strong>3. Гибкость:</strong></p><ul><li>Можно отозвать refresh token централизованно</li><li>Access token продолжит работать до истечения</li><li>Баланс между безопасностью и удобством</li></ul><h4>Типичный flow с обоими токенами:</h4><ol><li>Пользователь авторизуется → получает оба токена</li><li>Приложение использует access token для API запросов</li><li>Access token истекает</li><li>Приложение использует refresh token для получения нового access token</li><li>Authorization server проверяет refresh token</li><li>Возвращает новую пару токенов</li><li>Процесс повторяется</li></ol><h4>Когда refresh token не выдается:</h4><ul><li>Client Credentials Grant (машинный доступ)</li><li>Implicit Grant (устарел)</li><li>Некоторые Authorization Code flows (по выбору сервера)</li></ul><h4>Refresh Token Rotation:</h4><p><strong>Современная практика:</strong></p><ul><li>При каждом использовании refresh token выдается новый</li><li>Старый становится недействительным</li><li>Если старый используется → возможна атака → отзыв всех токенов</li><li>Дополнительная защита от кражи</li></ul><p><em>Принцип:</em> Access token для доступа (короткоживущий), refresh token для обновления (долгоживущий). Это defense in depth подход к безопасности.</p>",
    difficulty: 'middle',
    tags: ['OAuth', 'tokens', 'access token', 'refresh token']
  },
  {
    id: 81,
    question: "Что такое OAuth Scopes и как они используются для контроля доступа?",
    answer: "<p><strong>Scopes</strong> в OAuth 2.0 — это механизм для определения и ограничения прав доступа, которые запрашивает и получает клиентское приложение.</p><h4>Назначение scopes:</h4><ul><li>Гранулярный контроль доступа к ресурсам</li><li>Принцип наименьших привилегий</li><li>Прозрачность для пользователя</li><li>Возможность частичного отзыва доступа</li></ul><h4>Как работают scopes:</h4><p><strong>1. При запросе авторизации:</strong></p><ul><li>Клиент указывает желаемые scopes</li><li>Пример: scope=read:profile write:posts read:email</li><li>Пользователь видит список запрашиваемых разрешений</li><li>Может одобрить все или отказать</li></ul><p><strong>2. В access token:</strong></p><ul><li>Токен содержит одобренные scopes</li><li>Resource server проверяет scopes при каждом запросе</li><li>Отклоняет запросы без необходимых scopes</li></ul><h4>Типичные примеры scopes:</h4><p><strong>Google API:</strong></p><ul><li>https://www.googleapis.com/auth/drive.readonly</li><li>https://www.googleapis.com/auth/userinfo.email</li><li>https://www.googleapis.com/auth/calendar</li></ul><p><strong>GitHub API:</strong></p><ul><li>repo — доступ к репозиториям</li><li>user — чтение информации о пользователе</li><li>delete_repo — удаление репозиториев</li></ul><p><strong>Собственный API:</strong></p><ul><li>read:users — чтение данных пользователей</li><li>write:posts — создание/редактирование постов</li><li>admin:settings — административные функции</li></ul><h4>Иерархия scopes:</h4><ul><li>Scopes могут быть организованы иерархически</li><li>read:profile может включать email, name, avatar</li><li>admin может включать все read и write операции</li><li>Важно документировать зависимости</li></ul><h4>Динамические vs статические scopes:</h4><p><strong>Статические:</strong></p><ul><li>Предопределенный список</li><li>Не меняются во время выполнения</li><li>Проще управлять и валидировать</li></ul><p><strong>Динамические:</strong></p><ul><li>Могут включать параметры</li><li>Пример: read:repo:123</li><li>Более гибкие, но сложнее</li></ul><h4>Обработка scopes на сервере:</h4><p><strong>Authorization Server:</strong></p><ul><li>Валидирует запрашиваемые scopes</li><li>Проверяет, имеет ли клиент право запрашивать эти scopes</li><li>Может уменьшить запрошенные scopes</li><li>Включает одобренные scopes в токен</li></ul><p><strong>Resource Server:</strong></p><ul><li>Извлекает scopes из токена</li><li>Проверяет наличие необходимых scopes для endpoint</li><li>Возвращает 403 Forbidden при отсутствии прав</li></ul><h4>Best practices для scopes:</h4><ul><li><strong>Гранулярность:</strong> Достаточно детальные, но не избыточные</li><li><strong>Понятность:</strong> Очевидные названия для пользователей</li><li><strong>Консистентность:</strong> Единый стиль именования (read:, write:, admin:)</li><li><strong>Документация:</strong> Четкое описание каждого scope</li><li><strong>Минимализм:</strong> Запрашивайте только необходимые scopes</li></ul><h4>Проблемы и решения:</h4><p><strong>Проблема: Scope creep</strong></p><ul><li>Приложение запрашивает слишком много</li><li>Решение: Регулярный аудит, запрос scopes по мере необходимости</li></ul><p><strong>Проблема: Непонятные scopes</strong></p><ul><li>Пользователи не понимают, что одобряют</li><li>Решение: Человекочитаемые описания в consent screen</li></ul><p><em>Важно:</em> Scopes — это не полноценная система разрешений, а механизм ограничения доступа клиентского приложения. Полная авторизация должна проверяться на resource server.</p>",
    difficulty: 'middle',
    tags: ['OAuth', 'scopes', 'разрешения', 'контроль доступа']
  },
  {
    id: 82,
    question: "Чем отличается OAuth 2.0 от OAuth 1.0? Почему произошел переход?",
    answer: "<p>OAuth 2.0 — это <strong>полная переработка</strong> OAuth 1.0, а не просто обновление:</p><h4>Ключевые отличия OAuth 2.0:</h4><p><strong>1. Упрощение для разработчиков:</strong></p><ul><li>Нет криптографической подписи запросов</li><li>Не требуется сложная генерация signature</li><li>Токены передаются в заголовках, не в параметрах</li><li>Меньше шагов в процессе авторизации</li></ul><p><strong>2. Обязательность HTTPS:</strong></p><ul><li>OAuth 1.0: криптография компенсировала HTTP</li><li>OAuth 2.0: полагается на HTTPS для безопасности</li><li>Проще, но требует SSL/TLS везде</li></ul><p><strong>3. Разнообразие flows:</strong></p><ul><li>OAuth 1.0: один flow для всех</li><li>OAuth 2.0: множество grant types для разных сценариев</li><li>Гибкость под разные типы приложений</li></ul><p><strong>4. Разделение ролей:</strong></p><ul><li>Четкое разделение Authorization Server и Resource Server</li><li>Можно использовать разные серверы</li><li>Лучше масштабируемость</li></ul><p><strong>5. Короткоживущие токены:</strong></p><ul><li>OAuth 1.0: токены жили долго</li><li>OAuth 2.0: access tokens короткоживущие + refresh tokens</li><li>Лучше безопасность</li></ul><h4>Что потеряли в OAuth 2.0:</h4><p><strong>1. Криптографическая подпись:</strong></p><ul><li>OAuth 1.0 подписывал каждый запрос</li><li>Защита от MITM даже без HTTPS</li><li>OAuth 2.0 полностью зависит от HTTPS</li></ul><p><strong>2. Гарантия целостности:</strong></p><ul><li>OAuth 1.0: HMAC-SHA1 подпись гарантировала неизменность</li><li>OAuth 2.0: доверяет TLS</li></ul><h4>Почему произошел переход:</h4><p><strong>1. Сложность реализации OAuth 1.0:</strong></p><ul><li>Генерация подписи была источником багов</li><li>Трудно отлаживать проблемы</li><li>Высокий порог входа для разработчиков</li><li>Много неправильных реализаций</li></ul><p><strong>2. Ограничения OAuth 1.0:</strong></p><ul><li>Не подходил для browser-based apps</li><li>Проблемы с mobile приложениями</li><li>Один flow не покрывал все use cases</li></ul><p><strong>3. Зрелость HTTPS:</strong></p><ul><li>К 2012 году HTTPS стал стандартом</li><li>Let's Encrypt сделал SSL доступным</li><li>Можно было полагаться на транспортную безопасность</li></ul><p><strong>4. Потребности индустрии:</strong></p><ul><li>Рост SPA и mobile приложений</li><li>Microservices архитектура</li><li>API-first подход</li><li>Нужна была гибкость</li></ul><h4>Обратная совместимость:</h4><ul><li>OAuth 2.0 НЕ обратно совместим с 1.0</li><li>Это полностью новый протокол</li><li>Миграция требует переработки</li></ul><h4>Текущее состояние:</h4><ul><li>OAuth 1.0 практически не используется</li><li>Некоторые legacy системы (Twitter API v1.1)</li><li>OAuth 2.0 — индустриальный стандарт</li><li>OAuth 2.1 в разработке (консолидация best practices)</li></ul><h4>OAuth 2.1 (будущее):</h4><ul><li>PKCE обязателен для всех клиентов</li><li>Удаление Implicit Grant</li><li>Удаление Resource Owner Password Grant</li><li>Обязательный Refresh Token Rotation</li><li>Более безопасный и простой</li></ul><p><em>Вывод:</em> OAuth 2.0 пожертвовал встроенной криптографией ради простоты и гибкости, полагаясь на HTTPS. Это был правильный выбор для современного веба.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'OAuth 1.0', 'OAuth 2.0', 'история', 'сравнение']
  },
  {
    id: 83,
    question: "Что такое OpenID Connect и как он связан с OAuth 2.0?",
    answer: "<p><strong>OpenID Connect (OIDC)</strong> — это протокол аутентификации, построенный <strong>поверх OAuth 2.0</strong>, добавляющий слой идентификации пользователя.</p><h4>Ключевое различие OAuth 2.0 vs OIDC:</h4><p><strong>OAuth 2.0:</strong></p><ul><li>Протокол авторизации</li><li>Отвечает на вопрос: 'Что может делать приложение?'</li><li>Выдает access tokens</li><li>Не говорит ничего о пользователе</li></ul><p><strong>OpenID Connect:</strong></p><ul><li>Протокол аутентификации</li><li>Отвечает на вопрос: 'Кто этот пользователь?'</li><li>Выдает ID tokens + access tokens</li><li>Стандартизированная информация о пользователе</li></ul><h4>Как OIDC расширяет OAuth 2.0:</h4><p><strong>1. ID Token (главное дополнение):</strong></p><ul><li>JWT токен с информацией о пользователе</li><li>Содержит claims: sub, name, email, picture</li><li>Подписан провайдером</li><li>Используется для SSO (Single Sign-On)</li></ul><p><strong>2. UserInfo Endpoint:</strong></p><ul><li>Стандартный endpoint для получения информации о пользователе</li><li>Вызывается с access token</li><li>Возвращает подробные claims</li></ul><p><strong>3. Стандартные scopes:</strong></p><ul><li>openid — обязательный, активирует OIDC</li><li>profile — базовая информация (name, picture)</li><li>email — email адрес</li><li>address — физический адрес</li><li>phone — телефон</li></ul><p><strong>4. Стандартизированные flows:</strong></p><ul><li>Те же что OAuth 2.0, но с ID token</li><li>Четкие спецификации поведения</li></ul><h4>Структура ID Token:</h4><p>JWT содержит три части (header.payload.signature):</p><p><strong>Header:</strong> Алгоритм подписи и тип токена</p><p><strong>Payload (claims):</strong></p><ul><li>iss — issuer (кто выдал)</li><li>sub — subject (уникальный ID пользователя)</li><li>aud — audience (для кого предназначен)</li><li>exp — expiration time</li><li>iat — issued at time</li><li>+ дополнительные claims (name, email, etc.)</li></ul><p><strong>Signature:</strong> Криптографическая подпись для проверки</p><h4>Типичные use cases OIDC:</h4><p><strong>1. Single Sign-On (SSO):</strong></p><ul><li>'Войти через Google/Facebook'</li><li>Пользователь получает ID token</li><li>Приложение знает, кто пользователь</li><li>Создает локальную сессию</li></ul><p><strong>2. Federated Identity:</strong></p><ul><li>Один аккаунт для множества сервисов</li><li>Централизованное управление пользователями</li><li>Корпоративный SSO</li></ul><p><strong>3. Mobile/SPA authentication:</strong></p><ul><li>Безопасная аутентификация без паролей</li><li>Делегирование identity провайдеру</li></ul><h4>OIDC vs SAML:</h4><p>Оба для SSO, но:</p><p><strong>OIDC:</strong></p><ul><li>Современный, REST/JSON</li><li>Подходит для web, mobile, SPA</li><li>Проще в реализации</li><li>OAuth 2.0 в основе</li></ul><p><strong>SAML:</strong></p><ul><li>Старше, XML-based</li><li>Корпоративный стандарт</li><li>Сложнее, но больше возможностей</li><li>Legacy enterprise системы</li></ul><h4>Популярные OIDC провайдеры:</h4><ul><li>Google Identity Platform</li><li>Auth0</li><li>Okta</li><li>Microsoft Azure AD</li><li>Keycloak (open-source)</li></ul><h4>Discovery и Dynamic Registration:</h4><p><strong>OIDC Discovery:</strong></p><ul><li>Endpoint: /.well-known/openid-configuration</li><li>Метаданные провайдера (endpoints, supported features)</li><li>Автоматическая настройка клиентов</li></ul><p><strong>Dynamic Client Registration:</strong></p><ul><li>Автоматическая регистрация клиентов</li><li>Без ручной настройки через UI</li><li>Полезно для multi-tenant систем</li></ul><p><em>Вывод:</em> Если нужна авторизация (доступ к API) — OAuth 2.0. Если нужна аутентификация (знать кто пользователь) — OIDC. В реальности часто используются оба вместе.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'OpenID Connect', 'OIDC', 'аутентификация', 'SSO']
  },
  {
    id: 84,
    question: "Как безопасно хранить токены в браузере? Какие есть варианты и их плюсы/минусы?",
    answer: "<p>Хранение токенов в браузере — это <strong>критический вопрос безопасности</strong> с несколькими подходами:</p><h4>Варианты хранения:</h4><h4>1. localStorage:</h4><p><strong>Плюсы:</strong></p><ul><li>Простота использования</li><li>Данные сохраняются между сессиями</li><li>Большой объем (~5-10MB)</li><li>Синхронный API</li></ul><p><strong>Минусы:</strong></p><ul><li>Доступен из любого JavaScript кода</li><li>Уязвим к XSS атакам</li><li>Нет HttpOnly защиты</li><li>Привязан к origin, но виден всему коду</li></ul><p><strong>Когда использовать:</strong> Для некритичных данных, когда нужна персистентность</p><h4>2. sessionStorage:</h4><p><strong>Плюсы:</strong></p><ul><li>Те же что localStorage</li><li>Автоматически очищается при закрытии вкладки</li><li>Изолирован по вкладкам</li></ul><p><strong>Минусы:</strong></p><ul><li>Те же XSS риски что localStorage</li><li>Данные теряются при закрытии вкладки</li></ul><h4>3. Cookies с HttpOnly:</h4><p><strong>Плюсы:</strong></p><ul><li>HttpOnly защищает от XSS</li><li>JavaScript не может прочитать</li><li>Автоматически отправляются с запросами</li><li>Проверенный временем подход</li></ul><p><strong>Минусы:</strong></p><ul><li>Уязвимы к CSRF (нужна защита)</li><li>Размер ограничен (~4KB)</li><li>Отправляются с каждым запросом (overhead)</li><li>SameSite ограничения для cross-origin</li></ul><h4>4. Memory (JavaScript переменные):</h4><p><strong>Плюсы:</strong></p><ul><li>Самый безопасный от XSS (если нет утечки)</li><li>Не персистентный — исчезает при перезагрузке</li><li>Не может быть украден другими скриптами напрямую</li></ul><p><strong>Минусы:</strong></p><ul><li>Токен теряется при перезагрузке страницы</li><li>Плохой UX — частая переавторизация</li><li>Все равно уязвим к XSS при выполнении</li></ul><h4>Гибридные подходы:</h4><h4>1. Refresh Token в HttpOnly Cookie + Access Token в Memory:</h4><p><strong>Лучший баланс безопасности и UX:</strong></p><ul><li>Access token в памяти (короткоживущий)</li><li>Refresh token в HttpOnly cookie (долгоживущий)</li><li>При перезагрузке получаем новый access token</li><li>XSS может украсть access token, но на короткое время</li><li>CSRF защищен через SameSite и дополнительные меры</li></ul><h4>2. Backend-for-Frontend (BFF) Pattern:</h4><p><strong>Самый безопасный подход:</strong></p><ul><li>SPA взаимодействует только со своим backend</li><li>Backend хранит токены</li><li>Session cookie между SPA и backend</li><li>Backend проксирует запросы к API с токенами</li><li>Токены никогда не попадают в браузер</li></ul><p><strong>Плюсы:</strong> Максимальная безопасность</p><p><strong>Минусы:</strong> Дополнительная сложность, больше latency</p><h4>Защита от XSS (обязательно):</h4><ul><li>Content Security Policy (CSP)</li><li>Санитизация пользовательского ввода</li><li>Экранирование вывода</li><li>Регулярные security аудиты</li><li>Обновление зависимостей</li></ul><h4>Защита от CSRF (для cookies):</h4><ul><li>SameSite=Strict или Lax на cookies</li><li>CSRF токены для изменяющих операций</li><li>Custom headers в AJAX запросах</li><li>Проверка Origin/Referer headers</li></ul><h4>Рекомендации по выбору:</h4><p><strong>Высокая безопасность требуется:</strong></p><ul><li>BFF Pattern</li><li>Или Refresh in HttpOnly + Access in Memory</li></ul><p><strong>Баланс безопасности и простоты:</strong></p><ul><li>HttpOnly cookies с защитой от CSRF</li><li>SameSite=Strict для максимальной защиты</li></ul><p><strong>Прототипирование/низкие риски:</strong></p><ul><li>localStorage допустим</li><li>Но подготовьтесь к миграции</li></ul><h4>Что НЕ делать:</h4><ul><li>Не храните токены в localStorage в production для чувствительных данных</li><li>Не используйте cookies без HttpOnly для токенов</li><li>Не игнорируйте XSS защиту</li><li>Не используйте GET параметры для токенов</li></ul><p><em>Золотое правило:</em> Нет идеального решения. Выбирайте подход основываясь на threat model вашего приложения. Для high-security приложений — BFF Pattern.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'токены', 'хранение', 'безопасность', 'браузер']
  },
  {
    id: 85,
    question: "Объясните, что такое JWT и когда его использовать как access token",
    answer: "<p><strong>JWT (JSON Web Token)</strong> — это компактный, URL-safe способ представления claims между двумя сторонами, часто используется как access token.</p><h4>Структура JWT:</h4><p>Три части, разделенные точками: <strong>header.payload.signature</strong></p><p><strong>1. Header:</strong></p><ul><li>Тип токена (JWT)</li><li>Алгоритм подписи (HS256, RS256)</li><li>Base64Url encoded</li></ul><p><strong>2. Payload (claims):</strong></p><ul><li>Данные о пользователе и разрешениях</li><li>Стандартные claims: sub, exp, iat, iss, aud</li><li>Кастомные claims: user_id, roles, scopes</li><li>Base64Url encoded</li></ul><p><strong>3. Signature:</strong></p><ul><li>HMAC или RSA подпись header + payload</li><li>Гарантирует целостность и аутентичность</li></ul><h4>JWT как Access Token:</h4><h4>Преимущества:</h4><p><strong>1. Самодостаточность (Self-contained):</strong></p><ul><li>Вся необходимая информация внутри токена</li><li>Resource server не обращается к БД</li><li>Не нужна session store</li><li>Быстрая валидация через подпись</li></ul><p><strong>2. Stateless архитектура:</strong></p><ul><li>Сервер не хранит состояние сессии</li><li>Легко масштабируется горизонтально</li><li>Любой сервер может валидировать токен</li></ul><p><strong>3. Информативность:</strong></p><ul><li>Содержит scopes, roles, user_id</li><li>Resource server получает все что нужно</li><li>Не нужны дополнительные запросы</li></ul><p><strong>4. Межсервисное взаимодействие:</strong></p><ul><li>Токен можно передавать между микросервисами</li><li>Каждый сервис валидирует независимо</li></ul><h4>Недостатки JWT как Access Token:</h4><p><strong>1. Невозможность отзыва:</strong></p><ul><li>JWT действителен до истечения exp</li><li>Нельзя инвалидировать токен до истечения</li><li>Единственный способ — blacklist (но это уже не stateless)</li></ul><p><strong>2. Размер:</strong></p><ul><li>JWT больше чем opaque token</li><li>Передается с каждым запросом</li><li>Накладные расходы на bandwidth</li></ul><p><strong>3. Безопасность данных:</strong></p><ul><li>Payload не зашифрован, только подписан</li><li>Любой может прочитать содержимое</li><li>Нельзя хранить чувствительные данные</li></ul><p><strong>4. Сложность ротации секретов:</strong></p><ul><li>Смена ключа подписи требует координации</li><li>Старые токены становятся недействительными</li></ul><h4>Когда использовать JWT:</h4><p><strong>Хорошо подходит:</strong></p><ul><li>Stateless API (микросервисы)</li><li>Короткоживущие токены (5-15 минут)</li><li>Когда нужна информация о пользователе в токене</li><li>Distributed системы</li><li>Когда производительность критична</li></ul><p><strong>Не подходит:</strong></p><ul><li>Долгоживущие токены</li><li>Когда нужен немедленный отзыв</li><li>Чувствительная информация в payload</li><li>Когда размер токена критичен</li></ul><h4>JWT vs Opaque Token:</h4><p><strong>Opaque Token (reference token):</strong></p><ul><li>Случайная строка без смысла</li><li>Требует lookup в БД для валидации</li><li>Легко отозвать (удалить из БД)</li><li>Компактный размер</li><li>Используется для refresh tokens</li></ul><p><strong>JWT Token:</strong></p><ul><li>Содержит данные</li><li>Валидация через подпись, без БД</li><li>Нельзя отозвать до истечения</li><li>Больший размер</li><li>Используется для access tokens</li></ul><h4>Best practices для JWT:</h4><ul><li>Короткое время жизни (exp)</li><li>Валидация всех claims (exp, iss, aud)</li><li>Использование сильных алгоритмов (RS256 предпочтительнее HS256)</li><li>Не хранить чувствительные данные</li><li>Всегда валидировать подпись</li><li>Использовать HTTPS</li><li>Периодическая ротация ключей</li></ul><h4>Алгоритмы подписи:</h4><p><strong>HS256 (HMAC):</strong></p><ul><li>Симметричный ключ</li><li>Одинаковый ключ для подписи и проверки</li><li>Проще, но ключ должен быть на всех серверах</li></ul><p><strong>RS256 (RSA):</strong></p><ul><li>Асимметричные ключи</li><li>Приватный ключ для подписи, публичный для проверки</li><li>Безопаснее для distributed систем</li><li>Authorization server — приватный, Resource servers — публичный</li></ul><p><em>Совет:</em> Используйте JWT для access tokens (короткоживущие), opaque tokens для refresh tokens (долгоживущие, нужен отзыв).</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'JWT', 'токены', 'access token', 'безопасность']
  },
  {
    id: 86,
    question: "Какие security риски существуют при использовании OAuth и как их минимизировать?",
    answer: "<p>OAuth 2.0 имеет несколько <strong>известных векторов атак</strong>, требующих защиты:</p><h4>1. Authorization Code Interception:</h4><p><strong>Атака:</strong></p><ul><li>Злоумышленник перехватывает authorization code из redirect</li><li>Обменивает его на токены раньше легитимного клиента</li><li>Особенно опасно для mobile apps</li></ul><p><strong>Защита:</strong></p><ul><li>PKCE для всех публичных клиентов (обязательно)</li><li>Короткое время жизни authorization code (1-2 минуты)</li><li>Одноразовые коды (использовать можно только раз)</li><li>Привязка кода к client_id</li></ul><h4>2. Redirect URI Manipulation:</h4><p><strong>Атака:</strong></p><ul><li>Подмена redirect_uri для отправки кода на вредоносный сайт</li><li>Open redirect vulnerabilities</li></ul><p><strong>Защита:</strong></p><ul><li>Strict whitelist зарегистрированных redirect URIs</li><li>Точное совпадение, не prefix matching</li><li>Запрет localhost в production</li><li>Валидация redirect_uri на каждом шаге</li></ul><h4>3. CSRF на Authorization Endpoint:</h4><p><strong>Атака:</strong></p><ul><li>Злоумышленник инициирует OAuth flow от имени жертвы</li><li>Жертва авторизует доступ к аккаунту злоумышленника</li><li>Привязка аккаунтов</li></ul><p><strong>Защита:</strong></p><ul><li>State parameter (обязательно)</li><li>Криптографически случайное значение</li><li>Валидация state в callback</li><li>Привязка к session пользователя</li></ul><h4>4. Token Leakage:</h4><p><strong>Атака:</strong></p><ul><li>Токены попадают в логи, URL, referer headers</li><li>Хранятся небезопасно (localStorage)</li><li>Передаются по HTTP вместо HTTPS</li></ul><p><strong>Защита:</strong></p><ul><li>Только HTTPS (обязательно)</li><li>Токены в headers, не в URL</li><li>HttpOnly cookies для чувствительных токенов</li><li>Не логировать токены</li><li>Короткое время жизни</li></ul><h4>5. Token Substitution:</h4><p><strong>Атака:</strong></p><ul><li>Злоумышленник подменяет токен другого пользователя</li><li>Получает доступ к чужим ресурсам</li></ul><p><strong>Защита:</strong></p><ul><li>Валидация aud (audience) claim в токене</li><li>Проверка sub (subject) соответствует пользователю</li><li>Привязка токена к клиенту</li></ul><h4>6. Refresh Token Theft:</h4><p><strong>Атака:</strong></p><ul><li>Кража долгоживущего refresh token</li><li>Неограниченный доступ к аккаунту</li></ul><p><strong>Защита:</strong></p><ul><li>Refresh Token Rotation (обязательно)</li><li>Обнаружение повторного использования старого токена</li><li>Отзыв всей token family при подозрении</li><li>Привязка к device/IP (опционально)</li></ul><h4>7. Phishing и Social Engineering:</h4><p><strong>Атака:</strong></p><ul><li>Поддельные consent screens</li><li>Вредоносные приложения маскируются под доверенные</li></ul><p><strong>Защита:</strong></p><ul><li>Четкий брендинг authorization server</li><li>Понятные описания scopes</li><li>Верификация клиентов (для public apps)</li><li>User education</li></ul><h4>8. Scope Manipulation:</h4><p><strong>Атака:</strong></p><ul><li>Клиент запрашивает больше scopes чем нужно</li><li>Пользователь не понимает последствия</li></ul><p><strong>Защита:</strong></p><ul><li>Принцип наименьших привилегий</li><li>Понятные описания scopes</li><li>Регулярный аудит запрашиваемых scopes</li><li>Динамический consent только для необходимых scopes</li></ul><h4>9. Client Impersonation:</h4><p><strong>Атака:</strong></p><ul><li>Вредоносное приложение использует client_id легитимного</li><li>Пользователи доверяют знакомому имени</li></ul><p><strong>Защита:</strong></p><ul><li>Client authentication для confidential clients</li><li>PKCE для public clients</li><li>Верификация redirect_uri</li><li>App attestation для mobile</li></ul><h4>10. Mix-Up Attack:</h4><p><strong>Атака:</strong></p><ul><li>Клиент работает с несколькими authorization servers</li><li>Токен от одного AS используется с другим</li></ul><p><strong>Защита:</strong></p><ul><li>Валидация iss (issuer) claim</li><li>Привязка AS к state параметру</li><li>Проверка соответствия AS и redirect</li></ul><h4>Security Checklist:</h4><ul><li>☑ PKCE для всех flows</li><li>☑ State parameter всегда</li><li>☑ Strict redirect URI validation</li><li>☑ HTTPS только</li><li>☑ Короткие access tokens</li><li>☑ Refresh token rotation</li><li>☑ HttpOnly cookies где возможно</li><li>☑ Валидация всех JWT claims</li><li>☑ Rate limiting на endpoints</li><li>☑ Логирование и мониторинг</li><li>☑ Регулярные security аудиты</li></ul><p><em>Принцип:</em> OAuth безопасен только при правильной реализации. Следуйте best practices, используйте проверенные библиотеки, регулярно обновляйте.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'безопасность', 'атаки', 'уязвимости', 'защита']
  },
  {
    id: 87,
    question: "Как реализовать logout/revocation в OAuth 2.0? Какие существуют подходы?",
    answer: "<p>Logout и revocation токенов в OAuth 2.0 — это <strong>нетривиальная задача</strong> из-за stateless природы протокола:</p><h4>Типы logout:</h4><h4>1. Application-level Logout:</h4><p><strong>Что происходит:</strong></p><ul><li>Приложение удаляет токены локально</li><li>Очищает localStorage/cookies</li><li>Удаляет in-memory токены</li><li>Редирект на страницу логина</li></ul><p><strong>Проблема:</strong></p><ul><li>Токены остаются валидными</li><li>Если кто-то скопировал токен — все еще работает</li><li>Другие приложения с теми же токенами продолжат работать</li></ul><p><strong>Когда достаточно:</strong></p><ul><li>Короткоживущие access tokens</li><li>Низкие security требования</li><li>Single application scenario</li></ul><h4>2. Token Revocation (RFC 7009):</h4><p><strong>Как работает:</strong></p><ul><li>Приложение вызывает revocation endpoint</li><li>Отправляет токен для отзыва</li><li>Authorization server инвалидирует токен</li><li>Также отзывает связанные токены (refresh, access)</li></ul><p><strong>Endpoint:</strong></p><ul><li>POST /oauth/revoke</li><li>Параметры: token, token_type_hint</li><li>Требует client authentication</li></ul><p><strong>Особенности:</strong></p><ul><li>Работает только для opaque tokens</li><li>JWT токены сложнее отозвать (stateless)</li><li>Может потребоваться время для propagation</li></ul><h4>3. Token Introspection + Blacklist:</h4><p><strong>Для JWT токенов:</strong></p><ul><li>Resource server проверяет токен через introspection endpoint</li><li>Authorization server поддерживает blacklist отозванных токенов</li><li>Проверка при каждом запросе</li></ul><p><strong>Недостатки:</strong></p><ul><li>Теряется stateless преимущество JWT</li><li>Дополнительная latency</li><li>Нагрузка на authorization server</li></ul><h4>4. Back-Channel Logout (OpenID Connect):</h4><p><strong>Как работает:</strong></p><ul><li>Authorization server уведомляет приложения о logout</li><li>Прямое server-to-server взаимодействие</li><li>Приложения инвалидируют локальные сессии</li></ul><p><strong>Требования:</strong></p><ul><li>Приложение регистрирует logout endpoint</li><li>Authorization server отправляет logout token (JWT)</li><li>Приложение валидирует и обрабатывает</li></ul><h4>5. Front-Channel Logout (OpenID Connect):</h4><p><strong>Как работает:</strong></p><ul><li>Authorization server возвращает HTML с iframes</li><li>Каждый iframe указывает на logout endpoint приложения</li><li>Браузер загружает все iframe</li><li>Приложения очищают cookies через Set-Cookie</li></ul><p><strong>Ограничения:</strong></p><ul><li>Зависит от cookies third-party</li><li>Блокируется современными браузерами</li><li>Не работает для SPA</li></ul><h4>6. Single Logout (SLO) с Session Management:</h4><p><strong>Для SSO scenarios:</strong></p><ul><li>Authorization server отслеживает все активные сессии</li><li>При logout пользователя — завершает все сессии</li><li>Уведомляет все приложения</li></ul><h4>Стратегии для разных типов токенов:</h4><h4>Opaque Tokens:</h4><p><strong>Простой подход:</strong></p><ul><li>Храните в Redis/БД</li><li>При revocation — удалите из store</li><li>Resource server проверяет существование</li></ul><h4>JWT Tokens:</h4><p><strong>Вариант 1: Короткое время жизни</strong></p><ul><li>5-15 минут exp</li><li>Ждем истечения вместо revocation</li><li>Приемлемо для многих use cases</li></ul><p><strong>Вариант 2: Blacklist с TTL</strong></p><ul><li>Blacklist отозванных токенов</li><li>TTL = оставшееся время до exp</li><li>Проверка при каждом запросе</li></ul><p><strong>Вариант 3: Token versioning</strong></p><ul><li>Версия токена в payload</li><li>При revocation — инкремент версии пользователя</li><li>Токены со старой версией недействительны</li></ul><h4>Практические рекомендации:</h4><p><strong>Для веб-приложений:</strong></p><ul><li>Короткоживущие access tokens в memory</li><li>Refresh token в HttpOnly cookie</li><li>Revocation через Token Revocation endpoint</li><li>Local logout + token revocation</li></ul><p><strong>Для SPA:</strong></p><ul><li>Authorization Code + PKCE</li><li>Access tokens in memory (короткие)</li><li>Refresh token rotation</li><li>Local logout достаточно если токены короткие</li></ul><p><strong>Для mobile:</strong></p><ul><li>Secure storage для refresh tokens</li><li>Token revocation при logout</li><li>Опционально: device binding</li></ul><p><strong>Для enterprise SSO:</strong></p><ul><li>Back-Channel Logout обязательно</li><li>Session Management</li><li>Централизованное управление сессиями</li></ul><h4>Logout flow example:</h4><ol><li>Пользователь нажимает Logout</li><li>Приложение вызывает /oauth/revoke для refresh token</li><li>Удаляет все токены локально</li><li>Редирект на Authorization Server logout endpoint</li><li>Authorization Server завершает SSO session</li><li>Back-channel уведомления другим приложениям</li><li>Redirect обратно или на landing page</li></ol><p><em>Важно:</em> Полный logout — сложная проблема. Для большинства случаев комбинация короткоживущих токенов + token revocation дает достаточную безопасность.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'logout', 'revocation', 'session management']
  },
  {
    id: 88,
    question: "Как OAuth используется в microservices архитектуре? Какие паттерны существуют?",
    answer: "<p>OAuth в microservices требует <strong>специальных архитектурных паттернов</strong> для безопасного взаимодействия:</p><h4>Основные вызовы:</h4><ul><li>Множество сервисов, требующих авторизации</li><li>Service-to-service коммуникация</li><li>Распределенная природа токенов</li><li>Управление секретами</li><li>Прозрачность для пользователя</li></ul><h4>Паттерн 1: API Gateway + OAuth</h4><p><strong>Архитектура:</strong></p><ul><li>API Gateway — единая точка входа</li><li>Gateway валидирует токены</li><li>Внутренние сервисы доверяют Gateway</li><li>Возможна трансформация токенов</li></ul><p><strong>Процесс:</strong></p><ol><li>Клиент получает токен от Authorization Server</li><li>Отправляет запрос с токеном на Gateway</li><li>Gateway валидирует токен (JWT signature или introspection)</li><li>Извлекает user info и scopes</li><li>Добавляет headers с user context</li><li>Проксирует к внутренним сервисам</li><li>Сервисы доверяют headers от Gateway</li></ol><p><strong>Преимущества:</strong></p><ul><li>Централизованная валидация</li><li>Внутренние сервисы упрощены</li><li>Единая точка для security политик</li></ul><p><strong>Недостатки:</strong></p><ul><li>Single point of failure</li><li>Потенциальный bottleneck</li><li>Сервисы полностью доверяют Gateway</li></ul><h4>Паттерн 2: Token Propagation</h4><p><strong>Архитектура:</strong></p><ul><li>Каждый сервис валидирует токен независимо</li><li>Токен передается по всей цепочке вызовов</li><li>Distributed token validation</li></ul><p><strong>Процесс:</strong></p><ol><li>Клиент отправляет запрос с access token</li><li>Service A валидирует токен</li><li>Service A вызывает Service B, передавая тот же токен</li><li>Service B валидирует токен</li><li>И так далее по цепочке</li></ol><p><strong>Преимущества:</strong></p><ul><li>Нет single point of failure</li><li>Каждый сервис независимо проверяет права</li><li>Лучшая fault tolerance</li></ul><p><strong>Недостатки:</strong></p><ul><li>Дублирование валидации</li><li>Каждый сервис должен понимать OAuth</li><li>Сложнее управление</li></ul><h4>Паттерн 3: Token Exchange (RFC 8693)</h4><p><strong>Архитектура:</strong></p><ul><li>Сервисы обменивают токены на новые</li><li>Каждый сервис получает токен со своим audience</li><li>Более гранулярный контроль</li></ul><p><strong>Процесс:</strong></p><ol><li>Service A получает user token</li><li>Нужно вызвать Service B</li><li>Service A обменивает token на новый для Service B</li><li>Новый токен с aud=service-b</li><li>Service A вызывает Service B с новым токеном</li></ol><p><strong>Преимущества:</strong></p><ul><li>Принцип наименьших привилегий</li><li>Каждый токен для конкретного сервиса</li><li>Лучшая безопасность</li></ul><p><strong>Недостатки:</strong></p><ul><li>Дополнительные запросы к Authorization Server</li><li>Сложность реализации</li><li>Latency overhead</li></ul><h4>Паттерн 4: Service Mesh + mTLS</h4><p><strong>Архитектура:</strong></p><ul><li>OAuth для north-south трафика (клиент → API)</li><li>mTLS для east-west трафика (сервис → сервис)</li><li>Service identity через сертификаты</li></ul><p><strong>Процесс:</strong></p><ol><li>Gateway валидирует OAuth токен</li><li>Извлекает user identity</li><li>Внутри mesh — mTLS для service authentication</li><li>User context передается через headers</li></ol><p><strong>Преимущества:</strong></p><ul><li>Разделение user и service authentication</li><li>Высокая производительность внутри mesh</li><li>Сильная service identity</li></ul><h4>Паттерн 5: Backend for Frontend (BFF)</h4><p><strong>Архитектура:</strong></p><ul><li>Каждый UI имеет свой backend</li><li>BFF управляет OAuth flow</li><li>BFF вызывает микросервисы</li><li>UI не работает с токенами напрямую</li></ul><p><strong>Преимущества:</strong></p><ul><li>Токены не попадают в browser/mobile</li><li>Максимальная безопасность</li><li>Гибкость для каждого UI</li></ul><h4>Client Credentials для Service-to-Service:</h4><p><strong>Когда сервис вызывает другой сервис:</strong></p><ul><li>Используйте Client Credentials Grant</li><li>Service A аутентифицируется как клиент</li><li>Получает токен для вызова Service B</li><li>Нет user context (machine-to-machine)</li></ul><h4>Управление секретами:</h4><ul><li>Client secrets в secret managers (Vault, AWS Secrets Manager)</li><li>Ротация секретов</li><li>Избегайте hardcoded credentials</li><li>Environment-specific secrets</li></ul><h4>Best Practices для Microservices:</h4><ul><li>Используйте JWT для stateless валидации</li><li>Короткое время жизни токенов</li><li>Audience claim для каждого сервиса</li><li>Scope-based authorization</li><li>Централизованный Authorization Server</li><li>Consistent token validation</li><li>Proper error handling и fallbacks</li><li>Monitoring и audit logging</li></ul><h4>Рекомендации по выбору:</h4><p><strong>Простые архитектуры:</strong> API Gateway + Token Propagation</p><p><strong>High-security:</strong> Token Exchange + Service Mesh</p><p><strong>Enterprise:</strong> BFF + Client Credentials + mTLS</p><p><em>Главное:</em> Баланс между безопасностью, производительностью и сложностью. Начните проще, усложняйте по необходимости.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'microservices', 'архитектура', 'паттерны', 'security']
  },
  {
    id: 89,
    question: "Какие популярные библиотеки и инструменты существуют для работы с OAuth?",
    answer: "<p>Экосистема OAuth имеет множество <strong>проверенных библиотек и инструментов</strong> для разных платформ:</p><h4>Authorization Servers (OpenID Providers):</h4><h4>1. Open Source:</h4><p><strong>Keycloak:</strong></p><ul><li>Полнофункциональный Identity и Access Management</li><li>OAuth 2.0, OIDC, SAML</li><li>User Federation, Social Login</li><li>Отлично для enterprise и self-hosted</li><li>Java/WildFly based</li></ul><p><strong>ORY Hydra:</strong></p><ul><li>OAuth 2.0 и OIDC certified</li><li>Cloud native, API-first</li><li>Написан на Go, высокая производительность</li><li>Подходит для microservices</li></ul><p><strong>Authelia:</strong></p><ul><li>Self-hosted SSO и 2FA</li><li>Легковесный</li><li>Отлично для home lab и small deployments</li></ul><h4>2. Managed Services:</h4><p><strong>Auth0:</strong></p><ul><li>Полностью managed решение</li><li>Простая интеграция</li><li>Rich ecosystem</li><li>Платно, но проще в поддержке</li></ul><p><strong>Okta:</strong></p><ul><li>Enterprise-grade</li><li>OIDC, SAML, MFA</li><li>Отлично для крупных организаций</li></ul><p><strong>AWS Cognito:</strong></p><ul><li>Интеграция с AWS ecosystem</li><li>User pools для authentication</li><li>Identity pools для authorization</li></ul><p><strong>Firebase Authentication:</strong></p><ul><li>Простота для mobile и web</li><li>Social providers из коробки</li><li>Интеграция с Google Cloud</li></ul><h4>Client Libraries по языкам:</h4><h4>JavaScript/TypeScript:</h4><p><strong>oauth4webapi:</strong></p><ul><li>Современная, spec-compliant библиотека</li><li>Поддержка всех актуальных flows</li><li>TypeScript first</li></ul><p><strong>oidc-client-ts:</strong></p><ul><li>OIDC для SPA</li><li>Silent refresh, session management</li><li>Популярна для React/Vue/Angular</li></ul><p><strong>next-auth:</strong></p><ul><li>Для Next.js приложений</li><li>OAuth, OIDC, credentials</li><li>Built-in providers</li></ul><p><strong>Passport.js:</strong></p><ul><li>Для Node.js/Express</li><li>Множество стратегий (OAuth, OIDC, local)</li><li>Гибкая, но устаревший API</li></ul><h4>Python:</h4><p><strong>Authlib:</strong></p><ul><li>Полная имплементация OAuth 1.0, 2.0, OIDC</li><li>Client и server стороны</li><li>Flask и Django интеграция</li></ul><p><strong>python-jose:</strong></p><ul><li>JWT и JWS для Python</li><li>Валидация токенов</li></ul><p><strong>requests-oauthlib:</strong></p><ul><li>OAuth для requests библиотеки</li><li>Простой API</li></ul><h4>Java/Kotlin:</h4><p><strong>Spring Security OAuth:</strong></p><ul><li>Интеграция с Spring ecosystem</li><li>Authorization Server и Resource Server</li><li>Устаревает, переходит на Spring Authorization Server</li></ul><p><strong>Nimbus OAuth SDK:</strong></p><ul><li>Низкоуровневая библиотека</li><li>JWT, JWS, JWE</li><li>Полная спецификация</li></ul><h4>.NET:</h4><p><strong>IdentityServer:</strong></p><ul><li>OIDC и OAuth 2.0 framework</li><li>Certified implementation</li><li>Enterprise-ready</li></ul><p><strong>Microsoft.Identity.Web:</strong></p><ul><li>Для ASP.NET Core</li><li>Интеграция с Azure AD</li><li>MSAL под капотом</li></ul><h4>Mobile:</h4><p><strong>AppAuth (iOS/Android):</strong></p><ul><li>Официальная библиотека от IETF</li><li>Best practices из коробки</li><li>PKCE, system browser</li></ul><p><strong>React Native AppAuth:</strong></p><ul><li>Wrapper для React Native</li><li>Native модули</li></ul><h4>Инструменты для разработки и тестирования:</h4><h4>1. OAuth Debuggers:</h4><p><strong>oauth.tools:</strong></p><ul><li>Онлайн playground</li><li>Визуализация flows</li><li>JWT decode/encode</li></ul><p><strong>jwt.io:</strong></p><ul><li>JWT декодер и валидатор</li><li>От Auth0</li><li>Очень популярный</li></ul><h4>2. Testing Tools:</h4><p><strong>Mockoon:</strong></p><ul><li>Mock OAuth endpoints</li><li>Для integration testing</li></ul><p><strong>Postman:</strong></p><ul><li>OAuth 2.0 flows в коллекциях</li><li>Автоматическое получение токенов</li></ul><h4>3. CLI Tools:</h4><p><strong>oauth2c:</strong></p><ul><li>OAuth 2.0 client для CLI</li><li>Тестирование endpoints</li></ul><h4>API Gateway с OAuth:</h4><p><strong>Kong:</strong></p><ul><li>OAuth 2.0 plugin</li><li>JWT validation</li><li>Rate limiting по токенам</li></ul><p><strong>Traefik:</strong></p><ul><li>Forward auth middleware</li><li>Интеграция с OAuth providers</li></ul><p><strong>Nginx:</strong></p><ul><li>oauth2-proxy</li><li>JWT verification module</li></ul><h4>Выбор библиотеки — рекомендации:</h4><p><strong>Для SPA:</strong></p><ul><li>oidc-client-ts или oauth4webapi</li><li>next-auth для Next.js</li></ul><p><strong>Для Backend:</strong></p><ul><li>Passport.js (Node.js)</li><li>Authlib (Python)</li><li>Spring Security (Java)</li></ul><p><strong>Для Mobile:</strong></p><ul><li>AppAuth нативные библиотеки</li><li>React Native AppAuth</li></ul><p><strong>Authorization Server:</strong></p><ul><li>Managed: Auth0, Okta</li><li>Self-hosted: Keycloak, ORY Hydra</li></ul><p><em>Важно:</em> Используйте зрелые, активно поддерживаемые библиотеки. OAuth сложен, не пишите с нуля без необходимости. Проверяйте актуальность библиотек — OAuth спецификации обновляются.</p>",
    difficulty: 'middle',
    tags: ['OAuth', 'библиотеки', 'инструменты', 'ecosystem']
  },
  {
    id: 90,
    question: "Как правильно обрабатывать ошибки в OAuth flows? Какие типы ошибок существуют?",
    answer: "<p>OAuth 2.0 определяет <strong>стандартизированные коды ошибок</strong> и механизмы обработки для разных этапов:</p><h4>Типы ошибок в OAuth:</h4><h4>1. Authorization Errors (на redirect):</h4><p><strong>Возвращаются в redirect URI как query parameters:</strong></p><p><strong>access_denied:</strong></p><ul><li>Пользователь отказал в доступе</li><li>Нажал 'Cancel' на consent screen</li><li>Обработка: Показать пользователю понятное сообщение</li></ul><p><strong>invalid_request:</strong></p><ul><li>Отсутствует обязательный параметр</li><li>Неправильный формат запроса</li><li>Обработка: Проверить implementation клиента</li></ul><p><strong>unauthorized_client:</strong></p><ul><li>Клиент не авторизован использовать этот grant type</li><li>Неправильная конфигурация</li><li>Обработка: Проверить настройки клиента</li></ul><p><strong>unsupported_response_type:</strong></p><ul><li>Authorization server не поддерживает запрошенный response type</li><li>Обработка: Использовать поддерживаемый тип</li></ul><p><strong>invalid_scope:</strong></p><ul><li>Запрошенный scope недействителен или неизвестен</li><li>Обработка: Проверить доступные scopes</li></ul><p><strong>server_error:</strong></p><ul><li>Внутренняя ошибка сервера</li><li>Обработка: Retry с exponential backoff</li></ul><p><strong>temporarily_unavailable:</strong></p><ul><li>Сервер временно недоступен</li><li>Обработка: Retry позже</li></ul><h4>2. Token Endpoint Errors (в JSON response):</h4><p><strong>Формат ответа:</strong></p><ul><li>HTTP 400 Bad Request</li><li>JSON body: {\"error\": \"invalid_grant\", \"error_description\": \"...\"}</li></ul><p><strong>invalid_request:</strong></p><ul><li>Отсутствует параметр, неправильный формат</li></ul><p><strong>invalid_client:</strong></p><ul><li>Client authentication failed</li><li>Неправильный client_id или client_secret</li><li>Обработка: Проверить credentials</li></ul><p><strong>invalid_grant:</strong></p><ul><li>Authorization code недействителен, истек или уже использован</li><li>Refresh token отозван</li><li>Обработка: Перенаправить на authorization endpoint</li></ul><p><strong>unauthorized_client:</strong></p><ul><li>Клиент не авторизован для этого grant type</li></ul><p><strong>unsupported_grant_type:</strong></p><ul><li>Grant type не поддерживается</li></ul><h4>3. Resource Server Errors (при использовании access token):</h4><p><strong>HTTP 401 Unauthorized:</strong></p><ul><li>Access token отсутствует или недействителен</li><li>WWW-Authenticate header с деталями</li><li>Обработка: Обновить токен или переавторизоваться</li></ul><p><strong>HTTP 403 Forbidden:</strong></p><ul><li>Токен валиден, но недостаточно прав</li><li>Scope не разрешает операцию</li><li>Обработка: Запросить дополнительные scopes</li></ul><h4>Стратегии обработки ошибок:</h4><h4>1. Graceful Degradation:</h4><ul><li>access_denied → Предложить ограниченную функциональность</li><li>invalid_scope → Запросить минимальные scopes</li><li>Не блокировать полностью приложение</li></ul><h4>2. Automatic Retry:</h4><ul><li>server_error, temporarily_unavailable → Retry</li><li>Exponential backoff (1s, 2s, 4s, 8s...)</li><li>Максимальное количество попыток</li></ul><h4>3. Token Refresh Flow:</h4><ul><li>401 Unauthorized → Попытка refresh</li><li>Если refresh fails → Redirect на login</li><li>Прозрачно для пользователя</li></ul><h4>4. User-Friendly Messages:</h4><ul><li>Не показывать технические детали</li><li>'access_denied' → 'You cancelled the login'</li><li>'invalid_grant' → 'Session expired, please login again'</li></ul><h4>Обработка edge cases:</h4><h4>1. State Mismatch:</h4><ul><li>State в callback не совпадает с отправленным</li><li>Возможна CSRF атака</li><li>Обработка: Отклонить и логировать</li></ul><h4>2. Missing Authorization Code:</h4><ul><li>Redirect без кода и без ошибки</li><li>Возможно вмешательство в redirect</li><li>Обработка: Показать ошибку, не продолжать flow</li></ul><h4>3. PKCE Verification Failed:</h4><ul><li>code_verifier не соответствует code_challenge</li><li>Возможна атака</li><li>Обработка: Отклонить и логировать</li></ul><h4>Логирование и мониторинг:</h4><p><strong>Что логировать:</strong></p><ul><li>Тип ошибки и error_description</li><li>Timestamp и user_id (если доступен)</li><li>Client_id и flow type</li><li>НЕ логировать токены и секреты</li></ul><p><strong>Метрики для мониторинга:</strong></p><ul><li>Частота каждого типа ошибки</li><li>Success rate авторизации</li><li>Token refresh failures</li><li>Всплески определенных ошибок (может быть атака)</li></ul><h4>Error Recovery Flows:</h4><p><strong>Полная переавторизация:</strong></p><ol><li>Обнаружение невосстановимой ошибки</li><li>Очистка всех токенов</li><li>Сохранение intended destination</li><li>Redirect на authorization endpoint</li><li>После успеха — redirect на intended destination</li></ol><p><strong>Silent Token Refresh:</strong></p><ol><li>401 на API запросе</li><li>Попытка refresh token в фоне</li><li>Если успех → retry оригинального запроса</li><li>Если fail → переавторизация</li></ol><h4>Best Practices:</h4><ul><li>Всегда валидируйте state parameter</li><li>Логируйте все OAuth ошибки</li><li>Используйте user-friendly сообщения</li><li>Имейте fallback механизмы</li><li>Тестируйте все error scenarios</li><li>Мониторьте аномалии в ошибках</li><li>Документируйте handling каждой ошибки</li><li>Graceful fallback для non-critical features</li></ul><p><em>Важно:</em> Хорошая обработка ошибок — это разница между frustrating и smooth user experience. Тестируйте error paths так же тщательно, как happy path.</p>",
    difficulty: 'senior',
    tags: ['OAuth', 'ошибки', 'обработка ошибок', 'error handling']
  }
];
