export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 106,
    question: "Что такое Core Web Vitals и почему они важны?",
    answer: "<p><strong>Core Web Vitals</strong> — это набор метрик производительности, которые Google использует для оценки пользовательского опыта на веб-страницах и влияют на SEO-рейтинг.</p><p><strong>Три основные метрики:</strong></p><ul><li><strong>LCP (Largest Contentful Paint)</strong> — скорость загрузки основного контента</li><li><strong>FID (First Input Delay)</strong> — время отклика на первое взаимодействие пользователя</li><li><strong>CLS (Cumulative Layout Shift)</strong> — визуальная стабильность страницы</li></ul><p><strong>Почему важны:</strong></p><ul><li>Напрямую влияют на ранжирование в поисковой выдаче Google</li><li>Отражают реальный опыт пользователей</li><li>Коррелируют с бизнес-метриками (конверсия, отказы)</li><li>Измеряются на реальных устройствах пользователей</li></ul><p>Core Web Vitals — это мост между техническими метриками и бизнес-результатами, помогающий понять, где именно страница теряет пользователей.</p>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'производительность', 'SEO', 'метрики']
  },
  {
    id: 107,
    question: "Что измеряет LCP (Largest Contentful Paint) и какие значения считаются хорошими?",
    answer: "<p><strong>LCP</strong> измеряет время, за которое самый большой видимый элемент контента появляется в области просмотра.</p><p><strong>Что считается за LCP:</strong></p><ul><li>Изображения (img, picture, svg)</li><li>Видео с постером</li><li>Фоновые изображения через CSS</li><li>Блоки текста (параграфы, заголовки)</li></ul><p><strong>Целевые показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 2.5 секунд</li><li><strong>Требует улучшения:</strong> 2.5-4 секунды</li><li><strong>Плохо:</strong> более 4 секунд</li></ul><p><strong>Почему важен:</strong></p><ul><li>Показывает, когда пользователь видит основной контент</li><li>Отражает воспринимаемую скорость загрузки</li><li>Прямо влияет на первое впечатление</li><li>Коррелирует с показателем отказов</li></ul><p>LCP — это не просто техническая метрика, это момент, когда пользователь получает ценность от вашей страницы.</p>",
    difficulty: 'middle',
    tags: ['LCP', 'Web Vitals', 'производительность', 'загрузка']
  },
  {
    id: 108,
    question: "Какие факторы влияют на LCP и как его оптимизировать?",
    answer: "<p><strong>Основные факторы, влияющие на LCP:</strong></p><p><strong>1. Медленный сервер:</strong></p><ul><li>Долгий TTFB (Time to First Byte)</li><li>Неоптимизированный серверный рендеринг</li><li>Отсутствие CDN</li></ul><p><strong>2. Блокирующие ресурсы:</strong></p><ul><li>Render-blocking CSS и JavaScript</li><li>Большие файлы стилей</li><li>Синхронные скрипты в head</li></ul><p><strong>3. Медленная загрузка ресурсов:</strong></p><ul><li>Большие несжатые изображения</li><li>Неоптимальные форматы</li><li>Отсутствие кэширования</li></ul><p><strong>4. Клиентский рендеринг:</strong></p><ul><li>JavaScript-heavy приложения</li><li>Отсутствие SSR/SSG</li><li>Большие бандлы</li></ul><p><strong>Стратегии оптимизации:</strong></p><ul><li>Использовать современные форматы изображений (WebP, AVIF)</li><li>Применять preload для критических ресурсов</li><li>Оптимизировать серверное время ответа</li><li>Минимизировать render-blocking ресурсы</li><li>Использовать CDN для статики</li><li>Внедрить code splitting и lazy loading</li></ul>",
    difficulty: 'senior',
    tags: ['LCP', 'оптимизация', 'производительность', 'Web Vitals']
  },
  {
    id: 109,
    question: "Объясните FID (First Input Delay) и его связь с INP",
    answer: "<p><strong>FID (First Input Delay)</strong> измеряет время между первым взаимодействием пользователя со страницей и моментом, когда браузер может обработать это взаимодействие.</p><p><strong>Что измеряет FID:</strong></p><ul><li>Клики по кнопкам и ссылкам</li><li>Нажатия клавиш в формах</li><li>Выбор элементов в dropdown</li><li>Не измеряет: скроллинг, зум, hover</li></ul><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 100 мс</li><li><strong>Требует улучшения:</strong> 100-300 мс</li><li><strong>Плохо:</strong> более 300 мс</li></ul><p><strong>INP (Interaction to Next Paint):</strong></p><p>Новая метрика, которая заменяет FID. INP измеряет <em>все</em> взаимодействия на странице, а не только первое, и отслеживает полный цикл до отрисовки результата.</p><p><strong>Ключевые различия:</strong></p><ul><li>FID — только первое взаимодействие, INP — все взаимодействия</li><li>FID — до начала обработки, INP — до визуального отклика</li><li>INP более полно отражает интерактивность страницы</li></ul>",
    difficulty: 'middle',
    tags: ['FID', 'INP', 'интерактивность', 'Web Vitals']
  },
  {
    id: 110,
    question: "Как улучшить FID и что вызывает длительные задержки?",
    answer: "<p><strong>Основные причины плохого FID:</strong></p><p><strong>1. Долгие JavaScript-задачи:</strong></p><ul><li>Тяжелые вычисления блокируют главный поток</li><li>Парсинг и выполнение больших скриптов</li><li>Синхронные операции</li></ul><p><strong>2. Блокировка главного потока:</strong></p><ul><li>Обработка событий занимает много времени</li><li>Layout thrashing</li><li>Принудительные reflow</li></ul><p><strong>3. Большие бандлы JavaScript:</strong></p><ul><li>Долгий парсинг и компиляция</li><li>Много неиспользуемого кода</li><li>Отсутствие code splitting</li></ul><p><strong>Методы улучшения:</strong></p><ul><li><strong>Разбивайте длинные задачи:</strong> используйте requestIdleCallback, web workers</li><li><strong>Оптимизируйте JavaScript:</strong> code splitting, tree shaking, defer/async</li><li><strong>Минимизируйте сторонние скрипты:</strong> особенно analytics и widgets</li><li><strong>Используйте web workers:</strong> для тяжелых вычислений</li><li><strong>Оптимизируйте event handlers:</strong> debounce, throttle, passive listeners</li></ul><p>Главный принцип: освобождайте главный поток для быстрой реакции на действия пользователя.</p>",
    difficulty: 'senior',
    tags: ['FID', 'оптимизация', 'JavaScript', 'производительность']
  },
  {
    id: 111,
    question: "Что такое CLS (Cumulative Layout Shift) и как он рассчитывается?",
    answer: "<p><strong>CLS</strong> измеряет визуальную стабильность страницы, суммируя все неожиданные смещения контента во время загрузки.</p><p><strong>Как рассчитывается:</strong></p><p>CLS = Impact Fraction × Distance Fraction</p><ul><li><strong>Impact Fraction</strong> — какая часть viewport затронута смещением</li><li><strong>Distance Fraction</strong> — на какое расстояние сместился элемент</li></ul><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 0.1</li><li><strong>Требует улучшения:</strong> 0.1-0.25</li><li><strong>Плохо:</strong> более 0.25</li></ul><p><strong>Когда происходят смещения:</strong></p><ul><li>Изображения без размеров загружаются</li><li>Динамический контент добавляется сверху</li><li>Веб-шрифты загружаются (FOUT)</li><li>Баннеры и виджеты появляются неожиданно</li><li>Анимации изменяют размеры элементов</li></ul><p><strong>Пользовательский опыт:</strong></p><p>Плохой CLS раздражает пользователей — они нажимают на кнопку, но в последний момент контент смещается и клик попадает не туда. Это особенно критично для мобильных устройств.</p>",
    difficulty: 'middle',
    tags: ['CLS', 'Web Vitals', 'layout shift', 'визуальная стабильность']
  },
  {
    id: 112,
    question: "Какие техники помогают избежать layout shifts?",
    answer: "<p><strong>Превентивные меры для стабильного макета:</strong></p><p><strong>1. Резервирование места для изображений:</strong></p><ul><li>Всегда указывайте width и height атрибуты</li><li>Используйте aspect-ratio в CSS</li><li>Применяйте placeholder'ы с правильными пропорциями</li></ul><p><strong>2. Резервирование места для рекламы:</strong></p><ul><li>Создавайте контейнеры фиксированного размера</li><li>Используйте min-height для блоков</li><li>Показывайте placeholder до загрузки</li></ul><p><strong>3. Управление шрифтами:</strong></p><ul><li>Используйте font-display: optional или swap</li><li>Preload критичных шрифтов</li><li>Подбирайте fallback-шрифты с похожими метриками</li><li>Применяйте size-adjust для выравнивания размеров</li></ul><p><strong>4. Динамический контент:</strong></p><ul><li>Добавляйте новый контент снизу или по клику</li><li>Используйте transform вместо изменения размеров</li><li>Анимируйте через CSS transitions, а не изменение layout</li></ul><p><strong>5. Embeds и iframes:</strong></p><ul><li>Устанавливайте размеры заранее</li><li>Используйте aspect-ratio</li><li>Применяйте contain: layout для изоляции</li></ul><p>Золотое правило: никогда не вставляйте контент выше существующего без взаимодействия пользователя.</p>",
    difficulty: 'senior',
    tags: ['CLS', 'оптимизация', 'layout', 'стабильность']
  },
  {
    id: 113,
    question: "Что такое TTFB и как он влияет на Core Web Vitals?",
    answer: "<p><strong>TTFB (Time to First Byte)</strong> — это время от начала запроса страницы до получения первого байта ответа от сервера.</p><p><strong>Компоненты TTFB:</strong></p><ul><li>Время DNS lookup</li><li>Время установки соединения</li><li>TLS handshake (для HTTPS)</li><li>Время обработки на сервере</li></ul><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 800 мс</li><li><strong>Требует улучшения:</strong> 800-1800 мс</li><li><strong>Плохо:</strong> более 1800 мс</li></ul><p><strong>Влияние на Core Web Vitals:</strong></p><ul><li><strong>На LCP:</strong> медленный TTFB задерживает начало загрузки ресурсов</li><li><strong>На FID:</strong> косвенно — если страница долго грузится, JavaScript загружается позже</li><li><strong>На CLS:</strong> медленная загрузка может увеличить вероятность layout shifts</li></ul><p><strong>Оптимизация TTFB:</strong></p><ul><li>Использовать CDN для статического контента</li><li>Оптимизировать серверную обработку</li><li>Внедрить кэширование на разных уровнях</li><li>Использовать HTTP/2 или HTTP/3</li><li>Минимизировать редиректы</li></ul><p>TTFB — это фундамент: если сервер отвечает медленно, все остальные оптимизации теряют эффективность.</p>",
    difficulty: 'middle',
    tags: ['TTFB', 'производительность', 'серверная оптимизация', 'Web Vitals']
  },
  {
    id: 114,
    question: "Как измерять Web Vitals в реальных условиях?",
    answer: "<p><strong>Два подхода к измерению:</strong></p><p><strong>Lab Data (синтетические данные):</strong></p><ul><li><strong>Lighthouse:</strong> в Chrome DevTools или CI/CD</li><li><strong>WebPageTest:</strong> детальный анализ с разных локаций</li><li><strong>Chrome UX Report:</strong> агрегированные данные от реальных пользователей</li></ul><p><strong>Преимущества lab data:</strong> контролируемые условия, воспроизводимость, детальная диагностика</p><p><strong>Недостатки:</strong> не отражают реальный опыт пользователей</p><p><strong>Field Data (реальные пользователи):</strong></p><ul><li><strong>Web Vitals JavaScript library:</strong> для сбора метрик</li><li><strong>Google Analytics 4:</strong> автоматический сбор Web Vitals</li><li><strong>RUM (Real User Monitoring):</strong> специализированные сервисы</li><li><strong>Chrome User Experience Report:</strong> публичный датасет от Google</li></ul><p><strong>Преимущества field data:</strong> реальные устройства, сети, поведение пользователей</p><p><strong>Недостатки:</strong> сложнее диагностировать проблемы</p><p><strong>Лучшая практика:</strong></p><p>Используйте оба подхода — lab data для быстрой итерации и диагностики, field data для понимания реального опыта и приоритизации работы.</p>",
    difficulty: 'senior',
    tags: ['измерение', 'Web Vitals', 'мониторинг', 'инструменты']
  },
  {
    id: 115,
    question: "Что такое TBT (Total Blocking Time) и как он связан с FID?",
    answer: "<p><strong>TBT (Total Blocking Time)</strong> — это сумма всех периодов между FCP и TTI, когда главный поток был заблокирован достаточно долго, чтобы помешать отклику на ввод.</p><p><strong>Как рассчитывается:</strong></p><ul><li>Измеряется время между First Contentful Paint и Time to Interactive</li><li>Любая задача, занимающая более 50 мс, считается блокирующей</li><li>TBT = сумма времени выше 50 мс для всех длинных задач</li></ul><p><strong>Связь с FID:</strong></p><ul><li>TBT — это lab метрика, которая предсказывает FID</li><li>FID измеряет одно конкретное взаимодействие в реальности</li><li>Улучшение TBT обычно улучшает FID</li><li>TBT помогает диагностировать проблемы FID в lab условиях</li></ul><p><strong>Хорошие показатели TBT:</strong></p><ul><li><strong>Хорошо:</strong> менее 200 мс</li><li><strong>Требует улучшения:</strong> 200-600 мс</li><li><strong>Плохо:</strong> более 600 мс</li></ul><p><strong>Почему важен:</strong></p><p>TBT — это практичная метрика для разработки, потому что её легко измерить в Lighthouse, и она напрямую указывает на проблемы с JavaScript, которые будут влиять на интерактивность в продакшене.</p>",
    difficulty: 'middle',
    tags: ['TBT', 'FID', 'блокировка потока', 'lab metrics']
  },
  {
    id: 116,
    question: "Объясните концепцию Performance Budget и как её применять к Web Vitals",
    answer: "<p><strong>Performance Budget</strong> — это набор ограничений на метрики производительности, который команда обязуется не превышать.</p><p><strong>Типы бюджетов для Web Vitals:</strong></p><p><strong>1. Milestone-based:</strong></p><ul><li>LCP должен быть менее 2.5 секунд</li><li>FID менее 100 мс</li><li>CLS менее 0.1</li></ul><p><strong>2. Quantity-based:</strong></p><ul><li>Максимальный размер JavaScript: 300 KB</li><li>Максимальный размер изображений: 1 MB</li><li>Максимум 10 сторонних скриптов</li></ul><p><strong>3. Rule-based:</strong></p><ul><li>Все изображения должны иметь width/height</li><li>Критические ресурсы должны быть preloaded</li><li>Никакого render-blocking CSS</li></ul><p><strong>Внедрение в workflow:</strong></p><ul><li><strong>CI/CD интеграция:</strong> автоматические проверки при каждом PR</li><li><strong>Lighthouse CI:</strong> fail билда при превышении бюджетов</li><li><strong>Мониторинг:</strong> алерты при деградации метрик в продакшене</li><li><strong>Документация:</strong> четкие правила для всей команды</li></ul><p><strong>Преимущества:</strong></p><p>Performance Budget делает производительность измеримой целью, предотвращает регрессии и помогает команде принимать осознанные решения о trade-offs.</p>",
    difficulty: 'senior',
    tags: ['Performance Budget', 'Web Vitals', 'оптимизация', 'процессы']
  },
  {
    id: 117,
    question: "Как работает метрика INP и почему она заменяет FID?",
    answer: "<p><strong>INP (Interaction to Next Paint)</strong> — это метрика, которая измеряет общую отзывчивость страницы на взаимодействия пользователя в течение всего времени посещения.</p><p><strong>Ключевые отличия от FID:</strong></p><ul><li><strong>Все взаимодействия vs первое:</strong> INP учитывает все клики, нажатия клавиш, тапы, а FID только первое</li><li><strong>Полный цикл:</strong> INP измеряет от input до visual update, FID только до начала обработки</li><li><strong>Репрезентативность:</strong> INP берет p75 (75-й перцентиль) всех взаимодействий</li></ul><p><strong>Что измеряет INP:</strong></p><ol><li>Input delay — задержка до начала обработки</li><li>Processing time — время обработки event handler</li><li>Presentation delay — время до отрисовки результата</li></ol><p><strong>Хорошие показатели:</strong></p><ul><li><strong>Хорошо:</strong> менее 200 мс</li><li><strong>Требует улучшения:</strong> 200-500 мс</li><li><strong>Плохо:</strong> более 500 мс</li></ul><p><strong>Почему заменяет FID:</strong></p><ul><li>Более полно отражает интерактивность</li><li>Учитывает поведение после загрузки</li><li>Ловит проблемы с event handlers</li><li>Отражает весь пользовательский опыт</li></ul><p>INP — это эволюция метрик интерактивности, фокусирующаяся на общем опыте, а не на единичном моменте.</p>",
    difficulty: 'senior',
    tags: ['INP', 'FID', 'интерактивность', 'новые метрики']
  },
  {
    id: 118,
    question: "Какие инструменты помогают диагностировать проблемы с Web Vitals?",
    answer: "<p><strong>Браузерные инструменты:</strong></p><p><strong>Chrome DevTools:</strong></p><ul><li><strong>Lighthouse:</strong> комплексный аудит с рекомендациями</li><li><strong>Performance panel:</strong> детальная временная шкала загрузки</li><li><strong>Coverage:</strong> неиспользуемый CSS и JavaScript</li><li><strong>Network panel:</strong> анализ загрузки ресурсов</li></ul><p><strong>Онлайн-инструменты:</strong></p><ul><li><strong>PageSpeed Insights:</strong> lab и field data, рекомендации</li><li><strong>WebPageTest:</strong> детальный анализ водопада загрузки</li><li><strong>Chrome UX Report:</strong> агрегированные данные реальных пользователей</li></ul><p><strong>Библиотеки и мониторинг:</strong></p><ul><li><strong>web-vitals library:</strong> JavaScript библиотека от Google</li><li><strong>Sentry, DataDog, New Relic:</strong> RUM с Web Vitals</li><li><strong>Google Analytics 4:</strong> автоматический сбор метрик</li></ul><p><strong>CI/CD инструменты:</strong></p><ul><li><strong>Lighthouse CI:</strong> автоматизация проверок</li><li><strong>SpeedCurve:</strong> мониторинг регрессий</li><li><strong>Calibre:</strong> непрерывный мониторинг производительности</li></ul><p><strong>Диагностический workflow:</strong></p><ol><li>PageSpeed Insights — быстрая оценка</li><li>Lighthouse — детальный аудит</li><li>Performance panel — глубокая диагностика</li><li>Field data — валидация в реальности</li></ol>",
    difficulty: 'middle',
    tags: ['инструменты', 'диагностика', 'Web Vitals', 'DevTools']
  },
  {
    id: 119,
    question: "Как приоритизировать оптимизации Web Vitals?",
    answer: "<p><strong>Фреймворк приоритизации:</strong></p><p><strong>1. Анализ текущего состояния:</strong></p><ul><li>Соберите field data от реальных пользователей</li><li>Определите, какие метрики в красной зоне</li><li>Проанализируйте распределение по устройствам, регионам</li></ul><p><strong>2. Оценка влияния на бизнес:</strong></p><ul><li>Какие страницы генерируют больше конверсий?</li><li>Где пользователи чаще всего отваливаются?</li><li>Какие сегменты пользователей критичны?</li></ul><p><strong>3. Быстрые победы vs долгосрочные улучшения:</strong></p><p><strong>Быстрые победы (low-hanging fruit):</strong></p><ul><li>Добавить width/height к изображениям (CLS)</li><li>Оптимизировать изображения (LCP)</li><li>Добавить preload для критических ресурсов (LCP)</li><li>Отложить сторонние скрипты (FID/INP)</li></ul><p><strong>Долгосрочные:</strong></p><ul><li>Внедрить SSR/SSG</li><li>Рефакторинг архитектуры JavaScript</li><li>Миграция на CDN</li><li>Оптимизация бэкенда</li></ul><p><strong>4. ICE-скоринг:</strong></p><ul><li><strong>Impact:</strong> насколько улучшится метрика</li><li><strong>Confidence:</strong> уверенность в результате</li><li><strong>Ease:</strong> простота реализации</li></ul><p>Начинайте с метрик, которые влияют на бизнес-KPI, и с оптимизаций, дающих максимальный результат при минимальных усилиях.</p>",
    difficulty: 'senior',
    tags: ['приоритизация', 'оптимизация', 'стратегия', 'Web Vitals']
  },
  {
    id: 120,
    question: "Как Web Vitals влияют на SEO и бизнес-метрики?",
    answer: "<p><strong>Прямое влияние на SEO:</strong></p><ul><li>Core Web Vitals — официальный ranking factor Google с 2021 года</li><li>Плохие метрики могут снизить позиции в поиске</li><li>Особенно важно для мобильной выдачи</li><li>Влияние усиливается при прочих равных факторах</li></ul><p><strong>Корреляция с бизнес-метриками:</strong></p><p><strong>Конверсии:</strong></p><ul><li>Улучшение LCP на 0.1с может увеличить конверсию на 8%</li><li>53% мобильных пользователей покидают сайт, если загрузка длится более 3 секунд</li></ul><p><strong>Показатель отказов:</strong></p><ul><li>Плохой CLS раздражает пользователей и увеличивает bounce rate</li><li>Каждая секунда задержки FID коррелирует с ростом отказов</li></ul><p><strong>Вовлеченность:</strong></p><ul><li>Быстрые сайты показывают больше просмотров страниц</li><li>Лучше metrics вовлеченности (time on site, pages per session)</li></ul><p><strong>Документированные кейсы:</strong></p><ul><li>Vodafone: улучшение LCP на 31% → рост продаж на 8%</li><li>Tokopedia: улучшение всех Core Web Vitals → +35% органического трафика</li><li>Redbus: улучшение INP → +7% продаж</li></ul><p><strong>ROI оптимизации:</strong></p><p>Инвестиции в Web Vitals окупаются через улучшение органического трафика, конверсий и удержания пользователей.</p>",
    difficulty: 'middle',
    tags: ['SEO', 'бизнес-метрики', 'конверсии', 'ROI']
  },
  {
    id: 121,
    question: "Какие основные панели Chrome DevTools вы используете чаще всего и для каких задач?",
    answer: "<p><strong>Основные панели DevTools и их назначение:</strong></p><p><strong>Elements:</strong></p><ul><li>Инспекция и редактирование DOM в реальном времени</li><li>Просмотр и изменение CSS-стилей</li><li>Анализ computed styles и специфичности</li><li>Отладка layout и box model</li></ul><p><strong>Console:</strong></p><ul><li>Выполнение JavaScript-кода в контексте страницы</li><li>Просмотр логов, ошибок, предупреждений</li><li>Отладка через console.log, console.table</li><li>Работа с API браузера</li></ul><p><strong>Sources:</strong></p><ul><li>Отладка JavaScript с breakpoints</li><li>Просмотр исходного кода и sourcemaps</li><li>Step-by-step выполнение кода</li><li>Watch expressions и call stack</li></ul><p><strong>Network:</strong></p><ul><li>Анализ всех сетевых запросов</li><li>Отладка API-вызовов</li><li>Проверка размеров и времени загрузки</li><li>Throttling для тестирования медленных соединений</li></ul><p><strong>Performance:</strong></p><ul><li>Профилирование производительности</li><li>Анализ FPS и памяти</li><li>Поиск узких мест в коде</li></ul><p>Каждая панель решает специфические задачи — правильный выбор инструмента ускоряет отладку в разы.</p>",
    difficulty: 'junior',
    tags: ['DevTools', 'панели', 'отладка', 'инструменты']
  },
  {
    id: 122,
    question: "Как использовать breakpoints для отладки JavaScript?",
    answer: "<p><strong>Типы breakpoints в DevTools:</strong></p><p><strong>1. Line breakpoints:</strong></p><ul><li>Останавливают выполнение на конкретной строке</li><li>Самый простой и часто используемый тип</li><li>Кликаете на номер строки в Sources</li></ul><p><strong>2. Conditional breakpoints:</strong></p><ul><li>Срабатывают только при выполнении условия</li><li>Полезны в циклах: останавливаться только когда i === 5</li><li>Правый клик на номер строки → Add conditional breakpoint</li></ul><p><strong>3. Logpoints:</strong></p><ul><li>Вместо остановки выводят сообщение в консоль</li><li>Не требуют изменения исходного кода</li><li>Альтернатива console.log без модификации файлов</li></ul><p><strong>4. DOM breakpoints:</strong></p><ul><li>Subtree modifications — при изменении дочерних элементов</li><li>Attribute modifications — при изменении атрибутов</li><li>Node removal — при удалении элемента</li></ul><p><strong>5. Event listener breakpoints:</strong></p><ul><li>Останавливаются при срабатывании событий</li><li>Например, pause on all click events</li><li>Помогают отследить, где обрабатывается событие</li></ul><p><strong>Управление выполнением:</strong></p><ul><li><strong>Step over (F10):</strong> следующая строка</li><li><strong>Step into (F11):</strong> зайти внутрь функции</li><li><strong>Step out (Shift+F11):</strong> выйти из функции</li><li><strong>Continue (F8):</strong> продолжить до следующего breakpoint</li></ul>",
    difficulty: 'middle',
    tags: ['отладка', 'breakpoints', 'JavaScript', 'DevTools']
  },
  {
    id: 123,
    question: "Объясните, как работает Network панель и что означают различные цвета в waterfall?",
    answer: "<p><strong>Network панель показывает все сетевые запросы</strong> и позволяет анализировать загрузку ресурсов.</p><p><strong>Основные колонки:</strong></p><ul><li><strong>Name:</strong> имя и путь к ресурсу</li><li><strong>Status:</strong> HTTP-статус ответа</li><li><strong>Type:</strong> тип ресурса (document, script, stylesheet, xhr)</li><li><strong>Initiator:</strong> что инициировало запрос</li><li><strong>Size:</strong> размер ресурса (transferred vs resource)</li><li><strong>Time:</strong> время загрузки</li><li><strong>Waterfall:</strong> визуальная временная шкала</li></ul><p><strong>Цвета в waterfall диаграмме:</strong></p><p><strong>Светлые оттенки (queuing):</strong></p><ul><li>Запрос ждет в очереди</li><li>Браузер имеет лимит параллельных соединений</li></ul><p><strong>Оранжевый (Initial connection/SSL):</strong></p><ul><li>DNS lookup</li><li>Установка TCP соединения</li><li>SSL/TLS handshake</li></ul><p><strong>Зеленый (Waiting - TTFB):</strong></p><ul><li>Ожидание первого байта от сервера</li><li>Серверная обработка запроса</li></ul><p><strong>Синий (Content Download):</strong></p><ul><li>Получение содержимого</li><li>Зависит от размера файла и скорости соединения</li></ul><p><strong>Полезные фичи:</strong></p><ul><li>Throttling — эмуляция медленной сети</li><li>Disable cache — тестирование без кэша</li><li>Preserve log — сохранять логи при переходах</li><li>Filter — фильтрация по типу ресурсов</li></ul>",
    difficulty: 'middle',
    tags: ['Network', 'waterfall', 'загрузка', 'производительность']
  },
  {
    id: 124,
    question: "Как использовать Performance панель для анализа производительности?",
    answer: "<p><strong>Performance панель</strong> позволяет записать и проанализировать все, что происходит во время загрузки или взаимодействия с страницей.</p><p><strong>Процесс анализа:</strong></p><p><strong>1. Запись профиля:</strong></p><ul><li>Кнопка Record → выполнить действия → Stop</li><li>Или Reload с записью для анализа загрузки</li><li>Старайтесь делать короткие записи (5-10 секунд)</li></ul><p><strong>2. Основные секции профиля:</strong></p><p><strong>Summary (круговая диаграмма):</strong></p><ul><li>Loading — парсинг HTML, CSS</li><li>Scripting — выполнение JavaScript</li><li>Rendering — расчет стилей, layout</li><li>Painting — отрисовка пикселей</li><li>System — прочие операции браузера</li></ul><p><strong>Main thread (временная шкала):</strong></p><ul><li>Показывает все задачи главного потока</li><li>Длинные задачи (>50ms) — проблемы для интерактивности</li><li>Можно зумить и кликать на задачи для деталей</li></ul><p><strong>Frames:</strong></p><ul><li>Зеленые полоски — 60 FPS достигнуто</li><li>Красные — dropped frames, лаги</li></ul><p><strong>3. Что искать:</strong></p><ul><li>Длинные JavaScript-задачи (желтые блоки)</li><li>Частые layout thrashing (фиолетовые всплески)</li><li>Принудительные reflow</li><li>Много времени на idle</li></ul><p><strong>4. Bottom-Up / Call Tree:</strong></p><ul><li>Какие функции заняли больше всего времени</li><li>Где находятся узкие места</li></ul>",
    difficulty: 'senior',
    tags: ['Performance', 'профилирование', 'оптимизация', 'анализ']
  },
  {
    id: 125,
    question: "Что такое Coverage панель и как она помогает оптимизировать код?",
    answer: "<p><strong>Coverage панель</strong> показывает, какой процент загруженного CSS и JavaScript кода фактически используется на странице.</p><p><strong>Как использовать:</strong></p><ol><li>Открыть через Cmd+Shift+P → Show Coverage</li><li>Нажать кнопку Record</li><li>Взаимодействовать со страницей</li><li>Остановить запись</li></ol><p><strong>Что показывает:</strong></p><ul><li><strong>Красные полосы:</strong> неиспользуемый код</li><li><strong>Синие полосы:</strong> использованный код</li><li><strong>Процент использования:</strong> для каждого файла</li><li><strong>Unused Bytes:</strong> сколько байт не используется</li></ul><p><strong>Типичные проблемы:</strong></p><p><strong>CSS:</strong></p><ul><li>Библиотеки типа Bootstrap — используете 20%, загружаете 100%</li><li>Устаревшие стили для старых компонентов</li><li>Медиа-запросы для неактуальных breakpoints</li></ul><p><strong>JavaScript:</strong></p><ul><li>Большие библиотеки, где нужна лишь часть функционала</li><li>Polyfills для старых браузеров в современных</li><li>Неиспользуемые зависимости</li></ul><p><strong>Стратегии оптимизации:</strong></p><ul><li><strong>Code splitting:</strong> загружать код по требованию</li><li><strong>Tree shaking:</strong> удалить неиспользуемые exports</li><li><strong>Critical CSS:</strong> inline только нужные стили</li><li><strong>Lazy loading:</strong> отложенная загрузка модулей</li><li><strong>PurgeCSS:</strong> удаление неиспользуемого CSS</li></ul><p>Coverage помогает найти низко висящие фрукты — код, который можно удалить или отложить без потери функциональности.</p>",
    difficulty: 'middle',
    tags: ['Coverage', 'оптимизация', 'bundle size', 'неиспользуемый код']
  },
  {
    id: 126,
    question: "Как отлаживать CSS в Elements панели? Какие возможности есть для работы со стилями?",
    answer: "<p><strong>Elements панель предоставляет мощные инструменты для работы с CSS:</strong></p><p><strong>1. Styles панель:</strong></p><ul><li>Показывает все CSS-правила, применяемые к элементу</li><li>Можно изменять значения в реальном времени</li><li>Перечеркнутые свойства — переопределены другими правилами</li><li>Можно добавлять новые свойства через клик</li></ul><p><strong>2. Computed панель:</strong></p><ul><li>Итоговые значения всех CSS-свойств</li><li>Show All — полный список даже дефолтных значений</li><li>Клик на значение показывает, откуда оно взялось</li><li>Полезно для понимания каскада и наследования</li></ul><p><strong>3. Box Model:</strong></p><ul><li>Визуализация margin, border, padding, content</li><li>Можно кликнуть на значения и изменить их</li><li>Наглядно показывает размеры элемента</li></ul><p><strong>4. Специальные возможности:</strong></p><p><strong>Color Picker:</strong></p><ul><li>Клик на цвет открывает пикер</li><li>Можно менять формат (hex, rgb, hsl)</li><li>Проверка контраста для доступности</li></ul><p><strong>CSS classes:</strong></p><ul><li>.cls — добавление/удаление классов</li><li>Быстрое тестирование состояний</li></ul><p><strong>Force state:</strong></p><ul><li>:hover, :active, :focus, :visited</li><li>Тестирование псевдоклассов без физического взаимодействия</li></ul><p><strong>Copy styles:</strong></p><ul><li>Copy all declarations</li><li>Copy rule — скопировать весь селектор</li></ul><p><strong>5. Layout панель:</strong></p><ul><li>Визуализация Grid и Flexbox</li><li>Overlays для понимания структуры</li><li>Инструменты для отладки выравнивания</li></ul>",
    difficulty: 'middle',
    tags: ['CSS', 'Elements', 'стили', 'отладка']
  },
  {
    id: 127,
    question: "Объясните, как использовать Memory панель для поиска утечек памяти",
    answer: "<p><strong>Memory панель</strong> помогает найти и исправить утечки памяти — ситуации, когда приложение потребляет все больше памяти и не освобождает её.</p><p><strong>Типы профилей памяти:</strong></p><p><strong>1. Heap snapshot:</strong></p><ul><li>Снимок состояния памяти в конкретный момент</li><li>Показывает все объекты в памяти</li><li>Можно сравнивать снимки для поиска роста</li></ul><p><strong>2. Allocation instrumentation on timeline:</strong></p><ul><li>Запись выделения памяти во времени</li><li>Показывает, когда и где выделяется память</li><li>Синие полоски — выделенная память</li><li>Серые — освобожденная память</li></ul><p><strong>3. Allocation sampling:</strong></p><ul><li>Менее детальный, но легковесный профиль</li><li>Показывает call stacks выделений памяти</li></ul><p><strong>Процесс поиска утечек:</strong></p><ol><li><strong>Baseline snapshot:</strong> снять начальный snapshot</li><li><strong>Выполнить действия:</strong> сделать то, что подозревается в утечке</li><li><strong>Force GC:</strong> принудительно запустить garbage collector</li><li><strong>Второй snapshot:</strong> снять еще один snapshot</li><li><strong>Сравнить:</strong> переключиться в режим Comparison</li></ol><p><strong>Что искать:</strong></p><ul><li><strong>Detached DOM nodes:</strong> элементы удалены из DOM, но остались в памяти</li><li><strong>Event listeners:</strong> забытые подписки на события</li><li><strong>Closures:</strong> замыкания, держащие большие объекты</li><li><strong>Globals:</strong> глобальные переменные, которые растут</li><li><strong>Timers:</strong> не очищенные setInterval/setTimeout</li></ul><p><strong>Типичные паттерны утечек:</strong></p><ul><li>Забыли removeEventListener</li><li>Держим ссылки на удаленные DOM-элементы</li><li>Бесконечные массивы/кэши без ограничений</li><li>Неочищенные subscriptions в SPA</li></ul>",
    difficulty: 'senior',
    tags: ['Memory', 'утечки памяти', 'профилирование', 'оптимизация']
  },
  {
    id: 128,
    question: "Как работает Lighthouse в DevTools и какие метрики он проверяет?",
    answer: "<p><strong>Lighthouse</strong> — это автоматизированный инструмент для аудита веб-страниц по нескольким категориям качества.</p><p><strong>Категории аудита:</strong></p><p><strong>1. Performance (Производительность):</strong></p><ul><li>Core Web Vitals: LCP, FID, CLS</li><li>First Contentful Paint</li><li>Speed Index</li><li>Time to Interactive</li><li>Total Blocking Time</li></ul><p><strong>2. Accessibility (Доступность):</strong></p><ul><li>Правильность alt-атрибутов</li><li>Контрастность текста</li><li>ARIA-атрибуты</li><li>Семантическая разметка</li><li>Клавиатурная навигация</li></ul><p><strong>3. Best Practices (Лучшие практики):</strong></p><ul><li>HTTPS использование</li><li>Безопасность</li><li>Современные API</li><li>Отсутствие ошибок в консоли</li><li>Правильные размеры изображений</li></ul><p><strong>4. SEO:</strong></p><ul><li>Наличие meta-тегов</li><li>Правильные заголовки</li><li>Валидный robots.txt</li><li>Мобильная оптимизация</li><li>Структурированные данные</li></ul><p><strong>5. Progressive Web App:</strong></p><ul><li>Наличие manifest</li><li>Service Worker</li><li>Offline функциональность</li><li>Installability</li></ul><p><strong>Как использовать:</strong></p><ol><li>Открыть Lighthouse панель</li><li>Выбрать категории для проверки</li><li>Выбрать устройство (Mobile/Desktop)</li><li>Generate report</li></ol><p><strong>Интерпретация результатов:</strong></p><ul><li><strong>Зеленый (90-100):</strong> отлично</li><li><strong>Оранжевый (50-89):</strong> требует улучшения</li><li><strong>Красный (0-49):</strong> плохо</li></ul><p>Каждая проблема содержит описание и ссылку на документацию с решением.</p>",
    difficulty: 'middle',
    tags: ['Lighthouse', 'аудит', 'производительность', 'качество']
  },
  {
    id: 129,
    question: "Что такое Source Maps и как они помогают в отладке?",
    answer: "<p><strong>Source Maps</strong> — это файлы, которые связывают минифицированный/транспилированный код с оригинальным исходным кодом.</p><p><strong>Зачем нужны:</strong></p><ul><li>Продакшен-код минифицирован и нечитаем</li><li>TypeScript/Babel/webpack преобразуют код</li><li>Без source maps отладка превращается в кошмар</li><li>Source maps позволяют видеть оригинальный код в DevTools</li></ul><p><strong>Как работают:</strong></p><ol><li>Бандлер генерирует .map файл рядом с bundle</li><li>В bundle добавляется комментарий: //# sourceMappingURL=bundle.js.map</li><li>DevTools загружает и парсит .map файл</li><li>Показывает оригинальный код вместо минифицированного</li></ol><p><strong>Что позволяют в DevTools:</strong></p><p><strong>Sources панель:</strong></p><ul><li>Видеть оригинальные имена файлов и структуру проекта</li><li>Ставить breakpoints в TypeScript/JSX коде</li><li>Видеть оригинальные имена переменных</li><li>Нормальный stack traces в ошибках</li></ul><p><strong>Console:</strong></p><ul><li>Ошибки ссылаются на оригинальные строки кода</li><li>Stack traces показывают реальные файлы</li></ul><p><strong>Типы source maps:</strong></p><ul><li><strong>Inline:</strong> встроены в bundle (большой размер)</li><li><strong>External:</strong> отдельный .map файл (рекомендуется)</li><li><strong>eval-source-map:</strong> быстрая пересборка для разработки</li></ul><p><strong>Продакшен considerations:</strong></p><ul><li>Source maps могут раскрыть исходный код</li><li>Можно не публиковать .map файлы</li><li>Или использовать их только для error tracking сервисов</li><li>Некоторые используют private source maps на CDN</li></ul>",
    difficulty: 'middle',
    tags: ['Source Maps', 'отладка', 'минификация', 'транспиляция']
  },
  {
    id: 130,
    question: "Как использовать Local Overrides для тестирования изменений без деплоя?",
    answer: "<p><strong>Local Overrides</strong> позволяют сохранить изменения, сделанные в DevTools, и применять их при каждой перезагрузке страницы.</p><p><strong>Зачем это нужно:</strong></p><ul><li>Тестировать исправления без деплоя</li><li>Экспериментировать с чужими сайтами</li><li>Быстро проверять гипотезы</li><li>Отладка на production без доступа к коду</li></ul><p><strong>Как настроить:</strong></p><ol><li>Sources → Overrides tab</li><li>Enable Local Overrides</li><li>Выбрать папку на диске для хранения изменений</li><li>Разрешить доступ браузеру к папке</li></ol><p><strong>Что можно override:</strong></p><p><strong>JavaScript:</strong></p><ul><li>Изменить логику функций</li><li>Добавить console.log для отладки</li><li>Исправить баги временно</li></ul><p><strong>CSS:</strong></p><ul><li>Изменить стили</li><li>Тестировать дизайн-изменения</li><li>Исправить проблемы с layout</li></ul><p><strong>HTML:</strong></p><ul><li>Изменить структуру страницы</li><li>Добавить новые элементы</li></ul><p><strong>Network responses:</strong></p><ul><li>Подменить ответы API</li><li>Тестировать с mock данными</li><li>Симулировать ошибки</li></ul><p><strong>Workflow:</strong></p><ol><li>Открыть файл в Sources</li><li>Сделать изменения в коде</li><li>Ctrl+S для сохранения</li><li>Перезагрузить страницу — изменения применятся</li><li>Фиолетовая точка на вкладке означает override активен</li></ol><p><strong>Полезные сценарии:</strong></p><ul><li>Тестировать фикс бага на проде перед деплоем</li><li>Отладка багов, которые сложно воспроизвести локально</li><li>Тестирование на реальном окружении с реальными данными</li><li>A/B тестирование дизайна</li></ul>",
    difficulty: 'middle',
    tags: ['Local Overrides', 'отладка', 'тестирование', 'workflow']
  },
  {
    id: 131,
    question: "Объясните разницу между Throttling и Emulation в DevTools",
    answer: "<p><strong>Throttling</strong> и <strong>Emulation</strong> — это разные способы симуляции условий для тестирования.</p><p><strong>Network Throttling (сеть):</strong></p><p><strong>Что делает:</strong></p><ul><li>Искусственно замедляет сетевые запросы</li><li>Симулирует медленное соединение</li><li>Добавляет latency (задержку)</li><li>Ограничивает bandwidth (пропускную способность)</li></ul><p><strong>Пресеты:</strong></p><ul><li><strong>Fast 3G:</strong> 1.6 Mbps, 150ms latency</li><li><strong>Slow 3G:</strong> 400 Kbps, 400ms latency</li><li><strong>Offline:</strong> полное отсутствие сети</li><li><strong>Custom:</strong> свои настройки</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Тестировать загрузку на медленном интернете</li><li>Проверять offline-функциональность</li><li>Оптимизировать критический путь рендеринга</li></ul><p><strong>CPU Throttling (процессор):</strong></p><p><strong>Что делает:</strong></p><ul><li>Замедляет выполнение JavaScript</li><li>Симулирует слабое устройство</li><li>Множители: 4x slowdown, 6x slowdown</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Тестировать на слабых мобильных устройствах</li><li>Находить проблемы производительности JavaScript</li><li>Проверять, что приложение отзывчиво на слабом железе</li></ul><p><strong>Device Emulation (устройство):</strong></p><p><strong>Что эмулирует:</strong></p><ul><li>Размер экрана и viewport</li><li>Device pixel ratio (Retina)</li><li>Touch events вместо mouse</li><li>User agent строку</li><li>Geolocation</li><li>Ориентацию (portrait/landscape)</li></ul><p><strong>Важно понимать:</strong></p><ul><li><strong>Эмуляция ≠ реальное устройство</strong></li><li>DevTools не может симулировать GPU, RAM</li><li>Рендеринг все равно происходит на вашем ПК</li><li>Для точного тестирования нужны реальные устройства</li></ul>",
    difficulty: 'middle',
    tags: ['Throttling', 'Emulation', 'тестирование', 'производительность']
  },
  {
    id: 132,
    question: "Как использовать Command Menu (Cmd+Shift+P) для быстрого доступа к функциям?",
    answer: "<p><strong>Command Menu</strong> — это мощный инструмент для быстрого доступа ко всем функциям DevTools без поиска в меню.</p><p><strong>Как открыть:</strong></p><ul><li>Mac: Cmd + Shift + P</li><li>Windows/Linux: Ctrl + Shift + P</li></ul><p><strong>Популярные команды:</strong></p><p><strong>Панели и инструменты:</strong></p><ul><li><code>Show Coverage</code> — анализ неиспользуемого кода</li><li><code>Show Network conditions</code> — настройки сети</li><li><code>Show Rendering</code> — настройки рендеринга</li><li><code>Show Sensors</code> — эмуляция датчиков</li><li><code>Show Performance monitor</code> — реалтайм метрики</li></ul><p><strong>Скриншоты:</strong></p><ul><li><code>Capture full size screenshot</code> — скриншот всей страницы</li><li><code>Capture node screenshot</code> — скриншот выбранного элемента</li><li><code>Capture area screenshot</code> — выделить область</li><li><code>Capture screenshot</code> — видимая область</li></ul><p><strong>JavaScript и отладка:</strong></p><ul><li><code>Disable JavaScript</code> — отключить JS</li><li><code>Do not capture async stack traces</code></li><li><code>Show JavaScript profiler</code></li></ul><p><strong>Производительность:</strong></p><ul><li><code>Enable paint flashing</code> — подсветка перерисовок</li><li><code>Enable layer borders</code> — границы композитных слоев</li><li><code>Show frames per second (FPS) meter</code></li><li><code>Emulate CSS media type print</code> — печать</li></ul><p><strong>Accessibility:</strong></p><ul><li><code>Show Accessibility</code> — панель доступности</li><li><code>Emulate vision deficiencies</strong> — симуляция нарушений зрения</li></ul><p><strong>Network:</strong></p><ul><li><code>Block request URL</code> — блокировка запросов</li><li><code>Enable request blocking</code></li></ul><p><strong>Tips:</strong></p><ul><li>Начните печатать — появится автодополнение</li><li>Недавние команды показываются сверху</li><li>Можно искать по части названия</li></ul>",
    difficulty: 'junior',
    tags: ['Command Menu', 'shortcuts', 'productivity', 'DevTools']
  },
  {
    id: 133,
    question: "Как отлаживать проблемы с CORS в DevTools?",
    answer: "<p><strong>CORS-ошибки</strong> — одна из частых проблем при разработке, и DevTools помогает их диагностировать.</p><p><strong>Где видны CORS-ошибки:</strong></p><p><strong>Console:</strong></p><ul><li>Красная ошибка с текстом 'CORS policy'</li><li>Точное описание проблемы</li><li>Например: 'No Access-Control-Allow-Origin header is present'</li></ul><p><strong>Network панель:</strong></p><ul><li>Запрос может быть красным (failed)</li><li>Статус может быть (failed) или CORS error</li><li>Во вкладке Headers видны отсутствующие заголовки</li></ul><p><strong>Типичные CORS-проблемы:</strong></p><p><strong>1. Отсутствие Access-Control-Allow-Origin:</strong></p><ul><li>Сервер не разрешает запросы с вашего origin</li><li>Нужно добавить заголовок на сервере</li><li>Или использовать proxy</li></ul><p><strong>2. Preflight запрос провалился:</strong></p><ul><li>OPTIONS-запрос перед основным</li><li>Сервер должен отвечать на OPTIONS</li><li>Нужны заголовки: Access-Control-Allow-Methods, Access-Control-Allow-Headers</li></ul><p><strong>3. Credentials не разрешены:</strong></p><ul><li>Используете cookies/auth, но заголовок Access-Control-Allow-Credentials: true отсутствует</li><li>Origin не может быть * при credentials: true</li></ul><p><strong>Как отлаживать:</strong></p><ol><li><strong>Network → Headers:</strong> проверить Response Headers</li><li><strong>Искать:</strong> Access-Control-Allow-* заголовки</li><li><strong>Console:</strong> читать точное описание ошибки</li><li><strong>OPTIONS запрос:</strong> проверить preflight</li></ol><p><strong>Workarounds для разработки:</strong></p><ul><li>CORS-расширения для браузера (НЕ для продакшена!)</li><li>Proxy в webpack dev server</li><li>Локальный прокси-сервер</li><li>Отключить CORS в Chrome (небезопасно!)</li></ul><p>Правильное решение — всегда настроить CORS на сервере.</p>",
    difficulty: 'middle',
    tags: ['CORS', 'отладка', 'Network', 'безопасность']
  },
  {
    id: 134,
    question: "Объясните, как использовать Rendering панель для отладки визуальных проблем",
    answer: "<p><strong>Rendering панель</strong> предоставляет инструменты для визуализации и отладки рендеринга страницы.</p><p><strong>Основные инструменты:</strong></p><p><strong>1. Paint flashing:</strong></p><ul><li>Подсвечивает зеленым цветом области, которые перерисовываются</li><li>Помогает найти избыточные repaint'ы</li><li>Если вся страница мигает зеленым — проблема производительности</li></ul><p><strong>2. Layout Shift Regions:</strong></p><ul><li>Синим подсвечивает области layout shift</li><li>Помогает визуализировать CLS</li><li>Видно, какие элементы прыгают</li></ul><p><strong>3. Layer borders:</strong></p><ul><li>Показывает границы композитных слоев</li><li>Оранжевый — обычные слои</li><li>Синий — tiles (части больших слоев)</li><li>Помогает понять, сколько слоев создается</li></ul><p><strong>4. Frame Rendering Stats:</strong></p><ul><li>Реалтайм FPS метр</li><li>GPU memory использование</li><li>Dropped frames counter</li></ul><p><strong>5. Scrolling performance issues:</strong></p><ul><li>Подсвечивает элементы, замедляющие скролл</li><li>Touch event handlers без passive: true</li><li>Wheel event handlers</li></ul><p><strong>6. Core Web Vitals overlay:</strong></p><ul><li>Показывает LCP элемент</li><li>Layout shift areas</li><li>Помогает визуально определить проблемы</li></ul><p><strong>7. Emulate CSS media features:</strong></p><ul><li><code>prefers-color-scheme</code> — темная/светлая тема</li><li><code>prefers-reduced-motion</code> — уменьшенная анимация</li><li><code>prefers-contrast</code> — повышенная контрастность</li></ul><p><strong>Типичные use cases:</strong></p><ul><li>Найти элементы, вызывающие постоянные repaint</li><li>Оптимизировать количество композитных слоев</li><li>Отладить CLS проблемы визуально</li><li>Проверить accessibility preferences</li></ul>",
    difficulty: 'senior',
    tags: ['Rendering', 'визуализация', 'производительность', 'отладка']
  },
  {
    id: 135,
    question: "Какие полезные snippets и shortcuts вы используете в DevTools?",
    answer: "<p><strong>Snippets</strong> — это сохраненные JavaScript-скрипты, которые можно запускать на любой странице.</p><p><strong>Где находятся:</strong></p><ul><li>Sources → Snippets tab</li><li>New snippet → написать код → Ctrl+Enter для запуска</li></ul><p><strong>Полезные snippets:</strong></p><p><strong>1. Найти все изображения без alt:</strong></p><ul><li>Проверка accessibility</li><li>Перебор всех img на странице</li><li>Вывод списка проблемных изображений</li></ul><p><strong>2. Подсчет элементов по селектору:</strong></p><ul><li>Сколько div'ов, button'ов и т.д.</li><li>Анализ структуры DOM</li></ul><p><strong>3. Измерение производительности функций:</strong></p><ul><li>console.time/timeEnd обертки</li><li>Бенчмарки прямо в браузере</li></ul><p><strong>4. Очистка localStorage/cookies:</strong></p><ul><li>Быстрый сброс состояния для тестирования</li></ul><p><strong>5. Dump page info:</strong></p><ul><li>Извлечение meta-тегов, заголовков</li><li>Анализ SEO</li></ul><p><strong>Полезные shortcuts:</strong></p><p><strong>Общие:</strong></p><ul><li><code>Cmd/Ctrl + Shift + P</code> — Command menu</li><li><code>Cmd/Ctrl + P</code> — быстрый поиск файлов</li><li><code>Cmd/Ctrl + Shift + O</code> — поиск функций в файле</li><li><code>Cmd/Ctrl + F</code> — поиск в текущей панели</li></ul><p><strong>Elements:</strong></p><ul><li><code>H</code> — скрыть элемент (visibility: hidden)</li><li><code>Delete</code> — удалить элемент</li><li><code>F2</code> — редактировать HTML</li><li><code>Ctrl + Z</code> — отменить изменения</li></ul><p><strong>Console:</strong></p><ul><li><code>$0</code> — последний выбранный элемент в Elements</li><li><code>$_</code> — результат последнего выражения</li><li><code>$$()</code> — querySelectorAll shorthand</li><li><code>copy()</code> — скопировать в буфер</li></ul><p><strong>Sources:</strong></p><ul><li><code>Ctrl + G</code> — перейти к строке</li><li><code>Ctrl + Shift + E</code> — выполнить выделенный код</li></ul>",
    difficulty: 'middle',
    tags: ['snippets', 'shortcuts', 'productivity', 'automation']
  }
];
