export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое протокол HTTP и как он используется в веб-разработке?",
    answer: "<p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня для передачи данных в интернете, который является основой обмена данными в World Wide Web.</p><p><strong>Как работает HTTP:</strong></p><ul><li>Клиент-серверная модель — браузер (клиент) отправляет запрос, сервер обрабатывает и возвращает ответ</li><li>Протокол без состояния (stateless) — каждый запрос независим, сервер не хранит информацию о предыдущих запросах</li><li>Текстовый протокол — легко читается и отлаживается</li></ul><p><strong>Основные компоненты HTTP:</strong></p><ul><li><strong>Запрос (Request)</strong> — содержит метод, URL, заголовки и опционально тело запроса</li><li><strong>Ответ (Response)</strong> — содержит статус код, заголовки и тело ответа</li></ul><p><strong>Применение в веб-разработке:</strong></p><ul><li>Загрузка веб-страниц и ресурсов</li><li>Отправка форм и данных на сервер</li><li>REST API взаимодействие</li><li>Загрузка и скачивание файлов</li></ul><p>HTTP работает поверх TCP/IP, обычно использует порт 80 (443 для HTTPS).</p>",
    difficulty: 'junior',
    tags: ['HTTP', 'протокол', 'основы', 'веб']
  },
  {
    id: 2,
    question: "Какие основные методы запросов (HTTP methods) существуют и для чего используются?",
    answer: "<p>HTTP определяет несколько методов для указания желаемого действия над ресурсом:</p><p><strong>GET:</strong></p><ul><li>Получение данных с сервера</li><li>Идемпотентный и безопасный метод</li><li>Параметры передаются в URL</li><li>Может кэшироваться браузером</li><li>Пример: получение списка товаров, загрузка страницы</li></ul><p><strong>POST:</strong></p><ul><li>Создание нового ресурса</li><li>Данные передаются в теле запроса</li><li>Не идемпотентный — повторный запрос создаст дубликат</li><li>Не кэшируется</li><li>Пример: отправка формы регистрации, создание заказа</li></ul><p><strong>PUT:</strong></p><ul><li>Обновление существующего ресурса целиком</li><li>Идемпотентный — повторный запрос не изменит результат</li><li>Заменяет весь ресурс</li><li>Пример: обновление профиля пользователя</li></ul><p><strong>PATCH:</strong></p><ul><li>Частичное обновление ресурса</li><li>Изменяет только указанные поля</li><li>Более эффективен чем PUT для небольших изменений</li><li>Пример: изменение только email пользователя</li></ul><p><strong>DELETE:</strong></p><ul><li>Удаление ресурса</li><li>Идемпотентный</li><li>Пример: удаление комментария, товара из корзины</li></ul><p><strong>HEAD:</strong></p><ul><li>Аналогичен GET, но возвращает только заголовки</li><li>Используется для проверки существования ресурса</li><li>Пример: проверка размера файла перед загрузкой</li></ul><p><strong>OPTIONS:</strong></p><ul><li>Запрос информации о доступных методах для ресурса</li><li>Используется в CORS preflight запросах</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP methods', 'GET', 'POST', 'REST']
  },
  {
    id: 3,
    question: "Что такое заголовки HTTP (HTTP headers) и какую роль они играют?",
    answer: "<p><strong>HTTP заголовки</strong> — это пары ключ-значение, которые передают дополнительную информацию о запросе или ответе.</p><p><strong>Типы заголовков:</strong></p><p><strong>1. Заголовки запроса (Request Headers):</strong></p><ul><li><strong>User-Agent</strong> — информация о браузере и ОС клиента</li><li><strong>Accept</strong> — типы контента, которые клиент может обработать</li><li><strong>Authorization</strong> — учетные данные для аутентификации</li><li><strong>Cookie</strong> — сохраненные cookies для данного домена</li><li><strong>Content-Type</strong> — тип данных в теле запроса (для POST/PUT)</li></ul><p><strong>2. Заголовки ответа (Response Headers):</strong></p><ul><li><strong>Content-Type</strong> — тип возвращаемого контента</li><li><strong>Content-Length</strong> — размер тела ответа в байтах</li><li><strong>Set-Cookie</strong> — установка cookies на клиенте</li><li><strong>Cache-Control</strong> — директивы для кэширования</li><li><strong>Location</strong> — URL для перенаправления</li></ul><p><strong>3. Общие заголовки:</strong></p><ul><li><strong>Date</strong> — дата и время отправки сообщения</li><li><strong>Connection</strong> — управление соединением (keep-alive)</li></ul><p><strong>4. Заголовки сущности:</strong></p><ul><li><strong>Content-Encoding</strong> — метод сжатия (gzip, deflate)</li><li><strong>Last-Modified</strong> — дата последней модификации ресурса</li><li><strong>ETag</strong> — уникальный идентификатор версии ресурса</li></ul><p><strong>Роль заголовков:</strong></p><ul><li>Управление кэшированием и производительностью</li><li>Аутентификация и авторизация</li><li>Согласование контента (content negotiation)</li><li>Безопасность (CORS, CSP)</li><li>Мониторинг и отладка</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP headers', 'заголовки', 'метаданные']
  },
  {
    id: 4,
    question: "Что такое статусы ответов HTTP (HTTP status codes) и какие наиболее распространенные?",
    answer: "<p><strong>HTTP статус коды</strong> — это трехзначные числа, которые сервер возвращает в ответ на запрос, указывая результат его обработки.</p><p><strong>Категории статусов:</strong></p><p><strong>1xx — Информационные:</strong></p><ul><li><strong>100 Continue</strong> — сервер готов принять тело запроса</li><li><strong>101 Switching Protocols</strong> — переключение протокола (например, на WebSocket)</li></ul><p><strong>2xx — Успешные:</strong></p><ul><li><strong>200 OK</strong> — запрос выполнен успешно</li><li><strong>201 Created</strong> — ресурс успешно создан (обычно после POST)</li><li><strong>204 No Content</strong> — успех, но нет контента для возврата</li></ul><p><strong>3xx — Перенаправления:</strong></p><ul><li><strong>301 Moved Permanently</strong> — постоянное перенаправление, обновить закладки</li><li><strong>302 Found</strong> — временное перенаправление</li><li><strong>304 Not Modified</strong> — ресурс не изменился, используйте кэш</li><li><strong>307 Temporary Redirect</strong> — временное перенаправление с сохранением метода</li><li><strong>308 Permanent Redirect</strong> — постоянное перенаправление с сохранением метода</li></ul><p><strong>4xx — Ошибки клиента:</strong></p><ul><li><strong>400 Bad Request</strong> — некорректный синтаксис запроса</li><li><strong>401 Unauthorized</strong> — требуется аутентификация</li><li><strong>403 Forbidden</strong> — доступ запрещен</li><li><strong>404 Not Found</strong> — ресурс не найден</li><li><strong>405 Method Not Allowed</strong> — метод не поддерживается для данного ресурса</li><li><strong>429 Too Many Requests</strong> — превышен лимит запросов (rate limiting)</li></ul><p><strong>5xx — Ошибки сервера:</strong></p><ul><li><strong>500 Internal Server Error</strong> — внутренняя ошибка сервера</li><li><strong>502 Bad Gateway</strong> — некорректный ответ от вышестоящего сервера</li><li><strong>503 Service Unavailable</strong> — сервис временно недоступен</li><li><strong>504 Gateway Timeout</strong> — таймаут при получении ответа от вышестоящего сервера</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP status codes', 'статусы', 'коды ответов']
  },
  {
    id: 5,
    question: "Как работает механизм перенаправления (HTTP redirects) и какие типы существуют?",
    answer: "<p><strong>HTTP перенаправление</strong> — это механизм, при котором сервер указывает клиенту, что запрошенный ресурс находится по другому URL.</p><p><strong>Как работает:</strong></p><ol><li>Клиент отправляет запрос к URL-A</li><li>Сервер возвращает статус 3xx и заголовок Location с URL-B</li><li>Клиент автоматически отправляет новый запрос к URL-B</li><li>Сервер возвращает финальный ответ</li></ol><p><strong>Типы перенаправлений:</strong></p><p><strong>301 Moved Permanently:</strong></p><ul><li>Постоянное перенаправление</li><li>Поисковые системы обновляют индекс</li><li>Браузеры кэшируют перенаправление</li><li>Может изменить метод на GET</li><li>Используется для: переезда сайта, изменения URL структуры</li></ul><p><strong>302 Found (Temporary Redirect):</strong></p><ul><li>Временное перенаправление</li><li>Поисковики не обновляют индекс</li><li>Может изменить метод на GET</li><li>Используется для: временного технического обслуживания, A/B тестирования</li></ul><p><strong>307 Temporary Redirect:</strong></p><ul><li>Временное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 302</li></ul><p><strong>308 Permanent Redirect:</strong></p><ul><li>Постоянное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 301</li></ul><p><strong>303 See Other:</strong></p><ul><li>Перенаправление на другой URL методом GET</li><li>Используется после POST для избежания повторной отправки формы</li><li>Паттерн Post/Redirect/Get (PRG)</li></ul><p><strong>304 Not Modified:</strong></p><ul><li>Особый тип — не настоящее перенаправление</li><li>Указывает использовать кэшированную версию</li><li>Используется для условных запросов</li></ul><p><strong>Важные аспекты:</strong></p><ul><li>Максимум перенаправлений обычно ограничен (часто 20)</li><li>Выбор между 301 и 302 влияет на SEO</li><li>307/308 предпочтительнее 302/301 для современных приложений</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP redirects', 'перенаправления', '301', '302']
  },
  {
    id: 6,
    question: "Что такое HTTPS и как оно отличается от HTTP?",
    answer: "<p><strong>HTTPS (HTTP Secure)</strong> — это расширение HTTP с шифрованием через SSL/TLS для безопасной передачи данных.</p><p><strong>Ключевые отличия от HTTP:</strong></p><p><strong>1. Шифрование:</strong></p><ul><li>HTTP — данные передаются открытым текстом</li><li>HTTPS — данные зашифрованы с помощью TLS/SSL</li><li>Защита от перехвата и чтения данных третьими лицами</li></ul><p><strong>2. Аутентификация:</strong></p><ul><li>HTTPS использует SSL-сертификаты</li><li>Сертификат подтверждает подлинность сервера</li><li>Предотвращает атаки типа man-in-the-middle</li></ul><p><strong>3. Целостность данных:</strong></p><ul><li>HTTPS гарантирует, что данные не были изменены при передаче</li><li>Использует хеширование для проверки целостности</li></ul><p><strong>Как работает HTTPS:</strong></p><ol><li><strong>TLS Handshake:</strong> установка защищенного соединения<ul><li>Клиент инициирует соединение</li><li>Сервер отправляет SSL-сертификат</li><li>Клиент проверяет сертификат</li><li>Согласование алгоритмов шифрования</li><li>Обмен ключами шифрования</li></ul></li><li><strong>Шифрование данных:</strong> вся дальнейшая передача данных происходит в зашифрованном виде</li><li><strong>Закрытие соединения:</strong> безопасное завершение сессии</li></ol><p><strong>Типы SSL-сертификатов:</strong></p><ul><li><strong>DV (Domain Validated)</strong> — базовая проверка домена</li><li><strong>OV (Organization Validated)</strong> — проверка организации</li><li><strong>EV (Extended Validation)</strong> — расширенная проверка, зеленая строка в браузере</li></ul><p><strong>Преимущества HTTPS:</strong></p><ul><li>Защита конфиденциальных данных (пароли, платежная информация)</li><li>Доверие пользователей — браузеры помечают HTTP сайты как небезопасные</li><li>SEO преимущества — Google предпочитает HTTPS сайты</li><li>Необходимо для современных API (Service Workers, HTTP/2)</li><li>Защита от фишинга</li></ul><p><strong>Недостатки:</strong></p><ul><li>Небольшое снижение производительности (TLS handshake)</li><li>Необходимость покупки и обновления сертификатов (хотя Let's Encrypt предоставляет бесплатные)</li><li>Более сложная настройка сервера</li></ul><p><strong>Современные требования:</strong></p><ul><li>Многие браузеры требуют HTTPS для доступа к определенным API</li><li>HTTP/2 и HTTP/3 работают только через HTTPS</li><li>PWA требуют HTTPS для установки</li></ul>",
    difficulty: 'junior',
    tags: ['HTTPS', 'SSL', 'TLS', 'безопасность', 'шифрование']
  },
  {
    id: 7,
    question: "Что такое идемпотентность в контексте HTTP методов?",
    answer: "<p><strong>Идемпотентность</strong> — это свойство операции, при котором повторное выполнение запроса с теми же параметрами дает тот же результат, что и однократное выполнение.</p><p><strong>Идемпотентные методы:</strong></p><p><strong>GET:</strong></p><ul><li>Множественные запросы возвращают одни и те же данные</li><li>Не изменяет состояние сервера</li><li>Безопасен для повторного выполнения</li></ul><p><strong>PUT:</strong></p><ul><li>Повторное обновление ресурса тем же контентом дает тот же результат</li><li>Первый запрос создает/обновляет ресурс</li><li>Последующие запросы ничего не меняют</li></ul><p><strong>DELETE:</strong></p><ul><li>Первый запрос удаляет ресурс</li><li>Последующие запросы возвращают 404, но это ожидаемое поведение</li><li>Конечный результат одинаков — ресурса нет</li></ul><p><strong>HEAD, OPTIONS:</strong></p><ul><li>Только получают метаинформацию</li><li>Не изменяют состояние</li></ul><p><strong>Не идемпотентные методы:</strong></p><p><strong>POST:</strong></p><ul><li>Каждый запрос создает новый ресурс</li><li>Повторный запрос = дубликат</li><li>Результат отличается от однократного выполнения</li></ul><p><strong>PATCH:</strong></p><ul><li>Может быть идемпотентным или нет, зависит от реализации</li><li>Если PATCH содержит абсолютные значения — идемпотентен</li><li>Если содержит относительные изменения (increment) — не идемпотентен</li></ul><p><strong>Практическое значение:</strong></p><ul><li>Идемпотентные запросы можно безопасно повторять при ошибках сети</li><li>Важно для автоматических retry механизмов</li><li>Упрощает обработку сбоев и восстановление</li></ul><p><strong>Пример не идемпотентности:</strong></p><ul><li>POST /api/orders — каждый вызов создает новый заказ</li><li>PATCH /api/counter (increment) — каждый вызов увеличивает счетчик</li></ul><p><strong>Пример идемпотентности:</strong></p><ul><li>PUT /api/users/123 — обновление того же пользователя теми же данными</li><li>DELETE /api/posts/456 — удаление поста (первый раз удаляет, второй раз возвращает 404)</li></ul>",
    difficulty: 'middle',
    tags: ['идемпотентность', 'HTTP methods', 'REST', 'архитектура']
  },
  {
    id: 8,
    question: "Что такое Content Negotiation и как он работает в HTTP?",
    answer: "<p><strong>Content Negotiation</strong> — это механизм, позволяющий серверу предоставлять разные представления одного и того же ресурса в зависимости от возможностей и предпочтений клиента.</p><p><strong>Типы согласования контента:</strong></p><p><strong>1. Server-driven negotiation (проактивное):</strong></p><ul><li>Сервер выбирает представление на основе заголовков запроса</li><li>Клиент указывает предпочтения через заголовки Accept*</li></ul><p><strong>2. Agent-driven negotiation (реактивное):</strong></p><ul><li>Сервер возвращает список доступных вариантов</li><li>Клиент выбирает подходящий вариант</li><li>Обычно через статус 300 Multiple Choices</li></ul><p><strong>Основные заголовки для согласования:</strong></p><p><strong>Accept:</strong></p><ul><li>Указывает желаемые MIME-типы контента</li><li>Пример: Accept: application/json, text/html;q=0.9</li><li>q-фактор (0-1) определяет приоритет</li></ul><p><strong>Accept-Language:</strong></p><ul><li>Предпочитаемые языки</li><li>Пример: Accept-Language: ru-RU, en-US;q=0.8</li></ul><p><strong>Accept-Encoding:</strong></p><ul><li>Поддерживаемые методы сжатия</li><li>Пример: Accept-Encoding: gzip, deflate, br</li></ul><p><strong>Accept-Charset:</strong></p><ul><li>Предпочитаемые кодировки символов</li><li>Устарел, обычно используется UTF-8</li></ul><p><strong>User-Agent:</strong></p><ul><li>Информация о браузере и платформе</li><li>Может влиять на выбор контента (мобильная/десктопная версия)</li></ul><p><strong>Как работает процесс:</strong></p><ol><li>Клиент отправляет запрос с заголовками Accept*</li><li>Сервер анализирует заголовки и q-факторы</li><li>Сервер выбирает наилучшее представление</li><li>Сервер возвращает выбранный контент с заголовком Content-Type</li><li>Если подходящего представления нет — 406 Not Acceptable</li></ol><p><strong>Практические примеры:</strong></p><p><strong>Формат данных:</strong></p><ul><li>API может возвращать JSON или XML в зависимости от Accept</li><li>Одна и та же страница может быть HTML или Markdown</li></ul><p><strong>Язык:</strong></p><ul><li>Сайт отображается на русском или английском</li><li>Основано на Accept-Language</li></ul><p><strong>Сжатие:</strong></p><ul><li>Сервер выбирает gzip, brotli или отправляет без сжатия</li><li>Основано на Accept-Encoding и Content-Encoding</li></ul><p><strong>Адаптивный дизайн:</strong></p><ul><li>Мобильная или десктопная версия сайта</li><li>Основано на User-Agent или специальных заголовках</li></ul><p><strong>Заголовок Vary:</strong></p><ul><li>Сервер указывает, какие заголовки влияли на выбор контента</li><li>Важно для кэширования прокси-серверами</li><li>Пример: Vary: Accept-Language, Accept-Encoding</li></ul>",
    difficulty: 'middle',
    tags: ['Content Negotiation', 'Accept', 'заголовки', 'REST']
  },
  {
    id: 9,
    question: "Что такое HTTP/2 и какие преимущества он дает по сравнению с HTTP/1.1?",
    answer: "<p><strong>HTTP/2</strong> — это обновленная версия протокола HTTP, разработанная для улучшения производительности веб-приложений.</p><p><strong>Ключевые улучшения HTTP/2:</strong></p><p><strong>1. Бинарный протокол:</strong></p><ul><li>HTTP/1.1 — текстовый протокол</li><li>HTTP/2 — бинарный, более эффективен для парсинга</li><li>Меньше ошибок при обработке</li><li>Более компактное представление данных</li></ul><p><strong>2. Мультиплексирование:</strong></p><ul><li>Множество запросов/ответов одновременно в одном TCP соединении</li><li>Решает проблему head-of-line blocking</li><li>Не нужно открывать множество параллельных соединений</li><li>Более эффективное использование сетевых ресурсов</li></ul><p><strong>3. Server Push:</strong></p><ul><li>Сервер может отправлять ресурсы до запроса клиента</li><li>Например, при запросе HTML сервер сразу отправляет CSS и JS</li><li>Уменьшает количество round-trips</li><li>Снижает время загрузки страницы</li></ul><p><strong>4. Сжатие заголовков (HPACK):</strong></p><ul><li>HTTP/1.1 не сжимает заголовки</li><li>HPACK алгоритм сжимает повторяющиеся заголовки</li><li>Особенно эффективно для множества запросов</li><li>Снижает overhead на передачу метаданных</li></ul><p><strong>5. Приоритизация потоков:</strong></p><ul><li>Клиент может указать приоритет запросов</li><li>Критичные ресурсы загружаются первыми</li><li>Оптимизация порядка загрузки</li></ul><p><strong>6. Одно соединение:</strong></p><ul><li>Требуется только одно TCP соединение на домен</li><li>Уменьшает нагрузку на сервер и клиент</li><li>Снижает латентность установки соединения</li></ul><p><strong>Сравнение с HTTP/1.1:</strong></p><p><strong>HTTP/1.1 проблемы:</strong></p><ul><li>Head-of-line blocking — следующий запрос ждет завершения предыдущего</li><li>Дублирование заголовков в каждом запросе</li><li>Необходимость domain sharding для параллельных загрузок</li><li>Конкатенация файлов для уменьшения запросов</li></ul><p><strong>HTTP/2 решения:</strong></p><ul><li>Параллельные запросы без блокировки</li><li>Сжатые заголовки</li><li>Не нужен domain sharding</li><li>Можно не конкатенировать файлы</li></ul><p><strong>Требования HTTP/2:</strong></p><ul><li>Обязательно HTTPS (хотя спецификация допускает HTTP)</li><li>Поддержка сервера и клиента</li><li>TLS 1.2 или выше</li></ul><p><strong>Практический результат:</strong></p><ul><li>Уменьшение времени загрузки страницы на 20-50%</li><li>Лучшая производительность на мобильных сетях</li><li>Меньше накладных расходов</li><li>Улучшенный пользовательский опыт</li></ul><p><strong>Ограничения:</strong></p><ul><li>Все еще может быть TCP head-of-line blocking на уровне транспорта</li><li>Сложнее отладка из-за бинарного формата</li><li>Server Push не всегда эффективен</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/2', 'производительность', 'мультиплексирование', 'оптимизация']
  },
  {
    id: 10,
    question: "Что такое кэширование в HTTP и какие механизмы для этого существуют?",
    answer: "<p><strong>HTTP кэширование</strong> — это механизм хранения копий ресурсов для уменьшения нагрузки на сервер и ускорения загрузки страниц.</p><p><strong>Основные заголовки кэширования:</strong></p><p><strong>Cache-Control (основной заголовок):</strong></p><ul><li><strong>no-cache</strong> — проверять с сервером перед использованием кэша</li><li><strong>no-store</strong> — не кэшировать вообще (конфиденциальные данные)</li><li><strong>public</strong> — может кэшироваться любыми прокси</li><li><strong>private</strong> — только в браузере пользователя</li><li><strong>max-age=3600</strong> — время жизни кэша в секундах</li><li><strong>must-revalidate</strong> — проверять после истечения</li><li><strong>immutable</strong> — контент никогда не изменится</li></ul><p><strong>Expires:</strong></p><ul><li>Устаревший способ, указывает дату истечения</li><li>Пример: Expires: Wed, 21 Oct 2025 07:28:00 GMT</li><li>Cache-Control имеет приоритет</li></ul><p><strong>Условные запросы (Validation):</strong></p><p><strong>ETag:</strong></p><ul><li>Уникальный идентификатор версии ресурса</li><li>Сервер: ETag: \"abc123\"</li><li>Клиент при следующем запросе: If-None-Match: \"abc123\"</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Last-Modified:</strong></p><ul><li>Дата последней модификации ресурса</li><li>Сервер: Last-Modified: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Клиент: If-Modified-Since: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Уровни кэширования:</strong></p><ol><li><strong>Браузерный кэш:</strong><ul><li>Локальное хранилище в браузере</li><li>Memory cache (в RAM)</li><li>Disk cache (на диске)</li></ul></li><li><strong>Прокси-кэш:</strong><ul><li>Промежуточные серверы</li><li>CDN кэширование</li><li>Корпоративные прокси</li></ul></li><li><strong>Gateway cache:</strong><ul><li>Обратные прокси перед сервером</li><li>Varnish, Nginx кэш</li></ul></li></ol><p><strong>Стратегии кэширования:</strong></p><p><strong>1. Immutable assets (статические файлы):</strong></p><ul><li>CSS, JS, изображения с хешем в имени</li><li>Cache-Control: public, max-age=31536000, immutable</li><li>Можно кэшировать навсегда, так как имя файла изменится</li></ul><p><strong>2. HTML страницы:</strong></p><ul><li>Cache-Control: no-cache или max-age=0</li><li>Всегда проверять актуальность с сервером</li></ul><p><strong>3. API ответы:</strong></p><ul><li>Зависит от данных</li><li>Часто no-cache или короткий max-age</li><li>Использовать ETag для оптимизации</li></ul><p><strong>4. Конфиденциальные данные:</strong></p><ul><li>Cache-Control: private, no-store</li><li>Не хранить в кэше вообще</li></ul><p><strong>Vary заголовок:</strong></p><ul><li>Указывает, от каких заголовков зависит кэш</li><li>Vary: Accept-Encoding, Accept-Language</li><li>Важно для корректного кэширования прокси</li></ul><p><strong>Проблемы кэширования:</strong></p><ul><li>Устаревшие данные (stale content)</li><li>Необходимость инвалидации кэша</li><li>Сложность конфигурации</li></ul><p><strong>Best practices:</strong></p><ul><li>Использовать fingerprinting/hashing для статики</li><li>Правильно настраивать Cache-Control</li><li>Использовать ETag для динамического контента</li><li>Тестировать на разных уровнях кэширования</li></ul>",
    difficulty: 'middle',
    tags: ['кэширование', 'Cache-Control', 'ETag', 'производительность']
  },
  {
    id: 11,
    question: "Что такое CORS и как он работает в контексте HTTP?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм безопасности, позволяющий веб-страницам делать запросы к другим доменам с соблюдением политики безопасности.</p><p><strong>Same-Origin Policy (проблема):</strong></p><ul><li>Браузеры блокируют межсайтовые запросы по умолчанию</li><li>Защита от кражи данных злонамеренными сайтами</li><li>Origin = протокол + домен + порт</li><li>http://example.com:80 ≠ https://example.com:443</li></ul><p><strong>Как CORS решает проблему:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и добавляет CORS заголовки</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Типы CORS запросов:</strong></p><p><strong>1. Простые запросы (Simple requests):</strong></p><ul><li>Методы: GET, HEAD, POST</li><li>Только простые заголовки (Content-Type: text/plain, application/x-www-form-urlencoded, multipart/form-data)</li><li>Отправляются сразу без preflight</li></ul><p><strong>2. Preflight запросы:</strong></p><ul><li>Для сложных запросов (PUT, DELETE, custom headers)</li><li>Браузер сначала отправляет OPTIONS запрос</li><li>Сервер отвечает разрешенными методами и заголовками</li><li>Затем отправляется основной запрос</li></ul><p><strong>Основные CORS заголовки:</strong></p><p><strong>Со стороны клиента:</strong></p><ul><li><strong>Origin</strong> — источник запроса (автоматически добавляется браузером)</li></ul><p><strong>Со стороны сервера:</strong></p><ul><li><strong>Access-Control-Allow-Origin</strong> — разрешенные origins (* или конкретный origin)</li><li><strong>Access-Control-Allow-Methods</strong> — разрешенные HTTP методы</li><li><strong>Access-Control-Allow-Headers</strong> — разрешенные заголовки</li><li><strong>Access-Control-Allow-Credentials</strong> — разрешить cookies и authorization (true/false)</li><li><strong>Access-Control-Max-Age</strong> — время кэширования preflight ответа</li><li><strong>Access-Control-Expose-Headers</strong> — какие заголовки ответа доступны клиенту</li></ul><p><strong>Процесс Preflight:</strong></p><ol><li>Браузер отправляет OPTIONS запрос:<ul><li>Origin: https://example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Content-Type</li></ul></li><li>Сервер отвечает:<ul><li>Access-Control-Allow-Origin: https://example.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul></li><li>Если разрешено — браузер отправляет основной запрос</li></ol><p><strong>Credentials (cookies):</strong></p><ul><li>По умолчанию cookies не отправляются в cross-origin запросах</li><li>Нужно установить credentials: 'include' в fetch</li><li>Сервер должен вернуть Access-Control-Allow-Credentials: true</li><li>И конкретный origin, не * (для безопасности)</li></ul><p><strong>Типичные ошибки CORS:</strong></p><ul><li>Забыли добавить CORS заголовки на сервере</li><li>Неправильная настройка Access-Control-Allow-Origin</li><li>Использование * с credentials</li><li>Не обрабатывается OPTIONS preflight запрос</li></ul><p><strong>Решение проблем CORS:</strong></p><ul><li>Правильная настройка сервера</li><li>Использование прокси для разработки</li><li>JSONP (устаревший способ)</li><li>Server-side запросы (без ограничений CORS)</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'безопасность', 'cross-origin', 'Same-Origin Policy']
  },
  {
    id: 12,
    question: "Что такое Keep-Alive соединение и как оно улучшает производительность?",
    answer: "<p><strong>Keep-Alive (persistent connection)</strong> — это механизм, позволяющий повторно использовать одно TCP соединение для множества HTTP запросов/ответов.</p><p><strong>Как работало в HTTP/1.0:</strong></p><ul><li>Каждый запрос требовал нового TCP соединения</li><li>Соединение закрывалось после ответа</li><li>Высокие накладные расходы на установку/закрытие соединений</li></ul><p><strong>Keep-Alive в HTTP/1.1:</strong></p><ul><li>Соединение остается открытым по умолчанию</li><li>Множество запросов через одно соединение</li><li>Заголовок Connection: keep-alive (или по умолчанию)</li><li>Connection: close для явного закрытия</li></ul><p><strong>Преимущества Keep-Alive:</strong></p><p><strong>1. Снижение латентности:</strong></p><ul><li>Нет накладных расходов на TCP handshake для каждого запроса</li><li>TCP handshake занимает 1 RTT (Round Trip Time)</li><li>Экономия особенно заметна на высоколатентных соединениях</li></ul><p><strong>2. Снижение нагрузки:</strong></p><ul><li>Меньше нагрузки на сервер</li><li>Меньше создания/уничтожения сокетов</li><li>Экономия CPU и памяти</li></ul><p><strong>3. TLS эффективность:</strong></p><ul><li>Для HTTPS не нужно повторять TLS handshake</li><li>TLS handshake очень дорогая операция</li><li>Значительная экономия времени</li></ul><p><strong>4. TCP оптимизации:</strong></p><ul><li>TCP slow start работает эффективнее</li><li>Соединение \"разогревается\" и достигает полной пропускной способности</li><li>Congestion window растет с каждым пакетом</li></ul><p><strong>Параметры Keep-Alive:</strong></p><p><strong>Keep-Alive заголовок:</strong></p><ul><li>timeout — время простоя до закрытия (секунды)</li><li>max — максимальное количество запросов</li><li>Пример: Keep-Alive: timeout=5, max=100</li></ul><p><strong>Конфигурация сервера:</strong></p><ul><li>Nginx: keepalive_timeout 65;</li><li>Apache: KeepAlive On, KeepAliveTimeout 5</li></ul><p><strong>Проблемы Keep-Alive:</strong></p><p><strong>1. Head-of-line blocking (HTTP/1.1):</strong></p><ul><li>Запросы обрабатываются последовательно</li><li>Медленный запрос блокирует остальные</li><li>Решено в HTTP/2 через мультиплексирование</li></ul><p><strong>2. Ресурсы сервера:</strong></p><ul><li>Открытые соединения потребляют память</li><li>Нужен баланс между timeout и ресурсами</li><li>При большом количестве клиентов может быть проблемой</li></ul><p><strong>3. Idle соединения:</strong></p><ul><li>Простаивающие соединения занимают ресурсы</li><li>Firewall может разрывать долгие соединения</li><li>Нужны правильные timeout настройки</li></ul><p><strong>HTTP/2 и Keep-Alive:</strong></p><ul><li>В HTTP/2 концепция Keep-Alive встроена</li><li>Одно долгоживущее соединение на домен</li><li>Мультиплексирование решает проблему blocking</li><li>Еще более эффективное использование соединений</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда включать Keep-Alive (по умолчанию в HTTP/1.1)</li><li>Настраивать разумные timeout (5-15 секунд)</li><li>Ограничивать max запросов (100-1000)</li><li>Мониторить количество открытых соединений</li><li>Использовать HTTP/2 где возможно</li></ul><p><strong>Когда отключать Keep-Alive:</strong></p><ul><li>Один запрос к серверу (очень редкий случай)</li><li>Ограниченные ресурсы сервера</li><li>Специфические security требования</li></ul>",
    difficulty: 'senior',
    tags: ['Keep-Alive', 'persistent connection', 'производительность', 'TCP']
  },
  {
    id: 13,
    question: "Что такое HTTP cookies и как они работают? Какие атрибуты безопасности существуют?",
    answer: "<p><strong>HTTP Cookies</strong> — это небольшие фрагменты данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с последующими запросами.</p><p><strong>Как работают cookies:</strong></p><ol><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>Браузер автоматически отправляет cookie с каждым запросом через заголовок Cookie</li><li>Cookie существует до истечения срока или удаления</li></ol><p><strong>Установка cookie (Set-Cookie):</strong></p><ul><li>Set-Cookie: sessionId=abc123; Domain=example.com; Path=/; Max-Age=3600</li></ul><p><strong>Основные атрибуты cookie:</strong></p><p><strong>1. Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — дата истечения (Expires=Wed, 09 Jun 2025 10:18:14 GMT)</li><li><strong>Max-Age</strong> — время жизни в секундах (Max-Age=3600 для 1 часа)</li><li>Без этих атрибутов — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>2. Domain:</strong></p><ul><li>Для каких доменов доступна cookie</li><li>Domain=example.com — доступна для example.com и поддоменов</li><li>По умолчанию — только текущий домен, без поддоменов</li></ul><p><strong>3. Path:</strong></p><ul><li>Для каких путей доступна cookie</li><li>Path=/admin — только для URL начинающихся с /admin</li><li>Path=/ — для всего сайта</li></ul><p><strong>Атрибуты безопасности:</strong></p><p><strong>1. Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязательно для конфиденциальных данных</li><li>Set-Cookie: token=abc; Secure</li></ul><p><strong>2. HttpOnly:</strong></p><ul><li>Cookie недоступна для JavaScript (document.cookie)</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить cookie</li><li>Set-Cookie: sessionId=abc; HttpOnly</li></ul><p><strong>3. SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li><strong>SameSite=Strict</strong> — cookie только для same-site запросов (самая строгая защита от CSRF)</li><li><strong>SameSite=Lax</strong> — cookie для top-level navigation (GET), защита от большинства CSRF (по умолчанию в современных браузерах)</li><li><strong>SameSite=None</strong> — cookie отправляется всегда (требует Secure)</li></ul><p><strong>Типы cookies по назначению:</strong></p><p><strong>1. Session cookies:</strong></p><ul><li>Идентификация пользовательской сессии</li><li>Обычно HttpOnly и Secure</li></ul><p><strong>2. Persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Имеют Expires или Max-Age</li></ul><p><strong>3. Third-party cookies:</strong></p><ul><li>Устанавливаются другими доменами (реклама, аналитика)</li><li>Часто блокируются браузерами</li></ul><p><strong>Ограничения cookies:</strong></p><ul><li>Размер: обычно 4KB на cookie</li><li>Количество: ~50 cookies на домен, ~3000 total</li><li>Автоматически отправляются с каждым запросом (overhead)</li></ul><p><strong>Проблемы безопасности:</strong></p><p><strong>1. CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт использует ваши cookies</li><li>Решение: SameSite, CSRF токены</li></ul><p><strong>2. XSS (Cross-Site Scripting):</strong></p><ul><li>JavaScript может украсть cookies</li><li>Решение: HttpOnly, Content Security Policy</li></ul><p><strong>3. Session hijacking:</strong></p><ul><li>Перехват session cookie</li><li>Решение: Secure, HttpOnly, короткие сессии, регенерация session ID</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда использовать Secure для чувствительных данных</li><li>HttpOnly для session cookies</li><li>SameSite=Lax минимум, Strict для критичных операций</li><li>Минимальный срок жизни</li><li>Не хранить конфиденциальные данные в cookies</li><li>Регулярная регенерация session ID</li></ul><p><strong>Альтернативы cookies:</strong></p><ul><li>localStorage/sessionStorage — но доступны для JavaScript</li><li>IndexedDB — для больших объемов данных</li><li>JWT токены в Authorization header — не отправляются автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['cookies', 'безопасность', 'SameSite', 'HttpOnly', 'Secure']
  },
  {
    id: 14,
    question: "Что такое Range requests и как они используются в HTTP?",
    answer: "<p><strong>Range requests</strong> — это механизм HTTP, позволяющий запрашивать только часть ресурса вместо всего файла целиком.</p><p><strong>Зачем нужны Range requests:</strong></p><ul><li>Возобновление прерванной загрузки</li><li>Потоковая передача видео/аудио</li><li>Параллельная загрузка частей файла</li><li>Загрузка только нужного фрагмента большого файла</li><li>Экономия трафика</li></ul><p><strong>Как работает Range request:</strong></p><p><strong>1. Проверка поддержки:</strong></p><ul><li>Клиент отправляет HEAD запрос</li><li>Сервер отвечает заголовком Accept-Ranges: bytes</li><li>Если Accept-Ranges: none — range requests не поддерживаются</li></ul><p><strong>2. Запрос диапазона:</strong></p><ul><li>Клиент отправляет GET с заголовком Range</li><li>Range: bytes=0-1023 — первые 1024 байта</li><li>Range: bytes=1024-2047 — следующие 1024 байта</li><li>Range: bytes=1024- — от 1024 байта до конца</li><li>Range: bytes=-1024 — последние 1024 байта</li></ul><p><strong>3. Ответ сервера:</strong></p><ul><li>Статус 206 Partial Content</li><li>Content-Range: bytes 0-1023/5000 (диапазон/общий размер)</li><li>Content-Length: 1024 (размер этой части)</li><li>Тело ответа содержит запрошенные байты</li></ul><p><strong>Множественные диапазоны:</strong></p><ul><li>Range: bytes=0-100, 200-300</li><li>Ответ в формате multipart/byteranges</li><li>Каждая часть с собственными заголовками</li></ul><p><strong>Практические применения:</strong></p><p><strong>1. Возобновление загрузки:</strong></p><ol><li>Загрузка началась, загружено 5000 байт</li><li>Соединение прервалось</li><li>Клиент запрашивает Range: bytes=5000-</li><li>Загрузка продолжается с того же места</li></ol><p><strong>2. Видео стриминг:</strong></p><ul><li>Браузер загружает видео частями</li><li>При перемотке запрашивает нужный диапазон</li><li>Не нужно загружать весь файл</li></ul><p><strong>3. PDF viewer:</strong></p><ul><li>Загрузка только видимых страниц</li><li>Остальные загружаются по требованию</li></ul><p><strong>4. Параллельная загрузка:</strong></p><ul><li>Download managers разбивают файл на части</li><li>Каждая часть загружается параллельно</li><li>Увеличение скорости загрузки</li></ul><p><strong>Условные Range requests:</strong></p><ul><li>If-Range заголовок для проверки изменений</li><li>If-Range: \"etag-value\" или дата Last-Modified</li><li>Если файл изменился — возвращает весь файл (200)</li><li>Если нет — возвращает диапазон (206)</li></ul><p><strong>Заголовки для Range requests:</strong></p><p><strong>Запрос:</strong></p><ul><li>Range: bytes=start-end</li><li>If-Range: ETag или Last-Modified</li></ul><p><strong>Ответ:</strong></p><ul><li>Accept-Ranges: bytes (или none)</li><li>Content-Range: bytes start-end/total</li><li>Content-Length: size</li><li>ETag: \"version\"</li></ul><p><strong>Возможные ответы:</strong></p><ul><li><strong>206 Partial Content</strong> — успешная частичная отдача</li><li><strong>200 OK</strong> — если If-Range не совпал или не поддерживается</li><li><strong>416 Range Not Satisfiable</strong> — запрошенный диапазон вне границ</li></ul><p><strong>Ограничения и проблемы:</strong></p><ul><li>Не все серверы поддерживают Range requests</li><li>Динамический контент сложно отдавать по частям</li><li>Нужна правильная настройка кэширования</li><li>ETag/Last-Modified важны для консистентности</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда возвращать Accept-Ranges для статических файлов</li><li>Использовать ETag для динамического контента</li><li>Корректно обрабатывать некорректные диапазоны</li><li>Поддерживать If-Range для оптимизации</li></ul>",
    difficulty: 'senior',
    tags: ['Range requests', 'частичная загрузка', 'стриминг', 'производительность']
  },
  {
    id: 15,
    question: "Что такое HTTP/3 и QUIC, какие проблемы они решают?",
    answer: "<p><strong>HTTP/3</strong> — это новая версия HTTP протокола, работающая поверх QUIC вместо TCP.</p><p><strong>QUIC (Quick UDP Internet Connections):</strong></p><ul><li>Транспортный протокол от Google, теперь стандартизован IETF</li><li>Работает поверх UDP вместо TCP</li><li>Встроенное шифрование (TLS 1.3)</li><li>Мультиплексирование на уровне транспорта</li></ul><p><strong>Проблемы HTTP/2, которые решает HTTP/3:</strong></p><p><strong>1. TCP Head-of-Line Blocking:</strong></p><ul><li>В HTTP/2 потерянный TCP пакет блокирует все потоки</li><li>TCP гарантирует порядок доставки на уровне протокола</li><li>QUIC решает: независимые потоки на уровне транспорта</li><li>Потеря пакета влияет только на один поток</li></ul><p><strong>2. Медленное установление соединения:</strong></p><ul><li>TCP + TLS требуют 2-3 RTT для начала передачи данных</li><li>TCP handshake (1 RTT) + TLS handshake (1-2 RTT)</li><li>QUIC: 0-RTT или 1-RTT для установки соединения</li><li>Встроенное шифрование ускоряет процесс</li></ul><p><strong>3. Connection migration:</strong></p><ul><li>TCP соединение привязано к IP адресу и порту</li><li>Смена сети (WiFi на LTE) = новое соединение</li><li>QUIC: Connection ID не зависит от IP</li><li>Плавное переключение между сетями без разрыва</li></ul><p><strong>Ключевые особенности HTTP/3:</strong></p><p><strong>1. Мультиплексирование без блокировки:</strong></p><ul><li>Истинное мультиплексирование на транспортном уровне</li><li>Потоки полностью независимы</li><li>Нет head-of-line blocking</li></ul><p><strong>2. Быстрое установление соединения:</strong></p><ul><li>0-RTT для повторных соединений (resume)</li><li>1-RTT для новых соединений</li><li>Данные могут отправляться в первом пакете</li></ul><p><strong>3. Встроенное шифрование:</strong></p><ul><li>TLS 1.3 интегрирован в QUIC</li><li>Нельзя использовать QUIC без шифрования</li><li>Защита метаданных соединения</li></ul><p><strong>4. Улучшенная обработка потерь:</strong></p><ul><li>Более точное определение потерь пакетов</li><li>Быстрое восстановление</li><li>Лучшая работа на нестабильных сетях</li></ul><p><strong>5. Гибкость:</strong></p><ul><li>Протокол реализован в пространстве пользователя</li><li>Обновления без изменения ОС</li><li>Быстрая эволюция протокола</li></ul><p><strong>Преимущества для пользователей:</strong></p><ul><li>Быстрее загрузка страниц, особенно на мобильных сетях</li><li>Лучше работа при потере пакетов</li><li>Плавное переключение между сетями</li><li>Меньше латентности для первого запроса</li></ul><p><strong>UDP и проблемы:</strong></p><p><strong>Почему UDP:</strong></p><ul><li>TCP \"зашит\" в ОС и его сложно изменять</li><li>UDP — простой протокол, гибкая основа</li><li>Можно реализовать нужную функциональность поверх</li></ul><p><strong>Проблемы UDP:</strong></p><ul><li>Некоторые сети блокируют UDP трафик</li><li>Firewall и middlebox могут не пропускать</li><li>Необходим fallback на HTTP/2</li></ul><p><strong>Поддержка и внедрение:</strong></p><ul><li>Уже используется Google, Facebook, Cloudflare</li><li>Поддерживается современными браузерами</li><li>Постепенное внедрение с fallback на HTTP/2</li></ul><p><strong>Особенности разработки:</strong></p><ul><li>Прозрачно для приложений</li><li>Поддержка на уровне сервера и CDN</li><li>Браузер автоматически выбирает протокол</li><li>Alt-Svc заголовок для обнаружения HTTP/3</li></ul><p><strong>Когда HTTP/3 особенно эффективен:</strong></p><ul><li>Мобильные сети с потерями пакетов</li><li>Частая смена сетей (WiFi ↔ LTE)</li><li>Высоколатентные соединения</li><li>Множество параллельных запросов</li></ul><p><strong>Ограничения:</strong></p><ul><li>Потребление CPU (шифрование/дешифрование в userspace)</li><li>Не везде поддерживается UDP</li><li>Новый протокол, возможны проблемы совместимости</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/3', 'QUIC', 'UDP', 'производительность', 'современные протоколы']
  },

  {
    id: 16,
    question: "Что такое Cookie и для чего они используются в веб-разработке?",
    answer: "<p><strong>Cookie</strong> — это небольшие фрагменты текстовых данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с каждым последующим запросом к этому серверу.</p><p><strong>Основные цели использования:</strong></p><ul><li><strong>Управление сессиями</strong> — авторизация пользователя, корзина покупок, игровые очки</li><li><strong>Персонализация</strong> — пользовательские настройки, темы, языковые предпочтения</li><li><strong>Отслеживание</strong> — анализ поведения пользователей, рекламные кампании</li></ul><p><strong>Как работают:</strong></p><ul><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie и автоматически отправляет с каждым запросом через заголовок Cookie</li><li>Cookie привязаны к домену и пути</li></ul><p>Cookie были одним из первых механизмов для сохранения состояния в HTTP, который изначально был stateless протоколом. Несмотря на появление современных альтернатив вроде localStorage, cookie остаются важным инструментом, особенно для аутентификации.</p>",
    difficulty: 'junior',
    tags: ['Cookie', 'HTTP', 'основы', 'состояние']
  },
  {
    id: 17,
    question: "Какие атрибуты может иметь Cookie и что они означают?",
    answer: "<p>Cookie могут иметь несколько важных атрибутов, которые контролируют их поведение:</p><p><strong>Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — конкретная дата истечения cookie</li><li><strong>Max-Age</strong> — время жизни в секундах</li><li>Если не указаны — cookie становится session cookie и удаляется при закрытии браузера</li></ul><p><strong>Domain:</strong></p><ul><li>Определяет, на каких доменах будет доступен cookie</li><li>По умолчанию — текущий домен без поддоменов</li><li>Можно указать родительский домен для доступа с поддоменов</li></ul><p><strong>Path:</strong></p><ul><li>Определяет путь на сервере, для которого валиден cookie</li><li>По умолчанию — текущий путь</li><li>Path=/admin означает, что cookie доступен только для /admin и вложенных путей</li></ul><p><strong>Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Критически важен для защиты конфиденциальных данных</li></ul><p><strong>HttpOnly:</strong></p><ul><li>Cookie недоступен через JavaScript (document.cookie)</li><li>Защищает от XSS-атак</li></ul><p><strong>SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li>Защищает от CSRF-атак</li></ul><p>Правильная комбинация этих атрибутов критически важна для безопасности приложения.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'атрибуты', 'безопасность', 'HTTP']
  },
  {
    id: 18,
    question: "Объясните разницу между session cookies и persistent cookies",
    answer: "<p><strong>Session Cookies</strong> и <strong>Persistent Cookies</strong> различаются по времени жизни:</p><p><strong>Session Cookies (сессионные):</strong></p><ul><li>Не имеют атрибутов Expires или Max-Age</li><li>Существуют только во время сеанса браузера</li><li>Удаляются автоматически при закрытии браузера</li><li>Хранятся только в памяти</li></ul><p><strong>Типичное применение сессионных cookie:</strong></p><ul><li>Временная аутентификация в рамках сессии</li><li>Состояние формы во время заполнения</li><li>Временные настройки интерфейса</li></ul><p><strong>Persistent Cookies (постоянные):</strong></p><ul><li>Имеют явно указанный Expires или Max-Age</li><li>Сохраняются на диск</li><li>Остаются после закрытия браузера</li><li>Живут до истечения срока или явного удаления</li></ul><p><strong>Типичное применение постоянных cookie:</strong></p><ul><li>Функция 'Запомнить меня' при входе</li><li>Долгосрочные пользовательские настройки</li><li>Аналитика и отслеживание</li></ul><p><strong>Важное замечание:</strong> Современные браузеры могут восстанавливать сессионные cookie при 'восстановлении сессии', что размывает границу между типами. Для критичной безопасности полагайтесь на серверную валидацию, а не только на тип cookie.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'session', 'persistent', 'время жизни']
  },
  {
    id: 19,
    question: "Что такое SameSite атрибут и какие значения он может принимать?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, который контролирует отправку cookie в cross-site контексте, защищая от CSRF-атак.</p><p><strong>Три возможных значения:</strong></p><p><strong>SameSite=Strict:</strong></p><ul><li>Самый строгий режим</li><li>Cookie отправляется только для same-site запросов</li><li>Не отправляется при переходе на сайт по внешней ссылке</li><li>Идеально для критичных операций (управление аккаунтом, платежи)</li></ul><p><strong>SameSite=Lax (по умолчанию):</strong></p><ul><li>Баланс между безопасностью и удобством</li><li>Cookie отправляется при top-level навигации (переход по ссылке)</li><li>Не отправляется для подзапросов (img, iframe, fetch с других доменов)</li><li>Подходит для большинства сценариев аутентификации</li></ul><p><strong>SameSite=None:</strong></p><ul><li>Cookie отправляется во всех контекстах</li><li>Требует атрибута Secure (только HTTPS)</li><li>Необходим для легитимных cross-site сценариев (встроенные виджеты, OAuth)</li></ul><p><strong>Практическое значение:</strong> С введением SameSite=Lax по умолчанию, многие старые интеграции перестали работать. Важно явно указывать SameSite=None; Secure для легитимных cross-site использований.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'SameSite', 'CSRF', 'безопасность']
  },
  {
    id: 20,
    question: "Как Cookie связаны с безопасностью? Какие угрозы они создают?",
    answer: "<p>Cookie создают несколько <strong>серьезных векторов атак</strong>, которые нужно понимать и защищать:</p><p><strong>XSS (Cross-Site Scripting):</strong></p><ul><li>Злоумышленник внедряет JavaScript, который читает document.cookie</li><li>Получает доступ к session cookie и может захватить сессию</li><li><strong>Защита:</strong> HttpOnly атрибут делает cookie недоступным для JavaScript</li></ul><p><strong>CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт отправляет запросы от имени пользователя</li><li>Браузер автоматически прикрепляет cookie к запросам</li><li><strong>Защита:</strong> SameSite атрибут, CSRF-токены</li></ul><p><strong>Session Hijacking:</strong></p><ul><li>Перехват cookie через незащищенное соединение</li><li>Man-in-the-Middle атаки</li><li><strong>Защита:</strong> Secure атрибут (только HTTPS), HSTS</li></ul><p><strong>Cookie Injection:</strong></p><ul><li>Подмена или подделка cookie</li><li>Эксплуатация уязвимостей в приложении</li><li><strong>Защита:</strong> Подпись cookie, валидация на сервере</li></ul><p><strong>Tracking и Privacy:</strong></p><ul><li>Third-party cookie для отслеживания между сайтами</li><li>Нарушение приватности пользователей</li><li><strong>Защита:</strong> Ограничения браузеров на third-party cookie</li></ul><p><strong>Комплексная защита:</strong> Используйте HttpOnly, Secure, SameSite вместе, валидируйте на сервере, минимизируйте хранение чувствительных данных в cookie.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'безопасность', 'XSS', 'CSRF', 'атаки']
  },
  {
    id: 21,
    question: "В чем разница между first-party и third-party cookies?",
    answer: "<p><strong>First-party cookies</strong> и <strong>third-party cookies</strong> различаются по происхождению и назначению:</p><p><strong>First-party cookies:</strong></p><ul><li>Устанавливаются доменом, который пользователь посещает</li><li>Домен cookie совпадает с доменом в адресной строке</li><li>Используются для функциональности самого сайта</li><li>Примеры: аутентификация, настройки, корзина</li></ul><p><strong>Third-party cookies:</strong></p><ul><li>Устанавливаются доменом, отличным от посещаемого</li><li>Обычно через встроенный контент (скрипты, iframe, изображения)</li><li>Используются для отслеживания между сайтами</li><li>Примеры: реклама, аналитика, социальные виджеты</li></ul><p><strong>Как определить тип:</strong></p><ul><li>Если вы на example.com и cookie от example.com — first-party</li><li>Если cookie от analytics.com или ads.com — third-party</li></ul><p><strong>Современные тенденции:</strong></p><ul><li>Браузеры активно блокируют third-party cookies</li><li>Safari и Firefox блокируют по умолчанию</li><li>Chrome планирует полностью отказаться</li><li>Причина: защита приватности пользователей</li></ul><p><strong>Альтернативы для легитимного использования:</strong></p><ul><li>Storage Access API для необходимых сценариев</li><li>FLoC и Topics API от Google</li><li>Server-side решения</li></ul><p><em>Важно:</em> Если ваше приложение зависит от third-party cookies, нужно планировать миграцию на альтернативные решения.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'first-party', 'third-party', 'приватность', 'отслеживание']
  },
  {
    id: 22,
    question: "Какие ограничения существуют на размер и количество Cookie?",
    answer: "<p>Cookie имеют <strong>строгие технические ограничения</strong>, которые важно учитывать:</p><p><strong>Размер одного cookie:</strong></p><ul><li>Максимум около 4KB (4096 байт)</li><li>Включает имя, значение и все атрибуты</li><li>Превышение приводит к обрезанию или отклонению cookie</li></ul><p><strong>Количество cookie на домен:</strong></p><ul><li>Обычно ограничено 50-180 cookie на домен</li><li>Разные браузеры имеют разные лимиты</li><li>При превышении старые cookie удаляются</li></ul><p><strong>Общее количество cookie:</strong></p><ul><li>Около 3000 cookie на весь браузер</li><li>Варьируется между браузерами</li></ul><p><strong>Практические последствия:</strong></p><ul><li><strong>Производительность:</strong> Каждый cookie добавляется к каждому HTTP-запросу, увеличивая размер</li><li><strong>Overhead:</strong> Большое количество cookie замедляет запросы</li><li><strong>Потеря данных:</strong> Старые cookie могут быть вытеснены новыми</li></ul><p><strong>Лучшие практики:</strong></p><ul><li>Минимизируйте размер и количество cookie</li><li>Используйте короткие имена</li><li>Не храните большие объемы данных в cookie</li><li>Для больших данных используйте sessionStorage/localStorage</li><li>Используйте Path и Domain для ограничения отправки</li></ul><p><em>Золотое правило:</em> Cookie для идентификации и аутентификации, а не для хранения данных.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'ограничения', 'производительность', 'размер']
  },
  {
    id: 23,
    question: "Как работать с Cookie через JavaScript? Какие есть API?",
    answer: "<p>Работа с cookie через JavaScript возможна, но имеет свои особенности:</p><p><strong>document.cookie API:</strong></p><p>Это <strong>единственный нативный способ</strong> работы с cookie в браузере, но он не очень удобен:</p><ul><li>Чтение: document.cookie возвращает строку со всеми cookie</li><li>Запись: присваивание строки document.cookie создает/обновляет cookie</li><li>Удаление: установка cookie с датой в прошлом</li></ul><p><strong>Особенности document.cookie:</strong></p><ul><li>Не перезаписывает все cookie, а добавляет/обновляет один</li><li>Требует ручного парсинга строки для чтения</li><li>Нужно вручную форматировать атрибуты</li><li>HttpOnly cookie недоступны через JavaScript</li></ul><p><strong>Современные библиотеки:</strong></p><ul><li>js-cookie — популярная легковесная библиотека</li><li>universal-cookie — поддержка SSR</li><li>cookie-parser (Node.js) — для работы на сервере</li></ul><p><strong>Cookie Store API (экспериментальный):</strong></p><ul><li>Современный асинхронный API для работы с cookie</li><li>Более удобный и предсказуемый интерфейс</li><li>Поддержка событий изменения cookie</li><li>Пока ограниченная поддержка браузерами</li></ul><p><strong>Лучшие практики:</strong></p><ul><li>Используйте HttpOnly для чувствительных cookie</li><li>Валидируйте данные перед записью</li><li>Используйте библиотеки вместо ручного парсинга</li><li>Помните о синхронности document.cookie</li></ul>",
    difficulty: 'middle',
    tags: ['Cookie', 'JavaScript', 'API', 'document.cookie']
  },
  {
    id: 24,
    question: "Чем Cookie отличаются от localStorage и sessionStorage?",
    answer: "<p>Cookie, localStorage и sessionStorage — это три разных механизма хранения данных с различными характеристиками:</p><p><strong>Cookie:</strong></p><ul><li><strong>Размер:</strong> ~4KB</li><li><strong>Отправка:</strong> Автоматически с каждым HTTP-запросом</li><li><strong>Доступ:</strong> Клиент и сервер</li><li><strong>Истечение:</strong> Настраиваемое (session или persistent)</li><li><strong>Область:</strong> По домену и пути</li></ul><p><strong>localStorage:</strong></p><ul><li><strong>Размер:</strong> ~5-10MB</li><li><strong>Отправка:</strong> Никогда не отправляется автоматически</li><li><strong>Доступ:</strong> Только клиент (JavaScript)</li><li><strong>Истечение:</strong> Постоянное, пока не удалено явно</li><li><strong>Область:</strong> По origin (протокол + домен + порт)</li></ul><p><strong>sessionStorage:</strong></p><ul><li><strong>Размер:</strong> ~5-10MB</li><li><strong>Отправка:</strong> Никогда не отправляется</li><li><strong>Доступ:</strong> Только клиент</li><li><strong>Истечение:</strong> Удаляется при закрытии вкладки/окна</li><li><strong>Область:</strong> По origin + вкладка</li></ul><p><strong>Когда использовать:</strong></p><ul><li><strong>Cookie:</strong> Аутентификация, данные нужные серверу</li><li><strong>localStorage:</strong> Долгосрочные настройки, кеширование</li><li><strong>sessionStorage:</strong> Временное состояние в рамках сессии</li></ul><p><strong>Важно:</strong> Все три механизма доступны только для same-origin и не защищены от XSS. Не храните чувствительные данные без дополнительной защиты.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'localStorage', 'sessionStorage', 'хранилище', 'сравнение']
  },
  {
    id: 25,
    question: "Как реализовать функцию 'Запомнить меня' с использованием Cookie?",
    answer: "<p>Функция <strong>'Запомнить меня'</strong> требует тщательного подхода к безопасности:</p><p><strong>Архитектура решения:</strong></p><p><strong>1. Два типа сессий:</strong></p><ul><li>Обычная сессия — session cookie (удаляется при закрытии браузера)</li><li>'Запомнить меня' — persistent cookie с длительным сроком (например, 30 дней)</li></ul><p><strong>2. Токен-based подход (безопасный):</strong></p><ul><li>Генерируется криптографически стойкий случайный токен</li><li>Токен хешируется и сохраняется в БД</li><li>В cookie хранится только токен, а не user_id</li><li>При каждом запросе токен валидируется на сервере</li></ul><p><strong>3. Атрибуты cookie:</strong></p><ul><li>HttpOnly — защита от XSS</li><li>Secure — только HTTPS</li><li>SameSite=Lax или Strict — защита от CSRF</li><li>Max-Age или Expires — срок действия</li></ul><p><strong>Дополнительные меры безопасности:</strong></p><ul><li><strong>Ротация токенов:</strong> Обновление при каждом использовании</li><li><strong>Device fingerprinting:</strong> Привязка токена к устройству</li><li><strong>Список активных сессий:</strong> Возможность отозвать токен</li><li><strong>Периодическая реаутентификация:</strong> Для критичных операций</li></ul><p><strong>Плохие практики (не делайте так):</strong></p><ul><li>Хранение user_id напрямую в cookie</li><li>Использование предсказуемых токенов</li><li>Отсутствие валидации на сервере</li><li>Хранение паролей в cookie</li></ul>",
    difficulty: 'senior',
    tags: ['Cookie', 'аутентификация', 'запомнить меня', 'безопасность', 'токены']
  },
  {
    id: 26,
    question: "Как работает механизм подписи Cookie и зачем он нужен?",
    answer: "<p><strong>Подпись cookie</strong> — это механизм для проверки целостности и подлинности данных в cookie:</p><p><strong>Принцип работы:</strong></p><ul><li>Сервер создает криптографическую подпись значения cookie</li><li>Подпись добавляется к значению cookie</li><li>При получении cookie сервер проверяет подпись</li><li>Если подпись не совпадает — cookie был изменен или подделан</li></ul><p><strong>Типичная реализация:</strong></p><ul><li>Используется HMAC (Hash-based Message Authentication Code)</li><li>Секретный ключ известен только серверу</li><li>Значение cookie: value.signature</li><li>Подпись вычисляется как HMAC(secret_key, value)</li></ul><p><strong>Защита от атак:</strong></p><ul><li><strong>Tampering:</strong> Невозможно изменить значение без знания секретного ключа</li><li><strong>Forgery:</strong> Нельзя создать валидный cookie без секрета</li><li><strong>Целостность:</strong> Гарантия, что данные не изменились</li></ul><p><strong>Ограничения:</strong></p><ul><li><strong>Не шифрование:</strong> Данные видны, только защищены от изменения</li><li><strong>Не подлинность пользователя:</strong> Только целостность данных</li><li><strong>Replay атаки:</strong> Нужны дополнительные меры (timestamp, nonce)</li></ul><p><strong>Библиотеки:</strong></p><ul><li>Express.js: cookie-parser с secret</li><li>Django: signed cookies встроены</li><li>Rails: ActionDispatch::Cookies</li></ul><p><strong>Best practice:</strong> Используйте подпись для всех cookie, которые влияют на логику приложения. Для чувствительных данных используйте шифрование в дополнение к подписи.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'подпись', 'HMAC', 'безопасность', 'целостность']
  },
  {
    id: 27,
    question: "Какие проблемы возникают с Cookie в мобильных приложениях?",
    answer: "<p>Работа с cookie в мобильных приложениях создает <strong>уникальные вызовы</strong>:</p><p><strong>WebView и нативный код:</strong></p><ul><li><strong>Разные cookie stores:</strong> WebView и нативные HTTP-клиенты используют разные хранилища</li><li><strong>Синхронизация:</strong> Требуется явная синхронизация cookie между контекстами</li><li><strong>API различия:</strong> iOS и Android имеют разные API для работы с cookie</li></ul><p><strong>Проблемы безопасности:</strong></p><ul><li><strong>SSL Pinning:</strong> Может конфликтовать с отладкой cookie</li><li><strong>Доступ к cookie:</strong> Более сложный контроль доступа</li><li><strong>Backup:</strong> Cookie могут попасть в резервные копии</li></ul><p><strong>Особенности платформ:</strong></p><p><strong>iOS:</strong></p><ul><li>WKWebView имеет собственное cookie-хранилище</li><li>Требуется WKHTTPCookieStore для синхронизации</li><li>Ограничения на third-party cookie более строгие</li></ul><p><strong>Android:</strong></p><ul><li>CookieManager для работы с cookie в WebView</li><li>Нативный HttpURLConnection использует CookieHandler</li><li>Проще синхронизация, но больше вариативности</li></ul><p><strong>Альтернативные решения:</strong></p><ul><li><strong>Token в headers:</strong> Вместо cookie использовать Authorization header</li><li><strong>Secure Storage:</strong> Keychain (iOS) или KeyStore (Android)</li><li><strong>Custom session management:</strong> Собственная реализация</li></ul><p><strong>Best practices:</strong></p><ul><li>Минимизируйте зависимость от cookie</li><li>Используйте tokens для аутентификации</li><li>Тщательно тестируйте на обеих платформах</li></ul>",
    difficulty: 'senior',
    tags: ['Cookie', 'мобильные приложения', 'WebView', 'iOS', 'Android']
  },
  {
    id: 28,
    question: "Как Cookie работают в контексте CORS-запросов?",
    answer: "<p>Cookie и CORS имеют <strong>сложные взаимоотношения</strong>, требующие особой настройки:</p><p><strong>По умолчанию:</strong></p><ul><li>Cross-origin запросы <strong>не включают cookie</strong> автоматически</li><li>Это защитный механизм браузера</li><li>Относится к fetch, XMLHttpRequest, но не к навигации</li></ul><p><strong>Включение credentials:</strong></p><p><strong>На клиенте (JavaScript):</strong></p><ul><li>fetch: credentials: 'include'</li><li>XMLHttpRequest: withCredentials = true</li><li>Axios: withCredentials: true</li></ul><p><strong>На сервере (headers):</strong></p><ul><li>Access-Control-Allow-Credentials: true</li><li>Access-Control-Allow-Origin: конкретный origin (не *)</li><li>Access-Control-Allow-Headers: включить Cookie</li></ul><p><strong>Важные ограничения:</strong></p><ul><li><strong>Wildcard запрещен:</strong> Нельзя использовать * с credentials</li><li><strong>SameSite влияет:</strong> SameSite=Strict блокирует cross-site cookie</li><li><strong>Secure required:</strong> Cross-site cookie требуют Secure</li></ul><p><strong>Проблемы в production:</strong></p><ul><li><strong>Subdomains:</strong> Настройка Domain для работы через поддомены</li><li><strong>Different ports:</strong> Считаются разными origins</li><li><strong>Safari restrictions:</strong> Более строгие правила для third-party</li></ul><p><strong>Альтернативы:</strong></p><ul><li>Использование Authorization header вместо cookie</li><li>Proxy для same-origin запросов</li><li>Server-side для критичных операций</li></ul><p><em>Совет:</em> Для новых проектов рассмотрите token-based аутентификацию вместо cookie для cross-origin сценариев.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'CORS', 'credentials', 'cross-origin', 'безопасность']
  },
  {
    id: 29,
    question: "Как современные браузеры блокируют third-party cookies и какие есть альтернативы?",
    answer: "<p>Блокировка third-party cookies — это <strong>глобальный тренд</strong> в защите приватности:</p><p><strong>Текущее состояние по браузерам:</strong></p><p><strong>Safari (ITP - Intelligent Tracking Prevention):</strong></p><ul><li>Блокирует все third-party cookie по умолчанию</li><li>First-party cookie с ограничениями (7 дней для скриптов)</li><li>Самые строгие ограничения</li></ul><p><strong>Firefox (ETP - Enhanced Tracking Protection):</strong></p><ul><li>Блокирует известные трекеры</li><li>Total Cookie Protection изолирует cookie по сайтам</li><li>По умолчанию активна строгая защита</li></ul><p><strong>Chrome:</strong></p><ul><li>Планирует отказ от third-party cookies</li><li>Privacy Sandbox как альтернатива</li><li>Отложено до 2024-2025</li></ul><p><strong>Технические последствия:</strong></p><ul><li><strong>Аналитика:</strong> Многие системы перестают работать</li><li><strong>Реклама:</strong> Retargeting практически невозможен</li><li><strong>Виджеты:</strong> Embedded контент теряет состояние</li><li><strong>SSO:</strong> Single Sign-On требует адаптации</li></ul><p><strong>Альтернативные решения:</strong></p><p><strong>1. Server-side подходы:</strong></p><ul><li>First-party контекст через прокси</li><li>Server-side аналитика</li></ul><p><strong>2. Privacy Sandbox APIs:</strong></p><ul><li>Topics API для интересов</li><li>FLEDGE для ретаргетинга</li><li>Attribution Reporting</li></ul><p><strong>3. Storage Access API:</strong></p><ul><li>Запрос разрешения на third-party cookie</li><li>Требует user interaction</li></ul><p><strong>4. Альтернативные идентификаторы:</strong></p><ul><li>Unified ID 2.0</li><li>Fingerprinting (этически спорно)</li></ul><p><em>Будущее:</em> Индустрия движется к privacy-first подходам. Зависимость от third-party cookies нужно устранять сейчас.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'third-party', 'блокировка', 'приватность', 'альтернативы']
  },
  {
    id: 30,
    question: "Как правильно тестировать функциональность, связанную с Cookie?",
    answer: "<p>Тестирование cookie требует <strong>комплексного подхода</strong> на разных уровнях:</p><p><strong>Unit тестирование:</strong></p><ul><li>Парсинг и генерация cookie-строк</li><li>Валидация атрибутов</li><li>Проверка логики подписи</li><li>Мокирование document.cookie</li></ul><p><strong>Integration тестирование:</strong></p><p><strong>Backend:</strong></p><ul><li>Проверка Set-Cookie заголовков</li><li>Валидация атрибутов (Secure, HttpOnly, SameSite)</li><li>Тестирование различных сценариев (создание, обновление, удаление)</li><li>Проверка срока действия</li></ul><p><strong>Frontend:</strong></p><ul><li>Чтение/запись через document.cookie</li><li>Недоступность HttpOnly cookie</li><li>Работа с различными Path и Domain</li></ul><p><strong>E2E тестирование:</strong></p><ul><li><strong>Cypress:</strong> cy.getCookie(), cy.setCookie(), cy.clearCookies()</li><li><strong>Playwright:</strong> context.cookies(), context.addCookies()</li><li><strong>Selenium:</strong> driver.get_cookies(), driver.add_cookie()</li></ul><p><strong>Специфические сценарии:</strong></p><ul><li><strong>Cross-origin:</strong> Тестирование CORS с credentials</li><li><strong>SameSite:</strong> Проверка поведения в разных контекстах</li><li><strong>Session persistence:</strong> Закрытие/открытие браузера</li><li><strong>Security:</strong> Попытки XSS, CSRF атак</li></ul><p><strong>Инструменты:</strong></p><ul><li><strong>Browser DevTools:</strong> Application/Storage панель</li><li><strong>Postman:</strong> Тестирование HTTP-заголовков</li><li><strong>Cookie-editor extensions:</strong> Ручное тестирование</li></ul><p><strong>Best practices:</strong></p><ul><li>Тестируйте в разных браузерах (Safari особенно строг)</li><li>Проверяйте incognito/private режим</li><li>Тестируйте edge cases (переполнение, специальные символы)</li><li>Автоматизируйте проверки безопасности</li></ul>",
    difficulty: 'senior',
    tags: ['Cookie', 'тестирование', 'E2E', 'безопасность', 'инструменты']
  }
];
