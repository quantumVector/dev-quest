export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое протокол HTTP и как он используется в веб-разработке?",
    answer: "<p><strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол прикладного уровня для передачи данных в интернете, который является основой обмена данными в World Wide Web.</p><p><strong>Как работает HTTP:</strong></p><ul><li>Клиент-серверная модель — браузер (клиент) отправляет запрос, сервер обрабатывает и возвращает ответ</li><li>Протокол без состояния (stateless) — каждый запрос независим, сервер не хранит информацию о предыдущих запросах</li><li>Текстовый протокол — легко читается и отлаживается</li></ul><p><strong>Основные компоненты HTTP:</strong></p><ul><li><strong>Запрос (Request)</strong> — содержит метод, URL, заголовки и опционально тело запроса</li><li><strong>Ответ (Response)</strong> — содержит статус код, заголовки и тело ответа</li></ul><p><strong>Применение в веб-разработке:</strong></p><ul><li>Загрузка веб-страниц и ресурсов</li><li>Отправка форм и данных на сервер</li><li>REST API взаимодействие</li><li>Загрузка и скачивание файлов</li></ul><p>HTTP работает поверх TCP/IP, обычно использует порт 80 (443 для HTTPS).</p>",
    difficulty: 'junior',
    tags: ['HTTP', 'протокол', 'основы', 'веб']
  },
  {
    id: 2,
    question: "Какие основные методы запросов (HTTP methods) существуют и для чего используются?",
    answer: "<p>HTTP определяет несколько методов для указания желаемого действия над ресурсом:</p><p><strong>GET:</strong></p><ul><li>Получение данных с сервера</li><li>Идемпотентный и безопасный метод</li><li>Параметры передаются в URL</li><li>Может кэшироваться браузером</li><li>Пример: получение списка товаров, загрузка страницы</li></ul><p><strong>POST:</strong></p><ul><li>Создание нового ресурса</li><li>Данные передаются в теле запроса</li><li>Не идемпотентный — повторный запрос создаст дубликат</li><li>Не кэшируется</li><li>Пример: отправка формы регистрации, создание заказа</li></ul><p><strong>PUT:</strong></p><ul><li>Обновление существующего ресурса целиком</li><li>Идемпотентный — повторный запрос не изменит результат</li><li>Заменяет весь ресурс</li><li>Пример: обновление профиля пользователя</li></ul><p><strong>PATCH:</strong></p><ul><li>Частичное обновление ресурса</li><li>Изменяет только указанные поля</li><li>Более эффективен чем PUT для небольших изменений</li><li>Пример: изменение только email пользователя</li></ul><p><strong>DELETE:</strong></p><ul><li>Удаление ресурса</li><li>Идемпотентный</li><li>Пример: удаление комментария, товара из корзины</li></ul><p><strong>HEAD:</strong></p><ul><li>Аналогичен GET, но возвращает только заголовки</li><li>Используется для проверки существования ресурса</li><li>Пример: проверка размера файла перед загрузкой</li></ul><p><strong>OPTIONS:</strong></p><ul><li>Запрос информации о доступных методах для ресурса</li><li>Используется в CORS preflight запросах</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP methods', 'GET', 'POST', 'REST']
  },
  {
    id: 3,
    question: "Что такое заголовки HTTP (HTTP headers) и какую роль они играют?",
    answer: "<p><strong>HTTP заголовки</strong> — это пары ключ-значение, которые передают дополнительную информацию о запросе или ответе.</p><p><strong>Типы заголовков:</strong></p><p><strong>1. Заголовки запроса (Request Headers):</strong></p><ul><li><strong>User-Agent</strong> — информация о браузере и ОС клиента</li><li><strong>Accept</strong> — типы контента, которые клиент может обработать</li><li><strong>Authorization</strong> — учетные данные для аутентификации</li><li><strong>Cookie</strong> — сохраненные cookies для данного домена</li><li><strong>Content-Type</strong> — тип данных в теле запроса (для POST/PUT)</li></ul><p><strong>2. Заголовки ответа (Response Headers):</strong></p><ul><li><strong>Content-Type</strong> — тип возвращаемого контента</li><li><strong>Content-Length</strong> — размер тела ответа в байтах</li><li><strong>Set-Cookie</strong> — установка cookies на клиенте</li><li><strong>Cache-Control</strong> — директивы для кэширования</li><li><strong>Location</strong> — URL для перенаправления</li></ul><p><strong>3. Общие заголовки:</strong></p><ul><li><strong>Date</strong> — дата и время отправки сообщения</li><li><strong>Connection</strong> — управление соединением (keep-alive)</li></ul><p><strong>4. Заголовки сущности:</strong></p><ul><li><strong>Content-Encoding</strong> — метод сжатия (gzip, deflate)</li><li><strong>Last-Modified</strong> — дата последней модификации ресурса</li><li><strong>ETag</strong> — уникальный идентификатор версии ресурса</li></ul><p><strong>Роль заголовков:</strong></p><ul><li>Управление кэшированием и производительностью</li><li>Аутентификация и авторизация</li><li>Согласование контента (content negotiation)</li><li>Безопасность (CORS, CSP)</li><li>Мониторинг и отладка</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP headers', 'заголовки', 'метаданные']
  },
  {
    id: 4,
    question: "Что такое статусы ответов HTTP (HTTP status codes) и какие наиболее распространенные?",
    answer: "<p><strong>HTTP статус коды</strong> — это трехзначные числа, которые сервер возвращает в ответ на запрос, указывая результат его обработки.</p><p><strong>Категории статусов:</strong></p><p><strong>1xx — Информационные:</strong></p><ul><li><strong>100 Continue</strong> — сервер готов принять тело запроса</li><li><strong>101 Switching Protocols</strong> — переключение протокола (например, на WebSocket)</li></ul><p><strong>2xx — Успешные:</strong></p><ul><li><strong>200 OK</strong> — запрос выполнен успешно</li><li><strong>201 Created</strong> — ресурс успешно создан (обычно после POST)</li><li><strong>204 No Content</strong> — успех, но нет контента для возврата</li></ul><p><strong>3xx — Перенаправления:</strong></p><ul><li><strong>301 Moved Permanently</strong> — постоянное перенаправление, обновить закладки</li><li><strong>302 Found</strong> — временное перенаправление</li><li><strong>304 Not Modified</strong> — ресурс не изменился, используйте кэш</li><li><strong>307 Temporary Redirect</strong> — временное перенаправление с сохранением метода</li><li><strong>308 Permanent Redirect</strong> — постоянное перенаправление с сохранением метода</li></ul><p><strong>4xx — Ошибки клиента:</strong></p><ul><li><strong>400 Bad Request</strong> — некорректный синтаксис запроса</li><li><strong>401 Unauthorized</strong> — требуется аутентификация</li><li><strong>403 Forbidden</strong> — доступ запрещен</li><li><strong>404 Not Found</strong> — ресурс не найден</li><li><strong>405 Method Not Allowed</strong> — метод не поддерживается для данного ресурса</li><li><strong>429 Too Many Requests</strong> — превышен лимит запросов (rate limiting)</li></ul><p><strong>5xx — Ошибки сервера:</strong></p><ul><li><strong>500 Internal Server Error</strong> — внутренняя ошибка сервера</li><li><strong>502 Bad Gateway</strong> — некорректный ответ от вышестоящего сервера</li><li><strong>503 Service Unavailable</strong> — сервис временно недоступен</li><li><strong>504 Gateway Timeout</strong> — таймаут при получении ответа от вышестоящего сервера</li></ul>",
    difficulty: 'junior',
    tags: ['HTTP status codes', 'статусы', 'коды ответов']
  },
  {
    id: 5,
    question: "Как работает механизм перенаправления (HTTP redirects) и какие типы существуют?",
    answer: "<p><strong>HTTP перенаправление</strong> — это механизм, при котором сервер указывает клиенту, что запрошенный ресурс находится по другому URL.</p><p><strong>Как работает:</strong></p><ol><li>Клиент отправляет запрос к URL-A</li><li>Сервер возвращает статус 3xx и заголовок Location с URL-B</li><li>Клиент автоматически отправляет новый запрос к URL-B</li><li>Сервер возвращает финальный ответ</li></ol><p><strong>Типы перенаправлений:</strong></p><p><strong>301 Moved Permanently:</strong></p><ul><li>Постоянное перенаправление</li><li>Поисковые системы обновляют индекс</li><li>Браузеры кэшируют перенаправление</li><li>Может изменить метод на GET</li><li>Используется для: переезда сайта, изменения URL структуры</li></ul><p><strong>302 Found (Temporary Redirect):</strong></p><ul><li>Временное перенаправление</li><li>Поисковики не обновляют индекс</li><li>Может изменить метод на GET</li><li>Используется для: временного технического обслуживания, A/B тестирования</li></ul><p><strong>307 Temporary Redirect:</strong></p><ul><li>Временное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 302</li></ul><p><strong>308 Permanent Redirect:</strong></p><ul><li>Постоянное перенаправление</li><li>Гарантированно сохраняет метод и тело запроса</li><li>Более строгая версия 301</li></ul><p><strong>303 See Other:</strong></p><ul><li>Перенаправление на другой URL методом GET</li><li>Используется после POST для избежания повторной отправки формы</li><li>Паттерн Post/Redirect/Get (PRG)</li></ul><p><strong>304 Not Modified:</strong></p><ul><li>Особый тип — не настоящее перенаправление</li><li>Указывает использовать кэшированную версию</li><li>Используется для условных запросов</li></ul><p><strong>Важные аспекты:</strong></p><ul><li>Максимум перенаправлений обычно ограничен (часто 20)</li><li>Выбор между 301 и 302 влияет на SEO</li><li>307/308 предпочтительнее 302/301 для современных приложений</li></ul>",
    difficulty: 'middle',
    tags: ['HTTP redirects', 'перенаправления', '301', '302']
  },
  {
    id: 6,
    question: "Что такое HTTPS и как оно отличается от HTTP?",
    answer: "<p><strong>HTTPS (HTTP Secure)</strong> — это расширение HTTP с шифрованием через SSL/TLS для безопасной передачи данных.</p><p><strong>Ключевые отличия от HTTP:</strong></p><p><strong>1. Шифрование:</strong></p><ul><li>HTTP — данные передаются открытым текстом</li><li>HTTPS — данные зашифрованы с помощью TLS/SSL</li><li>Защита от перехвата и чтения данных третьими лицами</li></ul><p><strong>2. Аутентификация:</strong></p><ul><li>HTTPS использует SSL-сертификаты</li><li>Сертификат подтверждает подлинность сервера</li><li>Предотвращает атаки типа man-in-the-middle</li></ul><p><strong>3. Целостность данных:</strong></p><ul><li>HTTPS гарантирует, что данные не были изменены при передаче</li><li>Использует хеширование для проверки целостности</li></ul><p><strong>Как работает HTTPS:</strong></p><ol><li><strong>TLS Handshake:</strong> установка защищенного соединения<ul><li>Клиент инициирует соединение</li><li>Сервер отправляет SSL-сертификат</li><li>Клиент проверяет сертификат</li><li>Согласование алгоритмов шифрования</li><li>Обмен ключами шифрования</li></ul></li><li><strong>Шифрование данных:</strong> вся дальнейшая передача данных происходит в зашифрованном виде</li><li><strong>Закрытие соединения:</strong> безопасное завершение сессии</li></ol><p><strong>Типы SSL-сертификатов:</strong></p><ul><li><strong>DV (Domain Validated)</strong> — базовая проверка домена</li><li><strong>OV (Organization Validated)</strong> — проверка организации</li><li><strong>EV (Extended Validation)</strong> — расширенная проверка, зеленая строка в браузере</li></ul><p><strong>Преимущества HTTPS:</strong></p><ul><li>Защита конфиденциальных данных (пароли, платежная информация)</li><li>Доверие пользователей — браузеры помечают HTTP сайты как небезопасные</li><li>SEO преимущества — Google предпочитает HTTPS сайты</li><li>Необходимо для современных API (Service Workers, HTTP/2)</li><li>Защита от фишинга</li></ul><p><strong>Недостатки:</strong></p><ul><li>Небольшое снижение производительности (TLS handshake)</li><li>Необходимость покупки и обновления сертификатов (хотя Let's Encrypt предоставляет бесплатные)</li><li>Более сложная настройка сервера</li></ul><p><strong>Современные требования:</strong></p><ul><li>Многие браузеры требуют HTTPS для доступа к определенным API</li><li>HTTP/2 и HTTP/3 работают только через HTTPS</li><li>PWA требуют HTTPS для установки</li></ul>",
    difficulty: 'junior',
    tags: ['HTTPS', 'SSL', 'TLS', 'безопасность', 'шифрование']
  },
  {
    id: 7,
    question: "Что такое идемпотентность в контексте HTTP методов?",
    answer: "<p><strong>Идемпотентность</strong> — это свойство операции, при котором повторное выполнение запроса с теми же параметрами дает тот же результат, что и однократное выполнение.</p><p><strong>Идемпотентные методы:</strong></p><p><strong>GET:</strong></p><ul><li>Множественные запросы возвращают одни и те же данные</li><li>Не изменяет состояние сервера</li><li>Безопасен для повторного выполнения</li></ul><p><strong>PUT:</strong></p><ul><li>Повторное обновление ресурса тем же контентом дает тот же результат</li><li>Первый запрос создает/обновляет ресурс</li><li>Последующие запросы ничего не меняют</li></ul><p><strong>DELETE:</strong></p><ul><li>Первый запрос удаляет ресурс</li><li>Последующие запросы возвращают 404, но это ожидаемое поведение</li><li>Конечный результат одинаков — ресурса нет</li></ul><p><strong>HEAD, OPTIONS:</strong></p><ul><li>Только получают метаинформацию</li><li>Не изменяют состояние</li></ul><p><strong>Не идемпотентные методы:</strong></p><p><strong>POST:</strong></p><ul><li>Каждый запрос создает новый ресурс</li><li>Повторный запрос = дубликат</li><li>Результат отличается от однократного выполнения</li></ul><p><strong>PATCH:</strong></p><ul><li>Может быть идемпотентным или нет, зависит от реализации</li><li>Если PATCH содержит абсолютные значения — идемпотентен</li><li>Если содержит относительные изменения (increment) — не идемпотентен</li></ul><p><strong>Практическое значение:</strong></p><ul><li>Идемпотентные запросы можно безопасно повторять при ошибках сети</li><li>Важно для автоматических retry механизмов</li><li>Упрощает обработку сбоев и восстановление</li></ul><p><strong>Пример не идемпотентности:</strong></p><ul><li>POST /api/orders — каждый вызов создает новый заказ</li><li>PATCH /api/counter (increment) — каждый вызов увеличивает счетчик</li></ul><p><strong>Пример идемпотентности:</strong></p><ul><li>PUT /api/users/123 — обновление того же пользователя теми же данными</li><li>DELETE /api/posts/456 — удаление поста (первый раз удаляет, второй раз возвращает 404)</li></ul>",
    difficulty: 'middle',
    tags: ['идемпотентность', 'HTTP methods', 'REST', 'архитектура']
  },
  {
    id: 8,
    question: "Что такое Content Negotiation и как он работает в HTTP?",
    answer: "<p><strong>Content Negotiation</strong> — это механизм, позволяющий серверу предоставлять разные представления одного и того же ресурса в зависимости от возможностей и предпочтений клиента.</p><p><strong>Типы согласования контента:</strong></p><p><strong>1. Server-driven negotiation (проактивное):</strong></p><ul><li>Сервер выбирает представление на основе заголовков запроса</li><li>Клиент указывает предпочтения через заголовки Accept*</li></ul><p><strong>2. Agent-driven negotiation (реактивное):</strong></p><ul><li>Сервер возвращает список доступных вариантов</li><li>Клиент выбирает подходящий вариант</li><li>Обычно через статус 300 Multiple Choices</li></ul><p><strong>Основные заголовки для согласования:</strong></p><p><strong>Accept:</strong></p><ul><li>Указывает желаемые MIME-типы контента</li><li>Пример: Accept: application/json, text/html;q=0.9</li><li>q-фактор (0-1) определяет приоритет</li></ul><p><strong>Accept-Language:</strong></p><ul><li>Предпочитаемые языки</li><li>Пример: Accept-Language: ru-RU, en-US;q=0.8</li></ul><p><strong>Accept-Encoding:</strong></p><ul><li>Поддерживаемые методы сжатия</li><li>Пример: Accept-Encoding: gzip, deflate, br</li></ul><p><strong>Accept-Charset:</strong></p><ul><li>Предпочитаемые кодировки символов</li><li>Устарел, обычно используется UTF-8</li></ul><p><strong>User-Agent:</strong></p><ul><li>Информация о браузере и платформе</li><li>Может влиять на выбор контента (мобильная/десктопная версия)</li></ul><p><strong>Как работает процесс:</strong></p><ol><li>Клиент отправляет запрос с заголовками Accept*</li><li>Сервер анализирует заголовки и q-факторы</li><li>Сервер выбирает наилучшее представление</li><li>Сервер возвращает выбранный контент с заголовком Content-Type</li><li>Если подходящего представления нет — 406 Not Acceptable</li></ol><p><strong>Практические примеры:</strong></p><p><strong>Формат данных:</strong></p><ul><li>API может возвращать JSON или XML в зависимости от Accept</li><li>Одна и та же страница может быть HTML или Markdown</li></ul><p><strong>Язык:</strong></p><ul><li>Сайт отображается на русском или английском</li><li>Основано на Accept-Language</li></ul><p><strong>Сжатие:</strong></p><ul><li>Сервер выбирает gzip, brotli или отправляет без сжатия</li><li>Основано на Accept-Encoding и Content-Encoding</li></ul><p><strong>Адаптивный дизайн:</strong></p><ul><li>Мобильная или десктопная версия сайта</li><li>Основано на User-Agent или специальных заголовках</li></ul><p><strong>Заголовок Vary:</strong></p><ul><li>Сервер указывает, какие заголовки влияли на выбор контента</li><li>Важно для кэширования прокси-серверами</li><li>Пример: Vary: Accept-Language, Accept-Encoding</li></ul>",
    difficulty: 'middle',
    tags: ['Content Negotiation', 'Accept', 'заголовки', 'REST']
  },
  {
    id: 9,
    question: "Что такое HTTP/2 и какие преимущества он дает по сравнению с HTTP/1.1?",
    answer: "<p><strong>HTTP/2</strong> — это обновленная версия протокола HTTP, разработанная для улучшения производительности веб-приложений.</p><p><strong>Ключевые улучшения HTTP/2:</strong></p><p><strong>1. Бинарный протокол:</strong></p><ul><li>HTTP/1.1 — текстовый протокол</li><li>HTTP/2 — бинарный, более эффективен для парсинга</li><li>Меньше ошибок при обработке</li><li>Более компактное представление данных</li></ul><p><strong>2. Мультиплексирование:</strong></p><ul><li>Множество запросов/ответов одновременно в одном TCP соединении</li><li>Решает проблему head-of-line blocking</li><li>Не нужно открывать множество параллельных соединений</li><li>Более эффективное использование сетевых ресурсов</li></ul><p><strong>3. Server Push:</strong></p><ul><li>Сервер может отправлять ресурсы до запроса клиента</li><li>Например, при запросе HTML сервер сразу отправляет CSS и JS</li><li>Уменьшает количество round-trips</li><li>Снижает время загрузки страницы</li></ul><p><strong>4. Сжатие заголовков (HPACK):</strong></p><ul><li>HTTP/1.1 не сжимает заголовки</li><li>HPACK алгоритм сжимает повторяющиеся заголовки</li><li>Особенно эффективно для множества запросов</li><li>Снижает overhead на передачу метаданных</li></ul><p><strong>5. Приоритизация потоков:</strong></p><ul><li>Клиент может указать приоритет запросов</li><li>Критичные ресурсы загружаются первыми</li><li>Оптимизация порядка загрузки</li></ul><p><strong>6. Одно соединение:</strong></p><ul><li>Требуется только одно TCP соединение на домен</li><li>Уменьшает нагрузку на сервер и клиент</li><li>Снижает латентность установки соединения</li></ul><p><strong>Сравнение с HTTP/1.1:</strong></p><p><strong>HTTP/1.1 проблемы:</strong></p><ul><li>Head-of-line blocking — следующий запрос ждет завершения предыдущего</li><li>Дублирование заголовков в каждом запросе</li><li>Необходимость domain sharding для параллельных загрузок</li><li>Конкатенация файлов для уменьшения запросов</li></ul><p><strong>HTTP/2 решения:</strong></p><ul><li>Параллельные запросы без блокировки</li><li>Сжатые заголовки</li><li>Не нужен domain sharding</li><li>Можно не конкатенировать файлы</li></ul><p><strong>Требования HTTP/2:</strong></p><ul><li>Обязательно HTTPS (хотя спецификация допускает HTTP)</li><li>Поддержка сервера и клиента</li><li>TLS 1.2 или выше</li></ul><p><strong>Практический результат:</strong></p><ul><li>Уменьшение времени загрузки страницы на 20-50%</li><li>Лучшая производительность на мобильных сетях</li><li>Меньше накладных расходов</li><li>Улучшенный пользовательский опыт</li></ul><p><strong>Ограничения:</strong></p><ul><li>Все еще может быть TCP head-of-line blocking на уровне транспорта</li><li>Сложнее отладка из-за бинарного формата</li><li>Server Push не всегда эффективен</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/2', 'производительность', 'мультиплексирование', 'оптимизация']
  },
  {
    id: 10,
    question: "Что такое кэширование в HTTP и какие механизмы для этого существуют?",
    answer: "<p><strong>HTTP кэширование</strong> — это механизм хранения копий ресурсов для уменьшения нагрузки на сервер и ускорения загрузки страниц.</p><p><strong>Основные заголовки кэширования:</strong></p><p><strong>Cache-Control (основной заголовок):</strong></p><ul><li><strong>no-cache</strong> — проверять с сервером перед использованием кэша</li><li><strong>no-store</strong> — не кэшировать вообще (конфиденциальные данные)</li><li><strong>public</strong> — может кэшироваться любыми прокси</li><li><strong>private</strong> — только в браузере пользователя</li><li><strong>max-age=3600</strong> — время жизни кэша в секундах</li><li><strong>must-revalidate</strong> — проверять после истечения</li><li><strong>immutable</strong> — контент никогда не изменится</li></ul><p><strong>Expires:</strong></p><ul><li>Устаревший способ, указывает дату истечения</li><li>Пример: Expires: Wed, 21 Oct 2025 07:28:00 GMT</li><li>Cache-Control имеет приоритет</li></ul><p><strong>Условные запросы (Validation):</strong></p><p><strong>ETag:</strong></p><ul><li>Уникальный идентификатор версии ресурса</li><li>Сервер: ETag: \"abc123\"</li><li>Клиент при следующем запросе: If-None-Match: \"abc123\"</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Last-Modified:</strong></p><ul><li>Дата последней модификации ресурса</li><li>Сервер: Last-Modified: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Клиент: If-Modified-Since: Wed, 15 Nov 2023 12:00:00 GMT</li><li>Если не изменился: 304 Not Modified</li></ul><p><strong>Уровни кэширования:</strong></p><ol><li><strong>Браузерный кэш:</strong><ul><li>Локальное хранилище в браузере</li><li>Memory cache (в RAM)</li><li>Disk cache (на диске)</li></ul></li><li><strong>Прокси-кэш:</strong><ul><li>Промежуточные серверы</li><li>CDN кэширование</li><li>Корпоративные прокси</li></ul></li><li><strong>Gateway cache:</strong><ul><li>Обратные прокси перед сервером</li><li>Varnish, Nginx кэш</li></ul></li></ol><p><strong>Стратегии кэширования:</strong></p><p><strong>1. Immutable assets (статические файлы):</strong></p><ul><li>CSS, JS, изображения с хешем в имени</li><li>Cache-Control: public, max-age=31536000, immutable</li><li>Можно кэшировать навсегда, так как имя файла изменится</li></ul><p><strong>2. HTML страницы:</strong></p><ul><li>Cache-Control: no-cache или max-age=0</li><li>Всегда проверять актуальность с сервером</li></ul><p><strong>3. API ответы:</strong></p><ul><li>Зависит от данных</li><li>Часто no-cache или короткий max-age</li><li>Использовать ETag для оптимизации</li></ul><p><strong>4. Конфиденциальные данные:</strong></p><ul><li>Cache-Control: private, no-store</li><li>Не хранить в кэше вообще</li></ul><p><strong>Vary заголовок:</strong></p><ul><li>Указывает, от каких заголовков зависит кэш</li><li>Vary: Accept-Encoding, Accept-Language</li><li>Важно для корректного кэширования прокси</li></ul><p><strong>Проблемы кэширования:</strong></p><ul><li>Устаревшие данные (stale content)</li><li>Необходимость инвалидации кэша</li><li>Сложность конфигурации</li></ul><p><strong>Best practices:</strong></p><ul><li>Использовать fingerprinting/hashing для статики</li><li>Правильно настраивать Cache-Control</li><li>Использовать ETag для динамического контента</li><li>Тестировать на разных уровнях кэширования</li></ul>",
    difficulty: 'middle',
    tags: ['кэширование', 'Cache-Control', 'ETag', 'производительность']
  },
  {
    id: 11,
    question: "Что такое CORS и как он работает в контексте HTTP?",
    answer: "<p><strong>CORS (Cross-Origin Resource Sharing)</strong> — это механизм безопасности, позволяющий веб-страницам делать запросы к другим доменам с соблюдением политики безопасности.</p><p><strong>Same-Origin Policy (проблема):</strong></p><ul><li>Браузеры блокируют межсайтовые запросы по умолчанию</li><li>Защита от кражи данных злонамеренными сайтами</li><li>Origin = протокол + домен + порт</li><li>http://example.com:80 ≠ https://example.com:443</li></ul><p><strong>Как CORS решает проблему:</strong></p><ol><li>Браузер отправляет запрос с заголовком Origin</li><li>Сервер проверяет Origin и добавляет CORS заголовки</li><li>Браузер проверяет заголовки и разрешает/блокирует доступ к ответу</li></ol><p><strong>Типы CORS запросов:</strong></p><p><strong>1. Простые запросы (Simple requests):</strong></p><ul><li>Методы: GET, HEAD, POST</li><li>Только простые заголовки (Content-Type: text/plain, application/x-www-form-urlencoded, multipart/form-data)</li><li>Отправляются сразу без preflight</li></ul><p><strong>2. Preflight запросы:</strong></p><ul><li>Для сложных запросов (PUT, DELETE, custom headers)</li><li>Браузер сначала отправляет OPTIONS запрос</li><li>Сервер отвечает разрешенными методами и заголовками</li><li>Затем отправляется основной запрос</li></ul><p><strong>Основные CORS заголовки:</strong></p><p><strong>Со стороны клиента:</strong></p><ul><li><strong>Origin</strong> — источник запроса (автоматически добавляется браузером)</li></ul><p><strong>Со стороны сервера:</strong></p><ul><li><strong>Access-Control-Allow-Origin</strong> — разрешенные origins (* или конкретный origin)</li><li><strong>Access-Control-Allow-Methods</strong> — разрешенные HTTP методы</li><li><strong>Access-Control-Allow-Headers</strong> — разрешенные заголовки</li><li><strong>Access-Control-Allow-Credentials</strong> — разрешить cookies и authorization (true/false)</li><li><strong>Access-Control-Max-Age</strong> — время кэширования preflight ответа</li><li><strong>Access-Control-Expose-Headers</strong> — какие заголовки ответа доступны клиенту</li></ul><p><strong>Процесс Preflight:</strong></p><ol><li>Браузер отправляет OPTIONS запрос:<ul><li>Origin: https://example.com</li><li>Access-Control-Request-Method: DELETE</li><li>Access-Control-Request-Headers: Content-Type</li></ul></li><li>Сервер отвечает:<ul><li>Access-Control-Allow-Origin: https://example.com</li><li>Access-Control-Allow-Methods: GET, POST, DELETE</li><li>Access-Control-Allow-Headers: Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul></li><li>Если разрешено — браузер отправляет основной запрос</li></ol><p><strong>Credentials (cookies):</strong></p><ul><li>По умолчанию cookies не отправляются в cross-origin запросах</li><li>Нужно установить credentials: 'include' в fetch</li><li>Сервер должен вернуть Access-Control-Allow-Credentials: true</li><li>И конкретный origin, не * (для безопасности)</li></ul><p><strong>Типичные ошибки CORS:</strong></p><ul><li>Забыли добавить CORS заголовки на сервере</li><li>Неправильная настройка Access-Control-Allow-Origin</li><li>Использование * с credentials</li><li>Не обрабатывается OPTIONS preflight запрос</li></ul><p><strong>Решение проблем CORS:</strong></p><ul><li>Правильная настройка сервера</li><li>Использование прокси для разработки</li><li>JSONP (устаревший способ)</li><li>Server-side запросы (без ограничений CORS)</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'безопасность', 'cross-origin', 'Same-Origin Policy']
  },
  {
    id: 12,
    question: "Что такое Keep-Alive соединение и как оно улучшает производительность?",
    answer: "<p><strong>Keep-Alive (persistent connection)</strong> — это механизм, позволяющий повторно использовать одно TCP соединение для множества HTTP запросов/ответов.</p><p><strong>Как работало в HTTP/1.0:</strong></p><ul><li>Каждый запрос требовал нового TCP соединения</li><li>Соединение закрывалось после ответа</li><li>Высокие накладные расходы на установку/закрытие соединений</li></ul><p><strong>Keep-Alive в HTTP/1.1:</strong></p><ul><li>Соединение остается открытым по умолчанию</li><li>Множество запросов через одно соединение</li><li>Заголовок Connection: keep-alive (или по умолчанию)</li><li>Connection: close для явного закрытия</li></ul><p><strong>Преимущества Keep-Alive:</strong></p><p><strong>1. Снижение латентности:</strong></p><ul><li>Нет накладных расходов на TCP handshake для каждого запроса</li><li>TCP handshake занимает 1 RTT (Round Trip Time)</li><li>Экономия особенно заметна на высоколатентных соединениях</li></ul><p><strong>2. Снижение нагрузки:</strong></p><ul><li>Меньше нагрузки на сервер</li><li>Меньше создания/уничтожения сокетов</li><li>Экономия CPU и памяти</li></ul><p><strong>3. TLS эффективность:</strong></p><ul><li>Для HTTPS не нужно повторять TLS handshake</li><li>TLS handshake очень дорогая операция</li><li>Значительная экономия времени</li></ul><p><strong>4. TCP оптимизации:</strong></p><ul><li>TCP slow start работает эффективнее</li><li>Соединение \"разогревается\" и достигает полной пропускной способности</li><li>Congestion window растет с каждым пакетом</li></ul><p><strong>Параметры Keep-Alive:</strong></p><p><strong>Keep-Alive заголовок:</strong></p><ul><li>timeout — время простоя до закрытия (секунды)</li><li>max — максимальное количество запросов</li><li>Пример: Keep-Alive: timeout=5, max=100</li></ul><p><strong>Конфигурация сервера:</strong></p><ul><li>Nginx: keepalive_timeout 65;</li><li>Apache: KeepAlive On, KeepAliveTimeout 5</li></ul><p><strong>Проблемы Keep-Alive:</strong></p><p><strong>1. Head-of-line blocking (HTTP/1.1):</strong></p><ul><li>Запросы обрабатываются последовательно</li><li>Медленный запрос блокирует остальные</li><li>Решено в HTTP/2 через мультиплексирование</li></ul><p><strong>2. Ресурсы сервера:</strong></p><ul><li>Открытые соединения потребляют память</li><li>Нужен баланс между timeout и ресурсами</li><li>При большом количестве клиентов может быть проблемой</li></ul><p><strong>3. Idle соединения:</strong></p><ul><li>Простаивающие соединения занимают ресурсы</li><li>Firewall может разрывать долгие соединения</li><li>Нужны правильные timeout настройки</li></ul><p><strong>HTTP/2 и Keep-Alive:</strong></p><ul><li>В HTTP/2 концепция Keep-Alive встроена</li><li>Одно долгоживущее соединение на домен</li><li>Мультиплексирование решает проблему blocking</li><li>Еще более эффективное использование соединений</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда включать Keep-Alive (по умолчанию в HTTP/1.1)</li><li>Настраивать разумные timeout (5-15 секунд)</li><li>Ограничивать max запросов (100-1000)</li><li>Мониторить количество открытых соединений</li><li>Использовать HTTP/2 где возможно</li></ul><p><strong>Когда отключать Keep-Alive:</strong></p><ul><li>Один запрос к серверу (очень редкий случай)</li><li>Ограниченные ресурсы сервера</li><li>Специфические security требования</li></ul>",
    difficulty: 'senior',
    tags: ['Keep-Alive', 'persistent connection', 'производительность', 'TCP']
  },
  {
    id: 13,
    question: "Что такое HTTP cookies и как они работают? Какие атрибуты безопасности существуют?",
    answer: "<p><strong>HTTP Cookies</strong> — это небольшие фрагменты данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с последующими запросами.</p><p><strong>Как работают cookies:</strong></p><ol><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie локально</li><li>Браузер автоматически отправляет cookie с каждым запросом через заголовок Cookie</li><li>Cookie существует до истечения срока или удаления</li></ol><p><strong>Установка cookie (Set-Cookie):</strong></p><ul><li>Set-Cookie: sessionId=abc123; Domain=example.com; Path=/; Max-Age=3600</li></ul><p><strong>Основные атрибуты cookie:</strong></p><p><strong>1. Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — дата истечения (Expires=Wed, 09 Jun 2025 10:18:14 GMT)</li><li><strong>Max-Age</strong> — время жизни в секундах (Max-Age=3600 для 1 часа)</li><li>Без этих атрибутов — session cookie (удаляется при закрытии браузера)</li></ul><p><strong>2. Domain:</strong></p><ul><li>Для каких доменов доступна cookie</li><li>Domain=example.com — доступна для example.com и поддоменов</li><li>По умолчанию — только текущий домен, без поддоменов</li></ul><p><strong>3. Path:</strong></p><ul><li>Для каких путей доступна cookie</li><li>Path=/admin — только для URL начинающихся с /admin</li><li>Path=/ — для всего сайта</li></ul><p><strong>Атрибуты безопасности:</strong></p><p><strong>1. Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Защита от перехвата в незашифрованном соединении</li><li>Обязательно для конфиденциальных данных</li><li>Set-Cookie: token=abc; Secure</li></ul><p><strong>2. HttpOnly:</strong></p><ul><li>Cookie недоступна для JavaScript (document.cookie)</li><li>Защита от XSS атак</li><li>JavaScript не может прочитать или изменить cookie</li><li>Set-Cookie: sessionId=abc; HttpOnly</li></ul><p><strong>3. SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li><strong>SameSite=Strict</strong> — cookie только для same-site запросов (самая строгая защита от CSRF)</li><li><strong>SameSite=Lax</strong> — cookie для top-level navigation (GET), защита от большинства CSRF (по умолчанию в современных браузерах)</li><li><strong>SameSite=None</strong> — cookie отправляется всегда (требует Secure)</li></ul><p><strong>Типы cookies по назначению:</strong></p><p><strong>1. Session cookies:</strong></p><ul><li>Идентификация пользовательской сессии</li><li>Обычно HttpOnly и Secure</li></ul><p><strong>2. Persistent cookies:</strong></p><ul><li>\"Запомнить меня\" функциональность</li><li>Имеют Expires или Max-Age</li></ul><p><strong>3. Third-party cookies:</strong></p><ul><li>Устанавливаются другими доменами (реклама, аналитика)</li><li>Часто блокируются браузерами</li></ul><p><strong>Ограничения cookies:</strong></p><ul><li>Размер: обычно 4KB на cookie</li><li>Количество: ~50 cookies на домен, ~3000 total</li><li>Автоматически отправляются с каждым запросом (overhead)</li></ul><p><strong>Проблемы безопасности:</strong></p><p><strong>1. CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт использует ваши cookies</li><li>Решение: SameSite, CSRF токены</li></ul><p><strong>2. XSS (Cross-Site Scripting):</strong></p><ul><li>JavaScript может украсть cookies</li><li>Решение: HttpOnly, Content Security Policy</li></ul><p><strong>3. Session hijacking:</strong></p><ul><li>Перехват session cookie</li><li>Решение: Secure, HttpOnly, короткие сессии, регенерация session ID</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда использовать Secure для чувствительных данных</li><li>HttpOnly для session cookies</li><li>SameSite=Lax минимум, Strict для критичных операций</li><li>Минимальный срок жизни</li><li>Не хранить конфиденциальные данные в cookies</li><li>Регулярная регенерация session ID</li></ul><p><strong>Альтернативы cookies:</strong></p><ul><li>localStorage/sessionStorage — но доступны для JavaScript</li><li>IndexedDB — для больших объемов данных</li><li>JWT токены в Authorization header — не отправляются автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['cookies', 'безопасность', 'SameSite', 'HttpOnly', 'Secure']
  },
  {
    id: 14,
    question: "Что такое Range requests и как они используются в HTTP?",
    answer: "<p><strong>Range requests</strong> — это механизм HTTP, позволяющий запрашивать только часть ресурса вместо всего файла целиком.</p><p><strong>Зачем нужны Range requests:</strong></p><ul><li>Возобновление прерванной загрузки</li><li>Потоковая передача видео/аудио</li><li>Параллельная загрузка частей файла</li><li>Загрузка только нужного фрагмента большого файла</li><li>Экономия трафика</li></ul><p><strong>Как работает Range request:</strong></p><p><strong>1. Проверка поддержки:</strong></p><ul><li>Клиент отправляет HEAD запрос</li><li>Сервер отвечает заголовком Accept-Ranges: bytes</li><li>Если Accept-Ranges: none — range requests не поддерживаются</li></ul><p><strong>2. Запрос диапазона:</strong></p><ul><li>Клиент отправляет GET с заголовком Range</li><li>Range: bytes=0-1023 — первые 1024 байта</li><li>Range: bytes=1024-2047 — следующие 1024 байта</li><li>Range: bytes=1024- — от 1024 байта до конца</li><li>Range: bytes=-1024 — последние 1024 байта</li></ul><p><strong>3. Ответ сервера:</strong></p><ul><li>Статус 206 Partial Content</li><li>Content-Range: bytes 0-1023/5000 (диапазон/общий размер)</li><li>Content-Length: 1024 (размер этой части)</li><li>Тело ответа содержит запрошенные байты</li></ul><p><strong>Множественные диапазоны:</strong></p><ul><li>Range: bytes=0-100, 200-300</li><li>Ответ в формате multipart/byteranges</li><li>Каждая часть с собственными заголовками</li></ul><p><strong>Практические применения:</strong></p><p><strong>1. Возобновление загрузки:</strong></p><ol><li>Загрузка началась, загружено 5000 байт</li><li>Соединение прервалось</li><li>Клиент запрашивает Range: bytes=5000-</li><li>Загрузка продолжается с того же места</li></ol><p><strong>2. Видео стриминг:</strong></p><ul><li>Браузер загружает видео частями</li><li>При перемотке запрашивает нужный диапазон</li><li>Не нужно загружать весь файл</li></ul><p><strong>3. PDF viewer:</strong></p><ul><li>Загрузка только видимых страниц</li><li>Остальные загружаются по требованию</li></ul><p><strong>4. Параллельная загрузка:</strong></p><ul><li>Download managers разбивают файл на части</li><li>Каждая часть загружается параллельно</li><li>Увеличение скорости загрузки</li></ul><p><strong>Условные Range requests:</strong></p><ul><li>If-Range заголовок для проверки изменений</li><li>If-Range: \"etag-value\" или дата Last-Modified</li><li>Если файл изменился — возвращает весь файл (200)</li><li>Если нет — возвращает диапазон (206)</li></ul><p><strong>Заголовки для Range requests:</strong></p><p><strong>Запрос:</strong></p><ul><li>Range: bytes=start-end</li><li>If-Range: ETag или Last-Modified</li></ul><p><strong>Ответ:</strong></p><ul><li>Accept-Ranges: bytes (или none)</li><li>Content-Range: bytes start-end/total</li><li>Content-Length: size</li><li>ETag: \"version\"</li></ul><p><strong>Возможные ответы:</strong></p><ul><li><strong>206 Partial Content</strong> — успешная частичная отдача</li><li><strong>200 OK</strong> — если If-Range не совпал или не поддерживается</li><li><strong>416 Range Not Satisfiable</strong> — запрошенный диапазон вне границ</li></ul><p><strong>Ограничения и проблемы:</strong></p><ul><li>Не все серверы поддерживают Range requests</li><li>Динамический контент сложно отдавать по частям</li><li>Нужна правильная настройка кэширования</li><li>ETag/Last-Modified важны для консистентности</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда возвращать Accept-Ranges для статических файлов</li><li>Использовать ETag для динамического контента</li><li>Корректно обрабатывать некорректные диапазоны</li><li>Поддерживать If-Range для оптимизации</li></ul>",
    difficulty: 'senior',
    tags: ['Range requests', 'частичная загрузка', 'стриминг', 'производительность']
  },
  {
    id: 15,
    question: "Что такое HTTP/3 и QUIC, какие проблемы они решают?",
    answer: "<p><strong>HTTP/3</strong> — это новая версия HTTP протокола, работающая поверх QUIC вместо TCP.</p><p><strong>QUIC (Quick UDP Internet Connections):</strong></p><ul><li>Транспортный протокол от Google, теперь стандартизован IETF</li><li>Работает поверх UDP вместо TCP</li><li>Встроенное шифрование (TLS 1.3)</li><li>Мультиплексирование на уровне транспорта</li></ul><p><strong>Проблемы HTTP/2, которые решает HTTP/3:</strong></p><p><strong>1. TCP Head-of-Line Blocking:</strong></p><ul><li>В HTTP/2 потерянный TCP пакет блокирует все потоки</li><li>TCP гарантирует порядок доставки на уровне протокола</li><li>QUIC решает: независимые потоки на уровне транспорта</li><li>Потеря пакета влияет только на один поток</li></ul><p><strong>2. Медленное установление соединения:</strong></p><ul><li>TCP + TLS требуют 2-3 RTT для начала передачи данных</li><li>TCP handshake (1 RTT) + TLS handshake (1-2 RTT)</li><li>QUIC: 0-RTT или 1-RTT для установки соединения</li><li>Встроенное шифрование ускоряет процесс</li></ul><p><strong>3. Connection migration:</strong></p><ul><li>TCP соединение привязано к IP адресу и порту</li><li>Смена сети (WiFi на LTE) = новое соединение</li><li>QUIC: Connection ID не зависит от IP</li><li>Плавное переключение между сетями без разрыва</li></ul><p><strong>Ключевые особенности HTTP/3:</strong></p><p><strong>1. Мультиплексирование без блокировки:</strong></p><ul><li>Истинное мультиплексирование на транспортном уровне</li><li>Потоки полностью независимы</li><li>Нет head-of-line blocking</li></ul><p><strong>2. Быстрое установление соединения:</strong></p><ul><li>0-RTT для повторных соединений (resume)</li><li>1-RTT для новых соединений</li><li>Данные могут отправляться в первом пакете</li></ul><p><strong>3. Встроенное шифрование:</strong></p><ul><li>TLS 1.3 интегрирован в QUIC</li><li>Нельзя использовать QUIC без шифрования</li><li>Защита метаданных соединения</li></ul><p><strong>4. Улучшенная обработка потерь:</strong></p><ul><li>Более точное определение потерь пакетов</li><li>Быстрое восстановление</li><li>Лучшая работа на нестабильных сетях</li></ul><p><strong>5. Гибкость:</strong></p><ul><li>Протокол реализован в пространстве пользователя</li><li>Обновления без изменения ОС</li><li>Быстрая эволюция протокола</li></ul><p><strong>Преимущества для пользователей:</strong></p><ul><li>Быстрее загрузка страниц, особенно на мобильных сетях</li><li>Лучше работа при потере пакетов</li><li>Плавное переключение между сетями</li><li>Меньше латентности для первого запроса</li></ul><p><strong>UDP и проблемы:</strong></p><p><strong>Почему UDP:</strong></p><ul><li>TCP \"зашит\" в ОС и его сложно изменять</li><li>UDP — простой протокол, гибкая основа</li><li>Можно реализовать нужную функциональность поверх</li></ul><p><strong>Проблемы UDP:</strong></p><ul><li>Некоторые сети блокируют UDP трафик</li><li>Firewall и middlebox могут не пропускать</li><li>Необходим fallback на HTTP/2</li></ul><p><strong>Поддержка и внедрение:</strong></p><ul><li>Уже используется Google, Facebook, Cloudflare</li><li>Поддерживается современными браузерами</li><li>Постепенное внедрение с fallback на HTTP/2</li></ul><p><strong>Особенности разработки:</strong></p><ul><li>Прозрачно для приложений</li><li>Поддержка на уровне сервера и CDN</li><li>Браузер автоматически выбирает протокол</li><li>Alt-Svc заголовок для обнаружения HTTP/3</li></ul><p><strong>Когда HTTP/3 особенно эффективен:</strong></p><ul><li>Мобильные сети с потерями пакетов</li><li>Частая смена сетей (WiFi ↔ LTE)</li><li>Высоколатентные соединения</li><li>Множество параллельных запросов</li></ul><p><strong>Ограничения:</strong></p><ul><li>Потребление CPU (шифрование/дешифрование в userspace)</li><li>Не везде поддерживается UDP</li><li>Новый протокол, возможны проблемы совместимости</li></ul>",
    difficulty: 'senior',
    tags: ['HTTP/3', 'QUIC', 'UDP', 'производительность', 'современные протоколы']
  },

  {
    id: 16,
    question: "Что такое Cookie и для чего они используются в веб-разработке?",
    answer: "<p><strong>Cookie</strong> — это небольшие фрагменты текстовых данных, которые сервер отправляет браузеру, а браузер сохраняет и отправляет обратно с каждым последующим запросом к этому серверу.</p><p><strong>Основные цели использования:</strong></p><ul><li><strong>Управление сессиями</strong> — авторизация пользователя, корзина покупок, игровые очки</li><li><strong>Персонализация</strong> — пользовательские настройки, темы, языковые предпочтения</li><li><strong>Отслеживание</strong> — анализ поведения пользователей, рекламные кампании</li></ul><p><strong>Как работают:</strong></p><ul><li>Сервер устанавливает cookie через заголовок Set-Cookie</li><li>Браузер сохраняет cookie и автоматически отправляет с каждым запросом через заголовок Cookie</li><li>Cookie привязаны к домену и пути</li></ul><p>Cookie были одним из первых механизмов для сохранения состояния в HTTP, который изначально был stateless протоколом. Несмотря на появление современных альтернатив вроде localStorage, cookie остаются важным инструментом, особенно для аутентификации.</p>",
    difficulty: 'junior',
    tags: ['Cookie', 'HTTP', 'основы', 'состояние']
  },
  {
    id: 17,
    question: "Какие атрибуты может иметь Cookie и что они означают?",
    answer: "<p>Cookie могут иметь несколько важных атрибутов, которые контролируют их поведение:</p><p><strong>Expires / Max-Age:</strong></p><ul><li><strong>Expires</strong> — конкретная дата истечения cookie</li><li><strong>Max-Age</strong> — время жизни в секундах</li><li>Если не указаны — cookie становится session cookie и удаляется при закрытии браузера</li></ul><p><strong>Domain:</strong></p><ul><li>Определяет, на каких доменах будет доступен cookie</li><li>По умолчанию — текущий домен без поддоменов</li><li>Можно указать родительский домен для доступа с поддоменов</li></ul><p><strong>Path:</strong></p><ul><li>Определяет путь на сервере, для которого валиден cookie</li><li>По умолчанию — текущий путь</li><li>Path=/admin означает, что cookie доступен только для /admin и вложенных путей</li></ul><p><strong>Secure:</strong></p><ul><li>Cookie отправляется только через HTTPS</li><li>Критически важен для защиты конфиденциальных данных</li></ul><p><strong>HttpOnly:</strong></p><ul><li>Cookie недоступен через JavaScript (document.cookie)</li><li>Защищает от XSS-атак</li></ul><p><strong>SameSite:</strong></p><ul><li>Контролирует отправку cookie в cross-site запросах</li><li>Защищает от CSRF-атак</li></ul><p>Правильная комбинация этих атрибутов критически важна для безопасности приложения.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'атрибуты', 'безопасность', 'HTTP']
  },
  {
    id: 18,
    question: "Объясните разницу между session cookies и persistent cookies",
    answer: "<p><strong>Session Cookies</strong> и <strong>Persistent Cookies</strong> различаются по времени жизни:</p><p><strong>Session Cookies (сессионные):</strong></p><ul><li>Не имеют атрибутов Expires или Max-Age</li><li>Существуют только во время сеанса браузера</li><li>Удаляются автоматически при закрытии браузера</li><li>Хранятся только в памяти</li></ul><p><strong>Типичное применение сессионных cookie:</strong></p><ul><li>Временная аутентификация в рамках сессии</li><li>Состояние формы во время заполнения</li><li>Временные настройки интерфейса</li></ul><p><strong>Persistent Cookies (постоянные):</strong></p><ul><li>Имеют явно указанный Expires или Max-Age</li><li>Сохраняются на диск</li><li>Остаются после закрытия браузера</li><li>Живут до истечения срока или явного удаления</li></ul><p><strong>Типичное применение постоянных cookie:</strong></p><ul><li>Функция 'Запомнить меня' при входе</li><li>Долгосрочные пользовательские настройки</li><li>Аналитика и отслеживание</li></ul><p><strong>Важное замечание:</strong> Современные браузеры могут восстанавливать сессионные cookie при 'восстановлении сессии', что размывает границу между типами. Для критичной безопасности полагайтесь на серверную валидацию, а не только на тип cookie.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'session', 'persistent', 'время жизни']
  },
  {
    id: 19,
    question: "Что такое SameSite атрибут и какие значения он может принимать?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, который контролирует отправку cookie в cross-site контексте, защищая от CSRF-атак.</p><p><strong>Три возможных значения:</strong></p><p><strong>SameSite=Strict:</strong></p><ul><li>Самый строгий режим</li><li>Cookie отправляется только для same-site запросов</li><li>Не отправляется при переходе на сайт по внешней ссылке</li><li>Идеально для критичных операций (управление аккаунтом, платежи)</li></ul><p><strong>SameSite=Lax (по умолчанию):</strong></p><ul><li>Баланс между безопасностью и удобством</li><li>Cookie отправляется при top-level навигации (переход по ссылке)</li><li>Не отправляется для подзапросов (img, iframe, fetch с других доменов)</li><li>Подходит для большинства сценариев аутентификации</li></ul><p><strong>SameSite=None:</strong></p><ul><li>Cookie отправляется во всех контекстах</li><li>Требует атрибута Secure (только HTTPS)</li><li>Необходим для легитимных cross-site сценариев (встроенные виджеты, OAuth)</li></ul><p><strong>Практическое значение:</strong> С введением SameSite=Lax по умолчанию, многие старые интеграции перестали работать. Важно явно указывать SameSite=None; Secure для легитимных cross-site использований.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'SameSite', 'CSRF', 'безопасность']
  },
  {
    id: 20,
    question: "Как Cookie связаны с безопасностью? Какие угрозы они создают?",
    answer: "<p>Cookie создают несколько <strong>серьезных векторов атак</strong>, которые нужно понимать и защищать:</p><p><strong>XSS (Cross-Site Scripting):</strong></p><ul><li>Злоумышленник внедряет JavaScript, который читает document.cookie</li><li>Получает доступ к session cookie и может захватить сессию</li><li><strong>Защита:</strong> HttpOnly атрибут делает cookie недоступным для JavaScript</li></ul><p><strong>CSRF (Cross-Site Request Forgery):</strong></p><ul><li>Злонамеренный сайт отправляет запросы от имени пользователя</li><li>Браузер автоматически прикрепляет cookie к запросам</li><li><strong>Защита:</strong> SameSite атрибут, CSRF-токены</li></ul><p><strong>Session Hijacking:</strong></p><ul><li>Перехват cookie через незащищенное соединение</li><li>Man-in-the-Middle атаки</li><li><strong>Защита:</strong> Secure атрибут (только HTTPS), HSTS</li></ul><p><strong>Cookie Injection:</strong></p><ul><li>Подмена или подделка cookie</li><li>Эксплуатация уязвимостей в приложении</li><li><strong>Защита:</strong> Подпись cookie, валидация на сервере</li></ul><p><strong>Tracking и Privacy:</strong></p><ul><li>Third-party cookie для отслеживания между сайтами</li><li>Нарушение приватности пользователей</li><li><strong>Защита:</strong> Ограничения браузеров на third-party cookie</li></ul><p><strong>Комплексная защита:</strong> Используйте HttpOnly, Secure, SameSite вместе, валидируйте на сервере, минимизируйте хранение чувствительных данных в cookie.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'безопасность', 'XSS', 'CSRF', 'атаки']
  },
  {
    id: 21,
    question: "В чем разница между first-party и third-party cookies?",
    answer: "<p><strong>First-party cookies</strong> и <strong>third-party cookies</strong> различаются по происхождению и назначению:</p><p><strong>First-party cookies:</strong></p><ul><li>Устанавливаются доменом, который пользователь посещает</li><li>Домен cookie совпадает с доменом в адресной строке</li><li>Используются для функциональности самого сайта</li><li>Примеры: аутентификация, настройки, корзина</li></ul><p><strong>Third-party cookies:</strong></p><ul><li>Устанавливаются доменом, отличным от посещаемого</li><li>Обычно через встроенный контент (скрипты, iframe, изображения)</li><li>Используются для отслеживания между сайтами</li><li>Примеры: реклама, аналитика, социальные виджеты</li></ul><p><strong>Как определить тип:</strong></p><ul><li>Если вы на example.com и cookie от example.com — first-party</li><li>Если cookie от analytics.com или ads.com — third-party</li></ul><p><strong>Современные тенденции:</strong></p><ul><li>Браузеры активно блокируют third-party cookies</li><li>Safari и Firefox блокируют по умолчанию</li><li>Chrome планирует полностью отказаться</li><li>Причина: защита приватности пользователей</li></ul><p><strong>Альтернативы для легитимного использования:</strong></p><ul><li>Storage Access API для необходимых сценариев</li><li>FLoC и Topics API от Google</li><li>Server-side решения</li></ul><p><em>Важно:</em> Если ваше приложение зависит от third-party cookies, нужно планировать миграцию на альтернативные решения.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'first-party', 'third-party', 'приватность', 'отслеживание']
  },
  {
    id: 22,
    question: "Какие ограничения существуют на размер и количество Cookie?",
    answer: "<p>Cookie имеют <strong>строгие технические ограничения</strong>, которые важно учитывать:</p><p><strong>Размер одного cookie:</strong></p><ul><li>Максимум около 4KB (4096 байт)</li><li>Включает имя, значение и все атрибуты</li><li>Превышение приводит к обрезанию или отклонению cookie</li></ul><p><strong>Количество cookie на домен:</strong></p><ul><li>Обычно ограничено 50-180 cookie на домен</li><li>Разные браузеры имеют разные лимиты</li><li>При превышении старые cookie удаляются</li></ul><p><strong>Общее количество cookie:</strong></p><ul><li>Около 3000 cookie на весь браузер</li><li>Варьируется между браузерами</li></ul><p><strong>Практические последствия:</strong></p><ul><li><strong>Производительность:</strong> Каждый cookie добавляется к каждому HTTP-запросу, увеличивая размер</li><li><strong>Overhead:</strong> Большое количество cookie замедляет запросы</li><li><strong>Потеря данных:</strong> Старые cookie могут быть вытеснены новыми</li></ul><p><strong>Лучшие практики:</strong></p><ul><li>Минимизируйте размер и количество cookie</li><li>Используйте короткие имена</li><li>Не храните большие объемы данных в cookie</li><li>Для больших данных используйте sessionStorage/localStorage</li><li>Используйте Path и Domain для ограничения отправки</li></ul><p><em>Золотое правило:</em> Cookie для идентификации и аутентификации, а не для хранения данных.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'ограничения', 'производительность', 'размер']
  },
  {
    id: 23,
    question: "Как работать с Cookie через JavaScript? Какие есть API?",
    answer: "<p>Работа с cookie через JavaScript возможна, но имеет свои особенности:</p><p><strong>document.cookie API:</strong></p><p>Это <strong>единственный нативный способ</strong> работы с cookie в браузере, но он не очень удобен:</p><ul><li>Чтение: document.cookie возвращает строку со всеми cookie</li><li>Запись: присваивание строки document.cookie создает/обновляет cookie</li><li>Удаление: установка cookie с датой в прошлом</li></ul><p><strong>Особенности document.cookie:</strong></p><ul><li>Не перезаписывает все cookie, а добавляет/обновляет один</li><li>Требует ручного парсинга строки для чтения</li><li>Нужно вручную форматировать атрибуты</li><li>HttpOnly cookie недоступны через JavaScript</li></ul><p><strong>Современные библиотеки:</strong></p><ul><li>js-cookie — популярная легковесная библиотека</li><li>universal-cookie — поддержка SSR</li><li>cookie-parser (Node.js) — для работы на сервере</li></ul><p><strong>Cookie Store API (экспериментальный):</strong></p><ul><li>Современный асинхронный API для работы с cookie</li><li>Более удобный и предсказуемый интерфейс</li><li>Поддержка событий изменения cookie</li><li>Пока ограниченная поддержка браузерами</li></ul><p><strong>Лучшие практики:</strong></p><ul><li>Используйте HttpOnly для чувствительных cookie</li><li>Валидируйте данные перед записью</li><li>Используйте библиотеки вместо ручного парсинга</li><li>Помните о синхронности document.cookie</li></ul>",
    difficulty: 'middle',
    tags: ['Cookie', 'JavaScript', 'API', 'document.cookie']
  },
  {
    id: 24,
    question: "Чем Cookie отличаются от localStorage и sessionStorage?",
    answer: "<p>Cookie, localStorage и sessionStorage — это три разных механизма хранения данных с различными характеристиками:</p><p><strong>Cookie:</strong></p><ul><li><strong>Размер:</strong> ~4KB</li><li><strong>Отправка:</strong> Автоматически с каждым HTTP-запросом</li><li><strong>Доступ:</strong> Клиент и сервер</li><li><strong>Истечение:</strong> Настраиваемое (session или persistent)</li><li><strong>Область:</strong> По домену и пути</li></ul><p><strong>localStorage:</strong></p><ul><li><strong>Размер:</strong> ~5-10MB</li><li><strong>Отправка:</strong> Никогда не отправляется автоматически</li><li><strong>Доступ:</strong> Только клиент (JavaScript)</li><li><strong>Истечение:</strong> Постоянное, пока не удалено явно</li><li><strong>Область:</strong> По origin (протокол + домен + порт)</li></ul><p><strong>sessionStorage:</strong></p><ul><li><strong>Размер:</strong> ~5-10MB</li><li><strong>Отправка:</strong> Никогда не отправляется</li><li><strong>Доступ:</strong> Только клиент</li><li><strong>Истечение:</strong> Удаляется при закрытии вкладки/окна</li><li><strong>Область:</strong> По origin + вкладка</li></ul><p><strong>Когда использовать:</strong></p><ul><li><strong>Cookie:</strong> Аутентификация, данные нужные серверу</li><li><strong>localStorage:</strong> Долгосрочные настройки, кеширование</li><li><strong>sessionStorage:</strong> Временное состояние в рамках сессии</li></ul><p><strong>Важно:</strong> Все три механизма доступны только для same-origin и не защищены от XSS. Не храните чувствительные данные без дополнительной защиты.</p>",
    difficulty: 'middle',
    tags: ['Cookie', 'localStorage', 'sessionStorage', 'хранилище', 'сравнение']
  },
  {
    id: 25,
    question: "Как реализовать функцию 'Запомнить меня' с использованием Cookie?",
    answer: "<p>Функция <strong>'Запомнить меня'</strong> требует тщательного подхода к безопасности:</p><p><strong>Архитектура решения:</strong></p><p><strong>1. Два типа сессий:</strong></p><ul><li>Обычная сессия — session cookie (удаляется при закрытии браузера)</li><li>'Запомнить меня' — persistent cookie с длительным сроком (например, 30 дней)</li></ul><p><strong>2. Токен-based подход (безопасный):</strong></p><ul><li>Генерируется криптографически стойкий случайный токен</li><li>Токен хешируется и сохраняется в БД</li><li>В cookie хранится только токен, а не user_id</li><li>При каждом запросе токен валидируется на сервере</li></ul><p><strong>3. Атрибуты cookie:</strong></p><ul><li>HttpOnly — защита от XSS</li><li>Secure — только HTTPS</li><li>SameSite=Lax или Strict — защита от CSRF</li><li>Max-Age или Expires — срок действия</li></ul><p><strong>Дополнительные меры безопасности:</strong></p><ul><li><strong>Ротация токенов:</strong> Обновление при каждом использовании</li><li><strong>Device fingerprinting:</strong> Привязка токена к устройству</li><li><strong>Список активных сессий:</strong> Возможность отозвать токен</li><li><strong>Периодическая реаутентификация:</strong> Для критичных операций</li></ul><p><strong>Плохие практики (не делайте так):</strong></p><ul><li>Хранение user_id напрямую в cookie</li><li>Использование предсказуемых токенов</li><li>Отсутствие валидации на сервере</li><li>Хранение паролей в cookie</li></ul>",
    difficulty: 'senior',
    tags: ['Cookie', 'аутентификация', 'запомнить меня', 'безопасность', 'токены']
  },
  {
    id: 26,
    question: "Как работает механизм подписи Cookie и зачем он нужен?",
    answer: "<p><strong>Подпись cookie</strong> — это механизм для проверки целостности и подлинности данных в cookie:</p><p><strong>Принцип работы:</strong></p><ul><li>Сервер создает криптографическую подпись значения cookie</li><li>Подпись добавляется к значению cookie</li><li>При получении cookie сервер проверяет подпись</li><li>Если подпись не совпадает — cookie был изменен или подделан</li></ul><p><strong>Типичная реализация:</strong></p><ul><li>Используется HMAC (Hash-based Message Authentication Code)</li><li>Секретный ключ известен только серверу</li><li>Значение cookie: value.signature</li><li>Подпись вычисляется как HMAC(secret_key, value)</li></ul><p><strong>Защита от атак:</strong></p><ul><li><strong>Tampering:</strong> Невозможно изменить значение без знания секретного ключа</li><li><strong>Forgery:</strong> Нельзя создать валидный cookie без секрета</li><li><strong>Целостность:</strong> Гарантия, что данные не изменились</li></ul><p><strong>Ограничения:</strong></p><ul><li><strong>Не шифрование:</strong> Данные видны, только защищены от изменения</li><li><strong>Не подлинность пользователя:</strong> Только целостность данных</li><li><strong>Replay атаки:</strong> Нужны дополнительные меры (timestamp, nonce)</li></ul><p><strong>Библиотеки:</strong></p><ul><li>Express.js: cookie-parser с secret</li><li>Django: signed cookies встроены</li><li>Rails: ActionDispatch::Cookies</li></ul><p><strong>Best practice:</strong> Используйте подпись для всех cookie, которые влияют на логику приложения. Для чувствительных данных используйте шифрование в дополнение к подписи.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'подпись', 'HMAC', 'безопасность', 'целостность']
  },
  {
    id: 27,
    question: "Какие проблемы возникают с Cookie в мобильных приложениях?",
    answer: "<p>Работа с cookie в мобильных приложениях создает <strong>уникальные вызовы</strong>:</p><p><strong>WebView и нативный код:</strong></p><ul><li><strong>Разные cookie stores:</strong> WebView и нативные HTTP-клиенты используют разные хранилища</li><li><strong>Синхронизация:</strong> Требуется явная синхронизация cookie между контекстами</li><li><strong>API различия:</strong> iOS и Android имеют разные API для работы с cookie</li></ul><p><strong>Проблемы безопасности:</strong></p><ul><li><strong>SSL Pinning:</strong> Может конфликтовать с отладкой cookie</li><li><strong>Доступ к cookie:</strong> Более сложный контроль доступа</li><li><strong>Backup:</strong> Cookie могут попасть в резервные копии</li></ul><p><strong>Особенности платформ:</strong></p><p><strong>iOS:</strong></p><ul><li>WKWebView имеет собственное cookie-хранилище</li><li>Требуется WKHTTPCookieStore для синхронизации</li><li>Ограничения на third-party cookie более строгие</li></ul><p><strong>Android:</strong></p><ul><li>CookieManager для работы с cookie в WebView</li><li>Нативный HttpURLConnection использует CookieHandler</li><li>Проще синхронизация, но больше вариативности</li></ul><p><strong>Альтернативные решения:</strong></p><ul><li><strong>Token в headers:</strong> Вместо cookie использовать Authorization header</li><li><strong>Secure Storage:</strong> Keychain (iOS) или KeyStore (Android)</li><li><strong>Custom session management:</strong> Собственная реализация</li></ul><p><strong>Best practices:</strong></p><ul><li>Минимизируйте зависимость от cookie</li><li>Используйте tokens для аутентификации</li><li>Тщательно тестируйте на обеих платформах</li></ul>",
    difficulty: 'senior',
    tags: ['Cookie', 'мобильные приложения', 'WebView', 'iOS', 'Android']
  },
  {
    id: 28,
    question: "Как Cookie работают в контексте CORS-запросов?",
    answer: "<p>Cookie и CORS имеют <strong>сложные взаимоотношения</strong>, требующие особой настройки:</p><p><strong>По умолчанию:</strong></p><ul><li>Cross-origin запросы <strong>не включают cookie</strong> автоматически</li><li>Это защитный механизм браузера</li><li>Относится к fetch, XMLHttpRequest, но не к навигации</li></ul><p><strong>Включение credentials:</strong></p><p><strong>На клиенте (JavaScript):</strong></p><ul><li>fetch: credentials: 'include'</li><li>XMLHttpRequest: withCredentials = true</li><li>Axios: withCredentials: true</li></ul><p><strong>На сервере (headers):</strong></p><ul><li>Access-Control-Allow-Credentials: true</li><li>Access-Control-Allow-Origin: конкретный origin (не *)</li><li>Access-Control-Allow-Headers: включить Cookie</li></ul><p><strong>Важные ограничения:</strong></p><ul><li><strong>Wildcard запрещен:</strong> Нельзя использовать * с credentials</li><li><strong>SameSite влияет:</strong> SameSite=Strict блокирует cross-site cookie</li><li><strong>Secure required:</strong> Cross-site cookie требуют Secure</li></ul><p><strong>Проблемы в production:</strong></p><ul><li><strong>Subdomains:</strong> Настройка Domain для работы через поддомены</li><li><strong>Different ports:</strong> Считаются разными origins</li><li><strong>Safari restrictions:</strong> Более строгие правила для third-party</li></ul><p><strong>Альтернативы:</strong></p><ul><li>Использование Authorization header вместо cookie</li><li>Proxy для same-origin запросов</li><li>Server-side для критичных операций</li></ul><p><em>Совет:</em> Для новых проектов рассмотрите token-based аутентификацию вместо cookie для cross-origin сценариев.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'CORS', 'credentials', 'cross-origin', 'безопасность']
  },
  {
    id: 29,
    question: "Как современные браузеры блокируют third-party cookies и какие есть альтернативы?",
    answer: "<p>Блокировка third-party cookies — это <strong>глобальный тренд</strong> в защите приватности:</p><p><strong>Текущее состояние по браузерам:</strong></p><p><strong>Safari (ITP - Intelligent Tracking Prevention):</strong></p><ul><li>Блокирует все third-party cookie по умолчанию</li><li>First-party cookie с ограничениями (7 дней для скриптов)</li><li>Самые строгие ограничения</li></ul><p><strong>Firefox (ETP - Enhanced Tracking Protection):</strong></p><ul><li>Блокирует известные трекеры</li><li>Total Cookie Protection изолирует cookie по сайтам</li><li>По умолчанию активна строгая защита</li></ul><p><strong>Chrome:</strong></p><ul><li>Планирует отказ от third-party cookies</li><li>Privacy Sandbox как альтернатива</li><li>Отложено до 2024-2025</li></ul><p><strong>Технические последствия:</strong></p><ul><li><strong>Аналитика:</strong> Многие системы перестают работать</li><li><strong>Реклама:</strong> Retargeting практически невозможен</li><li><strong>Виджеты:</strong> Embedded контент теряет состояние</li><li><strong>SSO:</strong> Single Sign-On требует адаптации</li></ul><p><strong>Альтернативные решения:</strong></p><p><strong>1. Server-side подходы:</strong></p><ul><li>First-party контекст через прокси</li><li>Server-side аналитика</li></ul><p><strong>2. Privacy Sandbox APIs:</strong></p><ul><li>Topics API для интересов</li><li>FLEDGE для ретаргетинга</li><li>Attribution Reporting</li></ul><p><strong>3. Storage Access API:</strong></p><ul><li>Запрос разрешения на third-party cookie</li><li>Требует user interaction</li></ul><p><strong>4. Альтернативные идентификаторы:</strong></p><ul><li>Unified ID 2.0</li><li>Fingerprinting (этически спорно)</li></ul><p><em>Будущее:</em> Индустрия движется к privacy-first подходам. Зависимость от third-party cookies нужно устранять сейчас.</p>",
    difficulty: 'senior',
    tags: ['Cookie', 'third-party', 'блокировка', 'приватность', 'альтернативы']
  },
  {
    id: 30,
    question: "Как правильно тестировать функциональность, связанную с Cookie?",
    answer: "<p>Тестирование cookie требует <strong>комплексного подхода</strong> на разных уровнях:</p><p><strong>Unit тестирование:</strong></p><ul><li>Парсинг и генерация cookie-строк</li><li>Валидация атрибутов</li><li>Проверка логики подписи</li><li>Мокирование document.cookie</li></ul><p><strong>Integration тестирование:</strong></p><p><strong>Backend:</strong></p><ul><li>Проверка Set-Cookie заголовков</li><li>Валидация атрибутов (Secure, HttpOnly, SameSite)</li><li>Тестирование различных сценариев (создание, обновление, удаление)</li><li>Проверка срока действия</li></ul><p><strong>Frontend:</strong></p><ul><li>Чтение/запись через document.cookie</li><li>Недоступность HttpOnly cookie</li><li>Работа с различными Path и Domain</li></ul><p><strong>E2E тестирование:</strong></p><ul><li><strong>Cypress:</strong> cy.getCookie(), cy.setCookie(), cy.clearCookies()</li><li><strong>Playwright:</strong> context.cookies(), context.addCookies()</li><li><strong>Selenium:</strong> driver.get_cookies(), driver.add_cookie()</li></ul><p><strong>Специфические сценарии:</strong></p><ul><li><strong>Cross-origin:</strong> Тестирование CORS с credentials</li><li><strong>SameSite:</strong> Проверка поведения в разных контекстах</li><li><strong>Session persistence:</strong> Закрытие/открытие браузера</li><li><strong>Security:</strong> Попытки XSS, CSRF атак</li></ul><p><strong>Инструменты:</strong></p><ul><li><strong>Browser DevTools:</strong> Application/Storage панель</li><li><strong>Postman:</strong> Тестирование HTTP-заголовков</li><li><strong>Cookie-editor extensions:</strong> Ручное тестирование</li></ul><p><strong>Best practices:</strong></p><ul><li>Тестируйте в разных браузерах (Safari особенно строг)</li><li>Проверяйте incognito/private режим</li><li>Тестируйте edge cases (переполнение, специальные символы)</li><li>Автоматизируйте проверки безопасности</li></ul>",
    difficulty: 'senior',
    tags: ['Cookie', 'тестирование', 'E2E', 'безопасность', 'инструменты']
  },

  {
    id: 31,
    question: "Объясните подробнее, что такое preflight запрос и когда он отправляется?",
    answer: "<p><strong>Preflight запрос</strong> — это предварительный OPTIONS запрос, который браузер автоматически отправляет перед основным запросом для проверки разрешений CORS.</p><p><strong>Когда отправляется preflight:</strong></p><p><strong>1. Использование не-простых методов:</strong></p><ul><li>PUT, DELETE, PATCH, CONNECT, TRACE</li><li>Любые методы кроме GET, HEAD, POST</li></ul><p><strong>2. Пользовательские заголовки:</strong></p><ul><li>Любые заголовки кроме простых (Accept, Accept-Language, Content-Language)</li><li>Authorization, X-Custom-Header и подобные</li><li>Content-Type кроме простых значений</li></ul><p><strong>3. Content-Type с не-простыми значениями:</strong></p><ul><li>application/json требует preflight</li><li>application/xml требует preflight</li><li>Простые: text/plain, application/x-www-form-urlencoded, multipart/form-data</li></ul><p><strong>Что происходит при preflight:</strong></p><ol><li>Браузер отправляет OPTIONS с заголовками:<ul><li>Origin — откуда запрос</li><li>Access-Control-Request-Method — какой метод будет использован</li><li>Access-Control-Request-Headers — какие заголовки будут</li></ul></li><li>Сервер проверяет и отвечает с заголовками:<ul><li>Access-Control-Allow-Methods — разрешенные методы</li><li>Access-Control-Allow-Headers — разрешенные заголовки</li><li>Access-Control-Max-Age — время кэширования preflight</li></ul></li><li>Если все ОК — браузер отправляет основной запрос</li><li>Если нет — запрос блокируется</li></ol><p><strong>Оптимизация preflight:</strong></p><ul><li>Access-Control-Max-Age для кэширования (например, 86400 для суток)</li><li>Избегайте пользовательских заголовков где возможно</li><li>Используйте простые Content-Type для POST где уместно</li></ul><p><strong>Важный нюанс:</strong> Preflight — это дополнительный запрос, увеличивающий латентность. При разработке API стоит минимизировать его необходимость или правильно кэшировать.</p>",
    difficulty: 'middle',
    tags: ['CORS', 'preflight', 'OPTIONS', 'производительность']
  },
  {
    id: 32,
    question: "Почему нельзя использовать Access-Control-Allow-Origin: * с credentials?",
    answer: "<p>Это <strong>фундаментальное ограничение безопасности</strong> CORS, и вот почему:</p><p><strong>Суть проблемы:</strong></p><ul><li>Credentials (cookies, authorization headers) идентифицируют конкретного пользователя</li><li>Wildcard (*) разрешает запросы с любого домена</li><li>Комбинация = любой сайт может делать аутентифицированные запросы от имени пользователя</li></ul><p><strong>Сценарий атаки без этого ограничения:</strong></p><ol><li>Пользователь авторизован на вашем сайте bank.com</li><li>Посещает злонамеренный сайт evil.com</li><li>Evil.com делает запрос к bank.com/transfer с credentials: 'include'</li><li>Если сервер отвечает Access-Control-Allow-Origin: *, браузер разрешит</li><li>Запрос выполняется с cookie пользователя</li><li>Деньги переведены злоумышленнику</li></ol><p><strong>Как работает защита:</strong></p><ul><li>Браузер <strong>блокирует</strong> комбинацию * и credentials</li><li>Сервер должен явно указать конкретный Origin</li><li>Это заставляет разработчиков думать о безопасности</li></ul><p><strong>Правильные подходы:</strong></p><p><strong>1. Whitelist доменов:</strong></p><ul><li>Сервер проверяет Origin из запроса</li><li>Если в whitelist — возвращает этот Origin</li><li>Access-Control-Allow-Origin: https://trusted-site.com</li></ul><p><strong>2. Dynamic origin:</strong></p><ul><li>Получаем Origin из заголовка запроса</li><li>Валидируем по списку доверенных</li><li>Возвращаем в Access-Control-Allow-Origin</li></ul><p><strong>3. Избегайте credentials где возможно:</strong></p><ul><li>Используйте token в Authorization header</li><li>Не полагайтесь на автоматическую отправку cookies</li></ul><p><strong>Распространенная ошибка:</strong> Разработчики видят CORS ошибку, добавляют *, но credentials все равно не работают. Правильное решение — настроить конкретные origins.</p>",
    difficulty: 'middle',
    tags: ['CORS', 'безопасность', 'credentials', 'wildcard']
  },
  {
    id: 33,
    question: "Как CORS работает на практике с различными типами запросов (simple vs preflight)?",
    answer: "<p>Понимание разницы между простыми и сложными запросами <strong>критично для оптимизации</strong>:</p><p><strong>Simple Request (без preflight):</strong></p><p><strong>Условия:</strong></p><ul><li>Методы: GET, HEAD, POST</li><li>Только простые заголовки</li><li>Content-Type: text/plain, application/x-www-form-urlencoded, multipart/form-data</li><li>Нет custom заголовков</li></ul><p><strong>Процесс:</strong></p><ol><li>Браузер добавляет Origin заголовок</li><li>Запрос отправляется сразу</li><li>Сервер обрабатывает и возвращает Access-Control-Allow-Origin</li><li>Браузер проверяет разрешение и дает доступ к ответу</li></ol><p><strong>Пример:</strong> Обычная HTML форма с POST — это simple request</p><p><strong>Preflight Request (с предварительной проверкой):</strong></p><p><strong>Условия:</strong></p><ul><li>Методы: PUT, DELETE, PATCH и другие</li><li>Content-Type: application/json, application/xml</li><li>Custom заголовки: Authorization, X-Requested-With</li><li>Любые не-простые комбинации</li></ul><p><strong>Процесс:</strong></p><ol><li>Браузер отправляет OPTIONS запрос с:<ul><li>Access-Control-Request-Method</li><li>Access-Control-Request-Headers</li></ul></li><li>Сервер отвечает разрешениями</li><li>Если разрешено — отправляется основной запрос</li><li>Если нет — основной запрос не отправляется</li></ol><p><strong>Пример:</strong> API запрос с JSON данными через fetch — это preflight</p><p><strong>Практические последствия:</strong></p><p><strong>Производительность:</strong></p><ul><li>Simple: 1 round-trip</li><li>Preflight: 2 round-trips (OPTIONS + actual request)</li><li>На высоколатентных соединениях разница значительна</li></ul><p><strong>Оптимизация:</strong></p><ul><li>Используйте простые запросы где возможно</li><li>Кэшируйте preflight с Access-Control-Max-Age</li><li>Группируйте изменения чтобы уменьшить количество запросов</li></ul><p><strong>Важный момент:</strong> Даже если preflight успешен, основной запрос может быть отклонен на уровне бизнес-логики. Preflight проверяет только CORS разрешения, не авторизацию.</p>",
    difficulty: 'middle',
    tags: ['CORS', 'simple request', 'preflight', 'производительность']
  },
  {
    id: 34,
    question: "Какие проблемы возникают с CORS при работе с разными поддоменами?",
    answer: "<p>Работа с поддоменами создает <strong>специфические CORS вызовы</strong>:</p><p><strong>Основная проблема:</strong></p><ul><li>api.example.com и app.example.com — это <strong>разные origins</strong></li><li>Протокол + домен + порт должны совпадать полностью</li><li>Браузер не делает исключений для поддоменов</li></ul><p><strong>Типичные сценарии:</strong></p><p><strong>1. Frontend на app.example.com, API на api.example.com:</strong></p><ul><li>Требуется настройка CORS</li><li>Access-Control-Allow-Origin: https://app.example.com</li><li>Или wildcard для поддоменов (небезопасно с credentials)</li></ul><p><strong>2. Разные порты для разработки:</strong></p><ul><li>localhost:3000 и localhost:5000 — разные origins</li><li>Нужен CORS даже локально</li></ul><p><strong>Решения:</strong></p><p><strong>1. Cookie с Domain атрибутом:</strong></p><ul><li>Set-Cookie: token=abc; Domain=.example.com</li><li>Точка перед доменом разрешает поддомены</li><li>Cookie доступна для app, api, www поддоменов</li><li>Но: менее безопасно, широкая область действия</li></ul><p><strong>2. Dynamic Origin validation:</strong></p><ul><li>Сервер проверяет Origin на соответствие паттерну</li><li>Если matches *.example.com — разрешает</li><li>Возвращает конкретный Origin в ответе</li></ul><p><strong>3. Reverse Proxy:</strong></p><ul><li>Nginx/Apache проксирует /api на api.example.com</li><li>Для браузера все с одного origin</li><li>Нет CORS проблем вообще</li></ul><p><strong>4. BFF Pattern (Backend for Frontend):</strong></p><ul><li>Backend на том же origin что и frontend</li><li>BFF делает запросы к API (без CORS)</li><li>Передает данные frontend</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Используйте reverse proxy в production</li><li>Настраивайте CORS правильно для development</li><li>Не используйте wildcard с credentials</li><li>Тестируйте на production-like окружении</li></ul><p><strong>Частая ошибка:</strong> Разработчики настраивают CORS для localhost, но забывают про production поддомены. Результат — работает локально, падает в production.</p>",
    difficulty: 'senior',
    tags: ['CORS', 'поддомены', 'origin', 'домены']
  },
  {
    id: 35,
    question: "Как CORS взаимодействует с редиректами? Какие проблемы могут возникнуть?",
    answer: "<p>CORS и редиректы — это <strong>источник множества проблем</strong>, потому что правила сложные:</p><p><strong>Базовое правило:</strong></p><ul><li>CORS проверяется на <strong>каждом шаге</strong> редиректа</li><li>Если любой промежуточный сервер не отдает правильные заголовки — запрос падает</li><li>Браузер не следует редиректу автоматически для cross-origin</li></ul><p><strong>Сценарий проблемы:</strong></p><ol><li>Frontend на app.com делает запрос к api.example.com/login</li><li>Сервер редиректит (302) на api.example.com/auth</li><li>Промежуточный ответ не содержит CORS заголовки</li><li>Браузер блокирует, основной запрос не отправляется</li></ol><p><strong>Типы редиректов и CORS:</strong></p><p><strong>Same-origin редиректы:</strong></p><ul><li>api.com/old → api.com/new</li><li>Обычно работают без проблем</li><li>CORS заголовки не меняются</li></ul><p><strong>Cross-origin редиректы:</strong></p><ul><li>api.com → cdn.example.com</li><li>Критично: оба сервера должны отдавать CORS заголовки</li><li>Origin остается оригинальным</li></ul><p><strong>Redirect chains:</strong></p><ul><li>A → B → C</li><li>Каждый сервер в цепочке должен поддерживать CORS</li><li>Легко сломать</li></ul><p><strong>Особенности методов при редиректе:</strong></p><p><strong>301/302:</strong></p><ul><li>Могут изменить метод с POST на GET</li><li>Это проблема для API запросов</li><li>Может потеряться тело запроса</li></ul><p><strong>307/308:</strong></p><ul><li>Сохраняют метод и тело</li><li>Более предсказуемы для API</li><li>Но все равно требуют CORS на всех шагах</li></ul><p><strong>Решения:</strong></p><p><strong>1. Избегайте редиректов в API:</strong></p><ul><li>Возвращайте финальный URL в теле ответа</li><li>Клиент делает новый запрос явно</li></ul><p><strong>2. Правильные заголовки на всех серверах:</strong></p><ul><li>Каждый сервер в цепочке должен отдавать CORS заголовки</li><li>Включая промежуточные редиректы</li></ul><p><strong>3. Используйте 307/308:</strong></p><ul><li>Для API редиректов предпочтительнее</li><li>Сохраняют метод и тело</li></ul><p><strong>4. Handle на клиенте:</strong></p><ul><li>Отключите автоматический redirect: redirect: 'manual'</li><li>Обработайте 3xx статус вручную</li><li>Сделайте новый запрос с правильными заголовками</li></ul><p><strong>Debugging редирект проблем:</strong></p><ul><li>Используйте Network tab в DevTools</li><li>Проверьте каждый шаг редиректа</li><li>Убедитесь что CORS заголовки на всех ответах</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'редиректы', '302', '307', 'проблемы']
  },
  {
    id: 36,
    question: "Что такое CORS-safe заголовки и почему они важны?",
    answer: "<p><strong>CORS-safe заголовки</strong> — это заголовки, которые можно читать в JavaScript без explicit разрешения сервера:</p><p><strong>Safe response headers (по умолчанию доступны):</strong></p><ul><li>Cache-Control</li><li>Content-Language</li><li>Content-Type</li><li>Expires</li><li>Last-Modified</li><li>Pragma</li></ul><p><strong>Почему это важно:</strong></p><ul><li>Даже если CORS разрешен, по умолчанию JavaScript видит только эти заголовки</li><li>Остальные заголовки <strong>скрыты</strong> от клиента</li><li>Это защитный механизм браузера</li></ul><p><strong>Проблема на практике:</strong></p><ol><li>API возвращает кастомный заголовок X-Total-Count</li><li>Frontend пытается прочитать response.headers.get('X-Total-Count')</li><li>Получает null, хотя заголовок есть в ответе</li><li>DevTools показывает заголовок, но JavaScript не видит</li></ol><p><strong>Решение — Access-Control-Expose-Headers:</strong></p><ul><li>Сервер явно указывает, какие заголовки можно читать</li><li>Access-Control-Expose-Headers: X-Total-Count, X-Page-Number</li><li>Можно указать несколько через запятую</li><li>Wildcard (*) работает, но только без credentials</li></ul><p><strong>Типичные кастомные заголовки:</strong></p><ul><li><strong>Pagination:</strong> X-Total-Count, X-Page-Size, Link</li><li><strong>Rate limiting:</strong> X-RateLimit-Remaining, X-RateLimit-Reset</li><li><strong>Versioning:</strong> X-API-Version</li><li><strong>Custom auth:</strong> X-Auth-Token (но лучше в body)</li></ul><p><strong>Safe request headers (для preflight):</strong></p><p>Эти можно отправлять без preflight:</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (только простые значения)</li></ul><p>Все остальные требуют preflight и Access-Control-Allow-Headers</p><p><strong>Best practices:</strong></p><ul><li>Минимизируйте custom заголовки</li><li>Документируйте какие заголовки expose</li><li>Используйте Access-Control-Expose-Headers: * в development</li><li>В production явно перечисляйте нужные</li></ul><p><strong>Debugging:</strong></p><ul><li>Проверяйте Network tab — заголовок есть в ответе?</li><li>Проверяйте Console — JavaScript может его прочитать?</li><li>Если да/нет — проблема в Expose-Headers</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'заголовки', 'Expose-Headers', 'безопасность']
  },
  {
    id: 37,
    question: "Как правильно настроить CORS на сервере для production окружения?",
    answer: "<p>Настройка CORS для production требует <strong>баланса между безопасностью и функциональностью</strong>:</p><p><strong>Основные принципы:</strong></p><p><strong>1. Whitelist конкретных origins:</strong></p><ul><li>Никогда не используйте * в production с credentials</li><li>Храните список разрешенных доменов в конфигурации</li><li>Проверяйте Origin запроса против whitelist</li><li>Возвращайте конкретный Origin если разрешен</li></ul><p><strong>2. Используйте строгие credentials правила:</strong></p><ul><li>Access-Control-Allow-Credentials: true только если действительно нужно</li><li>С credentials требуйте конкретный Origin</li><li>Рассмотрите token-based auth вместо cookies</li></ul><p><strong>3. Минимизируйте Allowed Methods:</strong></p><ul><li>Не разрешайте все методы по умолчанию</li><li>Только необходимые: GET, POST, PUT, DELETE</li><li>Избегайте опасных методов если не нужны</li></ul><p><strong>4. Контролируйте Allowed Headers:</strong></p><ul><li>Явно перечисляйте разрешенные заголовки</li><li>Не используйте * с credentials</li><li>Включайте только необходимые: Content-Type, Authorization</li></ul><p><strong>5. Оптимизируйте Preflight кэширование:</strong></p><ul><li>Access-Control-Max-Age: 86400 (24 часа)</li><li>Уменьшает количество OPTIONS запросов</li><li>Баланс между производительностью и гибкостью</li></ul><p><strong>Пример безопасной конфигурации:</strong></p><p><strong>Node.js/Express:</strong></p><ul><li>Используйте библиотеку cors с whitelist</li><li>Dynamic origin validation</li><li>Разные настройки для разных endpoints</li></ul><p><strong>Nginx:</strong></p><ul><li>Проверка Origin через map</li><li>Условные заголовки только для разрешенных</li><li>Отдельная конфигурация для OPTIONS</li></ul><p><strong>Apache:</strong></p><ul><li>mod_headers с условиями</li><li>SetEnvIf для проверки Origin</li><li>Header set с условиями</li></ul><p><strong>Специфичные настройки по endpoints:</strong></p><ul><li><strong>Public API:</strong> более открытые правила</li><li><strong>Auth endpoints:</strong> строгие ограничения</li><li><strong>Admin API:</strong> максимально ограниченный whitelist</li></ul><p><strong>Security checklist:</strong></p><ul><li>✓ Whitelist origins вместо *</li><li>✓ HTTPS для всех origins</li><li>✓ Минимальный набор methods и headers</li><li>✓ Правильный Max-Age</li><li>✓ Логирование CORS запросов</li><li>✓ Мониторинг подозрительных origins</li><li>✓ Rate limiting для OPTIONS</li></ul><p><strong>Частые ошибки production:</strong></p><ul><li>Забыли добавить новый домен в whitelist</li><li>www vs non-www вариант не учтен</li><li>HTTP vs HTTPS variants</li><li>Staging домены в production whitelist</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'production', 'безопасность', 'конфигурация']
  },
  {
    id: 38,
    question: "Какие альтернативы CORS существуют для cross-origin взаимодействия?",
    answer: "<p>Помимо CORS существует несколько <strong>альтернативных подходов</strong> для cross-origin коммуникации:</p><p><strong>1. JSONP (устаревший):</strong></p><p><strong>Как работает:</strong></p><ul><li>Использует тег script для загрузки данных</li><li>Сервер оборачивает JSON в вызов функции</li><li>Обходит Same-Origin Policy</li></ul><p><strong>Проблемы:</strong></p><ul><li>Только GET запросы</li><li>Серьезные проблемы безопасности</li><li>Устарел с появлением CORS</li><li>Не используйте для новых проектов</li></ul><p><strong>2. Proxy Server:</strong></p><p><strong>Как работает:</strong></p><ul><li>Frontend делает запросы к своему backend</li><li>Backend проксирует запросы к внешнему API</li><li>Для браузера все same-origin</li></ul><p><strong>Преимущества:</strong></p><ul><li>Нет CORS проблем</li><li>Можно добавлять аутентификацию</li><li>Кэширование и rate limiting</li><li>Скрытие API ключей</li></ul><p><strong>Недостатки:</strong></p><ul><li>Дополнительная латентность</li><li>Нагрузка на backend</li><li>Сложность инфраструктуры</li></ul><p><strong>3. PostMessage API:</strong></p><p><strong>Как работает:</strong></p><ul><li>Для коммуникации между window/iframe</li><li>window.postMessage() для отправки</li><li>addEventListener('message') для получения</li></ul><p><strong>Применение:</strong></p><ul><li>Встроенные виджеты</li><li>OAuth flows</li><li>Cross-origin iframe коммуникация</li></ul><p><strong>Важно:</strong></p><ul><li>Валидация origin получателя обязательна</li><li>Проверка event.origin в обработчике</li></ul><p><strong>4. WebSockets:</strong></p><p><strong>Как работает:</strong></p><ul><li>Устанавливает постоянное соединение</li><li>Проверка origin на уровне handshake</li><li>Не использует CORS механизм</li></ul><p><strong>Преимущества:</strong></p><ul><li>Двусторонняя коммуникация</li><li>Низкая латентность</li><li>Для real-time приложений</li></ul><p><strong>5. Server-Sent Events (SSE):</strong></p><ul><li>Односторонний поток данных от сервера</li><li>Использует обычный HTTP</li><li>Подвержен CORS ограничениям</li></ul><p><strong>6. BFF Pattern (Backend for Frontend):</strong></p><ul><li>Dedicated backend для каждого frontend</li><li>BFF делает все cross-origin запросы</li><li>Frontend работает только с BFF (same-origin)</li></ul><p><strong>7. Browser Extensions:</strong></p><ul><li>Extensions могут обходить CORS</li><li>Для специфичных use cases</li><li>Требуют установки пользователем</li></ul><p><strong>Когда использовать что:</strong></p><ul><li><strong>Public API:</strong> CORS</li><li><strong>Sensitive data:</strong> Proxy или BFF</li><li><strong>Real-time:</strong> WebSockets</li><li><strong>Widget integration:</strong> postMessage</li><li><strong>Legacy support:</strong> Proxy</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'альтернативы', 'proxy', 'postMessage', 'WebSockets']
  },
  {
    id: 39,
    question: "Как отладить CORS проблемы? Какие инструменты и техники использовать?",
    answer: "<p>Отладка CORS проблем требует <strong>систематического подхода</strong>:</p><p><strong>Browser DevTools:</strong></p><p><strong>1. Network Tab:</strong></p><ul><li>Проверьте статус запроса (200, 403, OPTIONS)</li><li>Смотрите Request Headers — есть ли Origin?</li><li>Смотрите Response Headers — есть ли Access-Control-*?</li><li>Для preflight проверьте OPTIONS запрос отдельно</li></ul><p><strong>2. Console:</strong></p><ul><li>CORS ошибки отображаются в console</li><li>Читайте сообщения внимательно</li><li>Указывают конкретную причину блокировки</li></ul><p><strong>3. Типичные сообщения ошибок:</strong></p><ul><li>\"No 'Access-Control-Allow-Origin' header\" — сервер не отдает заголовок</li><li>\"Wildcard '*' cannot be used with credentials\" — нужен конкретный origin</li><li>\"Method X is not allowed\" — preflight не разрешил метод</li><li>\"Header Y is not allowed\" — заголовок не в Allow-Headers</li></ul><p><strong>Пошаговая диагностика:</strong></p><p><strong>Шаг 1: Определите тип запроса</strong></p><ul><li>Простой или preflight?</li><li>Проверьте метод и заголовки</li><li>Content-Type = application/json → preflight</li></ul><p><strong>Шаг 2: Для preflight проверьте OPTIONS</strong></p><ul><li>Отправляется ли OPTIONS запрос?</li><li>Какой статус (200, 204, 404)?</li><li>Есть ли нужные заголовки в ответе?</li></ul><p><strong>Шаг 3: Проверьте все CORS заголовки</strong></p><ul><li>Access-Control-Allow-Origin — соответствует Origin?</li><li>Access-Control-Allow-Methods — включает нужный метод?</li><li>Access-Control-Allow-Headers — включает все custom headers?</li><li>Access-Control-Allow-Credentials — true если нужны credentials?</li></ul><p><strong>Шаг 4: Проверьте origin matching</strong></p><ul><li>Origin из Request Headers</li><li>Allow-Origin из Response Headers</li><li>Должны совпадать точно (включая протокол, порт)</li></ul><p><strong>Инструменты:</strong></p><p><strong>1. curl для тестирования:</strong></p><ul><li>Добавьте -H \"Origin: https://example.com\"</li><li>Проверьте ответ сервера напрямую</li><li>Обходите браузерные кэши</li></ul><p><strong>2. Postman/Insomnia:</strong></p><ul><li>Не применяют CORS ограничения</li><li>Полезны для тестирования API отдельно</li><li>Если работает там, но не в браузере — точно CORS</li></ul><p><strong>3. Browser extensions:</strong></p><ul><li>CORS Unblock (для development)</li><li>ModHeader для добавления заголовков</li><li>Только для тестирования, не для production!</li></ul><p><strong>4. Proxy для development:</strong></p><ul><li>webpack-dev-server proxy</li><li>Vite proxy</li><li>Create React App proxy</li></ul><p><strong>Checklist для debugging:</strong></p><ul><li>□ Preflight запрос успешен (200/204)?</li><li>□ Origin в запросе совпадает с Allow-Origin?</li><li>□ Все методы разрешены?</li><li>□ Все заголовки разрешены?</li><li>□ Credentials настроены правильно?</li><li>□ Max-Age не слишком большой?</li><li>□ HTTPS для Secure cookies?</li></ul><p><strong>Частые ошибки:</strong></p><ul><li>Забыли настроить OPTIONS handler</li><li>Origin с/без www различаются</li><li>HTTP vs HTTPS mismatch</li><li>Port в Origin игнорируется</li><li>Кэширование старых preflight ответов</li></ul>",
    difficulty: 'middle',
    tags: ['CORS', 'отладка', 'debugging', 'DevTools']
  },
  {
    id: 40,
    question: "Как CORS работает с WebSockets и есть ли там особенности?",
    answer: "<p>WebSockets имеют <strong>свой механизм проверки origin</strong>, отличный от CORS:</p><p><strong>Ключевые отличия от HTTP CORS:</strong></p><ul><li>WebSockets не используют CORS заголовки</li><li>Проверка origin происходит при handshake</li><li>После установки соединения проверки нет</li></ul><p><strong>WebSocket Handshake:</strong></p><p><strong>1. Клиент отправляет upgrade запрос:</strong></p><ul><li>GET запрос с заголовками:<ul><li>Upgrade: websocket</li><li>Connection: Upgrade</li><li>Origin: https://example.com</li><li>Sec-WebSocket-Key: случайный ключ</li></ul></li></ul><p><strong>2. Сервер проверяет Origin:</strong></p><ul><li>Валидирует значение Origin заголовка</li><li>Решает принять или отклонить соединение</li><li>Возвращает 101 Switching Protocols или 403</li></ul><p><strong>3. Если принято:</strong></p><ul><li>HTTP соединение upgrade в WebSocket</li><li>Дальнейшая коммуникация по WebSocket протоколу</li><li>CORS больше не применяется</li></ul><p><strong>Настройка на сервере:</strong></p><p><strong>Node.js (ws library):</strong></p><ul><li>Проверка origin в verifyClient callback</li><li>Сравнение с whitelist</li><li>Return true/false для accept/reject</li></ul><p><strong>Socket.IO:</strong></p><ul><li>Настройка через cors опцию</li><li>Origin whitelist</li><li>Credentials support</li></ul><p><strong>Важные особенности:</strong></p><p><strong>1. Нет preflight:</strong></p><ul><li>WebSocket handshake не использует OPTIONS</li><li>Проверка origin только при соединении</li><li>Быстрее чем CORS preflight</li></ul><p><strong>2. После handshake нет ограничений:</strong></p><ul><li>Можно отправлять любые данные</li><li>Двусторонняя коммуникация</li><li>Сервер должен валидировать все сообщения</li></ul><p><strong>3. Cookies отправляются автоматически:</strong></p><ul><li>При handshake браузер отправляет cookies</li><li>SameSite ограничения применяются</li><li>Secure требуется для wss://</li></ul><p><strong>Безопасность WebSocket:</strong></p><p><strong>1. Валидация Origin обязательна:</strong></p><ul><li>Проверяйте Origin при каждом соединении</li><li>Whitelist известных доменов</li><li>Reject подозрительные origins</li></ul><p><strong>2. CSRF защита:</strong></p><ul><li>Token-based auth предпочтительнее cookies</li><li>Передавайте токен в handshake query/headers</li><li>Валидируйте токен на сервере</li></ul><p><strong>3. Rate limiting:</strong></p><ul><li>Ограничивайте количество соединений с origin</li><li>Throttling для сообщений</li><li>Защита от DOS</li></ul><p><strong>Debugging WebSocket CORS:</strong></p><ul><li>Проверьте Network tab → WS filter</li><li>Смотрите Handshake статус</li><li>Проверьте Origin в handshake request</li><li>Логируйте на сервере почему отклонено</li></ul><p><strong>Best practices:</strong></p><ul><li>Всегда валидируйте Origin</li><li>Используйте wss:// (WebSocket Secure)</li><li>Аутентификация через токены</li><li>Мониторинг подозрительных соединений</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'WebSockets', 'origin', 'handshake']
  },
  {
    id: 41,
    question: "Как CORS влияет на производительность и как это оптимизировать?",
    answer: "<p>CORS может <strong>значительно влиять на производительность</strong> веб-приложений:</p><p><strong>Основные проблемы производительности:</strong></p><p><strong>1. Preflight запросы:</strong></p><ul><li>Каждый 'сложный' запрос требует дополнительный OPTIONS</li><li>+1 round-trip = удвоение латентности</li><li>На высоколатентных соединениях (mobile) особенно заметно</li><li>Умножается на количество API endpoints</li></ul><p><strong>2. Множественные preflight:</strong></p><ul><li>Разные endpoints = разные preflight</li><li>Каждый уникальный набор headers = новый preflight</li><li>При параллельных запросах накладывается</li></ul><p><strong>3. Overhead заголовков:</strong></p><ul><li>CORS заголовки добавляют байты к каждому запросу/ответу</li><li>Особенно заметно для небольших API responses</li></ul><p><strong>Стратегии оптимизации:</strong></p><p><strong>1. Максимизируйте Access-Control-Max-Age:</strong></p><ul><li>Кэширование preflight результатов</li><li>Рекомендуется: 86400 (24 часа)</li><li>Браузеры могут игнорировать слишком большие значения</li><li>Баланс: производительность vs гибкость изменений</li></ul><p><strong>2. Используйте простые запросы где возможно:</strong></p><ul><li>GET вместо POST с JSON где подходит</li><li>application/x-www-form-urlencoded вместо application/json</li><li>Избегайте custom headers когда не нужны</li><li>Но: не жертвуйте правильной архитектурой</li></ul><p><strong>3. Группируйте запросы:</strong></p><ul><li>Batch API endpoints для уменьшения количества запросов</li><li>GraphQL вместо множества REST endpoints</li><li>Один preflight вместо нескольких</li></ul><p><strong>4. Connection: keep-alive:</strong></p><ul><li>Переиспользование TCP соединений</li><li>Уменьшает overhead на соединения</li><li>Особенно эффективно с HTTP/2</li></ul><p><strong>5. HTTP/2 и HTTP/3:</strong></p><ul><li>Multiplexing уменьшает влияние preflight</li><li>Параллельные запросы по одному соединению</li><li>Сжатие заголовков (HPACK)</li></ul><p><strong>Архитектурные решения:</strong></p><p><strong>1. Избегайте CORS через proxy:</strong></p><ul><li>Reverse proxy на вашем домене</li><li>Nginx/Apache проксирует к API</li><li>Для браузера все same-origin → нет CORS</li><li>Лучшая производительность в целом</li></ul><p><strong>2. BFF Pattern:</strong></p><ul><li>Backend for Frontend на том же домене</li><li>BFF делает cross-origin запросы</li><li>Frontend only same-origin</li></ul><p><strong>3. CDN и Edge Computing:</strong></p><ul><li>Edge functions для обработки CORS</li><li>Ближе к пользователям</li><li>Меньше латентность</li></ul><p><strong>Мониторинг производительности:</strong></p><ul><li>Отслеживайте количество preflight запросов</li><li>Измеряйте время на OPTIONS vs actual requests</li><li>Процент кэшированных preflight</li><li>Общее влияние на page load time</li></ul><p><strong>Измерение эффекта:</strong></p><ul><li>Navigation Timing API для метрик</li><li>Performance Observer для детализации</li><li>RUM (Real User Monitoring) для production данных</li></ul><p><strong>Trade-offs:</strong></p><ul><li>Безопасность vs производительность</li><li>Простота API vs количество запросов</li><li>Гибкость vs кэширование</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'производительность', 'оптимизация', 'preflight']
  },
  {
    id: 42,
    question: "Какие security риски связаны с неправильной настройкой CORS?",
    answer: "<p>Неправильная конфигурация CORS создает <strong>серьезные уязвимости безопасности</strong>:</p><p><strong>1. Wildcard (*) с чувствительными данными:</strong></p><p><strong>Проблема:</strong></p><ul><li>Access-Control-Allow-Origin: *</li><li>Любой сайт может читать ответы API</li><li>Утечка конфиденциальных данных</li></ul><p><strong>Атака:</strong></p><ul><li>Злоумышленник создает сайт evil.com</li><li>Делает запрос к вашему API</li><li>Получает доступ к данным пользователей</li></ul><p><strong>Защита:</strong></p><ul><li>Никогда не используйте * для приватных API</li><li>Whitelist конкретных доменов</li><li>Разделяйте public и private endpoints</li></ul><p><strong>2. Динамический origin без валидации:</strong></p><p><strong>Проблема:</strong></p><ul><li>Сервер просто отражает Origin из запроса</li><li>Access-Control-Allow-Origin: {request.origin}</li><li>Доверяет любому origin</li></ul><p><strong>Атака:</strong></p><ul><li>Аналогично wildcard</li><li>Еще опаснее с credentials: true</li></ul><p><strong>Защита:</strong></p><ul><li>Всегда валидируйте origin против whitelist</li><li>Не доверяйте значению из запроса</li></ul><p><strong>3. Credentials с небезопасным origin:</strong></p><p><strong>Проблема:</strong></p><ul><li>Allow-Credentials: true + недостаточная проверка origin</li><li>Cookies отправляются к недоверенному домену</li></ul><p><strong>Атака:</strong></p><ul><li>Session hijacking</li><li>CSRF через CORS</li><li>Кража аутентификационных данных</li></ul><p><strong>Защита:</strong></p><ul><li>Строгий whitelist с credentials</li><li>Рассмотрите token-based auth</li><li>SameSite cookies</li></ul><p><strong>4. Слишком широкий Allow-Headers:</strong></p><p><strong>Проблема:</strong></p><ul><li>Access-Control-Allow-Headers: *</li><li>Разрешает любые заголовки</li><li>Может обойти некоторые защиты</li></ul><p><strong>Защита:</strong></p><ul><li>Явно перечисляйте нужные заголовки</li><li>Минимальный необходимый набор</li></ul><p><strong>5. Allow-Methods с опасными методами:</strong></p><p><strong>Проблема:</strong></p><ul><li>Разрешены методы вроде TRACE, CONNECT</li><li>Могут использоваться для атак</li></ul><p><strong>Защита:</strong></p><ul><li>Только необходимые методы</li><li>GET, POST, PUT, DELETE обычно достаточно</li></ul><p><strong>6. Игнорирование OPTIONS запросов:</strong></p><p><strong>Проблема:</strong></p><ul><li>Сервер не обрабатывает OPTIONS</li><li>Или обрабатывает неправильно</li><li>Может пропустить проверки безопасности</li></ul><p><strong>Защита:</strong></p><ul><li>Правильный handler для OPTIONS</li><li>Те же проверки что и для других методов</li></ul><p><strong>7. Отсутствие rate limiting:</strong></p><p><strong>Проблема:</strong></p><ul><li>OPTIONS запросы не ограничены</li><li>Можно использовать для DOS</li></ul><p><strong>Защита:</strong></p><ul><li>Rate limiting для preflight</li><li>Мониторинг подозрительной активности</li></ul><p><strong>Best Practices для безопасности:</strong></p><ul><li>Принцип наименьших привилегий</li><li>Явное лучше неявного</li><li>Регулярный аудит CORS конфигурации</li><li>Разные настройки для разных endpoints</li><li>Логирование CORS нарушений</li><li>Тестирование на проникновение</li></ul><p><strong>Security checklist:</strong></p><ul><li>□ Нет wildcard с sensitive data</li><li>□ Origin validation работает</li><li>□ Credentials только для trusted origins</li><li>□ Минимальный набор headers/methods</li><li>□ Rate limiting настроен</li><li>□ Логирование активно</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'безопасность', 'уязвимости', 'атаки']
  },
  {
    id: 43,
    question: "Как CORS работает с различными типами аутентификации (Bearer tokens, API keys)?",
    answer: "<p>Взаимодействие CORS с аутентификацией имеет <strong>важные нюансы</strong>:</p><p><strong>Bearer Token Authentication:</strong></p><p><strong>Как работает:</strong></p><ul><li>Token передается в Authorization header</li><li>Authorization: Bearer {token}</li><li>Не использует cookies</li></ul><p><strong>CORS особенности:</strong></p><ul><li>Authorization — custom header → требует preflight</li><li>Нужен Access-Control-Allow-Headers: Authorization</li><li>Credentials: 'include' НЕ нужен (нет cookies)</li><li>Более CORS-friendly чем cookie-based auth</li></ul><p><strong>Преимущества:</strong></p><ul><li>Не подвержен CSRF</li><li>Работает без cookies</li><li>Можно использовать с * origin (но не рекомендуется)</li><li>Проще для mobile apps</li></ul><p><strong>Настройка:</strong></p><ul><li>Access-Control-Allow-Headers: Authorization, Content-Type</li><li>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</li><li>Credentials: false (по умолчанию)</li></ul><p><strong>API Key Authentication:</strong></p><p><strong>Вариант 1: В custom header</strong></p><ul><li>X-API-Key: {key}</li><li>Требует preflight</li><li>Access-Control-Allow-Headers: X-API-Key</li></ul><p><strong>Вариант 2: В query parameter</strong></p><ul><li>?api_key={key}</li><li>Не требует preflight (простой GET)</li><li>Но менее безопасно (логируется в URLs)</li></ul><p><strong>Вариант 3: В Authorization header</strong></p><ul><li>Authorization: ApiKey {key}</li><li>Требует preflight</li><li>Более стандартный подход</li></ul><p><strong>Cookie-based Authentication:</strong></p><p><strong>CORS требования:</strong></p><ul><li>Access-Control-Allow-Credentials: true обязателен</li><li>Origin должен быть конкретным (не *)</li><li>Credentials: 'include' в fetch</li><li>SameSite cookie атрибуты критичны</li></ul><p><strong>Проблемы:</strong></p><ul><li>Сложнее настройка CORS</li><li>CSRF риски</li><li>SameSite=Strict блокирует cross-site</li><li>Third-party cookie блокировка браузерами</li></ul><p><strong>OAuth 2.0 и OIDC:</strong></p><p><strong>Authorization Code Flow:</strong></p><ul><li>Редиректы не подвержены CORS</li><li>Token exchange через backend</li><li>CORS только для API вызовов с token</li></ul><p><strong>Implicit Flow (устарел):</strong></p><ul><li>Token в URL fragment</li><li>CORS для authorize endpoint</li><li>Не рекомендуется для production</li></ul><p><strong>PKCE:</strong></p><ul><li>Более безопасная альтернатива</li><li>CORS для token endpoint</li><li>Используется в SPA</li></ul><p><strong>Basic Authentication:</strong></p><ul><li>Authorization: Basic base64(user:pass)</li><li>Требует preflight</li><li>Небезопасно без HTTPS</li><li>Редко используется в modern apps</li></ul><p><strong>Best Practices по типу auth:</strong></p><p><strong>Для SPA:</strong></p><ul><li>Предпочитайте Bearer tokens</li><li>JWT с reasonable expiration</li><li>Refresh tokens через secure endpoint</li></ul><p><strong>Для традиционных веб-приложений:</strong></p><ul><li>Cookie-based с SameSite=Lax</li><li>CSRF protection обязательна</li><li>HTTPS only</li></ul><p><strong>Для mobile/desktop apps:</strong></p><ul><li>OAuth 2.0 с PKCE</li><li>Secure storage для tokens</li><li>Token refresh flow</li></ul><p><strong>Для public APIs:</strong></p><ul><li>API keys в headers</li><li>Rate limiting по ключам</li><li>Rotating keys</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'аутентификация', 'Bearer token', 'API keys', 'OAuth']
  },
  {
    id: 44,
    question: "Какие проблемы возникают с CORS при использовании CDN и как их решать?",
    answer: "<p>CDN и CORS создают <strong>уникальные вызовы</strong> из-за множественности origins:</p><p><strong>Основные проблемы:</strong></p><p><strong>1. Множественные origins:</strong></p><ul><li>cdn.example.com отличается от app.example.com</li><li>Требуется настройка CORS для CDN домена</li><li>Особенно для fetch запросов к CDN ресурсам</li></ul><p><strong>2. Статические ресурсы и CORS:</strong></p><p><strong>Images:</strong></p><ul><li>Загружаются без CORS по умолчанию</li><li>Но canvas.toDataURL() требует CORS</li><li>crossorigin=\"anonymous\" атрибут для CORS</li></ul><p><strong>CSS:</strong></p><ul><li>Загружается без CORS</li><li>Font-face в CSS требует CORS</li><li>@font-face с CDN нуждается в правильных заголовках</li></ul><p><strong>JavaScript:</strong></p><ul><li>Загружается без CORS обычно</li><li>Но module scripts требуют CORS</li><li>type=\"module\" активирует CORS проверку</li></ul><p><strong>3. Web Fonts проблемы:</strong></p><p><strong>Проблема:</strong></p><ul><li>Браузеры требуют CORS для fonts</li><li>Защита от font fingerprinting</li><li>WOFF/WOFF2/TTF требуют заголовки</li></ul><p><strong>Решение:</strong></p><ul><li>Access-Control-Allow-Origin на CDN</li><li>Wildcard OK для fonts (public resources)</li><li>Или конкретные домены</li></ul><p><strong>4. Caching и Vary header:</strong></p><p><strong>Проблема:</strong></p><ul><li>CORS ответы должны vary по Origin</li><li>CDN может кэшировать неправильный вариант</li><li>Пользователь A получает CORS для домена B</li></ul><p><strong>Решение:</strong></p><ul><li>Vary: Origin в ответах</li><li>CDN respects Vary и кэширует отдельно</li><li>Или отдельные URLs для разных origins</li></ul><p><strong>5. CORS для API через CDN:</strong></p><p><strong>Edge computing:</strong></p><ul><li>Cloudflare Workers, Lambda@Edge</li><li>Могут добавлять CORS headers динамически</li><li>Обработка preflight на edge</li></ul><p><strong>Reverse proxy:</strong></p><ul><li>CDN проксирует к origin server</li><li>Добавляет CORS headers</li><li>Кэширует preflight ответы</li></ul><p><strong>Конфигурация популярных CDN:</strong></p><p><strong>Cloudflare:</strong></p><ul><li>Page Rules для CORS headers</li><li>Workers для динамической обработки</li><li>Transform Rules для модификации headers</li></ul><p><strong>AWS CloudFront:</strong></p><ul><li>Behavior settings для CORS</li><li>Lambda@Edge для сложной логики</li><li>Origin Response для добавления headers</li></ul><p><strong>Fastly:</strong></p><ul><li>VCL для настройки CORS</li><li>Header manipulation</li><li>Edge logic для validation</li></ul><p><strong>Azure CDN:</strong></p><ul><li>Rules engine для CORS</li><li>Custom domains configuration</li></ul><p><strong>Best Practices:</strong></p><p><strong>1. Разделение контента:</strong></p><ul><li>Публичные статические ресурсы на CDN</li><li>Приватные API на origin server</li><li>Разные CORS политики для разных типов</li></ul><p><strong>2. Правильный Vary:</strong></p><ul><li>Vary: Origin для CORS ресурсов</li><li>Cache-Control учитывает это</li></ul><p><strong>3. Preflight кэширование:</strong></p><ul><li>CDN кэширует OPTIONS ответы</li><li>Значительная экономия для edge locations</li></ul><p><strong>4. Мониторинг:</strong></p><ul><li>Отслеживайте CORS errors</li><li>CDN analytics для проблемных origins</li><li>Логирование rejected requests</li></ul><p><strong>5. Testing:</strong></p><ul><li>Тестируйте с разных origins</li><li>Проверяйте cache behavior</li><li>Различные edge locations</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'CDN', 'статические ресурсы', 'кэширование']
  },
  {
    id: 45,
    question: "Как правильно обрабатывать CORS ошибки на клиенте и предоставлять полезные сообщения пользователю?",
    answer: "<p>Обработка CORS ошибок на клиенте требует <strong>специального подхода</strong>, так как браузер ограничивает доступ к деталям:</p><p><strong>Особенности CORS ошибок:</strong></p><p><strong>1. Ограниченная информация:</strong></p><ul><li>Браузер не предоставляет детали CORS ошибок в JavaScript</li><li>fetch просто reject с типичным сообщением</li><li>Нет доступа к response при CORS failure</li><li>Невозможно определить точную причину programmatically</li></ul><p><strong>2. Что доступно:</strong></p><ul><li>TypeError в catch блоке</li><li>network error сообщение</li><li>Детали только в console (недоступны JS)</li></ul><p><strong>Определение CORS ошибки:</strong></p><p><strong>Индикаторы CORS проблемы:</strong></p><ul><li>Network error при cross-origin запросе</li><li>Статус 0 или отсутствие статуса</li><li>Нет response body</li><li>Ошибка только при cross-origin (work same-origin)</li></ul><p><strong>Отличие от других network errors:</strong></p><ul><li>CORS ошибка VS offline</li><li>CORS ошибка VS DNS failure</li><li>CORS ошибка VS timeout</li><li>Точно определить сложно, нужна эвристика</li></ul><p><strong>Стратегии обработки:</strong></p><p><strong>1. Graceful degradation:</strong></p><ul><li>Fallback на альтернативный источник данных</li><li>Retry через proxy если доступен</li><li>Использовать cached data если есть</li></ul><p><strong>2. User-friendly сообщения:</strong></p><ul><li>Избегайте технических терминов</li><li>\"Не удалось загрузить данные\" вместо \"CORS error\"</li><li>Предложите действия (обновить, попробовать позже)</li></ul><p><strong>3. Диагностика для разработчиков:</strong></p><ul><li>Детальное логирование в development</li><li>Отправка errors в error tracking (Sentry, etc)</li><li>Включайте URL, origin, метод</li></ul><p><strong>4. Retry логика:</strong></p><ul><li>CORS ошибки обычно не временные</li><li>Retry бесполезен без изменения подхода</li><li>Но можно retry через fallback URL</li></ul><p><strong>Практическая реализация:</strong></p><p><strong>Error handling wrapper:</strong></p><ul><li>Централизованная обработка fetch</li><li>Определение типа ошибки</li><li>Логирование и user notification</li><li>Fallback механизмы</li></ul><p><strong>Различные уровни detail:</strong></p><ul><li>Development: полная информация</li><li>Production: user-friendly messages</li><li>Logging: все детали для debugging</li></ul><p><strong>Работа с разными endpoints:</strong></p><ul><li>Критичные: блокирующее сообщение</li><li>Некритичные: тихий fallback</li><li>Background: retry без UI impact</li></ul><p><strong>Превентивные меры:</strong></p><p><strong>1. Preflight check:</strong></p><ul><li>HEAD запрос перед основным</li><li>Проверка доступности</li><li>Но удваивает запросы</li></ul><p><strong>2. Feature detection:</strong></p><ul><li>Проверка поддержки CORS</li><li>Выбор метода загрузки данных</li></ul><p><strong>3. Configuration check:</strong></p><ul><li>Endpoint health check при инициализации</li><li>Предупреждение администратора</li></ul><p><strong>Коммуникация с пользователем:</strong></p><p><strong>Типы сообщений:</strong></p><ul><li><strong>Для временных проблем:</strong> \"Попробуйте обновить страницу\"</li><li><strong>Для блокировки:</strong> \"Контент недоступен из вашего региона\"</li><li><strong>Для конфигурации:</strong> \"Проверьте настройки браузера\"</li></ul><p><strong>Дополнительные действия:</strong></p><ul><li>Кнопка retry</li><li>Ссылка на support</li><li>Инструкции по устранению</li></ul><p><strong>Мониторинг CORS issues:</strong></p><ul><li>Tracking CORS errors frequency</li><li>Определение паттернов (browser, origin, endpoint)</li><li>Alerts для критических сервисов</li><li>Dashboard для visibility</li></ul>",
    difficulty: 'senior',
    tags: ['CORS', 'обработка ошибок', 'UX', 'error handling']
  },

  {
    id: 46,
    question: "Что такое XSS (Cross-Site Scripting) и какие типы XSS-атак существуют?",
    answer: "<p><strong>XSS</strong> — это уязвимость, которая позволяет злоумышленнику внедрить вредоносный JavaScript-код в веб-страницу, просматриваемую другими пользователями.</p><h4>Три основных типа XSS:</h4><p><strong>Reflected XSS (Отраженная):</strong></p><ul><li>Вредоносный код передается через URL или параметры запроса</li><li>Сервер сразу возвращает его в ответе без сохранения</li><li>Требует, чтобы жертва перешла по специальной ссылке</li><li>Пример: поисковый запрос отображается без экранирования</li></ul><p><strong>Stored XSS (Хранимая):</strong></p><ul><li>Вредоносный код сохраняется на сервере (в БД, файлах)</li><li>Выполняется каждый раз, когда пользователи просматривают зараженную страницу</li><li>Наиболее опасный тип, не требует действий от жертвы</li><li>Пример: комментарии, профили пользователей, форумы</li></ul><p><strong>DOM-based XSS (Основанная на DOM):</strong></p><ul><li>Уязвимость находится в клиентском коде JavaScript</li><li>Сервер может быть не задействован вообще</li><li>Манипуляция DOM на стороне клиента</li><li>Пример: использование location.hash без проверки</li></ul><p><em>Опасность:</em> XSS позволяет украсть cookies, перехватить сессии, изменить контент страницы, перенаправить пользователя на фишинговый сайт.</p>",
    difficulty: 'middle',
    tags: ['XSS', 'безопасность', 'уязвимости', 'атаки']
  },
  {
    id: 47,
    question: "Как защититься от XSS-атак? Какие методы защиты вы знаете?",
    answer: "<p>Защита от XSS требует <strong>многоуровневого подхода</strong>:</p><h4>1. Экранирование и санитизация:</h4><p><strong>HTML-экранирование:</strong></p><ul><li>Преобразование специальных символов: &lt; &gt; &quot; ' &amp;</li><li>Использование библиотек: DOMPurify, js-xss</li><li>Применение на стороне сервера перед выводом</li></ul><p><strong>Контекстное экранирование:</strong></p><ul><li>Разное экранирование для HTML, JavaScript, CSS, URL</li><li>Учет контекста вывода данных</li></ul><h4>2. Content Security Policy (CSP):</h4><ul><li>HTTP-заголовок, ограничивающий источники выполнения скриптов</li><li>Блокировка inline-скриптов и eval()</li><li>Whitelist доверенных источников</li><li>Nonce или hash для разрешенных inline-скриптов</li></ul><h4>3. HTTPOnly cookies:</h4><ul><li>Флаг HTTPOnly запрещает доступ к cookies из JavaScript</li><li>Защита от кражи сессионных токенов</li></ul><h4>4. Валидация ввода:</h4><ul><li>Whitelist допустимых символов</li><li>Проверка типов и форматов данных</li><li>Ограничение длины строк</li></ul><h4>5. Безопасное использование фреймворков:</h4><ul><li>React автоматически экранирует JSX</li><li>Vue и Angular имеют встроенную защиту</li><li>Избегать dangerouslySetInnerHTML, v-html без санитизации</li></ul><p><em>Принцип:</em> Никогда не доверяйте пользовательскому вводу, всегда валидируйте и экранируйте данные.</p>",
    difficulty: 'middle',
    tags: ['XSS', 'защита', 'безопасность', 'CSP']
  },
  {
    id: 48,
    question: "Что такое CSRF (Cross-Site Request Forgery) и как работает эта атака?",
    answer: "<p><strong>CSRF</strong> — это атака, при которой злоумышленник заставляет аутентифицированного пользователя выполнить нежелательные действия на доверенном сайте без его ведома.</p><h4>Механизм атаки:</h4><ol><li>Пользователь аутентифицирован на сайте A (например, банк)</li><li>Пользователь посещает вредоносный сайт B</li><li>Сайт B содержит скрытый запрос к сайту A</li><li>Браузер автоматически отправляет cookies сайта A</li><li>Сервер A не может отличить легитимный запрос от поддельного</li></ol><h4>Примеры атак:</h4><p><strong>GET-запросы:</strong></p><ul><li>Скрытое изображение с URL действия</li><li>Автоматический переход по ссылке</li><li>Пример: перевод денег через GET-запрос</li></ul><p><strong>POST-запросы:</strong></p><ul><li>Автоматическая отправка скрытой формы через JavaScript</li><li>Изменение настроек, удаление данных</li><li>Пример: форма смены email с автоотправкой</li></ul><h4>Условия успешной атаки:</h4><ul><li>Пользователь аутентифицирован на целевом сайте</li><li>Сайт использует только cookies для аутентификации</li><li>Действие можно выполнить одним запросом</li><li>Нет дополнительной защиты (CSRF-токены)</li></ul><p><em>Опасность:</em> CSRF позволяет выполнять действия от имени пользователя: переводы денег, изменение настроек, удаление данных.</p>",
    difficulty: 'middle',
    tags: ['CSRF', 'безопасность', 'уязвимости', 'атаки']
  },
  {
    id: 49,
    question: "Какие методы защиты от CSRF-атак вы знаете?",
    answer: "<p>Существует несколько эффективных методов защиты от CSRF:</p><h4>1. CSRF-токены (основной метод):</h4><p><strong>Synchronizer Token Pattern:</strong></p><ul><li>Генерация уникального токена для каждой сессии или формы</li><li>Встраивание токена в формы как hidden-поле</li><li>Проверка токена на сервере при обработке запроса</li><li>Токен недоступен для стороннего сайта</li></ul><h4>2. SameSite Cookie атрибут:</h4><ul><li><strong>SameSite=Strict:</strong> Cookies не отправляются при переходе со сторонних сайтов</li><li><strong>SameSite=Lax:</strong> Cookies отправляются только для безопасных методов (GET)</li><li>Современная и эффективная защита</li><li>Поддерживается всеми современными браузерами</li></ul><h4>3. Double Submit Cookie:</h4><ul><li>Токен отправляется и в cookie, и в параметре запроса</li><li>Сервер сравнивает оба значения</li><li>Злоумышленник не может прочитать cookie стороннего домена</li></ul><h4>4. Custom Headers:</h4><ul><li>Требование кастомных заголовков для AJAX-запросов</li><li>CORS не позволит стороннему сайту добавить кастомные заголовки</li><li>Проверка заголовков типа X-Requested-With</li></ul><h4>5. Проверка Referer/Origin:</h4><ul><li>Валидация заголовков Referer или Origin</li><li>Дополнительная защита, не основная</li><li>Может быть обойдена или отсутствовать</li></ul><h4>6. Требование повторной аутентификации:</h4><ul><li>Для критичных операций запрашивать пароль</li><li>Подтверждение через email/SMS</li></ul><p><em>Лучшая практика:</em> Комбинировать несколько методов — CSRF-токены + SameSite cookies.</p>",
    difficulty: 'middle',
    tags: ['CSRF', 'защита', 'токены', 'безопасность']
  },
  {
    id: 50,
    question: "Объясните, что такое Content Security Policy (CSP) и как он защищает от XSS",
    answer: "<p><strong>Content Security Policy (CSP)</strong> — это механизм безопасности, который помогает предотвратить XSS-атаки путем ограничения источников, из которых браузер может загружать ресурсы.</p><h4>Как работает CSP:</h4><p>Сервер отправляет HTTP-заголовок <code>Content-Security-Policy</code> с набором директив, которые определяют разрешенные источники контента.</p><h4>Основные директивы:</h4><p><strong>script-src:</strong></p><ul><li>Определяет источники JavaScript</li><li>Может блокировать inline-скрипты</li><li>Запрещает eval() и подобные функции</li></ul><p><strong>default-src:</strong></p><ul><li>Fallback для остальных директив</li><li>Устанавливает политику по умолчанию</li></ul><p><strong>style-src, img-src, font-src:</strong></p><ul><li>Ограничения для стилей, изображений, шрифтов</li></ul><h4>Значения источников:</h4><ul><li><strong>'self':</strong> Только с текущего домена</li><li><strong>'none':</strong> Блокировать полностью</li><li><strong>'unsafe-inline':</strong> Разрешить inline-код (небезопасно)</li><li><strong>'unsafe-eval':</strong> Разрешить eval() (небезопасно)</li><li><strong>nonce-'xxx':</strong> Разрешить скрипт с конкретным nonce</li><li><strong>hash:</strong> Разрешить скрипт с определенным хешем</li></ul><h4>Защита от XSS:</h4><ul><li>Блокирует выполнение inline-скриптов</li><li>Запрещает загрузку скриптов со сторонних доменов</li><li>Предотвращает использование eval()</li><li>Даже если злоумышленник внедрит код, браузер его не выполнит</li></ul><p><em>Важно:</em> CSP — это дополнительный уровень защиты, не заменяющий экранирование ввода.</p>",
    difficulty: 'senior',
    tags: ['CSP', 'XSS', 'безопасность', 'заголовки']
  },
  {
    id: 51,
    question: "В чем разница между XSS и CSRF? Как они связаны?",
    answer: "<p>XSS и CSRF — это <strong>разные типы атак</strong> с разными целями и методами:</p><h4>XSS (Cross-Site Scripting):</h4><ul><li><strong>Цель:</strong> Внедрение и выполнение вредоносного кода</li><li><strong>Выполнение:</strong> Код выполняется в контексте уязвимого сайта</li><li><strong>Атакуемый:</strong> Пользователи уязвимого сайта</li><li><strong>Последствия:</strong> Кража данных, cookies, манипуляция DOM</li><li><strong>Защита:</strong> Экранирование, CSP, HTTPOnly cookies</li></ul><h4>CSRF (Cross-Site Request Forgery):</h4><ul><li><strong>Цель:</strong> Заставить пользователя выполнить нежелательное действие</li><li><strong>Выполнение:</strong> Запрос отправляется со стороннего сайта</li><li><strong>Атакуемый:</strong> Целевой сайт, на котором аутентифицирован пользователь</li><li><strong>Последствия:</strong> Нежелательные действия от имени пользователя</li><li><strong>Защита:</strong> CSRF-токены, SameSite cookies</li></ul><h4>Как они связаны:</h4><p><strong>XSS может обойти защиту от CSRF:</strong></p><ul><li>Через XSS можно прочитать CSRF-токен со страницы</li><li>XSS позволяет отправить валидный запрос с токеном</li><li>XSS делает защиту от CSRF бесполезной</li></ul><p><strong>Цепочка атак:</strong></p><ul><li>XSS для получения информации</li><li>CSRF для выполнения действий</li><li>Комбинация усиливает эффект</li></ul><p><em>Вывод:</em> XSS — это внедрение кода, CSRF — подделка запросов. XSS опаснее, так как позволяет обойти многие защиты, включая CSRF-токены.</p>",
    difficulty: 'middle',
    tags: ['XSS', 'CSRF', 'сравнение', 'безопасность']
  },
  {
    id: 52,
    question: "Что такое HTTPOnly и Secure флаги для cookies? Как они защищают от атак?",
    answer: "<p>HTTPOnly и Secure — это <strong>флаги безопасности для cookies</strong>, которые существенно повышают защиту:</p><h4>HTTPOnly флаг:</h4><p><strong>Назначение:</strong></p><ul><li>Запрещает доступ к cookie из JavaScript</li><li>Cookie доступен только серверу через HTTP-заголовки</li><li>document.cookie не может прочитать или изменить такой cookie</li></ul><p><strong>Защита от XSS:</strong></p><ul><li>Даже если злоумышленник внедрит JavaScript, он не сможет украсть сессионный cookie</li><li>Предотвращает кражу аутентификационных токенов</li><li>Критически важен для session cookies</li></ul><h4>Secure флаг:</h4><p><strong>Назначение:</strong></p><ul><li>Cookie передается только по HTTPS</li><li>Запрещает передачу cookie по незащищенному HTTP</li><li>Защита от перехвата в незащищенных сетях</li></ul><p><strong>Защита от атак:</strong></p><ul><li>Предотвращает перехват cookies при MITM-атаках</li><li>Защита в публичных Wi-Fi сетях</li><li>Обязателен для всех чувствительных cookies</li></ul><h4>SameSite флаг (бонус):</h4><ul><li><strong>SameSite=Strict:</strong> Cookie не отправляется при cross-site запросах</li><li><strong>SameSite=Lax:</strong> Cookie отправляется только для безопасных методов</li><li>Защита от CSRF-атак</li></ul><h4>Лучшие практики:</h4><ul><li>Всегда используйте HTTPOnly для session cookies</li><li>Всегда используйте Secure в production</li><li>Добавляйте SameSite для защиты от CSRF</li><li>Комбинируйте все три флага для максимальной безопасности</li></ul><p><em>Важно:</em> Эти флаги — базовая защита, обязательная для любого современного веб-приложения.</p>",
    difficulty: 'middle',
    tags: ['cookies', 'HTTPOnly', 'Secure', 'безопасность', 'XSS']
  },
  {
    id: 53,
    question: "Как правильно обрабатывать пользовательский ввод для предотвращения XSS?",
    answer: "<p>Обработка пользовательского ввода требует <strong>комплексного подхода</strong> на всех уровнях:</p><h4>1. Никогда не доверяйте вводу:</h4><ul><li>Любой пользовательский ввод потенциально опасен</li><li>Проверяйте данные на клиенте И на сервере</li><li>Клиентская валидация — для UX, серверная — для безопасности</li></ul><h4>2. Контекстное экранирование:</h4><p><strong>HTML-контекст:</strong></p><ul><li>Экранируйте &lt; &gt; &quot; ' &amp;</li><li>Используйте textContent вместо innerHTML</li><li>При необходимости innerHTML — санитизация через DOMPurify</li></ul><p><strong>JavaScript-контекст:</strong></p><ul><li>JSON.stringify() для данных в JavaScript</li><li>Избегайте вставки данных в eval() или Function()</li><li>Экранируйте обратные слеши и кавычки</li></ul><p><strong>URL-контекст:</strong></p><ul><li>encodeURIComponent() для параметров URL</li><li>Валидация протокола (запрет javascript:, data:)</li></ul><p><strong>CSS-контекст:</strong></p><ul><li>Избегайте вставки пользовательских данных в CSS</li><li>Валидация значений цветов, размеров</li></ul><h4>3. Использование безопасных API:</h4><ul><li>createElement() вместо innerHTML</li><li>textContent вместо innerText</li><li>setAttribute() для атрибутов</li><li>Параметризованные запросы для SQL</li></ul><h4>4. Санитизация HTML:</h4><ul><li>Библиотека DOMPurify для очистки HTML</li><li>Whitelist разрешенных тегов и атрибутов</li><li>Удаление event handlers (onclick, onerror)</li></ul><h4>5. Валидация типов данных:</h4><ul><li>Проверка формата email, URL, номеров</li><li>Ограничение длины строк</li><li>Whitelist символов для каждого типа ввода</li></ul><p><em>Золотое правило:</em> Экранируйте при выводе, валидируйте при вводе, санитизируйте при необходимости.</p>",
    difficulty: 'senior',
    tags: ['XSS', 'валидация', 'санитизация', 'экранирование']
  },
  {
    id: 54,
    question: "Объясните, что такое DOM-based XSS и чем она отличается от других типов",
    answer: "<p><strong>DOM-based XSS</strong> — это уязвимость, при которой вредоносный код выполняется в результате изменения DOM-окружения в браузере клиента.</p><h4>Ключевые отличия:</h4><p><strong>От Reflected XSS:</strong></p><ul><li>Код не проходит через сервер</li><li>Вся атака происходит на стороне клиента</li><li>Сервер может быть полностью безопасным</li><li>Логи сервера не покажут атаку</li></ul><p><strong>От Stored XSS:</strong></p><ul><li>Данные не сохраняются в БД</li><li>Не требует взаимодействия с сервером</li><li>Полностью клиентская уязвимость</li></ul><h4>Механизм атаки:</h4><ol><li>JavaScript на странице читает данные из небезопасного источника</li><li>Небезопасные источники: location.hash, location.search, document.referrer</li><li>Данные используются в опасных методах без валидации</li><li>Опасные методы: eval(), innerHTML, document.write()</li></ol><h4>Примеры уязвимого кода:</h4><p><strong>location.hash в innerHTML:</strong> Чтение хеша URL и вставка в DOM</p><p><strong>postMessage обработчик:</strong> Прием сообщений без проверки origin</p><p><strong>URL параметры в eval():</strong> Выполнение кода из URL</p><h4>Источники данных (sources):</h4><ul><li>location.href, location.search, location.hash</li><li>document.referrer, document.cookie</li><li>window.name, localStorage</li><li>postMessage события</li></ul><h4>Опасные методы (sinks):</h4><ul><li>eval(), setTimeout(string), setInterval(string)</li><li>innerHTML, outerHTML, document.write()</li><li>element.setAttribute('onclick', ...)</li><li>location.href = 'javascript:...'</li></ul><h4>Защита:</h4><ul><li>Избегайте опасных методов</li><li>Валидация всех данных из sources</li><li>Используйте textContent вместо innerHTML</li><li>CSP для блокировки inline-скриптов</li><li>Статический анализ кода</li></ul><p><em>Опасность:</em> DOM-based XSS труднее обнаружить, так как не видна на сервере и в HTML-коде.</p>",
    difficulty: 'senior',
    tags: ['DOM-based XSS', 'XSS', 'клиентская безопасность', 'JavaScript']
  },
  {
    id: 55,
    question: "Что такое CSP nonce и hash? Когда их использовать?",
    answer: "<p>Nonce и hash — это механизмы CSP для <strong>разрешения конкретных inline-скриптов</strong> без полного отключения защиты:</p><h4>CSP Nonce (Number used ONCE):</h4><p><strong>Как работает:</strong></p><ul><li>Сервер генерирует уникальное случайное значение для каждого запроса</li><li>Nonce добавляется в CSP-заголовок и в атрибут script</li><li>Браузер выполняет только скрипты с правильным nonce</li><li>Каждый page load — новый nonce</li></ul><p><strong>Преимущества:</strong></p><ul><li>Разрешает нужные inline-скрипты</li><li>Сохраняет защиту от XSS</li><li>Гибкость для динамического контента</li></ul><p><strong>Требования:</strong></p><ul><li>Nonce должен быть криптографически случайным</li><li>Минимум 128 бит энтропии</li><li>Уникален для каждого запроса</li><li>Непредсказуем для атакующего</li></ul><h4>CSP Hash:</h4><p><strong>Как работает:</strong></p><ul><li>Сервер вычисляет хеш содержимого скрипта</li><li>Хеш добавляется в CSP-заголовок</li><li>Браузер вычисляет хеш скрипта и сравнивает</li><li>Выполняются только скрипты с совпадающим хешем</li></ul><p><strong>Преимущества:</strong></p><ul><li>Не требует серверного состояния</li><li>Подходит для статического контента</li><li>Кэшируемые CSP-заголовки</li></ul><p><strong>Ограничения:</strong></p><ul><li>Любое изменение скрипта меняет хеш</li><li>Не подходит для динамического контента</li><li>Нужно пересчитывать при каждом изменении</li></ul><h4>Когда использовать:</h4><p><strong>Nonce:</strong></p><ul><li>Динамический контент</li><li>Server-side rendering</li><li>Когда скрипты генерируются на лету</li></ul><p><strong>Hash:</strong></p><ul><li>Статические скрипты</li><li>Редко изменяющийся код</li><li>Build-time генерация</li></ul><h4>Комбинирование:</h4><ul><li>Можно использовать и nonce, и hash одновременно</li><li>Nonce для динамических, hash для статических скриптов</li><li>Максимальная гибкость и безопасность</li></ul><p><em>Best practice:</em> Предпочитайте nonce для максимальной безопасности и гибкости.</p>",
    difficulty: 'senior',
    tags: ['CSP', 'nonce', 'hash', 'безопасность', 'inline-скрипты']
  },
  {
    id: 56,
    question: "Как тестировать веб-приложение на наличие XSS-уязвимостей?",
    answer: "<p>Тестирование на XSS требует <strong>систематического подхода</strong> и использования различных инструментов:</p><h4>1. Ручное тестирование:</h4><p><strong>Базовые payload'ы:</strong></p><ul><li>Простые теги: &lt;script&gt;alert(1)&lt;/script&gt;</li><li>Event handlers: &lt;img src=x onerror=alert(1)&gt;</li><li>JavaScript схема: &lt;a href='javascript:alert(1)'&gt;</li></ul><p><strong>Обход фильтров:</strong></p><ul><li>Регистр: &lt;ScRiPt&gt;alert(1)&lt;/ScRiPt&gt;</li><li>Кодировки: HTML entities, URL encoding, Unicode</li><li>Разные контексты: HTML, JavaScript, CSS, URL</li></ul><p><strong>Где тестировать:</strong></p><ul><li>Все поля форм и параметры URL</li><li>Поисковые запросы</li><li>Профили пользователей</li><li>Комментарии и отзывы</li><li>Заголовки HTTP (User-Agent, Referer)</li></ul><h4>2. Автоматизированные сканеры:</h4><p><strong>Специализированные инструменты:</strong></p><ul><li>XSStrike — мощный XSS сканер</li><li>XSSer — автоматизация XSS тестирования</li><li>Burp Suite Pro — комплексный сканер</li><li>OWASP ZAP — бесплатный security scanner</li></ul><h4>3. Браузерные инструменты:</h4><ul><li>DevTools Console для выполнения payload'ов</li><li>Network tab для анализа запросов</li><li>XSS Hunter для поиска blind XSS</li></ul><h4>4. Код-ревью:</h4><p><strong>Опасные паттерны:</strong></p><ul><li>innerHTML без санитизации</li><li>eval() с пользовательскими данными</li><li>document.write() с внешними данными</li><li>Отсутствие экранирования в шаблонах</li></ul><p><strong>Статический анализ:</strong></p><ul><li>ESLint правила для безопасности</li><li>SonarQube для поиска уязвимостей</li><li>Semgrep для паттерн-матчинга</li></ul><h4>5. Контекстное тестирование:</h4><ul><li>HTML контекст: теги и атрибуты</li><li>JavaScript контекст: строки и переменные</li><li>URL контекст: параметры и фрагменты</li><li>CSS контекст: свойства и значения</li></ul><h4>6. Проверка защит:</h4><ul><li>Наличие CSP-заголовков</li><li>HTTPOnly флаг на cookies</li><li>Корректность экранирования</li><li>Работа санитизации</li></ul><p><em>Важно:</em> Тестирование должно быть регулярным, включено в CI/CD, и комбинировать автоматические и ручные методы.</p>",
    difficulty: 'senior',
    tags: ['XSS', 'тестирование', 'безопасность', 'пентест']
  },
  {
    id: 57,
    question: "Какие библиотеки помогают защититься от XSS в JavaScript?",
    answer: "<p>Существует множество проверенных библиотек для защиты от XSS:</p><h4>1. DOMPurify:</h4><p><strong>Назначение:</strong> Санитизация HTML, удаление опасных элементов и атрибутов</p><p><strong>Особенности:</strong></p><ul><li>Наиболее популярная и надежная библиотека</li><li>Whitelist-подход к очистке</li><li>Поддержка конфигурации для разных случаев</li><li>Работает в браузере и Node.js</li><li>Регулярные обновления и патчи</li></ul><p><strong>Когда использовать:</strong> Когда нужно отобразить пользовательский HTML (rich text editors, markdown)</p><h4>2. js-xss:</h4><p><strong>Назначение:</strong> Фильтрация XSS на основе whitelist</p><p><strong>Особенности:</strong></p><ul><li>Гибкая настройка разрешенных тегов</li><li>Поддержка кастомных обработчиков</li><li>Легковесная альтернатива DOMPurify</li></ul><h4>3. xss-filters (Yahoo):</h4><p><strong>Назначение:</strong> Контекстное экранирование для различных контекстов</p><p><strong>Особенности:</strong></p><ul><li>Специализированные функции для HTML, JS, CSS, URL</li><li>Правильное экранирование по контексту</li><li>Минимальные зависимости</li></ul><h4>4. Фреймворк-специфичные решения:</h4><p><strong>React:</strong></p><ul><li>Встроенное экранирование в JSX</li><li>react-html-parser для безопасного парсинга</li><li>Избегайте dangerouslySetInnerHTML без DOMPurify</li></ul><p><strong>Vue:</strong></p><ul><li>Автоматическое экранирование в template</li><li>v-html требует санитизации</li><li>vue-dompurify-html для безопасного HTML</li></ul><p><strong>Angular:</strong></p><ul><li>Встроенная санитизация через DomSanitizer</li><li>Автоматическая защита в templates</li><li>Bypass методы только для доверенного контента</li></ul><h4>5. Validator.js:</h4><p><strong>Назначение:</strong> Валидация и санитизация строк</p><p><strong>Особенности:</strong></p><ul><li>Валидация email, URL, IP адресов</li><li>Escape функции для HTML</li><li>Trim и нормализация данных</li></ul><h4>Рекомендации по использованию:</h4><ul><li>DOMPurify для очистки HTML-контента</li><li>Встроенные механизмы фреймворков по умолчанию</li><li>xss-filters для специфичного контекстного экранирования</li><li>Регулярное обновление всех библиотек</li><li>Комбинирование с CSP для многоуровневой защиты</li></ul><p><em>Важно:</em> Библиотеки — не панацея, нужен правильный архитектурный подход к безопасности.</p>",
    difficulty: 'middle',
    tags: ['XSS', 'библиотеки', 'защита', 'DOMPurify', 'санитизация']
  },
  {
    id: 58,
    question: "Объясните, что такое Same-Origin Policy и как она связана с CSRF",
    answer: "<p><strong>Same-Origin Policy (SOP)</strong> — это фундаментальная концепция безопасности браузера, ограничивающая взаимодействие между ресурсами с разных источников.</p><h4>Определение origin (источника):</h4><p>Origin определяется комбинацией трех компонентов:</p><ul><li><strong>Протокол</strong> (scheme): http vs https</li><li><strong>Домен</strong> (host): example.com vs api.example.com</li><li><strong>Порт</strong> (port): :80 vs :443</li></ul><p>Все три должны совпадать для одного origin</p><h4>Что ограничивает SOP:</h4><ul><li>JavaScript не может читать ответы от запросов к другому origin</li><li>Нельзя получить доступ к DOM другого origin в iframe</li><li>Нельзя читать cookies другого домена</li><li>Ограничения на доступ к localStorage, indexedDB</li></ul><h4>Что НЕ ограничивает SOP:</h4><ul><li>Отправку запросов (можно отправить, но не прочитать ответ)</li><li>Загрузку изображений, скриптов, стилей</li><li>Отправку форм (POST-запросы выполняются)</li><li>Navigation requests (переходы по ссылкам)</li></ul><h4>Связь с CSRF:</h4><p><strong>Почему SOP не защищает от CSRF:</strong></p><ul><li>SOP не запрещает отправку cross-origin запросов</li><li>Браузер автоматически отправляет cookies с запросом</li><li>Сервер выполнит действие, даже если ответ не будет прочитан</li><li>Атакующему не нужно читать ответ для успешной CSRF</li></ul><p><strong>Пример CSRF-атаки несмотря на SOP:</strong></p><ol><li>Вредоносный сайт отправляет POST-запрос к банку</li><li>SOP не блокирует отправку запроса</li><li>Браузер отправляет cookies авторизации</li><li>Банк выполняет перевод денег</li><li>SOP блокирует чтение ответа, но это уже неважно</li></ol><h4>Дополнительные механизмы:</h4><p><strong>CORS (Cross-Origin Resource Sharing):</strong></p><ul><li>Контролируемое ослабление SOP</li><li>Сервер явно разрешает cross-origin запросы</li><li>Preflight requests для проверки разрешений</li></ul><p><strong>CSRF-защита поверх SOP:</strong></p><ul><li>CSRF-токены проверяют намерение пользователя</li><li>SameSite cookies ограничивают отправку cookies</li><li>Custom headers требуют CORS preflight</li></ul><p><em>Вывод:</em> SOP защищает конфиденциальность данных, но не целостность операций — поэтому CSRF-защита необходима отдельно.</p>",
    difficulty: 'senior',
    tags: ['Same-Origin Policy', 'CSRF', 'CORS', 'безопасность браузера']
  },
  {
    id: 59,
    question: "Как работает атрибут SameSite для cookies и какие значения он может принимать?",
    answer: "<p><strong>SameSite</strong> — это атрибут cookie, который контролирует, когда браузер отправляет cookie в cross-site запросах, обеспечивая защиту от CSRF.</p><h4>Три значения SameSite:</h4><h4>1. SameSite=Strict:</h4><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется ТОЛЬКО при запросах с того же сайта</li><li>Не отправляется при переходе с внешнего сайта</li><li>Даже обычные ссылки не включают cookie</li></ul><p><strong>Защита:</strong> Максимальная защита от CSRF</p><p><strong>Проблемы:</strong></p><ul><li>Пользователь не будет авторизован при переходе по ссылке</li><li>Неудобно для пользователей</li><li>Может нарушить UX</li></ul><p><strong>Когда использовать:</strong> Для особо чувствительных операций (банковские транзакции)</p><h4>2. SameSite=Lax (по умолчанию):</h4><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется для 'безопасной' top-level навигации</li><li>Разрешены GET-запросы при переходах по ссылкам</li><li>Запрещены POST, PUT, DELETE из внешних сайтов</li><li>Запрещены AJAX/fetch запросы из других origin</li></ul><p><strong>Защита:</strong> Хорошая защита от CSRF для изменяющих операций</p><p><strong>Преимущества:</strong></p><ul><li>Баланс между безопасностью и удобством</li><li>Пользователь остается авторизован при переходах</li><li>Защищает опасные методы (POST, DELETE)</li></ul><p><strong>Когда использовать:</strong> Для большинства сценариев, рекомендуется по умолчанию</p><h4>3. SameSite=None:</h4><p><strong>Поведение:</strong></p><ul><li>Cookie отправляется во всех запросах</li><li>Включая все cross-site запросы</li><li>ТРЕБУЕТ атрибут Secure (только HTTPS)</li></ul><p><strong>Защита:</strong> Нет защиты от CSRF, нужны другие механизмы</p><p><strong>Когда использовать:</strong></p><ul><li>Embed виджеты (платежи, чаты)</li><li>OAuth и Single Sign-On</li><li>Любые сценарии cross-site аутентификации</li></ul><h4>Изменения в браузерах:</h4><ul><li>Chrome 80+ сделал Lax дефолтным значением</li><li>Если SameSite не указан, применяется Lax</li><li>Старые браузеры игнорируют атрибут (без SameSite)</li></ul><h4>Рекомендации:</h4><ul><li><strong>Session cookies:</strong> SameSite=Lax или Strict</li><li><strong>CSRF tokens:</strong> SameSite=Strict</li><li><strong>Analytics:</strong> SameSite=None; Secure</li><li><strong>Всегда комбинируйте:</strong> SameSite + HTTPOnly + Secure</li></ul><p><em>Best practice:</em> Используйте SameSite=Lax для всех аутентификационных cookies, если нет специфичных требований.</p>",
    difficulty: 'middle',
    tags: ['SameSite', 'cookies', 'CSRF', 'защита']
  },
  {
    id: 60,
    question: "Какие распространенные ошибки разработчики допускают, открывая уязвимости для XSS и CSRF?",
    answer: "<p>Разработчики часто допускают <strong>типичные ошибки</strong>, создавая уязвимости:</p><h4>Ошибки, приводящие к XSS:</h4><p><strong>1. Доверие клиентской валидации:</strong></p><ul><li>Валидация только на фронтенде</li><li>Отсутствие проверки на бэкенде</li><li>Легко обойти через DevTools или прямые запросы</li></ul><p><strong>2. Неправильное использование innerHTML:</strong></p><ul><li>Прямая вставка пользовательских данных</li><li>Использование без санитизации</li><li>Забывают про textContent как альтернативу</li></ul><p><strong>3. Некорректное экранирование:</strong></p><ul><li>Экранирование только для HTML, но не для JavaScript/URL</li><li>Одинарное экранирование вместо контекстного</li><li>Пропуск экранирования в динамических атрибутах</li></ul><p><strong>4. Опасные методы JavaScript:</strong></p><ul><li>eval() с пользовательскими данными</li><li>setTimeout/setInterval со строками</li><li>new Function() с внешними данными</li><li>document.write() с непроверенными данными</li></ul><p><strong>5. Неправильный CSP:</strong></p><ul><li>Использование 'unsafe-inline' и 'unsafe-eval'</li><li>Слишком широкие whitelist источников</li><li>Отсутствие CSP вообще</li></ul><h4>Ошибки, приводящие к CSRF:</h4><p><strong>1. Отсутствие CSRF-токенов:</strong></p><ul><li>Полагаются только на session cookies</li><li>Не проверяют токены на изменяющих операциях</li><li>Используют предсказуемые токены</li></ul><p><strong>2. Неправильное использование HTTP-методов:</strong></p><ul><li>GET-запросы для изменения данных</li><li>Идемпотентность игнорируется</li><li>Все операции через GET для 'простоты'</li></ul><p><strong>3. Игнорирование SameSite:</strong></p><ul><li>Не устанавливают SameSite для cookies</li><li>Используют SameSite=None без необходимости</li><li>Забывают про Secure с SameSite=None</li></ul><p><strong>4. Проверка только Referer:</strong></p><ul><li>Полагаются только на Referer-заголовок</li><li>Referer может отсутствовать или подделываться</li><li>Не достаточно для надежной защиты</li></ul><h4>Общие организационные ошибки:</h4><ul><li><strong>Отсутствие security testing:</strong> Нет регулярных проверок на уязвимости</li><li><strong>Устаревшие зависимости:</strong> Не обновляют библиотеки с известными уязвимостями</li><li><strong>Недостаток обучения:</strong> Разработчики не знают о базовых уязвимостях</li><li><strong>Спешка в разработке:</strong> Пропуск security review из-за дедлайнов</li><li><strong>Копипаста кода:</strong> Перенос уязвимого кода из StackOverflow</li></ul><h4>Превентивные меры:</h4><ul><li>Обязательный security code review</li><li>Автоматизированное тестирование безопасности в CI/CD</li><li>Регулярное обучение команды</li><li>Использование безопасных фреймворков и библиотек</li><li>Следование принципу defense in depth</li></ul><p><em>Главное правило:</em> Безопасность должна быть встроена в процесс разработки с самого начала, а не добавляться потом.</p>",
    difficulty: 'senior',
    tags: ['XSS', 'CSRF', 'ошибки', 'best practices', 'безопасность']
  }
];
