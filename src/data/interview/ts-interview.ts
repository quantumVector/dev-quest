export interface TSQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const tsInterviewQuestions: TSQuestion[] = [
  {
    id: 1,
    question: "Какие основные преимущества TypeScript перед JavaScript вы можете назвать?",
    answer: "<p>TypeScript предоставляет несколько <strong>ключевых преимуществ</strong> по сравнению с обычным JavaScript:</p><h4>Статическая типизация:</h4><p><strong>Раннее обнаружение ошибок</strong> — большинство ошибок выявляются на этапе разработки, а не в production. Это особенно критично для крупных проектов.</p><h4>Улучшенная поддержка IDE:</h4><p><strong>Автодополнение и IntelliSense</strong> работают на порядок лучше благодаря информации о типах. Рефакторинг становится безопаснее и быстрее.</p><h4>Документация кода:</h4><p>Типы служат <strong>встроенной документацией</strong> — не нужно гадать, какие параметры принимает функция и что она возвращает.</p><h4>Масштабируемость:</h4><p>TypeScript делает код <strong>более предсказуемым</strong> в больших командах и проектах. Легче понимать код, написанный другими разработчиками.</p><h4>Современный JavaScript:</h4><p>Возможность использовать <strong>новейшие возможности JS</strong> с компиляцией в старые версии для совместимости.</p><p><em>Результат:</em> Меньше багов, быстрая разработка, лучшая поддержка кода.</p>",
    difficulty: 'junior',
    tags: ['преимущества', 'TypeScript', 'основы']
  },
  {
    id: 2,
    question: "Какие недостатки или сложности использования TypeScript вы можете выделить?",
    answer: "<p>При всех преимуществах, TypeScript имеет ряд <strong>недостатков и сложностей</strong>:</p><h4>Порог входа:</h4><p><strong>Кривая обучения</strong> — разработчикам нужно изучить систему типов, дженерики, advanced типы. Это требует времени.</p><h4>Время компиляции:</h4><p><strong>Дополнительный шаг сборки</strong> — код нужно компилировать перед запуском, что замедляет разработку больших проектов.</p><h4>Overhead для небольших проектов:</h4><p>Для <strong>маленьких скриптов или прототипов</strong> TypeScript может быть избыточным — больше времени на настройку, чем на реальную разработку.</p><h4>Ложное чувство безопасности:</h4><p>TypeScript проверяет типы только <strong>на этапе компиляции</strong> — runtime ошибки все еще возможны, особенно при работе с внешними API.</p><h4>Сложность типизации:</h4><p><strong>Типизация сложных библиотек</strong> может быть трудной. Иногда проще написать <code>any</code>, что сводит на нет преимущества TypeScript.</p><h4>Размер экосистемы:</h4><p>Не все библиотеки имеют <strong>качественные типы</strong> — приходится писать свои или использовать @types пакеты.</p>",
    difficulty: 'junior',
    tags: ['недостатки', 'TypeScript', 'сложности']
  },
  {
    id: 3,
    question: "Как TypeScript влияет на производительность разработки?",
    answer: "<p>Влияние TypeScript на производительность разработки <strong>неоднозначно</strong> и зависит от контекста:</p><h4>Замедление на старте:</h4><p><strong>Начальная настройка</strong> требует времени — конфигурация tsconfig, настройка путей, установка типов для библиотек.</p><p><strong>Написание типов</strong> замедляет первоначальную разработку — нужно явно описывать интерфейсы, типы параметров.</p><h4>Ускорение в долгосрочной перспективе:</h4><p><strong>Меньше времени на отладку</strong> — большинство ошибок ловятся до запуска приложения.</p><p><strong>Безопасный рефакторинг</strong> — изменения в коде сразу показывают, что сломалось. Не нужно искать все места использования вручную.</p><p><strong>Быстрая навигация</strong> — IDE мгновенно показывает определения, использования, сигнатуры функций.</p><h4>Факторы влияния:</h4><p><strong>Размер команды:</strong> В больших командах TypeScript ускоряет разработку значительно.</p><p><strong>Размер проекта:</strong> Для pet-проектов может быть overhead, для enterprise — необходимость.</p><p><em>Вывод:</em> Краткосрочно замедляет, долгосрочно ускоряет разработку.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'разработка', 'эффективность']
  },
  {
    id: 4,
    question: "В каких случаях использование TypeScript оправдано, а в каких — нет?",
    answer: "<p>Выбор TypeScript должен основываться на <strong>контексте проекта</strong>:</p><h4>TypeScript оправдан:</h4><p><strong>Крупные проекты:</strong> Где работает несколько разработчиков и кодовая база большая — типизация критична.</p><p><strong>Long-term проекты:</strong> Которые будут поддерживаться годами — типы служат документацией.</p><p><strong>Библиотеки и SDK:</strong> Публичные API выигрывают от типизации — пользователи получают автодополнение.</p><p><strong>Backend на Node.js:</strong> Где нет браузерной проверки и ошибки дороже.</p><p><strong>Работа с данными:</strong> Сложные data structures, API интеграции — типы предотвращают ошибки.</p><h4>TypeScript избыточен:</h4><p><strong>Прототипы и MVP:</strong> Когда важна скорость валидации идеи.</p><p><strong>Маленькие скрипты:</strong> Утилиты, однократные задачи — overhead не окупается.</p><p><strong>Простые landing pages:</strong> Минимум логики, много верстки.</p><p><strong>Команда не готова:</strong> Если разработчики не знают TypeScript — внедрение замедлит работу.</p><p><em>Золотое правило:</em> Если проект проживет дольше месяца и в нем больше 1000 строк — TypeScript оправдан.</p>",
    difficulty: 'middle',
    tags: ['применение', 'выбор технологии', 'контекст']
  },
  {
    id: 5,
    question: "Как TypeScript помогает в рефакторинге кода?",
    answer: "<p>TypeScript делает рефакторинг <strong>значительно безопаснее и быстрее</strong>:</p><h4>Автоматическое обнаружение проблем:</h4><p>При изменении сигнатуры функции или интерфейса TypeScript <strong>сразу показывает все места</strong>, где код сломался. Не нужно гадать или искать вручную.</p><h4>Уверенный rename:</h4><p><strong>Переименование переменных и функций</strong> работает безопасно — IDE находит все использования благодаря типам.</p><h4>Изменение структур данных:</h4><p>Если изменить интерфейс, компилятор <strong>укажет все места</strong>, где нужно обновить код для соответствия новой структуре.</p><h4>Удаление мертвого кода:</h4><p>TypeScript помогает найти <strong>неиспользуемый код</strong> — если функция нигде не вызывается, это видно по отсутствию ссылок.</p><h4>Безопасные эксперименты:</h4><p>Можно смело экспериментировать с архитектурой — <strong>типы сразу покажут</strong>, что сломалось и где нужны изменения.</p><p><em>Реальный пример:</em> Изменение API endpoint с 5 параметрами на объект с опциями — TypeScript покажет все 50+ вызовов, которые нужно обновить.</p>",
    difficulty: 'middle',
    tags: ['рефакторинг', 'поддержка кода', 'безопасность']
  },
  {
    id: 6,
    question: "Какие проблемы могут возникнуть при миграции JavaScript проекта на TypeScript?",
    answer: "<p>Миграция на TypeScript может встретить <strong>ряд серьезных вызовов</strong>:</p><h4>Технические сложности:</h4><p><strong>Legacy код:</strong> Старый JavaScript код может использовать паттерны, которые сложно типизировать — динамические свойства, monkey patching.</p><p><strong>Отсутствие типов для библиотек:</strong> Старые или малоизвестные библиотеки могут не иметь @types пакетов.</p><p><strong>Build процесс:</strong> Нужно настроить компиляцию, sourcemaps, интеграцию с существующими инструментами сборки.</p><h4>Временные затраты:</h4><p><strong>Постепенная миграция:</strong> Нельзя мигрировать все сразу — нужна стратегия постепенного перехода файл за файлом.</p><p><strong>Обучение команды:</strong> Разработчики должны изучить TypeScript, что отнимает время от основной работы.</p><h4>Организационные проблемы:</h4><p><strong>Сопротивление команды:</strong> Не все хотят менять привычный workflow.</p><p><strong>Снижение velocity:</strong> Первое время команда будет работать медленнее.</p><p><em>Решение:</em> Начинать с новых файлов, постепенно мигрировать критичные части, использовать <code>allowJs</code> для плавного перехода.</p>",
    difficulty: 'middle',
    tags: ['миграция', 'TypeScript', 'проблемы', 'переход']
  },
  {
    id: 7,
    question: "Как TypeScript влияет на размер финального бандла?",
    answer: "<p>Влияние TypeScript на размер бандла <strong>минимально или отсутствует</strong>:</p><h4>TypeScript компилируется в JavaScript:</h4><p>Типы существуют только <strong>на этапе разработки</strong> и полностью удаляются при компиляции. В production попадает чистый JavaScript.</p><h4>Потенциальное увеличение:</h4><p><strong>Polyfills и helper функции:</strong> TypeScript может добавлять вспомогательный код для эмуляции новых возможностей в старых браузерах — decorators, async/await.</p><p><strong>Импорт типов:</strong> Если случайно импортировать не только типы, но и runtime код из type-only модулей.</p><h4>Оптимизация:</h4><p><strong>importHelpers:</strong> Использование tslib для переиспользования helper функций вместо дублирования в каждом файле.</p><p><strong>Type-only imports:</strong> Явное указание <code>import type</code> гарантирует, что импорт не попадет в бандл.</p><p><strong>Tree shaking:</strong> Работает одинаково хорошо с TypeScript и JavaScript при правильной настройке.</p><p><em>Вывод:</em> TypeScript сам по себе не увеличивает размер бандла — важнее настройки компиляции и bundler'а.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'бандл', 'оптимизация']
  },
  {
    id: 8,
    question: "Какие альтернативы TypeScript существуют и в чем их отличия?",
    answer: "<p>Существует несколько <strong>альтернативных подходов</strong> к типизации JavaScript:</p><h4>Flow:</h4><p><strong>Разработан Facebook</strong> — похож на TypeScript, но менее популярен. Основное отличие — более строгая система типов, но меньше community поддержки.</p><h4>JSDoc:</h4><p><strong>Типизация через комментарии</strong> — позволяет добавлять типы в обычный JavaScript без компиляции. Поддерживается в VS Code, но менее мощная, чем TypeScript.</p><h4>ReScript (ex ReasonML):</h4><p><strong>Функциональный язык</strong>, компилирующийся в JavaScript — более строгая система типов, но радикально отличается синтаксисом.</p><h4>Dart:</h4><p><strong>Альтернативный язык</strong> от Google — собственная экосистема, используется в Flutter, но не популярен для веб-разработки.</p><h4>Vanilla JavaScript + ESLint:</h4><p><strong>Без явной типизации</strong> — полагается на линтинг и тесты. Подходит для небольших проектов.</p><p><em>Позиция TypeScript:</em> Наиболее популярная и поддерживаемая альтернатива с огромной экосистемой, постепенным adoption и отличной интеграцией с существующим JS.</p>",
    difficulty: 'senior',
    tags: ['альтернативы', 'сравнение', 'Flow', 'JSDoc']
  },
  {
    id: 9,
    question: "Как TypeScript справляется с динамической природой JavaScript?",
    answer: "<p>TypeScript предлагает <strong>компромисс между безопасностью и гибкостью</strong>:</p><h4>Escape hatches:</h4><p><strong>Type any:</strong> Позволяет отключить проверку типов когда это необходимо — работа с legacy кодом, сложные динамические структуры.</p><p><strong>Type unknown:</strong> Более безопасная альтернатива any — требует явной проверки перед использованием.</p><p><strong>Type assertions:</strong> Возможность явно указать тип, когда разработчик знает больше компилятора.</p><h4>Advanced типы:</h4><p><strong>Union types:</strong> Тип может быть одним из нескольких вариантов — моделирует динамическое поведение безопасно.</p><p><strong>Type guards:</strong> Сужение типов через runtime проверки — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Conditional types:</strong> Типы, которые меняются в зависимости от условий — мощный инструмент для сложной логики.</p><h4>Проблемные области:</h4><p><strong>Prototype manipulation:</strong> Динамическое добавление свойств сложно типизировать.</p><p><strong>eval и dynamic code:</strong> Невозможно статически проверить.</p><p><em>Философия:</em> TypeScript не борется с динамичностью JS, а предоставляет инструменты для безопасной работы с ней.</p>",
    difficulty: 'senior',
    tags: ['типизация', 'динамичность', 'гибкость', 'advanced types']
  },
  {
    id: 10,
    question: "Какие проблемы с типизацией третьесторонних библиотек вы встречали?",
    answer: "<p>Работа с типами сторонних библиотек часто вызывает <strong>специфические проблемы</strong>:</p><h4>Отсутствие типов:</h4><p><strong>Старые библиотеки</strong> могут не иметь TypeScript поддержки вообще — приходится писать свои <code>.d.ts</code> файлы или использовать <code>any</code>.</p><h4>Неточные типы:</h4><p><strong>@types пакеты</strong> могут отставать от реальной библиотеки или содержать ошибки. Типы пишут энтузиасты, не авторы библиотеки.</p><h4>Конфликты версий:</h4><p><strong>Несоответствие версий</strong> между библиотекой и @types пакетом может приводить к неправильным типам.</p><h4>Слишком строгие типы:</h4><p>Некоторые библиотеки типизированы <strong>слишком строго</strong>, не позволяя делать валидные, но не предусмотренные автором вещи.</p><h4>Generic hell:</h4><p><strong>Сложная generic типизация</strong> в библиотеках типа RxJS или Redux может быть трудна для понимания и использования.</p><h4>Решения:</h4><p>Использование <strong>module augmentation</strong> для расширения типов, создание своих type wrappers, contributing в DefinitelyTyped.</p><p><em>Практика:</em> Важно проверять качество типов библиотеки перед использованием в проекте.</p>",
    difficulty: 'senior',
    tags: ['библиотеки', 'типизация', 'проблемы', '@types']
  },
  {
    id: 11,
    question: "Как TypeScript влияет на время сборки проекта?",
    answer: "<p>TypeScript может <strong>заметно влиять на время сборки</strong>, особенно в больших проектах:</p><h4>Факторы замедления:</h4><p><strong>Type checking:</strong> Проверка типов требует времени — чем сложнее типы и больше файлов, тем дольше компиляция.</p><p><strong>Incremental compilation:</strong> Первая сборка может быть очень долгой, последующие быстрее благодаря кэшированию.</p><p><strong>Сложные типы:</strong> Advanced types, глубокие generic типы, сложные conditional types замедляют компиляцию значительно.</p><h4>Оптимизация:</h4><p><strong>Project references:</strong> Разделение проекта на подпроекты ускоряет сборку через параллелизацию.</p><p><strong>skipLibCheck:</strong> Пропуск проверки типов в node_modules ускоряет компиляцию, но может скрыть ошибки.</p><p><strong>Isolatedmodules:</strong> Упрощает компиляцию, позволяя обрабатывать файлы независимо.</p><p><strong>Использование esbuild/swc:</strong> Альтернативные компиляторы быстрее tsc, но не проверяют типы.</p><h4>Практический подход:</h4><p>Использовать <strong>type checking отдельно от сборки</strong> в development — сборщик компилирует без проверки типов, а tsc проверяет в фоне.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'сборка', 'оптимизация', 'компиляция']
  },
  {
    id: 12,
    question: "Какие проблемы может создать чрезмерное использование типа any?",
    answer: "<p>Злоупотребление <code>any</code> <strong>нивелирует преимущества TypeScript</strong>:</p><h4>Потеря безопасности типов:</h4><p><strong>Ошибки не ловятся:</strong> Компилятор не может предупредить о проблемах — any отключает всю проверку типов для этого значения.</p><p><strong>Цепная реакция:</strong> Any <em>распространяется</em> — если функция принимает any, её возвращаемое значение тоже становится any.</p><h4>Ухудшение developer experience:</h4><p><strong>Нет автодополнения:</strong> IDE не может подсказать доступные свойства и методы.</p><p><strong>Сложный рефакторинг:</strong> При изменении кода с any невозможно найти все затронутые места.</p><h4>Ложная безопасность:</h4><p><strong>Иллюзия типизации:</strong> Проект формально на TypeScript, но фактически работает как JavaScript без проверок.</p><h4>Технический долг:</h4><p><strong>Откладывание проблем:</strong> Any — это часто временное решение, которое становится постоянным.</p><h4>Альтернативы:</h4><p>Использовать <strong>unknown</strong> вместо any, писать конкретные типы, использовать union types для динамических значений.</p><p><em>Правило:</em> Каждый any в коде должен иметь обоснование и план по замене на конкретный тип.</p>",
    difficulty: 'middle',
    tags: ['any', 'типы', 'безопасность', 'best practices']
  },
  {
    id: 13,
    question: "Как TypeScript помогает в работе с большими командами разработчиков?",
    answer: "<p>TypeScript особенно ценен в <strong>командной разработке</strong>:</p><h4>Единое понимание кода:</h4><p><strong>Типы как контракты:</strong> Интерфейсы и типы служат соглашением между разработчиками — явно определяют, что ожидается и что возвращается.</p><p><strong>Самодокументирующийся код:</strong> Типы объясняют намерения без необходимости читать реализацию.</p><h4>Снижение code review нагрузки:</h4><p><strong>Меньше trivial ошибок:</strong> Компилятор ловит опечатки, неправильные типы, missing properties — ревьюеры могут фокусироваться на логике.</p><p><strong>Безопасные изменения API:</strong> Изменения в публичных интерфейсах сразу видны всей команде через ошибки компиляции.</p><h4>Onboarding новых разработчиков:</h4><p><strong>Быстрое понимание:</strong> Новички быстрее разбираются в кодовой базе благодаря типам и автодополнению.</p><p><strong>Меньше вопросов:</strong> IDE отвечает на многие вопросы о структурах данных и API.</p><h4>Предотвращение конфликтов:</h4><p><strong>Breaking changes видны сразу:</strong> Если один разработчик меняет интерфейс, другие сразу видят ошибки в своих ветках.</p><p><em>Эффект:</em> Команда работает быстрее и увереннее, коммуникация улучшается.</p>",
    difficulty: 'senior',
    tags: ['командная работа', 'масштабирование', 'collaboration']
  },
  {
    id: 14,
    question: "Какие проблемы возникают при использовании TypeScript в монорепозиториях?",
    answer: "<p>Монорепозитории с TypeScript имеют <strong>специфические вызовы</strong>:</p><h4>Сложность настройки:</h4><p><strong>Project references:</strong> Настройка зависимостей между пакетами требует внимательности — каждый подпроект нуждается в своем tsconfig.</p><p><strong>Path mapping:</strong> Сложная конфигурация путей для импортов между пакетами.</p><h4>Проблемы сборки:</h4><p><strong>Порядок компиляции:</strong> Пакеты должны компилироваться в правильном порядке зависимостей.</p><p><strong>Долгое время сборки:</strong> Проверка типов во всех пакетах может занимать значительное время.</p><p><strong>Incremental builds:</strong> Не всегда работают корректно, приходится делать полную пересборку.</p><h4>Version management:</h4><p><strong>Синхронизация версий TypeScript:</strong> Разные пакеты могут требовать разные версии, что создает конфликты.</p><p><strong>@types пакеты:</strong> Нужно следить за совместимостью типов между пакетами.</p><h4>Решения:</h4><p>Использование инструментов типа <strong>Turborepo, Nx</strong> для управления сборкой, правильная настройка project references, shared tsconfig для общих правил.</p><p><em>Рекомендация:</em> Инвестировать время в правильную настройку на старте проекта.</p>",
    difficulty: 'senior',
    tags: ['монорепозиторий', 'масштабирование', 'сложности', 'настройка']
  },
  {
    id: 15,
    question: "Как вы оцениваете будущее TypeScript в веб-разработке?",
    answer: "<p>TypeScript имеет <strong>перспективное будущее</strong> в веб-разработке:</p><h4>Текущие тренды:</h4><p><strong>Повсеместное принятие:</strong> Большинство популярных фреймворков и библиотек написаны на TypeScript или имеют first-class поддержку.</p><p><strong>Стандарт индустрии:</strong> В вакансиях TypeScript часто является требованием, а не плюсом.</p><h4>Развитие языка:</h4><p><strong>Type annotations proposal:</strong> Обсуждается возможность добавления синтаксиса типов напрямую в JavaScript — TypeScript может стать частью стандарта.</p><p><strong>Улучшение производительности:</strong> Работа над ускорением компиляции продолжается.</p><h4>Потенциальные вызовы:</h4><p><strong>Альтернативные подходы:</strong> JSDoc с TypeScript, новые инструменты типа Hegel могут составить конкуренцию.</p><p><strong>Усложнение языка:</strong> Каждая новая возможность делает систему типов сложнее.</p><h4>Вероятный сценарий:</h4><p>TypeScript останется <strong>доминирующим решением</strong> для типизации JavaScript на ближайшие 5-10 лет. Возможна более тесная интеграция с JavaScript стандартами.</p><p><em>Вывод:</em> Инвестиции в изучение TypeScript оправданы — он никуда не исчезнет.</p>",
    difficulty: 'senior',
    tags: ['будущее', 'тренды', 'индустрия', 'перспективы']
  },
  {
    id: 16,
    question: "Какие базовые типы данных доступны в TypeScript?",
    answer: "<p>TypeScript предоставляет <strong>богатый набор базовых типов</strong>, расширяющий JavaScript:</p><h4>Примитивные типы:</h4><p><strong>string, number, boolean</strong> — основные типы для текста, чисел и логических значений.</p><p><strong>null и undefined</strong> — представляют отсутствие значения, каждый со своей семантикой.</p><p><strong>symbol</strong> — уникальные неизменяемые значения, часто используются как ключи свойств.</p><p><strong>bigint</strong> — для работы с большими целыми числами, превышающими Number.MAX_SAFE_INTEGER.</p><h4>Специальные типы:</h4><p><strong>any</strong> — отключает проверку типов, любое значение допустимо.</p><p><strong>unknown</strong> — безопасная версия any, требует проверки перед использованием.</p><p><strong>void</strong> — отсутствие возвращаемого значения, обычно для функций.</p><p><strong>never</strong> — тип для значений, которые никогда не возникают.</p><h4>Составные типы:</h4><p><strong>Array и Tuple</strong> — для коллекций значений.</p><p><strong>Object</strong> — для любых объектных типов.</p><p><em>Важно:</em> Все эти типы существуют только на этапе компиляции и исчезают в runtime.</p>",
    difficulty: 'junior',
    tags: ['типы данных', 'примитивы', 'основы', 'базовые типы']
  },
  {
    id: 17,
    question: "Что такое тип tuple и как он отличается от массива?",
    answer: "<p>Tuple — это <strong>массив фиксированной длины</strong> с известными типами для каждого элемента:</p><h4>Основные отличия:</h4><p><strong>Фиксированная длина:</strong> Tuple имеет строго определенное количество элементов — <code>[string, number]</code> всегда содержит ровно 2 элемента.</p><p><strong>Разные типы элементов:</strong> Каждая позиция может иметь свой тип — <code>[string, number, boolean]</code>, в отличие от массива с единым типом.</p><p><strong>Позиционная типизация:</strong> Первый элемент строго string, второй — number. Доступ по индексу типизирован — <code>tuple[0]</code> это string.</p><h4>Использование:</h4><p><strong>Возврат множественных значений:</strong> <code>function useState(): [value, setValue]</code> — как в React hooks.</p><p><strong>Координаты и пары:</strong> <code>[number, number]</code> для точек, <code>[key, value]</code> для пар.</p><h4>Ограничения:</h4><p>Методы массива типа <strong>push</strong> могут нарушить структуру tuple в runtime — TypeScript не всегда может это предотвратить.</p><p><em>Практика:</em> Tuple удобен для небольших структурированных данных вместо создания отдельных интерфейсов.</p>",
    difficulty: 'junior',
    tags: ['tuple', 'массивы', 'типы данных', 'структуры']
  },
  {
    id: 18,
    question: "Чем отличается тип any от типа unknown и never?",
    answer: "<p>Эти три типа имеют <strong>фундаментально разное назначение</strong>:</p><h4>any — отключение проверки:</h4><p><strong>Любое значение допустимо</strong> — можно присвоить что угодно и делать с ним что угодно.</p><p><strong>Отключает type safety:</strong> Компилятор не проверяет операции с any.</p><p><strong>Заразный тип:</strong> Распространяется по коду, нивелируя пользу TypeScript.</p><h4>unknown — безопасный any:</h4><p><strong>Любое значение можно присвоить</strong>, но использовать напрямую нельзя.</p><p><strong>Требует проверки:</strong> Перед использованием нужен type guard — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Top type:</strong> Все типы совместимы с unknown, но unknown не совместим ни с чем без проверки.</p><h4>never — невозможное значение:</h4><p><strong>Нет значений этого типа</strong> — представляет недостижимый код.</p><p><strong>Bottom type:</strong> Подтип всех типов, но никакой тип не присваивается never.</p><p><strong>Используется для:</strong> Функций, которые никогда не возвращаются — бесконечные циклы, throw исключений.</p><p><em>Правило:</em> Предпочитайте unknown вместо any для действительно динамических значений.</p>",
    difficulty: 'middle',
    tags: ['any', 'unknown', 'never', 'типы', 'безопасность']
  },
  {
    id: 19,
    question: "Как использовать тип enum для определения перечисления значений?",
    answer: "<p>Enum позволяет определить <strong>набор именованных констант</strong>:</p><h4>Числовые enum:</h4><p><strong>По умолчанию</strong> — значения автоматически увеличиваются с 0: <code>enum Direction { Up, Down, Left, Right }</code></p><p><strong>Кастомные значения:</strong> Можно задать явно — <code>enum Status { Active = 1, Inactive = 0 }</code></p><h4>Строковые enum:</h4><p><strong>Явные строковые значения</strong> — <code>enum Color { Red = 'RED', Green = 'GREEN' }</code></p><p><strong>Преимущества:</strong> Более читаемы в runtime, лучше для отладки и логирования.</p><h4>Особенности:</h4><p><strong>Двунаправленное mapping</strong> у числовых enum — можно получить имя по значению: <code>Direction[0] === 'Up'</code></p><p><strong>Компилируются в объекты</strong> в JavaScript коде, увеличивают размер бандла.</p><h4>Альтернативы:</h4><p><strong>Const enum:</strong> Исчезает после компиляции, заменяется на значения — экономит место.</p><p><strong>Union literal types:</strong> <code>type Direction = 'up' | 'down'</code> — более современный подход, не добавляет runtime код.</p><p><em>Выбор:</em> Для новых проектов часто предпочитают union types вместо enum.</p>",
    difficulty: 'junior',
    tags: ['enum', 'константы', 'перечисления', 'типы']
  },
  {
    id: 20,
    question: "Что такое литеральные типы и где их можно применять?",
    answer: "<p>Литеральные типы — это <strong>конкретные значения как типы</strong>:</p><h4>Типы литералов:</h4><p><strong>Строковые литералы:</strong> <code>type Answer = 'yes' | 'no'</code> — переменная может быть только этими строками.</p><p><strong>Числовые литералы:</strong> <code>type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6</code> — только эти числа допустимы.</p><p><strong>Boolean литералы:</strong> <code>type Success = true</code> — только конкретное булево значение.</p><h4>Практическое применение:</h4><p><strong>Ограниченные наборы значений:</strong> Статусы заказов, HTTP методы, режимы работы приложения.</p><p><strong>Discriminated unions:</strong> <code>type Action = { type: 'add' } | { type: 'remove' }</code> — различение union типов по литеральному полю.</p><p><strong>Конфигурация:</strong> Явное указание допустимых опций — <code>env: 'development' | 'production'</code></p><h4>Преимущества:</h4><p><strong>Автодополнение:</strong> IDE показывает только допустимые значения.</p><p><strong>Защита от опечаток:</strong> <code>'prodaction'</code> вызовет ошибку компиляции.</p><p><strong>Type narrowing:</strong> TypeScript может сужать типы в условиях.</p><p><em>Практика:</em> Предпочитайте литеральные union типы перед enum для строковых констант.</p>",
    difficulty: 'middle',
    tags: ['литеральные типы', 'union types', 'константы', 'типизация']
  },
  {
    id: 21,
    question: "Как работает type assertion и когда его следует использовать?",
    answer: "<p>Type assertion — это способ <strong>явно указать тип</strong>, который знает разработчик, но не может вывести компилятор:</p><h4>Синтаксис:</h4><p><strong>Угловые скобки:</strong> <code>&lt;string&gt;someValue</code> — старый синтаксис, несовместим с JSX.</p><p><strong>as синтаксис:</strong> <code>someValue as string</code> — предпочтительный современный вариант.</p><h4>Когда использовать:</h4><p><strong>DOM элементы:</strong> <code>document.getElementById('input') as HTMLInputElement</code> — браузер знает тип, TypeScript нет.</p><p><strong>API ответы:</strong> Когда мы уверены в структуре данных, но TypeScript видит общий тип.</p><p><strong>Миграция кода:</strong> Временное решение при переходе с JavaScript.</p><h4>Опасности:</h4><p><strong>Обход проверки типов:</strong> Assertion не проверяет реальный тип в runtime — можно получить ошибку.</p><p><strong>Ложная уверенность:</strong> Разработчик может ошибаться в своих предположениях.</p><h4>Безопасные альтернативы:</h4><p><strong>Type guards:</strong> Использовать проверки вместо assertion.</p><p><strong>Проверка в runtime:</strong> Валидация данных перед использованием.</p><p><em>Правило:</em> Каждый assertion — потенциальный баг. Используйте только когда действительно уверены.</p>",
    difficulty: 'middle',
    tags: ['type assertion', 'приведение типов', 'безопасность', 'типизация']
  },
  {
    id: 22,
    question: "В чем разница между type и interface и когда использовать каждый?",
    answer: "<p>Type и interface имеют <strong>много общего, но разные возможности</strong>:</p><h4>Interface:</h4><p><strong>Declaration merging:</strong> Несколько объявлений с одним именем сливаются — полезно для расширения библиотечных типов.</p><p><strong>Extends наследование:</strong> <code>interface Admin extends User</code> — более явное расширение.</p><p><strong>Implements в классах:</strong> Классы могут реализовывать интерфейсы — <code>class User implements IUser</code></p><h4>Type:</h4><p><strong>Union и intersection types:</strong> <code>type Result = Success | Error</code> — interface так не умеет.</p><p><strong>Примитивы и литералы:</strong> <code>type ID = string | number</code> — alias для любых типов.</p><p><strong>Mapped и conditional types:</strong> Продвинутые трансформации типов.</p><h4>Когда что использовать:</h4><p><strong>Interface для объектов:</strong> Публичные API, React компоненты, структуры данных.</p><p><strong>Type для union:</strong> Комбинации типов, алиасы, сложные трансформации.</p><p><strong>Consistency:</strong> В одном проекте лучше придерживаться единого стиля.</p><p><em>Тренд:</em> Современная практика склоняется к использованию type для большей гибкости.</p>",
    difficulty: 'middle',
    tags: ['type', 'interface', 'различия', 'определение типов']
  },
  {
    id: 23,
    question: "Что такое type guards и как их создавать?",
    answer: "<p>Type guards — это <strong>механизм сужения типов</strong> через runtime проверки:</p><h4>Встроенные type guards:</h4><p><strong>typeof:</strong> <code>if (typeof value === 'string')</code> — для примитивов.</p><p><strong>instanceof:</strong> <code>if (error instanceof Error)</code> — для проверки классов.</p><p><strong>in оператор:</strong> <code>if ('message' in error)</code> — проверка наличия свойства.</p><h4>Пользовательские type guards:</h4><p><strong>Predicate функции:</strong> <code>function isString(value: unknown): value is string { return typeof value === 'string' }</code></p><p><strong>Возвращаемый тип</strong> <code>value is Type</code> сообщает TypeScript о сужении типа.</p><h4>Discriminated unions:</h4><p><strong>Тип с литеральным полем:</strong> <code>if (action.type === 'add')</code> — TypeScript понимает конкретный тип в этой ветке.</p><h4>Применение:</h4><p><strong>Работа с union types:</strong> Безопасное различение вариантов.</p><p><strong>Работа с unknown:</strong> Проверка перед использованием динамических данных.</p><p><strong>API responses:</strong> Валидация структуры данных от сервера.</p><p><em>Преимущество:</em> Type guards делают код и безопасным, и понятным для TypeScript.</p>",
    difficulty: 'middle',
    tags: ['type guards', 'сужение типов', 'проверки', 'безопасность']
  },
  {
    id: 24,
    question: "Как работают Generic типы и зачем они нужны?",
    answer: "<p>Generic типы позволяют создавать <strong>переиспользуемые компоненты</strong>, работающие с разными типами:</p><h4>Основная идея:</h4><p><strong>Параметризация типов:</strong> <code>Array&lt;T&gt;</code> — массив любого типа, где T — параметр типа.</p><p><strong>Type safety с гибкостью:</strong> Сохраняется связь между входными и выходными типами.</p><h4>Применение:</h4><p><strong>Функции:</strong> <code>function identity&lt;T&gt;(value: T): T</code> — возвращает тот же тип, что получила.</p><p><strong>Интерфейсы:</strong> <code>interface Box&lt;T&gt; { value: T }</code> — контейнер для любого типа.</p><p><strong>Классы:</strong> <code>class Storage&lt;T&gt;</code> — типизированное хранилище.</p><h4>Ограничения (constraints):</h4><p><strong>extends:</strong> <code>&lt;T extends HasId&gt;</code> — ограничивает T только типами с определенными свойствами.</p><p><strong>Множественные параметры:</strong> <code>&lt;K, V&gt;</code> — для Map-подобных структур.</p><h4>Вывод типов:</h4><p>TypeScript <strong>автоматически выводит</strong> T из аргументов — не всегда нужно явно указывать.</p><p><em>Цель:</em> Generic'и избавляют от дублирования кода и сохраняют type safety.</p>",
    difficulty: 'senior',
    tags: ['generics', 'параметризация', 'переиспользование', 'типизация']
  },
  {
    id: 25,
    question: "Что такое union и intersection types и как их применять?",
    answer: "<p>Union и intersection — это <strong>способы комбинирования типов</strong>:</p><h4>Union types (|):</h4><p><strong>Логическое ИЛИ:</strong> <code>string | number</code> — значение может быть одним из типов.</p><p><strong>Применение:</strong> Параметры, которые принимают разные типы, состояния с вариантами, опциональные значения.</p><p><strong>Type narrowing:</strong> Нужны проверки для безопасного использования — TypeScript не знает конкретный тип.</p><h4>Intersection types (&):</h4><p><strong>Логическое И:</strong> <code>User & Admin</code> — объект должен иметь свойства обоих типов.</p><p><strong>Применение:</strong> Миксины, композиция типов, расширение типов без наследования.</p><p><strong>Объединение свойств:</strong> Результирующий тип содержит все поля из обоих типов.</p><h4>Практические примеры:</h4><p><strong>Union для вариантов:</strong> <code>type Status = 'loading' | 'success' | 'error'</code></p><p><strong>Intersection для расширения:</strong> <code>type AdminUser = User & { role: 'admin' }</code></p><h4>Особенности:</h4><p><strong>Приоритет:</strong> Intersection имеет выше приоритет, чем union — скобки важны.</p><p><em>Комбинирование:</em> Можно создавать сложные типы — <code>(A & B) | (C & D)</code></p>",
    difficulty: 'middle',
    tags: ['union types', 'intersection types', 'комбинирование типов', 'композиция']
  },
  {
    id: 26,
    question: "Как работают mapped types и для чего их используют?",
    answer: "<p>Mapped types позволяют <strong>трансформировать существующие типы</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Итерация по ключам:</strong> <code>{ [K in keyof T]: T[K] }</code> — проходим по всем свойствам типа T.</p><p><strong>Трансформация типов:</strong> Можем изменить тип каждого свойства.</p><h4>Встроенные utility types:</h4><p><strong>Partial&lt;T&gt;:</strong> Делает все свойства опциональными — <code>{ [K in keyof T]?: T[K] }</code></p><p><strong>Required&lt;T&gt;:</strong> Делает все свойства обязательными — убирает знаки вопроса.</p><p><strong>Readonly&lt;T&gt;:</strong> Делает все свойства только для чтения — <code>readonly</code> перед каждым.</p><p><strong>Pick&lt;T, K&gt;:</strong> Выбирает только указанные ключи.</p><p><strong>Omit&lt;T, K&gt;:</strong> Исключает указанные ключи.</p><h4>Кастомные mapped types:</h4><p><strong>Префиксы/суффиксы:</strong> <code>type Getters&lt;T&gt; = { [K in keyof T as `get${K}`]: () =&gt; T[K] }</code></p><p><strong>Conditional mapping:</strong> Применение условий при трансформации.</p><h4>Применение:</h4><p>Создание вариаций типов без дублирования, форм с валидацией, API response типов.</p><p><em>Мощь:</em> Mapped types — основа для создания продвинутых utility типов.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'трансформация типов', 'utility types', 'продвинутые типы']
  },
  {
    id: 27,
    question: "Что такое conditional types и как их использовать?",
    answer: "<p>Conditional types позволяют типам <strong>зависеть от условий</strong>:</p><h4>Синтаксис:</h4><p><strong>Тернарный оператор для типов:</strong> <code>T extends U ? X : Y</code> — если T расширяет U, то X, иначе Y.</p><h4>Применение:</h4><p><strong>Извлечение типов:</strong> <code>type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never</code></p><p><strong>infer ключевое слово:</strong> Позволяет извлечь тип из структуры — тип возвращаемого значения, параметров функции.</p><p><strong>Фильтрация union types:</strong> <code>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T</code></p><h4>Встроенные utility types:</h4><p><strong>Exclude&lt;T, U&gt;:</strong> Исключает типы из union.</p><p><strong>Extract&lt;T, U&gt;:</strong> Извлекает только совпадающие типы.</p><p><strong>ReturnType&lt;T&gt;:</strong> Получает тип возвращаемого значения функции.</p><h4>Distributive conditionals:</h4><p><strong>Автоматическое распределение:</strong> Conditional type применяется к каждому члену union типа отдельно.</p><h4>Сложные сценарии:</h4><p>Рекурсивные типы, deep partial, вложенные условия.</p><p><em>Использование:</em> Для создания type-level логики и продвинутых трансформаций.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'продвинутые типы', 'type-level программирование', 'utility types']
  },
  {
    id: 28,
    question: "Как правильно типизировать функции и их параметры?",
    answer: "<p>Типизация функций включает <strong>несколько аспектов</strong>:</p><h4>Базовая типизация:</h4><p><strong>Параметры и возврат:</strong> <code>function add(a: number, b: number): number</code> — явные типы для всего.</p><p><strong>Стрелочные функции:</strong> <code>const add = (a: number, b: number): number =&gt; a + b</code></p><h4>Опциональные параметры:</h4><p><strong>Знак вопроса:</strong> <code>function log(message: string, level?: string)</code> — level может отсутствовать.</p><p><strong>Значения по умолчанию:</strong> <code>function greet(name = 'Guest')</code> — TypeScript выводит тип автоматически.</p><h4>Rest параметры:</h4><p><strong>Spread оператор:</strong> <code>function sum(...numbers: number[])</code> — массив параметров одного типа.</p><h4>Перегрузка функций:</h4><p><strong>Несколько сигнатур:</strong> Разные варианты вызова с разными типами параметров и возврата.</p><p><strong>Реализация:</strong> Одна реализация покрывает все варианты.</p><h4>Типы функций как параметры:</h4><p><strong>Callback типизация:</strong> <code>function map&lt;T, U&gt;(arr: T[], fn: (item: T) =&gt; U): U[]</code></p><p><strong>Function type:</strong> <code>type Handler = (event: Event) =&gt; void</code></p><p><em>Совет:</em> Избегайте <code>Function</code> типа — всегда указывайте конкретную сигнатуру.</p>",
    difficulty: 'middle',
    tags: ['функции', 'параметры', 'типизация', 'сигнатуры']
  },
  {
    id: 29,
    question: "Как работать с типами для асинхронного кода и Promise?",
    answer: "<p>Типизация асинхронного кода требует <strong>понимания Promise типов</strong>:</p><h4>Promise типизация:</h4><p><strong>Generic параметр:</strong> <code>Promise&lt;T&gt;</code> — T это тип разрешенного значения.</p><p><strong>Async функции:</strong> <code>async function fetchData(): Promise&lt;User&gt;</code> — возвращаемый тип всегда Promise.</p><h4>Обработка ошибок:</h4><p><strong>Try-catch:</strong> Тип в catch всегда <code>unknown</code> — нужен type guard для безопасной работы.</p><p><strong>Rejection типы:</strong> Promise технически может отклониться с любым типом, но TypeScript не проверяет это статически.</p><h4>Множественные промисы:</h4><p><strong>Promise.all:</strong> <code>Promise.all([promise1, promise2])</code> возвращает <code>Promise&lt;[Type1, Type2]&gt;</code> — tuple типов.</p><p><strong>Promise.race:</strong> Возвращает union тип всех возможных результатов.</p><h4>Async iterators:</h4><p><strong>AsyncIterable:</strong> <code>async function* generator(): AsyncIterableIterator&lt;number&gt;</code></p><h4>Практические паттерны:</h4><p><strong>Типизация API вызовов:</strong> Создание типов для response и error.</p><p><strong>Wrapper типы:</strong> <code>type AsyncResult&lt;T&gt; = { data: T | null; error: Error | null }</code></p><p><em>Важно:</em> Async/await не меняет принципы типизации, только упрощает синтаксис.</p>",
    difficulty: 'middle',
    tags: ['асинхронность', 'Promise', 'async/await', 'типизация']
  },
  {
    id: 30,
    question: "Как типизировать объекты с динамическими ключами?",
    answer: "<p>Динамические ключи требуют <strong>специальных подходов к типизации</strong>:</p><h4>Index signatures:</h4><p><strong>Базовый синтаксис:</strong> <code>{ [key: string]: number }</code> — любой строковый ключ ведет к числу.</p><p><strong>Ограничения ключей:</strong> Ключи могут быть только <code>string</code>, <code>number</code> или <code>symbol</code>.</p><h4>Record utility type:</h4><p><strong>Более явный синтаксис:</strong> <code>Record&lt;string, User&gt;</code> — объект где ключи строки, значения User.</p><p><strong>С литеральными типами:</strong> <code>Record&lt;'a' | 'b' | 'c', number&gt;</code> — только конкретные ключи.</p><h4>Смешанные типы:</h4><p><strong>Известные + динамические ключи:</strong> <code>interface Data { id: number; [key: string]: any }</code></p><p><strong>Проблема:</strong> Index signature должна быть совместима со всеми известными свойствами.</p><h4>Mapped types для динамики:</h4><p><strong>Условные ключи:</strong> <code>{ [K in keyof T]: T[K] extends string ? K : never }</code></p><h4>Практические случаи:</h4><p><strong>Словари и maps:</strong> Хранение данных по ключам.</p><p><strong>API responses:</strong> Когда структура не полностью известна.</p><p><strong>Конфигурационные объекты:</strong> С расширяемыми опциями.</p><p><em>Альтернатива:</em> Map&lt;K, V&gt; для действительно динамических структур лучше обычных объектов.</p>",
    difficulty: 'senior',
    tags: ['динамические ключи', 'index signature', 'Record', 'типизация объектов']
  }
];
