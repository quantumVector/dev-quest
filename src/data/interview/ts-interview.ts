export interface TSQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const tsInterviewQuestions: TSQuestion[] = [
  {
    id: 1,
    question: "Какие основные преимущества TypeScript перед JavaScript вы можете назвать?",
    answer: "<p>TypeScript предоставляет несколько <strong>ключевых преимуществ</strong> по сравнению с обычным JavaScript:</p><h4>Статическая типизация:</h4><p><strong>Раннее обнаружение ошибок</strong> — большинство ошибок выявляются на этапе разработки, а не в production. Это особенно критично для крупных проектов.</p><h4>Улучшенная поддержка IDE:</h4><p><strong>Автодополнение и IntelliSense</strong> работают на порядок лучше благодаря информации о типах. Рефакторинг становится безопаснее и быстрее.</p><h4>Документация кода:</h4><p>Типы служат <strong>встроенной документацией</strong> — не нужно гадать, какие параметры принимает функция и что она возвращает.</p><h4>Масштабируемость:</h4><p>TypeScript делает код <strong>более предсказуемым</strong> в больших командах и проектах. Легче понимать код, написанный другими разработчиками.</p><h4>Современный JavaScript:</h4><p>Возможность использовать <strong>новейшие возможности JS</strong> с компиляцией в старые версии для совместимости.</p><p><em>Результат:</em> Меньше багов, быстрая разработка, лучшая поддержка кода.</p>",
    difficulty: 'junior',
    tags: ['преимущества', 'TypeScript', 'основы']
  },
  {
    id: 2,
    question: "Какие недостатки или сложности использования TypeScript вы можете выделить?",
    answer: "<p>При всех преимуществах, TypeScript имеет ряд <strong>недостатков и сложностей</strong>:</p><h4>Порог входа:</h4><p><strong>Кривая обучения</strong> — разработчикам нужно изучить систему типов, дженерики, advanced типы. Это требует времени.</p><h4>Время компиляции:</h4><p><strong>Дополнительный шаг сборки</strong> — код нужно компилировать перед запуском, что замедляет разработку больших проектов.</p><h4>Overhead для небольших проектов:</h4><p>Для <strong>маленьких скриптов или прототипов</strong> TypeScript может быть избыточным — больше времени на настройку, чем на реальную разработку.</p><h4>Ложное чувство безопасности:</h4><p>TypeScript проверяет типы только <strong>на этапе компиляции</strong> — runtime ошибки все еще возможны, особенно при работе с внешними API.</p><h4>Сложность типизации:</h4><p><strong>Типизация сложных библиотек</strong> может быть трудной. Иногда проще написать <code>any</code>, что сводит на нет преимущества TypeScript.</p><h4>Размер экосистемы:</h4><p>Не все библиотеки имеют <strong>качественные типы</strong> — приходится писать свои или использовать @types пакеты.</p>",
    difficulty: 'junior',
    tags: ['недостатки', 'TypeScript', 'сложности']
  },
  {
    id: 3,
    question: "Как TypeScript влияет на производительность разработки?",
    answer: "<p>Влияние TypeScript на производительность разработки <strong>неоднозначно</strong> и зависит от контекста:</p><h4>Замедление на старте:</h4><p><strong>Начальная настройка</strong> требует времени — конфигурация tsconfig, настройка путей, установка типов для библиотек.</p><p><strong>Написание типов</strong> замедляет первоначальную разработку — нужно явно описывать интерфейсы, типы параметров.</p><h4>Ускорение в долгосрочной перспективе:</h4><p><strong>Меньше времени на отладку</strong> — большинство ошибок ловятся до запуска приложения.</p><p><strong>Безопасный рефакторинг</strong> — изменения в коде сразу показывают, что сломалось. Не нужно искать все места использования вручную.</p><p><strong>Быстрая навигация</strong> — IDE мгновенно показывает определения, использования, сигнатуры функций.</p><h4>Факторы влияния:</h4><p><strong>Размер команды:</strong> В больших командах TypeScript ускоряет разработку значительно.</p><p><strong>Размер проекта:</strong> Для pet-проектов может быть overhead, для enterprise — необходимость.</p><p><em>Вывод:</em> Краткосрочно замедляет, долгосрочно ускоряет разработку.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'разработка', 'эффективность']
  },
  {
    id: 4,
    question: "В каких случаях использование TypeScript оправдано, а в каких — нет?",
    answer: "<p>Выбор TypeScript должен основываться на <strong>контексте проекта</strong>:</p><h4>TypeScript оправдан:</h4><p><strong>Крупные проекты:</strong> Где работает несколько разработчиков и кодовая база большая — типизация критична.</p><p><strong>Long-term проекты:</strong> Которые будут поддерживаться годами — типы служат документацией.</p><p><strong>Библиотеки и SDK:</strong> Публичные API выигрывают от типизации — пользователи получают автодополнение.</p><p><strong>Backend на Node.js:</strong> Где нет браузерной проверки и ошибки дороже.</p><p><strong>Работа с данными:</strong> Сложные data structures, API интеграции — типы предотвращают ошибки.</p><h4>TypeScript избыточен:</h4><p><strong>Прототипы и MVP:</strong> Когда важна скорость валидации идеи.</p><p><strong>Маленькие скрипты:</strong> Утилиты, однократные задачи — overhead не окупается.</p><p><strong>Простые landing pages:</strong> Минимум логики, много верстки.</p><p><strong>Команда не готова:</strong> Если разработчики не знают TypeScript — внедрение замедлит работу.</p><p><em>Золотое правило:</em> Если проект проживет дольше месяца и в нем больше 1000 строк — TypeScript оправдан.</p>",
    difficulty: 'middle',
    tags: ['применение', 'выбор технологии', 'контекст']
  },
  {
    id: 5,
    question: "Как TypeScript помогает в рефакторинге кода?",
    answer: "<p>TypeScript делает рефакторинг <strong>значительно безопаснее и быстрее</strong>:</p><h4>Автоматическое обнаружение проблем:</h4><p>При изменении сигнатуры функции или интерфейса TypeScript <strong>сразу показывает все места</strong>, где код сломался. Не нужно гадать или искать вручную.</p><h4>Уверенный rename:</h4><p><strong>Переименование переменных и функций</strong> работает безопасно — IDE находит все использования благодаря типам.</p><h4>Изменение структур данных:</h4><p>Если изменить интерфейс, компилятор <strong>укажет все места</strong>, где нужно обновить код для соответствия новой структуре.</p><h4>Удаление мертвого кода:</h4><p>TypeScript помогает найти <strong>неиспользуемый код</strong> — если функция нигде не вызывается, это видно по отсутствию ссылок.</p><h4>Безопасные эксперименты:</h4><p>Можно смело экспериментировать с архитектурой — <strong>типы сразу покажут</strong>, что сломалось и где нужны изменения.</p><p><em>Реальный пример:</em> Изменение API endpoint с 5 параметрами на объект с опциями — TypeScript покажет все 50+ вызовов, которые нужно обновить.</p>",
    difficulty: 'middle',
    tags: ['рефакторинг', 'поддержка кода', 'безопасность']
  },
  {
    id: 6,
    question: "Какие проблемы могут возникнуть при миграции JavaScript проекта на TypeScript?",
    answer: "<p>Миграция на TypeScript может встретить <strong>ряд серьезных вызовов</strong>:</p><h4>Технические сложности:</h4><p><strong>Legacy код:</strong> Старый JavaScript код может использовать паттерны, которые сложно типизировать — динамические свойства, monkey patching.</p><p><strong>Отсутствие типов для библиотек:</strong> Старые или малоизвестные библиотеки могут не иметь @types пакетов.</p><p><strong>Build процесс:</strong> Нужно настроить компиляцию, sourcemaps, интеграцию с существующими инструментами сборки.</p><h4>Временные затраты:</h4><p><strong>Постепенная миграция:</strong> Нельзя мигрировать все сразу — нужна стратегия постепенного перехода файл за файлом.</p><p><strong>Обучение команды:</strong> Разработчики должны изучить TypeScript, что отнимает время от основной работы.</p><h4>Организационные проблемы:</h4><p><strong>Сопротивление команды:</strong> Не все хотят менять привычный workflow.</p><p><strong>Снижение velocity:</strong> Первое время команда будет работать медленнее.</p><p><em>Решение:</em> Начинать с новых файлов, постепенно мигрировать критичные части, использовать <code>allowJs</code> для плавного перехода.</p>",
    difficulty: 'middle',
    tags: ['миграция', 'TypeScript', 'проблемы', 'переход']
  },
  {
    id: 7,
    question: "Как TypeScript влияет на размер финального бандла?",
    answer: "<p>Влияние TypeScript на размер бандла <strong>минимально или отсутствует</strong>:</p><h4>TypeScript компилируется в JavaScript:</h4><p>Типы существуют только <strong>на этапе разработки</strong> и полностью удаляются при компиляции. В production попадает чистый JavaScript.</p><h4>Потенциальное увеличение:</h4><p><strong>Polyfills и helper функции:</strong> TypeScript может добавлять вспомогательный код для эмуляции новых возможностей в старых браузерах — decorators, async/await.</p><p><strong>Импорт типов:</strong> Если случайно импортировать не только типы, но и runtime код из type-only модулей.</p><h4>Оптимизация:</h4><p><strong>importHelpers:</strong> Использование tslib для переиспользования helper функций вместо дублирования в каждом файле.</p><p><strong>Type-only imports:</strong> Явное указание <code>import type</code> гарантирует, что импорт не попадет в бандл.</p><p><strong>Tree shaking:</strong> Работает одинаково хорошо с TypeScript и JavaScript при правильной настройке.</p><p><em>Вывод:</em> TypeScript сам по себе не увеличивает размер бандла — важнее настройки компиляции и bundler'а.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'бандл', 'оптимизация']
  },
  {
    id: 8,
    question: "Какие альтернативы TypeScript существуют и в чем их отличия?",
    answer: "<p>Существует несколько <strong>альтернативных подходов</strong> к типизации JavaScript:</p><h4>Flow:</h4><p><strong>Разработан Facebook</strong> — похож на TypeScript, но менее популярен. Основное отличие — более строгая система типов, но меньше community поддержки.</p><h4>JSDoc:</h4><p><strong>Типизация через комментарии</strong> — позволяет добавлять типы в обычный JavaScript без компиляции. Поддерживается в VS Code, но менее мощная, чем TypeScript.</p><h4>ReScript (ex ReasonML):</h4><p><strong>Функциональный язык</strong>, компилирующийся в JavaScript — более строгая система типов, но радикально отличается синтаксисом.</p><h4>Dart:</h4><p><strong>Альтернативный язык</strong> от Google — собственная экосистема, используется в Flutter, но не популярен для веб-разработки.</p><h4>Vanilla JavaScript + ESLint:</h4><p><strong>Без явной типизации</strong> — полагается на линтинг и тесты. Подходит для небольших проектов.</p><p><em>Позиция TypeScript:</em> Наиболее популярная и поддерживаемая альтернатива с огромной экосистемой, постепенным adoption и отличной интеграцией с существующим JS.</p>",
    difficulty: 'senior',
    tags: ['альтернативы', 'сравнение', 'Flow', 'JSDoc']
  },
  {
    id: 9,
    question: "Как TypeScript справляется с динамической природой JavaScript?",
    answer: "<p>TypeScript предлагает <strong>компромисс между безопасностью и гибкостью</strong>:</p><h4>Escape hatches:</h4><p><strong>Type any:</strong> Позволяет отключить проверку типов когда это необходимо — работа с legacy кодом, сложные динамические структуры.</p><p><strong>Type unknown:</strong> Более безопасная альтернатива any — требует явной проверки перед использованием.</p><p><strong>Type assertions:</strong> Возможность явно указать тип, когда разработчик знает больше компилятора.</p><h4>Advanced типы:</h4><p><strong>Union types:</strong> Тип может быть одним из нескольких вариантов — моделирует динамическое поведение безопасно.</p><p><strong>Type guards:</strong> Сужение типов через runtime проверки — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Conditional types:</strong> Типы, которые меняются в зависимости от условий — мощный инструмент для сложной логики.</p><h4>Проблемные области:</h4><p><strong>Prototype manipulation:</strong> Динамическое добавление свойств сложно типизировать.</p><p><strong>eval и dynamic code:</strong> Невозможно статически проверить.</p><p><em>Философия:</em> TypeScript не борется с динамичностью JS, а предоставляет инструменты для безопасной работы с ней.</p>",
    difficulty: 'senior',
    tags: ['типизация', 'динамичность', 'гибкость', 'advanced types']
  },
  {
    id: 10,
    question: "Какие проблемы с типизацией третьесторонних библиотек вы встречали?",
    answer: "<p>Работа с типами сторонних библиотек часто вызывает <strong>специфические проблемы</strong>:</p><h4>Отсутствие типов:</h4><p><strong>Старые библиотеки</strong> могут не иметь TypeScript поддержки вообще — приходится писать свои <code>.d.ts</code> файлы или использовать <code>any</code>.</p><h4>Неточные типы:</h4><p><strong>@types пакеты</strong> могут отставать от реальной библиотеки или содержать ошибки. Типы пишут энтузиасты, не авторы библиотеки.</p><h4>Конфликты версий:</h4><p><strong>Несоответствие версий</strong> между библиотекой и @types пакетом может приводить к неправильным типам.</p><h4>Слишком строгие типы:</h4><p>Некоторые библиотеки типизированы <strong>слишком строго</strong>, не позволяя делать валидные, но не предусмотренные автором вещи.</p><h4>Generic hell:</h4><p><strong>Сложная generic типизация</strong> в библиотеках типа RxJS или Redux может быть трудна для понимания и использования.</p><h4>Решения:</h4><p>Использование <strong>module augmentation</strong> для расширения типов, создание своих type wrappers, contributing в DefinitelyTyped.</p><p><em>Практика:</em> Важно проверять качество типов библиотеки перед использованием в проекте.</p>",
    difficulty: 'senior',
    tags: ['библиотеки', 'типизация', 'проблемы', '@types']
  },
  {
    id: 11,
    question: "Как TypeScript влияет на время сборки проекта?",
    answer: "<p>TypeScript может <strong>заметно влиять на время сборки</strong>, особенно в больших проектах:</p><h4>Факторы замедления:</h4><p><strong>Type checking:</strong> Проверка типов требует времени — чем сложнее типы и больше файлов, тем дольше компиляция.</p><p><strong>Incremental compilation:</strong> Первая сборка может быть очень долгой, последующие быстрее благодаря кэшированию.</p><p><strong>Сложные типы:</strong> Advanced types, глубокие generic типы, сложные conditional types замедляют компиляцию значительно.</p><h4>Оптимизация:</h4><p><strong>Project references:</strong> Разделение проекта на подпроекты ускоряет сборку через параллелизацию.</p><p><strong>skipLibCheck:</strong> Пропуск проверки типов в node_modules ускоряет компиляцию, но может скрыть ошибки.</p><p><strong>Isolatedmodules:</strong> Упрощает компиляцию, позволяя обрабатывать файлы независимо.</p><p><strong>Использование esbuild/swc:</strong> Альтернативные компиляторы быстрее tsc, но не проверяют типы.</p><h4>Практический подход:</h4><p>Использовать <strong>type checking отдельно от сборки</strong> в development — сборщик компилирует без проверки типов, а tsc проверяет в фоне.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'сборка', 'оптимизация', 'компиляция']
  },
  {
    id: 12,
    question: "Какие проблемы может создать чрезмерное использование типа any?",
    answer: "<p>Злоупотребление <code>any</code> <strong>нивелирует преимущества TypeScript</strong>:</p><h4>Потеря безопасности типов:</h4><p><strong>Ошибки не ловятся:</strong> Компилятор не может предупредить о проблемах — any отключает всю проверку типов для этого значения.</p><p><strong>Цепная реакция:</strong> Any <em>распространяется</em> — если функция принимает any, её возвращаемое значение тоже становится any.</p><h4>Ухудшение developer experience:</h4><p><strong>Нет автодополнения:</strong> IDE не может подсказать доступные свойства и методы.</p><p><strong>Сложный рефакторинг:</strong> При изменении кода с any невозможно найти все затронутые места.</p><h4>Ложная безопасность:</h4><p><strong>Иллюзия типизации:</strong> Проект формально на TypeScript, но фактически работает как JavaScript без проверок.</p><h4>Технический долг:</h4><p><strong>Откладывание проблем:</strong> Any — это часто временное решение, которое становится постоянным.</p><h4>Альтернативы:</h4><p>Использовать <strong>unknown</strong> вместо any, писать конкретные типы, использовать union types для динамических значений.</p><p><em>Правило:</em> Каждый any в коде должен иметь обоснование и план по замене на конкретный тип.</p>",
    difficulty: 'middle',
    tags: ['any', 'типы', 'безопасность', 'best practices']
  },
  {
    id: 13,
    question: "Как TypeScript помогает в работе с большими командами разработчиков?",
    answer: "<p>TypeScript особенно ценен в <strong>командной разработке</strong>:</p><h4>Единое понимание кода:</h4><p><strong>Типы как контракты:</strong> Интерфейсы и типы служат соглашением между разработчиками — явно определяют, что ожидается и что возвращается.</p><p><strong>Самодокументирующийся код:</strong> Типы объясняют намерения без необходимости читать реализацию.</p><h4>Снижение code review нагрузки:</h4><p><strong>Меньше trivial ошибок:</strong> Компилятор ловит опечатки, неправильные типы, missing properties — ревьюеры могут фокусироваться на логике.</p><p><strong>Безопасные изменения API:</strong> Изменения в публичных интерфейсах сразу видны всей команде через ошибки компиляции.</p><h4>Onboarding новых разработчиков:</h4><p><strong>Быстрое понимание:</strong> Новички быстрее разбираются в кодовой базе благодаря типам и автодополнению.</p><p><strong>Меньше вопросов:</strong> IDE отвечает на многие вопросы о структурах данных и API.</p><h4>Предотвращение конфликтов:</h4><p><strong>Breaking changes видны сразу:</strong> Если один разработчик меняет интерфейс, другие сразу видят ошибки в своих ветках.</p><p><em>Эффект:</em> Команда работает быстрее и увереннее, коммуникация улучшается.</p>",
    difficulty: 'senior',
    tags: ['командная работа', 'масштабирование', 'collaboration']
  },
  {
    id: 14,
    question: "Какие проблемы возникают при использовании TypeScript в монорепозиториях?",
    answer: "<p>Монорепозитории с TypeScript имеют <strong>специфические вызовы</strong>:</p><h4>Сложность настройки:</h4><p><strong>Project references:</strong> Настройка зависимостей между пакетами требует внимательности — каждый подпроект нуждается в своем tsconfig.</p><p><strong>Path mapping:</strong> Сложная конфигурация путей для импортов между пакетами.</p><h4>Проблемы сборки:</h4><p><strong>Порядок компиляции:</strong> Пакеты должны компилироваться в правильном порядке зависимостей.</p><p><strong>Долгое время сборки:</strong> Проверка типов во всех пакетах может занимать значительное время.</p><p><strong>Incremental builds:</strong> Не всегда работают корректно, приходится делать полную пересборку.</p><h4>Version management:</h4><p><strong>Синхронизация версий TypeScript:</strong> Разные пакеты могут требовать разные версии, что создает конфликты.</p><p><strong>@types пакеты:</strong> Нужно следить за совместимостью типов между пакетами.</p><h4>Решения:</h4><p>Использование инструментов типа <strong>Turborepo, Nx</strong> для управления сборкой, правильная настройка project references, shared tsconfig для общих правил.</p><p><em>Рекомендация:</em> Инвестировать время в правильную настройку на старте проекта.</p>",
    difficulty: 'senior',
    tags: ['монорепозиторий', 'масштабирование', 'сложности', 'настройка']
  },
  {
    id: 15,
    question: "Как вы оцениваете будущее TypeScript в веб-разработке?",
    answer: "<p>TypeScript имеет <strong>перспективное будущее</strong> в веб-разработке:</p><h4>Текущие тренды:</h4><p><strong>Повсеместное принятие:</strong> Большинство популярных фреймворков и библиотек написаны на TypeScript или имеют first-class поддержку.</p><p><strong>Стандарт индустрии:</strong> В вакансиях TypeScript часто является требованием, а не плюсом.</p><h4>Развитие языка:</h4><p><strong>Type annotations proposal:</strong> Обсуждается возможность добавления синтаксиса типов напрямую в JavaScript — TypeScript может стать частью стандарта.</p><p><strong>Улучшение производительности:</strong> Работа над ускорением компиляции продолжается.</p><h4>Потенциальные вызовы:</h4><p><strong>Альтернативные подходы:</strong> JSDoc с TypeScript, новые инструменты типа Hegel могут составить конкуренцию.</p><p><strong>Усложнение языка:</strong> Каждая новая возможность делает систему типов сложнее.</p><h4>Вероятный сценарий:</h4><p>TypeScript останется <strong>доминирующим решением</strong> для типизации JavaScript на ближайшие 5-10 лет. Возможна более тесная интеграция с JavaScript стандартами.</p><p><em>Вывод:</em> Инвестиции в изучение TypeScript оправданы — он никуда не исчезнет.</p>",
    difficulty: 'senior',
    tags: ['будущее', 'тренды', 'индустрия', 'перспективы']
  },
  {
    id: 16,
    question: "Какие базовые типы данных доступны в TypeScript?",
    answer: "<p>TypeScript предоставляет <strong>богатый набор базовых типов</strong>, расширяющий JavaScript:</p><h4>Примитивные типы:</h4><p><strong>string, number, boolean</strong> — основные типы для текста, чисел и логических значений.</p><p><strong>null и undefined</strong> — представляют отсутствие значения, каждый со своей семантикой.</p><p><strong>symbol</strong> — уникальные неизменяемые значения, часто используются как ключи свойств.</p><p><strong>bigint</strong> — для работы с большими целыми числами, превышающими Number.MAX_SAFE_INTEGER.</p><h4>Специальные типы:</h4><p><strong>any</strong> — отключает проверку типов, любое значение допустимо.</p><p><strong>unknown</strong> — безопасная версия any, требует проверки перед использованием.</p><p><strong>void</strong> — отсутствие возвращаемого значения, обычно для функций.</p><p><strong>never</strong> — тип для значений, которые никогда не возникают.</p><h4>Составные типы:</h4><p><strong>Array и Tuple</strong> — для коллекций значений.</p><p><strong>Object</strong> — для любых объектных типов.</p><p><em>Важно:</em> Все эти типы существуют только на этапе компиляции и исчезают в runtime.</p>",
    difficulty: 'junior',
    tags: ['типы данных', 'примитивы', 'основы', 'базовые типы']
  },
  {
    id: 17,
    question: "Что такое тип tuple и как он отличается от массива?",
    answer: "<p>Tuple — это <strong>массив фиксированной длины</strong> с известными типами для каждого элемента:</p><h4>Основные отличия:</h4><p><strong>Фиксированная длина:</strong> Tuple имеет строго определенное количество элементов — <code>[string, number]</code> всегда содержит ровно 2 элемента.</p><p><strong>Разные типы элементов:</strong> Каждая позиция может иметь свой тип — <code>[string, number, boolean]</code>, в отличие от массива с единым типом.</p><p><strong>Позиционная типизация:</strong> Первый элемент строго string, второй — number. Доступ по индексу типизирован — <code>tuple[0]</code> это string.</p><h4>Использование:</h4><p><strong>Возврат множественных значений:</strong> <code>function useState(): [value, setValue]</code> — как в React hooks.</p><p><strong>Координаты и пары:</strong> <code>[number, number]</code> для точек, <code>[key, value]</code> для пар.</p><h4>Ограничения:</h4><p>Методы массива типа <strong>push</strong> могут нарушить структуру tuple в runtime — TypeScript не всегда может это предотвратить.</p><p><em>Практика:</em> Tuple удобен для небольших структурированных данных вместо создания отдельных интерфейсов.</p>",
    difficulty: 'junior',
    tags: ['tuple', 'массивы', 'типы данных', 'структуры']
  },
  {
    id: 18,
    question: "Чем отличается тип any от типа unknown и never?",
    answer: "<p>Эти три типа имеют <strong>фундаментально разное назначение</strong>:</p><h4>any — отключение проверки:</h4><p><strong>Любое значение допустимо</strong> — можно присвоить что угодно и делать с ним что угодно.</p><p><strong>Отключает type safety:</strong> Компилятор не проверяет операции с any.</p><p><strong>Заразный тип:</strong> Распространяется по коду, нивелируя пользу TypeScript.</p><h4>unknown — безопасный any:</h4><p><strong>Любое значение можно присвоить</strong>, но использовать напрямую нельзя.</p><p><strong>Требует проверки:</strong> Перед использованием нужен type guard — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Top type:</strong> Все типы совместимы с unknown, но unknown не совместим ни с чем без проверки.</p><h4>never — невозможное значение:</h4><p><strong>Нет значений этого типа</strong> — представляет недостижимый код.</p><p><strong>Bottom type:</strong> Подтип всех типов, но никакой тип не присваивается never.</p><p><strong>Используется для:</strong> Функций, которые никогда не возвращаются — бесконечные циклы, throw исключений.</p><p><em>Правило:</em> Предпочитайте unknown вместо any для действительно динамических значений.</p>",
    difficulty: 'middle',
    tags: ['any', 'unknown', 'never', 'типы', 'безопасность']
  },
  {
    id: 19,
    question: "Как использовать тип enum для определения перечисления значений?",
    answer: "<p>Enum позволяет определить <strong>набор именованных констант</strong>:</p><h4>Числовые enum:</h4><p><strong>По умолчанию</strong> — значения автоматически увеличиваются с 0: <code>enum Direction { Up, Down, Left, Right }</code></p><p><strong>Кастомные значения:</strong> Можно задать явно — <code>enum Status { Active = 1, Inactive = 0 }</code></p><h4>Строковые enum:</h4><p><strong>Явные строковые значения</strong> — <code>enum Color { Red = 'RED', Green = 'GREEN' }</code></p><p><strong>Преимущества:</strong> Более читаемы в runtime, лучше для отладки и логирования.</p><h4>Особенности:</h4><p><strong>Двунаправленное mapping</strong> у числовых enum — можно получить имя по значению: <code>Direction[0] === 'Up'</code></p><p><strong>Компилируются в объекты</strong> в JavaScript коде, увеличивают размер бандла.</p><h4>Альтернативы:</h4><p><strong>Const enum:</strong> Исчезает после компиляции, заменяется на значения — экономит место.</p><p><strong>Union literal types:</strong> <code>type Direction = 'up' | 'down'</code> — более современный подход, не добавляет runtime код.</p><p><em>Выбор:</em> Для новых проектов часто предпочитают union types вместо enum.</p>",
    difficulty: 'junior',
    tags: ['enum', 'константы', 'перечисления', 'типы']
  },
  {
    id: 20,
    question: "Что такое литеральные типы и где их можно применять?",
    answer: "<p>Литеральные типы — это <strong>конкретные значения как типы</strong>:</p><h4>Типы литералов:</h4><p><strong>Строковые литералы:</strong> <code>type Answer = 'yes' | 'no'</code> — переменная может быть только этими строками.</p><p><strong>Числовые литералы:</strong> <code>type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6</code> — только эти числа допустимы.</p><p><strong>Boolean литералы:</strong> <code>type Success = true</code> — только конкретное булево значение.</p><h4>Практическое применение:</h4><p><strong>Ограниченные наборы значений:</strong> Статусы заказов, HTTP методы, режимы работы приложения.</p><p><strong>Discriminated unions:</strong> <code>type Action = { type: 'add' } | { type: 'remove' }</code> — различение union типов по литеральному полю.</p><p><strong>Конфигурация:</strong> Явное указание допустимых опций — <code>env: 'development' | 'production'</code></p><h4>Преимущества:</h4><p><strong>Автодополнение:</strong> IDE показывает только допустимые значения.</p><p><strong>Защита от опечаток:</strong> <code>'prodaction'</code> вызовет ошибку компиляции.</p><p><strong>Type narrowing:</strong> TypeScript может сужать типы в условиях.</p><p><em>Практика:</em> Предпочитайте литеральные union типы перед enum для строковых констант.</p>",
    difficulty: 'middle',
    tags: ['литеральные типы', 'union types', 'константы', 'типизация']
  },
  {
    id: 21,
    question: "Как работает type assertion и когда его следует использовать?",
    answer: "<p>Type assertion — это способ <strong>явно указать тип</strong>, который знает разработчик, но не может вывести компилятор:</p><h4>Синтаксис:</h4><p><strong>Угловые скобки:</strong> <code>&lt;string&gt;someValue</code> — старый синтаксис, несовместим с JSX.</p><p><strong>as синтаксис:</strong> <code>someValue as string</code> — предпочтительный современный вариант.</p><h4>Когда использовать:</h4><p><strong>DOM элементы:</strong> <code>document.getElementById('input') as HTMLInputElement</code> — браузер знает тип, TypeScript нет.</p><p><strong>API ответы:</strong> Когда мы уверены в структуре данных, но TypeScript видит общий тип.</p><p><strong>Миграция кода:</strong> Временное решение при переходе с JavaScript.</p><h4>Опасности:</h4><p><strong>Обход проверки типов:</strong> Assertion не проверяет реальный тип в runtime — можно получить ошибку.</p><p><strong>Ложная уверенность:</strong> Разработчик может ошибаться в своих предположениях.</p><h4>Безопасные альтернативы:</h4><p><strong>Type guards:</strong> Использовать проверки вместо assertion.</p><p><strong>Проверка в runtime:</strong> Валидация данных перед использованием.</p><p><em>Правило:</em> Каждый assertion — потенциальный баг. Используйте только когда действительно уверены.</p>",
    difficulty: 'middle',
    tags: ['type assertion', 'приведение типов', 'безопасность', 'типизация']
  },
  {
    id: 22,
    question: "В чем разница между type и interface и когда использовать каждый?",
    answer: "<p>Type и interface имеют <strong>много общего, но разные возможности</strong>:</p><h4>Interface:</h4><p><strong>Declaration merging:</strong> Несколько объявлений с одним именем сливаются — полезно для расширения библиотечных типов.</p><p><strong>Extends наследование:</strong> <code>interface Admin extends User</code> — более явное расширение.</p><p><strong>Implements в классах:</strong> Классы могут реализовывать интерфейсы — <code>class User implements IUser</code></p><h4>Type:</h4><p><strong>Union и intersection types:</strong> <code>type Result = Success | Error</code> — interface так не умеет.</p><p><strong>Примитивы и литералы:</strong> <code>type ID = string | number</code> — alias для любых типов.</p><p><strong>Mapped и conditional types:</strong> Продвинутые трансформации типов.</p><h4>Когда что использовать:</h4><p><strong>Interface для объектов:</strong> Публичные API, React компоненты, структуры данных.</p><p><strong>Type для union:</strong> Комбинации типов, алиасы, сложные трансформации.</p><p><strong>Consistency:</strong> В одном проекте лучше придерживаться единого стиля.</p><p><em>Тренд:</em> Современная практика склоняется к использованию type для большей гибкости.</p>",
    difficulty: 'middle',
    tags: ['type', 'interface', 'различия', 'определение типов']
  },
  {
    id: 23,
    question: "Что такое type guards и как их создавать?",
    answer: "<p>Type guards — это <strong>механизм сужения типов</strong> через runtime проверки:</p><h4>Встроенные type guards:</h4><p><strong>typeof:</strong> <code>if (typeof value === 'string')</code> — для примитивов.</p><p><strong>instanceof:</strong> <code>if (error instanceof Error)</code> — для проверки классов.</p><p><strong>in оператор:</strong> <code>if ('message' in error)</code> — проверка наличия свойства.</p><h4>Пользовательские type guards:</h4><p><strong>Predicate функции:</strong> <code>function isString(value: unknown): value is string { return typeof value === 'string' }</code></p><p><strong>Возвращаемый тип</strong> <code>value is Type</code> сообщает TypeScript о сужении типа.</p><h4>Discriminated unions:</h4><p><strong>Тип с литеральным полем:</strong> <code>if (action.type === 'add')</code> — TypeScript понимает конкретный тип в этой ветке.</p><h4>Применение:</h4><p><strong>Работа с union types:</strong> Безопасное различение вариантов.</p><p><strong>Работа с unknown:</strong> Проверка перед использованием динамических данных.</p><p><strong>API responses:</strong> Валидация структуры данных от сервера.</p><p><em>Преимущество:</em> Type guards делают код и безопасным, и понятным для TypeScript.</p>",
    difficulty: 'middle',
    tags: ['type guards', 'сужение типов', 'проверки', 'безопасность']
  },
  {
    id: 24,
    question: "Как работают Generic типы и зачем они нужны?",
    answer: "<p>Generic типы позволяют создавать <strong>переиспользуемые компоненты</strong>, работающие с разными типами:</p><h4>Основная идея:</h4><p><strong>Параметризация типов:</strong> <code>Array&lt;T&gt;</code> — массив любого типа, где T — параметр типа.</p><p><strong>Type safety с гибкостью:</strong> Сохраняется связь между входными и выходными типами.</p><h4>Применение:</h4><p><strong>Функции:</strong> <code>function identity&lt;T&gt;(value: T): T</code> — возвращает тот же тип, что получила.</p><p><strong>Интерфейсы:</strong> <code>interface Box&lt;T&gt; { value: T }</code> — контейнер для любого типа.</p><p><strong>Классы:</strong> <code>class Storage&lt;T&gt;</code> — типизированное хранилище.</p><h4>Ограничения (constraints):</h4><p><strong>extends:</strong> <code>&lt;T extends HasId&gt;</code> — ограничивает T только типами с определенными свойствами.</p><p><strong>Множественные параметры:</strong> <code>&lt;K, V&gt;</code> — для Map-подобных структур.</p><h4>Вывод типов:</h4><p>TypeScript <strong>автоматически выводит</strong> T из аргументов — не всегда нужно явно указывать.</p><p><em>Цель:</em> Generic'и избавляют от дублирования кода и сохраняют type safety.</p>",
    difficulty: 'senior',
    tags: ['generics', 'параметризация', 'переиспользование', 'типизация']
  },
  {
    id: 25,
    question: "Что такое union и intersection types и как их применять?",
    answer: "<p>Union и intersection — это <strong>способы комбинирования типов</strong>:</p><h4>Union types (|):</h4><p><strong>Логическое ИЛИ:</strong> <code>string | number</code> — значение может быть одним из типов.</p><p><strong>Применение:</strong> Параметры, которые принимают разные типы, состояния с вариантами, опциональные значения.</p><p><strong>Type narrowing:</strong> Нужны проверки для безопасного использования — TypeScript не знает конкретный тип.</p><h4>Intersection types (&):</h4><p><strong>Логическое И:</strong> <code>User & Admin</code> — объект должен иметь свойства обоих типов.</p><p><strong>Применение:</strong> Миксины, композиция типов, расширение типов без наследования.</p><p><strong>Объединение свойств:</strong> Результирующий тип содержит все поля из обоих типов.</p><h4>Практические примеры:</h4><p><strong>Union для вариантов:</strong> <code>type Status = 'loading' | 'success' | 'error'</code></p><p><strong>Intersection для расширения:</strong> <code>type AdminUser = User & { role: 'admin' }</code></p><h4>Особенности:</h4><p><strong>Приоритет:</strong> Intersection имеет выше приоритет, чем union — скобки важны.</p><p><em>Комбинирование:</em> Можно создавать сложные типы — <code>(A & B) | (C & D)</code></p>",
    difficulty: 'middle',
    tags: ['union types', 'intersection types', 'комбинирование типов', 'композиция']
  },
  {
    id: 26,
    question: "Как работают mapped types и для чего их используют?",
    answer: "<p>Mapped types позволяют <strong>трансформировать существующие типы</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Итерация по ключам:</strong> <code>{ [K in keyof T]: T[K] }</code> — проходим по всем свойствам типа T.</p><p><strong>Трансформация типов:</strong> Можем изменить тип каждого свойства.</p><h4>Встроенные utility types:</h4><p><strong>Partial&lt;T&gt;:</strong> Делает все свойства опциональными — <code>{ [K in keyof T]?: T[K] }</code></p><p><strong>Required&lt;T&gt;:</strong> Делает все свойства обязательными — убирает знаки вопроса.</p><p><strong>Readonly&lt;T&gt;:</strong> Делает все свойства только для чтения — <code>readonly</code> перед каждым.</p><p><strong>Pick&lt;T, K&gt;:</strong> Выбирает только указанные ключи.</p><p><strong>Omit&lt;T, K&gt;:</strong> Исключает указанные ключи.</p><h4>Кастомные mapped types:</h4><p><strong>Префиксы/суффиксы:</strong> <code>type Getters&lt;T&gt; = { [K in keyof T as `get${K}`]: () =&gt; T[K] }</code></p><p><strong>Conditional mapping:</strong> Применение условий при трансформации.</p><h4>Применение:</h4><p>Создание вариаций типов без дублирования, форм с валидацией, API response типов.</p><p><em>Мощь:</em> Mapped types — основа для создания продвинутых utility типов.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'трансформация типов', 'utility types', 'продвинутые типы']
  },
  {
    id: 27,
    question: "Что такое conditional types и как их использовать?",
    answer: "<p>Conditional types позволяют типам <strong>зависеть от условий</strong>:</p><h4>Синтаксис:</h4><p><strong>Тернарный оператор для типов:</strong> <code>T extends U ? X : Y</code> — если T расширяет U, то X, иначе Y.</p><h4>Применение:</h4><p><strong>Извлечение типов:</strong> <code>type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never</code></p><p><strong>infer ключевое слово:</strong> Позволяет извлечь тип из структуры — тип возвращаемого значения, параметров функции.</p><p><strong>Фильтрация union types:</strong> <code>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T</code></p><h4>Встроенные utility types:</h4><p><strong>Exclude&lt;T, U&gt;:</strong> Исключает типы из union.</p><p><strong>Extract&lt;T, U&gt;:</strong> Извлекает только совпадающие типы.</p><p><strong>ReturnType&lt;T&gt;:</strong> Получает тип возвращаемого значения функции.</p><h4>Distributive conditionals:</h4><p><strong>Автоматическое распределение:</strong> Conditional type применяется к каждому члену union типа отдельно.</p><h4>Сложные сценарии:</h4><p>Рекурсивные типы, deep partial, вложенные условия.</p><p><em>Использование:</em> Для создания type-level логики и продвинутых трансформаций.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'продвинутые типы', 'type-level программирование', 'utility types']
  },
  {
    id: 28,
    question: "Как правильно типизировать функции и их параметры?",
    answer: "<p>Типизация функций включает <strong>несколько аспектов</strong>:</p><h4>Базовая типизация:</h4><p><strong>Параметры и возврат:</strong> <code>function add(a: number, b: number): number</code> — явные типы для всего.</p><p><strong>Стрелочные функции:</strong> <code>const add = (a: number, b: number): number =&gt; a + b</code></p><h4>Опциональные параметры:</h4><p><strong>Знак вопроса:</strong> <code>function log(message: string, level?: string)</code> — level может отсутствовать.</p><p><strong>Значения по умолчанию:</strong> <code>function greet(name = 'Guest')</code> — TypeScript выводит тип автоматически.</p><h4>Rest параметры:</h4><p><strong>Spread оператор:</strong> <code>function sum(...numbers: number[])</code> — массив параметров одного типа.</p><h4>Перегрузка функций:</h4><p><strong>Несколько сигнатур:</strong> Разные варианты вызова с разными типами параметров и возврата.</p><p><strong>Реализация:</strong> Одна реализация покрывает все варианты.</p><h4>Типы функций как параметры:</h4><p><strong>Callback типизация:</strong> <code>function map&lt;T, U&gt;(arr: T[], fn: (item: T) =&gt; U): U[]</code></p><p><strong>Function type:</strong> <code>type Handler = (event: Event) =&gt; void</code></p><p><em>Совет:</em> Избегайте <code>Function</code> типа — всегда указывайте конкретную сигнатуру.</p>",
    difficulty: 'middle',
    tags: ['функции', 'параметры', 'типизация', 'сигнатуры']
  },
  {
    id: 29,
    question: "Как работать с типами для асинхронного кода и Promise?",
    answer: "<p>Типизация асинхронного кода требует <strong>понимания Promise типов</strong>:</p><h4>Promise типизация:</h4><p><strong>Generic параметр:</strong> <code>Promise&lt;T&gt;</code> — T это тип разрешенного значения.</p><p><strong>Async функции:</strong> <code>async function fetchData(): Promise&lt;User&gt;</code> — возвращаемый тип всегда Promise.</p><h4>Обработка ошибок:</h4><p><strong>Try-catch:</strong> Тип в catch всегда <code>unknown</code> — нужен type guard для безопасной работы.</p><p><strong>Rejection типы:</strong> Promise технически может отклониться с любым типом, но TypeScript не проверяет это статически.</p><h4>Множественные промисы:</h4><p><strong>Promise.all:</strong> <code>Promise.all([promise1, promise2])</code> возвращает <code>Promise&lt;[Type1, Type2]&gt;</code> — tuple типов.</p><p><strong>Promise.race:</strong> Возвращает union тип всех возможных результатов.</p><h4>Async iterators:</h4><p><strong>AsyncIterable:</strong> <code>async function* generator(): AsyncIterableIterator&lt;number&gt;</code></p><h4>Практические паттерны:</h4><p><strong>Типизация API вызовов:</strong> Создание типов для response и error.</p><p><strong>Wrapper типы:</strong> <code>type AsyncResult&lt;T&gt; = { data: T | null; error: Error | null }</code></p><p><em>Важно:</em> Async/await не меняет принципы типизации, только упрощает синтаксис.</p>",
    difficulty: 'middle',
    tags: ['асинхронность', 'Promise', 'async/await', 'типизация']
  },
  {
    id: 30,
    question: "Как типизировать объекты с динамическими ключами?",
    answer: "<p>Динамические ключи требуют <strong>специальных подходов к типизации</strong>:</p><h4>Index signatures:</h4><p><strong>Базовый синтаксис:</strong> <code>{ [key: string]: number }</code> — любой строковый ключ ведет к числу.</p><p><strong>Ограничения ключей:</strong> Ключи могут быть только <code>string</code>, <code>number</code> или <code>symbol</code>.</p><h4>Record utility type:</h4><p><strong>Более явный синтаксис:</strong> <code>Record&lt;string, User&gt;</code> — объект где ключи строки, значения User.</p><p><strong>С литеральными типами:</strong> <code>Record&lt;'a' | 'b' | 'c', number&gt;</code> — только конкретные ключи.</p><h4>Смешанные типы:</h4><p><strong>Известные + динамические ключи:</strong> <code>interface Data { id: number; [key: string]: any }</code></p><p><strong>Проблема:</strong> Index signature должна быть совместима со всеми известными свойствами.</p><h4>Mapped types для динамики:</h4><p><strong>Условные ключи:</strong> <code>{ [K in keyof T]: T[K] extends string ? K : never }</code></p><h4>Практические случаи:</h4><p><strong>Словари и maps:</strong> Хранение данных по ключам.</p><p><strong>API responses:</strong> Когда структура не полностью известна.</p><p><strong>Конфигурационные объекты:</strong> С расширяемыми опциями.</p><p><em>Альтернатива:</em> Map&lt;K, V&gt; для действительно динамических структур лучше обычных объектов.</p>",
    difficulty: 'senior',
    tags: ['динамические ключи', 'index signature', 'Record', 'типизация объектов']
  },
  {
    id: 31,
    question: "В чем фундаментальное различие между interface и type в TypeScript?",
    answer: "<p>Interface и type имеют <strong>разную природу и возможности</strong>:</p><h4>Interface — для объектных структур:</h4><p><strong>Только объекты:</strong> Interface описывает исключительно форму объектов и не может быть алиасом для примитивов или union типов.</p><p><strong>Declaration merging:</strong> Повторное объявление interface с тем же именем <em>сливает</em> определения — это ключевое отличие.</p><p><strong>Расширение через extends:</strong> Явное наследование, более читаемое и понятное.</p><h4>Type — универсальный алиас:</h4><p><strong>Любые типы:</strong> Type может быть алиасом для чего угодно — примитивов, union, intersection, tuple, функций.</p><p><strong>Нет merging:</strong> Повторное объявление — ошибка. Защищает от случайных конфликтов.</p><p><strong>Более мощные трансформации:</strong> Поддерживает mapped types, conditional types, template literal types.</p><h4>Практическая разница:</h4><p><strong>Extends vs intersection:</strong> <code>interface Admin extends User</code> четче показывает намерение, чем <code>type Admin = User & AdminProps</code>.</p><p><em>Суть:</em> Interface — контракт для объектов, type — гибкий инструмент для любых типов.</p>",
    difficulty: 'middle',
    tags: ['interface', 'type', 'различия', 'определение типов']
  },
  {
    id: 32,
    question: "Когда следует использовать interface, а когда type?",
    answer: "<p>Выбор между interface и type зависит от <strong>конкретной задачи</strong>:</p><h4>Используйте interface когда:</h4><p><strong>Описываете публичные API:</strong> Библиотеки, компоненты, внешние контракты — interface явно показывает намерение.</p><p><strong>Работаете с классами:</strong> <code>class User implements IUser</code> — более естественная семантика.</p><p><strong>Нужно расширение извне:</strong> Declaration merging позволяет пользователям добавлять свойства к вашим типам.</p><p><strong>ООП паттерны:</strong> Наследование, полиморфизм — interface традиционно для этого.</p><h4>Используйте type когда:</h4><p><strong>Union или intersection:</strong> <code>type Status = 'active' | 'inactive'</code> — interface не может.</p><p><strong>Tuple типы:</strong> <code>type Point = [number, number]</code> — четкая структура.</p><p><strong>Mapped или conditional types:</strong> Продвинутые трансформации типов.</p><p><strong>Алиасы примитивов:</strong> <code>type ID = string | number</code></p><h4>Универсальное правило:</h4><p><strong>Согласованность:</strong> В одном проекте придерживайтесь единого стиля — либо interface-first, либо type-first.</p><p><em>Тренд:</em> Современные проекты чаще используют type для гибкости, но interface для React props и публичных API.</p>",
    difficulty: 'middle',
    tags: ['interface', 'type', 'выбор', 'best practices']
  },
  {
    id: 33,
    question: "Как работает declaration merging у интерфейсов и почему это важно?",
    answer: "<p>Declaration merging — это <strong>автоматическое объединение</strong> нескольких объявлений одного interface:</p><h4>Механизм работы:</h4><p><strong>Слияние определений:</strong> Если объявить interface дважды с одним именем, TypeScript объединит их свойства.</p><p><strong>Дополнение типов:</strong> Каждое новое объявление добавляет свойства, не перезаписывая существующие.</p><h4>Практическое применение:</h4><p><strong>Расширение библиотек:</strong> Можно добавить свойства к существующим типам — например, добавить поля в <code>Window</code> или расширить типы библиотеки.</p><p><strong>Module augmentation:</strong> <code>declare module 'library' { interface Config { myField: string } }</code> — расширяем чужие типы в своем коде.</p><p><strong>Глобальные расширения:</strong> Добавление методов к глобальным объектам безопасным способом.</p><h4>Когда это проблема:</h4><p><strong>Случайные конфликты:</strong> В больших проектах можно не заметить, что interface уже существует.</p><p><strong>Неявное поведение:</strong> Merging происходит автоматически, что может быть неочевидно.</p><p><em>Почему type не имеет merging:</em> Чтобы защитить от случайных переопределений — более строгая проверка.</p>",
    difficulty: 'senior',
    tags: ['interface', 'declaration merging', 'расширение типов', 'модули']
  },
  {
    id: 34,
    question: "Какие преимущества дают интерфейсы при работе с классами?",
    answer: "<p>Интерфейсы и классы имеют <strong>естественную совместимость</strong> в TypeScript:</p><h4>Implements ключевое слово:</h4><p><strong>Контракт для класса:</strong> <code>class User implements IUser</code> — класс обязан реализовать все свойства интерфейса.</p><p><strong>Множественная реализация:</strong> <code>class Admin implements IUser, IAdmin</code> — один класс может реализовывать несколько интерфейсов.</p><h4>Разделение контракта и реализации:</h4><p><strong>Dependency inversion:</strong> Код зависит от интерфейсов, а не конкретных классов — упрощает тестирование.</p><p><strong>Полиморфизм:</strong> Разные классы реализуют один интерфейс — работаем с абстракцией, не с конкретикой.</p><h4>Проверка на этапе компиляции:</h4><p><strong>Гарантия структуры:</strong> TypeScript проверит, что класс действительно реализует все требуемые члены интерфейса.</p><p><strong>Эволюция API:</strong> При изменении интерфейса все реализации получат ошибки компиляции — не забудете обновить.</p><h4>Отличие от type:</h4><p><strong>Implements vs type:</strong> С type можно, но <code>implements</code> семантически правильнее для контрактов классов.</p><p><em>Паттерн:</em> Interface для публичных контрактов, class для реализации — чистая архитектура.</p>",
    difficulty: 'middle',
    tags: ['interface', 'классы', 'implements', 'ООП']
  },
  {
    id: 35,
    question: "Можно ли расширять type и как это отличается от extends у interface?",
    answer: "<p>Type можно расширять, но <strong>механизм отличается</strong>:</p><h4>Расширение через intersection:</h4><p><strong>Оператор &:</strong> <code>type Admin = User & { role: 'admin' }</code> — объединение свойств двух типов.</p><p><strong>Результат:</strong> Новый тип содержит все свойства обоих типов.</p><h4>Отличия от interface extends:</h4><p><strong>Interface extends:</strong> <code>interface Admin extends User</code> — явное наследование с проверкой совместимости.</p><p><strong>Конфликты свойств:</strong> Extends выдаст ошибку при несовместимых типах одноименных свойств, intersection попытается их объединить.</p><p><strong>Читаемость:</strong> Extends более декларативен и понятен — «Admin это User плюс дополнительные свойства».</p><h4>Сложные сценарии:</h4><p><strong>Множественное расширение:</strong> <code>type SuperAdmin = User & Admin & Permissions</code> — можно комбинировать много типов.</p><p><strong>Union в intersection:</strong> <code>type Result = (Success | Error) & Timestamped</code> — смешивание подходов.</p><h4>Когда что использовать:</h4><p><strong>Extends для ясности:</strong> Когда важна явная иерархия типов.</p><p><strong>Intersection для композиции:</strong> Когда собираем тип из нескольких частей без строгой иерархии.</p><p><em>Нюанс:</em> Intersection может создавать невозможные типы при конфликтах — extends безопаснее.</p>",
    difficulty: 'senior',
    tags: ['type', 'interface', 'extends', 'intersection', 'расширение']
  },
  {
    id: 36,
    question: "Как типизировать опциональные свойства в интерфейсах?",
    answer: "<p>Опциональные свойства позволяют <strong>делать поля необязательными</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Знак вопроса:</strong> <code>interface User { name: string; email?: string }</code> — email может отсутствовать.</p><p><strong>Семантика:</strong> Опциональное свойство может быть <code>undefined</code> или присутствовать с указанным типом.</p><h4>Отличие от undefined union:</h4><p><strong>Optional property:</strong> <code>{ email?: string }</code> — свойство может отсутствовать в объекте.</p><p><strong>Explicit undefined:</strong> <code>{ email: string | undefined }</code> — свойство должно быть, но может быть undefined.</p><p><strong>Проверка наличия:</strong> <code>'email' in user</code> vs <code>user.email !== undefined</code> — разные проверки.</p><h4>Utility types:</h4><p><strong>Partial&lt;T&gt;:</strong> Делает все свойства опциональными — <code>Partial&lt;User&gt;</code> эквивалентно всем полям с <code>?</code></p><p><strong>Required&lt;T&gt;:</strong> Обратная операция — убирает все знаки вопроса.</p><h4>Практическое применение:</h4><p><strong>API параметры:</strong> Часть полей обязательна, часть опциональна.</p><p><strong>Конфигурационные объекты:</strong> Значения по умолчанию для отсутствующих полей.</p><p><strong>Частичные обновления:</strong> PATCH запросы, где можно обновить только некоторые поля.</p>",
    difficulty: 'junior',
    tags: ['interface', 'опциональные свойства', 'optional', 'типизация']
  },
  {
    id: 37,
    question: "Что такое readonly свойства и как они работают в интерфейсах?",
    answer: "<p>Readonly модификатор обеспечивает <strong>иммутабельность на уровне типов</strong>:</p><h4>Базовое использование:</h4><p><strong>Модификатор readonly:</strong> <code>interface User { readonly id: string }</code> — свойство нельзя переназначить после создания.</p><p><strong>Защита от изменений:</strong> Попытка присвоить новое значение вызовет ошибку компиляции.</p><h4>Важные нюансы:</h4><p><strong>Только на уровне типов:</strong> Readonly проверяется только при компиляции — в runtime ничто не мешает изменить свойство.</p><p><strong>Shallow readonly:</strong> Только само свойство readonly, вложенные объекты можно мутировать — <code>user.profile.name = 'New'</code> работает.</p><h4>Utility types:</h4><p><strong>Readonly&lt;T&gt;:</strong> Делает все свойства readonly — <code>Readonly&lt;User&gt;</code></p><p><strong>DeepReadonly:</strong> Нужен кастомный тип для рекурсивного readonly всех вложенных объектов.</p><h4>Применение:</h4><p><strong>ID и ключи:</strong> Поля, которые не должны меняться после создания.</p><p><strong>Конфигурация:</strong> Immutable настройки приложения.</p><p><strong>React props:</strong> Props компонентов обычно readonly.</p><h4>Readonly массивы:</h4><p><strong>ReadonlyArray&lt;T&gt;:</strong> Массив без методов мутации — <code>readonly string[]</code></p><p><em>Защита:</em> Readonly помогает предотвратить случайные мутации, но не гарантирует полную иммутабельность.</p>",
    difficulty: 'middle',
    tags: ['readonly', 'иммутабельность', 'interface', 'модификаторы']
  },
  {
    id: 38,
    question: "Как создавать индексные сигнатуры в интерфейсах?",
    answer: "<p>Индексные сигнатуры позволяют типизировать <strong>объекты с динамическими ключами</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>String index:</strong> <code>interface Dictionary { [key: string]: number }</code> — любой строковый ключ ведет к числу.</p><p><strong>Number index:</strong> <code>interface List { [index: number]: string }</code> — числовые индексы, как в массивах.</p><h4>Ограничения:</h4><p><strong>Типы ключей:</strong> Можно использовать только <code>string</code>, <code>number</code> или <code>symbol</code> (с ES2015).</p><p><strong>Совместимость свойств:</strong> Все известные свойства должны быть совместимы с типом индексной сигнатуры.</p><h4>Смешанные определения:</h4><p><strong>Известные + динамические:</strong> <code>interface Config { name: string; [key: string]: string | number }</code></p><p><strong>Проблема:</strong> Индексная сигнатура должна покрывать все свойства — <code>name</code> должен быть совместим с <code>string | number</code>.</p><h4>Альтернативы:</h4><p><strong>Record type:</strong> <code>Record&lt;string, User&gt;</code> — более явный и современный подход.</p><p><strong>Map:</strong> Для действительно динамических структур Map&lt;K, V&gt; лучше объектов.</p><h4>Применение:</h4><p><strong>Словари:</strong> Хранение данных по строковым ключам.</p><p><strong>JSON объекты:</strong> Динамическая структура из API.</p><p><em>Осторожность:</em> Индексные сигнатуры ослабляют type safety — используйте когда действительно нужна динамичность.</p>",
    difficulty: 'middle',
    tags: ['index signature', 'динамические ключи', 'interface', 'типизация']
  },
  {
    id: 39,
    question: "Можно ли описать функцию через interface и как это сделать?",
    answer: "<p>Interface может описывать <strong>форму функции</strong> через call signature:</p><h4>Call signature синтаксис:</h4><p><strong>Функция как объект:</strong> <code>interface Greeter { (name: string): string }</code> — интерфейс описывает функцию.</p><p><strong>Использование:</strong> <code>const greet: Greeter = (name) =&gt; `Hello, ${name}`</code></p><h4>Функции с дополнительными свойствами:</h4><p><strong>Callable objects:</strong> Функция может иметь свои свойства — <code>interface Counter { (): number; reset(): void }</code></p><p><strong>Практика:</strong> Функция-счетчик с методом reset — паттерн из jQuery и других библиотек.</p><h4>Отличие от type:</h4><p><strong>Type alias:</strong> <code>type Greeter = (name: string) =&gt; string</code> — более краткая запись.</p><p><strong>Выбор подхода:</strong> Type предпочтительнее для простых функций, interface когда нужны дополнительные свойства.</p><h4>Множественные сигнатуры:</h4><p><strong>Overloading:</strong> Interface может описать несколько вариантов вызова функции с разными параметрами.</p><h4>Применение:</h4><p><strong>Callbacks:</strong> Типизация функций обратного вызова.</p><p><strong>Factory функции:</strong> С дополнительными методами и свойствами.</p><p><em>Совет:</em> Для простых функций используйте type, для сложных с методами — interface.</p>",
    difficulty: 'middle',
    tags: ['interface', 'функции', 'call signature', 'типизация']
  },
  {
    id: 40,
    question: "Как работают generic параметры в интерфейсах?",
    answer: "<p>Generic параметры делают интерфейсы <strong>переиспользуемыми и гибкими</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Параметр типа:</strong> <code>interface Box&lt;T&gt; { value: T }</code> — T будет заменен конкретным типом при использовании.</p><p><strong>Использование:</strong> <code>const numberBox: Box&lt;number&gt; = { value: 42 }</code></p><h4>Множественные параметры:</h4><p><strong>Несколько generic:</strong> <code>interface Pair&lt;K, V&gt; { key: K; value: V }</code> — для map-подобных структур.</p><p><strong>Связь типов:</strong> Generic параметры могут зависеть друг от друга.</p><h4>Ограничения (constraints):</h4><p><strong>Extends constraint:</strong> <code>interface Repository&lt;T extends { id: string }&gt;</code> — T должен иметь поле id.</p><p><strong>Использование:</strong> Гарантирует, что тип имеет нужные свойства для работы интерфейса.</p><h4>Default типы:</h4><p><strong>Значение по умолчанию:</strong> <code>interface Response&lt;T = unknown&gt;</code> — если не указан, используется unknown.</p><h4>Применение:</h4><p><strong>Контейнеры данных:</strong> Box, Option, Result — обертки над значениями.</p><p><strong>API responses:</strong> <code>ApiResponse&lt;User&gt;</code> — общая структура с generic данными.</p><p><strong>Репозитории:</strong> CRUD операции для любых сущностей с id.</p><p><em>Мощь:</em> Generic делают один интерфейс применимым к множеству типов безопасно.</p>",
    difficulty: 'senior',
    tags: ['interface', 'generics', 'параметризация', 'типизация']
  },
  {
    id: 41,
    question: "Что такое excess property checking и как он работает с интерфейсами?",
    answer: "<p>Excess property checking — это <strong>дополнительная проверка</strong> при прямом присваивании литералов:</p><h4>Механизм работы:</h4><p><strong>Литеральная проверка:</strong> При присваивании объектного литерала TypeScript проверяет, нет ли лишних свойств.</p><p><strong>Только для литералов:</strong> Проверка срабатывает только при прямом присваивании — <code>const user: User = { name: 'John', extra: 'oops' }</code> выдаст ошибку.</p><h4>Почему это важно:</h4><p><strong>Защита от опечаток:</strong> Помогает поймать ошибки типа <code>usrName</code> вместо <code>userName</code>.</p><p><strong>API контракты:</strong> Гарантирует, что клиент не отправляет неожиданные поля.</p><h4>Обход проверки:</h4><p><strong>Через переменную:</strong> <code>const data = { name: 'John', extra: 'ok' }; const user: User = data</code> — проверка не срабатывает.</p><p><strong>Type assertion:</strong> <code>const user = { extra: 'ok' } as User</code> — отключает проверку явно.</p><p><strong>Index signature:</strong> <code>[key: string]: any</code> в интерфейсе разрешает любые дополнительные свойства.</p><h4>Практические случаи:</h4><p><strong>Проблема с React props:</strong> Excess properties могут вызвать ошибки при передаче spread props.</p><p><strong>API интеграции:</strong> Сервер может вернуть дополнительные поля — сохранение в переменной помогает.</p><p><em>Философия:</em> Строгая проверка для новых объектов, гибкость для существующих данных.</p>",
    difficulty: 'senior',
    tags: ['excess property checking', 'интерфейсы', 'проверка типов', 'строгость']
  },
  {
    id: 42,
    question: "Как использовать extends для условного расширения интерфейсов?",
    answer: "<p>Extends в интерфейсах обеспечивает <strong>наследование и композицию</strong>:</p><h4>Базовое наследование:</h4><p><strong>Один родитель:</strong> <code>interface Admin extends User { role: 'admin' }</code> — наследует все свойства User плюс добавляет свои.</p><p><strong>Проверка совместимости:</strong> TypeScript проверит, что нет конфликтов типов одноименных свойств.</p><h4>Множественное наследование:</h4><p><strong>Несколько родителей:</strong> <code>interface SuperUser extends User, Admin, Permissions</code> — комбинация нескольких интерфейсов.</p><p><strong>Разрешение конфликтов:</strong> Если свойства совпадают, их типы должны быть совместимы.</p><h4>Переопределение свойств:</h4><p><strong>Сужение типа:</strong> Можно сузить тип свойства — если родитель имеет <code>string | number</code>, потомок может указать только <code>string</code>.</p><p><strong>Расширение нельзя:</strong> Нельзя расширить тип свойства — это вызовет ошибку.</p><h4>Generic extends:</h4><p><strong>Условное расширение:</strong> <code>interface Repository&lt;T extends Entity&gt; extends BaseRepo</code> — комбинация generic и наследования.</p><h4>Применение:</h4><p><strong>Иерархии типов:</strong> User → Customer → PremiumCustomer — построение type hierarchy.</p><p><strong>Миксины:</strong> Комбинация нескольких интерфейсов для создания составных типов.</p><p><em>Преимущество:</em> Явная иерархия типов облегчает понимание и рефакторинг кода.</p>",
    difficulty: 'middle',
    tags: ['extends', 'наследование', 'interface', 'иерархия типов']
  },
  {
    id: 43,
    question: "Как типизировать методы в интерфейсах и какие есть варианты синтаксиса?",
    answer: "<p>TypeScript предлагает <strong>два способа описания методов</strong> в интерфейсах:</p><h4>Method syntax:</h4><p><strong>Краткая форма:</strong> <code>interface User { greet(name: string): void }</code> — метод как часть интерфейса.</p><p><strong>Семантика:</strong> Выглядит как классовый метод, привычнее для ООП.</p><h4>Property function syntax:</h4><p><strong>Функция как свойство:</strong> <code>interface User { greet: (name: string) =&gt; void }</code> — свойство, которое является функцией.</p><p><strong>Стрелочная функция:</strong> Явно показывает, что это функциональное свойство.</p><h4>Различия:</h4><p><strong>Strictness:</strong> Method syntax менее строгий при проверке — позволяет больше вариантов реализации.</p><p><strong>This binding:</strong> В классах method syntax правильно обрабатывает <code>this</code>, property function может требовать bind.</p><p><strong>Overloading:</strong> Method syntax поддерживает перегрузку методов, property function — нет.</p><h4>Когда что использовать:</h4><p><strong>Method syntax:</strong> Для интерфейсов классов, когда нужна перегрузка, в ООП контексте.</p><p><strong>Property function:</strong> Для чистых функций, callbacks, когда важна явная сигнатура.</p><h4>Опциональные методы:</h4><p><strong>Знак вопроса:</strong> <code>interface Logger { debug?(message: string): void }</code> — метод может отсутствовать.</p><p><em>Consistency:</em> Выберите один стиль и придерживайтесь его в проекте.</p>",
    difficulty: 'middle',
    tags: ['методы', 'interface', 'функции', 'синтаксис']
  },
  {
    id: 44,
    question: "Что такое hybrid types и как создавать интерфейсы для них?",
    answer: "<p>Hybrid types — это объекты, которые <strong>одновременно функции и имеют свойства</strong>:</p><h4>Концепция:</h4><p><strong>Callable + properties:</strong> Объект можно вызвать как функцию И он имеет свои методы/свойства.</p><p><strong>JavaScript реальность:</strong> jQuery, lodash — функции с дополнительными методами.</p><h4>Синтаксис в интерфейсах:</h4><p><strong>Call signature + properties:</strong></p><p><code>interface Counter {</code></p><p><code>  (start: number): string</code></p><p><code>  interval: number</code></p><p><code>  reset(): void</code></p><p><code>}</code></p><p>Объект Counter можно вызвать, и у него есть свойство interval и метод reset.</p><h4>Реализация:</h4><p><strong>Создание объекта:</strong> Функция с добавленными свойствами — <code>const counter = ((start) =&gt; '') as Counter; counter.interval = 1000;</code></p><p><strong>Проблема типизации:</strong> Нужны type assertions для создания таких объектов.</p><h4>Примеры из реальности:</h4><p><strong>jQuery:</strong> <code>$</code> — функция с огромным количеством методов.</p><p><strong>Express middleware:</strong> Функции с дополнительными свойствами конфигурации.</p><h4>Современная альтернатива:</h4><p><strong>Объект с методом call:</strong> Обычный объект с явным методом вместо callable — проще и понятнее.</p><p><em>Применение:</em> Используется редко, в основном при типизации legacy библиотек.</p>",
    difficulty: 'senior',
    tags: ['hybrid types', 'callable objects', 'interface', 'продвинутые типы']
  },
  {
    id: 45,
    question: "Как правильно типизировать this в методах интерфейсов?",
    answer: "<p>TypeScript позволяет <strong>явно типизировать this</strong> для методов:</p><h4>This параметр:</h4><p><strong>Явный this:</strong> <code>interface Chainable { setValue(this: Chainable, value: string): this }</code></p><p><strong>Первый параметр:</strong> <code>this</code> указывается первым, но не считается реальным параметром функции.</p><h4>Return this для chaining:</h4><p><strong>Fluent interface:</strong> Методы возвращают <code>this</code> для цепочки вызовов — <code>obj.setValue('a').setValue('b')</code></p><p><strong>Полиморфный this:</strong> <code>this</code> как возвращаемый тип правильно работает с наследованием.</p><h4>ThisType utility:</h4><p><strong>Контекст для объектов:</strong> <code>type ObjectDescriptor&lt;D&gt; = { [key: string]: Function } & ThisType&lt;D&gt;</code></p><p><strong>Использование:</strong> Устанавливает тип <code>this</code> для всех методов объекта.</p><h4>Проблемы с this:</h4><p><strong>Arrow functions:</strong> Не имеют своего <code>this</code> — могут вызвать проблемы в классах.</p><p><strong>Bind потеря типа:</strong> <code>.bind()</code> может потерять правильный тип this.</p><h4>Практическое применение:</h4><p><strong>Builder pattern:</strong> Методы возвращают this для построения объекта цепочкой.</p><p><strong>Миксины и композиция:</strong> Правильная типизация this при комбинировании классов.</p><p><em>Важность:</em> Правильный this критичен для type safety в ООП паттернах.</p>",
    difficulty: 'senior',
    tags: ['this', 'методы', 'interface', 'контекст', 'типизация']
  },
  {
    id: 46,
    question: "Что такое type narrowing (сужение типов) в TypeScript и зачем оно нужно?",
    answer: "<p>Type narrowing — это процесс <strong>уточнения типа</strong> из более широкого к более конкретному:</p><h4>Суть механизма:</h4><p><strong>От общего к частному:</strong> TypeScript анализирует код и понимает, что внутри определенной ветки тип более специфичен.</p><p><strong>Control flow analysis:</strong> Компилятор отслеживает поток выполнения и сужает типы на основе проверок.</p><h4>Зачем это нужно:</h4><p><strong>Работа с union types:</strong> Когда переменная может быть <code>string | number</code>, нужно сузить до конкретного типа для безопасных операций.</p><p><strong>Устранение неопределенности:</strong> После проверки <code>if (x !== null)</code> TypeScript знает, что в этой ветке x точно не null.</p><h4>Базовый пример:</h4><p><strong>Проверка typeof:</strong> <code>if (typeof value === 'string')</code> — внутри блока TypeScript знает, что value это string.</p><p><strong>Автоматическое сужение:</strong> Не нужны type assertions, компилятор сам понимает.</p><h4>Преимущества:</h4><p><strong>Type safety без избыточности:</strong> Пишем естественные проверки, получаем строгую типизацию.</p><p><strong>Меньше ошибок:</strong> Компилятор предотвращает вызов методов на неправильных типах.</p><p><em>Философия:</em> TypeScript понимает JavaScript идиомы и делает их type-safe.</p>",
    difficulty: 'junior',
    tags: ['type narrowing', 'сужение типов', 'основы', 'union types']
  },
  {
    id: 47,
    question: "Как работает сужение типов через typeof и каковы его ограничения?",
    answer: "<p>Typeof — это <strong>базовый type guard</strong> для примитивных типов:</p><h4>Принцип работы:</h4><p><strong>Проверка примитива:</strong> <code>if (typeof value === 'string')</code> — TypeScript понимает, что внутри value строго string.</p><p><strong>Поддерживаемые типы:</strong> 'string', 'number', 'boolean', 'symbol', 'undefined', 'object', 'function', 'bigint'.</p><h4>Ограничения typeof:</h4><p><strong>Проблема с null:</strong> <code>typeof null === 'object'</code> — историческая особенность JavaScript, требует дополнительной проверки.</p><p><strong>Все объекты одинаковы:</strong> <code>typeof [] === 'object'</code>, <code>typeof {} === 'object'</code> — не различает конкретные типы объектов.</p><p><strong>Классы как функции:</strong> <code>typeof MyClass === 'function'</code> — не подходит для проверки экземпляров.</p><h4>Практические паттерны:</h4><p><strong>Защита от null:</strong> <code>if (value !== null && typeof value === 'object')</code> — правильная проверка объекта.</p><p><strong>Проверка функций:</strong> <code>typeof callback === 'function'</code> — безопасный вызов колбэков.</p><h4>Когда использовать:</h4><p>Идеально для <strong>примитивных типов</strong>, для объектов нужны другие guards.</p><p><em>Совет:</em> Typeof отлично работает с union примитивов — <code>string | number | boolean</code></p>",
    difficulty: 'junior',
    tags: ['typeof', 'type guard', 'сужение типов', 'примитивы']
  },
  {
    id: 48,
    question: "Чем instanceof отличается от typeof и когда его использовать?",
    answer: "<p>Instanceof проверяет <strong>принадлежность к классу</strong>, в отличие от typeof:</p><h4>Механизм работы:</h4><p><strong>Проверка прототипа:</strong> <code>value instanceof Date</code> — проверяет, есть ли Date в цепочке прототипов.</p><p><strong>Для классов и конструкторов:</strong> Работает с классами, встроенными конструкторами (Date, Array, Error).</p><h4>Отличия от typeof:</h4><p><strong>Конкретные типы:</strong> Instanceof различает <code>Array</code> от обычного <code>Object</code>, чего typeof не умеет.</p><p><strong>Иерархия классов:</strong> <code>admin instanceof User</code> — работает с наследованием.</p><p><strong>Runtime проверка:</strong> Instanceof смотрит на реальный объект, а typeof на примитивный тип.</p><h4>Ограничения:</h4><p><strong>Не работает с интерфейсами:</strong> TypeScript интерфейсы существуют только на этапе компиляции.</p><p><strong>Проблемы с разными realms:</strong> iframe или разные контексты выполнения могут ломать instanceof.</p><p><strong>Примитивы:</strong> <code>'text' instanceof String === false</code> — не работает с литералами примитивов.</p><h4>Применение:</h4><p><strong>Обработка ошибок:</strong> <code>if (error instanceof ApiError)</code> — различение типов ошибок.</p><p><strong>Полиморфизм:</strong> Проверка конкретного класса в иерархии.</p><p><em>Правило:</em> Typeof для примитивов, instanceof для объектов и классов.</p>",
    difficulty: 'middle',
    tags: ['instanceof', 'type guard', 'классы', 'сужение типов']
  },
  {
    id: 49,
    question: "Как работает оператор in для сужения типов и какие у него особенности?",
    answer: "<p>Оператор in проверяет <strong>наличие свойства</strong> в объекте:</p><h4>Базовое использование:</h4><p><strong>Проверка свойства:</strong> <code>if ('message' in error)</code> — TypeScript понимает, что внутри error имеет свойство message.</p><p><strong>Работа с объектами:</strong> Проверяет как собственные, так и унаследованные свойства.</p><h4>Discriminated unions:</h4><p><strong>Различение типов:</strong> <code>if ('success' in response)</code> — различает Success от Error response по наличию поля.</p><p><strong>Эффективный паттерн:</strong> Добавление discriminator поля специально для различения union типов.</p><h4>Особенности:</h4><p><strong>Проверяет всю цепочку:</strong> In смотрит не только на собственные свойства, но и прототип.</p><p><strong>Runtime проверка:</strong> Реально проверяет объект, не только типы.</p><p><strong>Опциональные свойства:</strong> <code>in</code> отличает отсутствие свойства от <code>undefined</code> значения.</p><h4>Проблемы:</h4><p><strong>Ложные срабатывания:</strong> Если свойство есть в прототипе случайно, проверка пройдет.</p><p><strong>Строковые ключи:</strong> Нужно следить за опечатками — <code>'mesage' in error</code> не выдаст ошибку компиляции.</p><h4>Применение:</h4><p><strong>API responses:</strong> Различение типов ответов от сервера.</p><p><strong>Type guards:</strong> Создание функций проверки типов.</p><p><em>Совет:</em> Комбинируйте с literal types для надежных discriminated unions.</p>",
    difficulty: 'middle',
    tags: ['in operator', 'type guard', 'свойства', 'discriminated unions']
  },
  {
    id: 50,
    question: "Что такое user-defined type guards и как их создавать?",
    answer: "<p>User-defined type guards — это <strong>функции с type predicate</strong>, которые выполняют кастомную проверку:</p><h4>Синтаксис type predicate:</h4><p><strong>Возвращаемый тип:</strong> <code>function isString(value: unknown): value is string</code></p><p><strong>value is Type:</strong> Специальный синтаксис, сообщающий TypeScript о сужении типа.</p><h4>Создание type guard:</h4><p><strong>Реализация проверки:</strong> Внутри функции выполняем runtime проверки — typeof, instanceof, проверку свойств.</p><p><strong>Boolean недостаточно:</strong> Просто <code>return typeof value === 'string'</code> с типом boolean не сужает тип.</p><h4>Сложные проверки:</h4><p><strong>Множественные условия:</strong> Можем комбинировать проверки для сложных типов — наличие свойств, их типы, структура.</p><p><strong>Валидация структуры:</strong> <code>function isUser(obj: any): obj is User { return obj && typeof obj.name === 'string' && typeof obj.age === 'number' }</code></p><h4>Применение:</h4><p><strong>API responses:</strong> Проверка данных от сервера перед использованием.</p><p><strong>Union types:</strong> Различение вариантов в сложных union.</p><p><strong>Unknown типы:</strong> Безопасная работа с неизвестными данными.</p><h4>Важные моменты:</h4><p><strong>Честная реализация:</strong> Функция должна действительно проверять тип — лживый type guard приведет к runtime ошибкам.</p><p><em>Мощь:</em> Type guards делают динамические проверки type-safe.</p>",
    difficulty: 'middle',
    tags: ['type guards', 'type predicate', 'пользовательские проверки', 'сужение типов']
  },
  {
    id: 51,
    question: "Как работают discriminated unions и почему они важны для сужения типов?",
    answer: "<p>Discriminated unions используют <strong>литеральное поле для различения</strong> вариантов:</p><h4>Структура паттерна:</h4><p><strong>Общее поле-discriminator:</strong> Все варианты union имеют одно поле с литеральным типом — обычно <code>type</code> или <code>kind</code>.</p><p><strong>Уникальные значения:</strong> Каждый вариант имеет свое уникальное значение discriminator'а.</p><h4>Пример:</h4><p><code>type Success = { type: 'success'; data: User }</code></p><p><code>type Error = { type: 'error'; message: string }</code></p><p><code>type Result = Success | Error</code></p><p>Проверка <code>if (result.type === 'success')</code> автоматически сужает тип до Success.</p><h4>Преимущества:</h4><p><strong>Exhaustiveness checking:</strong> TypeScript может проверить, что обработаны все варианты — забыли case, получите ошибку.</p><p><strong>Автоматическое сужение:</strong> Не нужны сложные type guards, простая проверка discriminator'а.</p><p><strong>Читаемость:</strong> Явная структура данных, понятно какие варианты существуют.</p><h4>Применение:</h4><p><strong>State machines:</strong> Разные состояния приложения с разными данными.</p><p><strong>API responses:</strong> Success/Error результаты с разной структурой.</p><p><strong>Redux actions:</strong> Действия с type полем и разными payloads.</p><p><em>Best practice:</em> Используйте discriminated unions вместо опциональных полей для различных вариантов.</p>",
    difficulty: 'middle',
    tags: ['discriminated unions', 'type narrowing', 'паттерны', 'union types']
  },
  {
    id: 52,
    question: "Что такое equality narrowing и как TypeScript использует проверки на равенство?",
    answer: "<p>Equality narrowing — это сужение типов через <strong>проверки на равенство</strong>:</p><h4>Принцип работы:</h4><p><strong>Сравнение с известным типом:</strong> <code>if (x === y)</code> — если y имеет конкретный тип, TypeScript понимает, что x тоже этого типа.</p><p><strong>Strict и loose equality:</strong> TypeScript анализирует как <code>===</code>, так и <code>==</code>, но строгое равенство предпочтительнее.</p><h4>Проверка на null/undefined:</h4><p><strong>Отсечение null:</strong> <code>if (value !== null)</code> — сужает тип, исключая null.</p><p><strong>Truthiness недостаточно:</strong> <code>if (value)</code> сужает меньше, чем явная проверка — могут остаться falsy значения.</p><h4>Сравнение с литералами:</h4><p><strong>Discriminator проверка:</strong> <code>if (action.type === 'ADD')</code> — сужает до конкретного варианта union.</p><p><strong>Enum значения:</strong> Сравнение с enum тоже сужает тип.</p><h4>Двустороннее сужение:</h4><p><strong>Обе переменные:</strong> <code>if (a === b)</code> сужает типы обеих переменных на основе друг друга.</p><h4>Особенности:</h4><p><strong>Control flow aware:</strong> Работает с else ветками — в else тип исключает проверенное значение.</p><p><strong>Switch statements:</strong> Case проверки также сужают типы.</p><p><em>Практика:</em> Используйте строгие проверки (<code>===</code>, <code>!==</code>) для надежного сужения.</p>",
    difficulty: 'middle',
    tags: ['equality narrowing', 'сравнение', 'сужение типов', 'control flow']
  },
  {
    id: 53,
    question: "Как работает truthiness narrowing и каковы его подводные камни?",
    answer: "<p>Truthiness narrowing основан на <strong>JavaScript правилах приведения к boolean</strong>:</p><h4>Механизм:</h4><p><strong>Проверка в условии:</strong> <code>if (value)</code> — TypeScript понимает, что внутри value не является falsy.</p><p><strong>Исключает null и undefined:</strong> После проверки тип сужается, убирая эти значения.</p><h4>Falsy значения в JavaScript:</h4><p><strong>Полный список:</strong> <code>false</code>, <code>0</code>, <code>-0</code>, <code>0n</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code></p><p><strong>Проблема с числами:</strong> <code>if (count)</code> не сработает для 0, хотя это валидное число.</p><h4>Подводные камни:</h4><p><strong>Пустая строка:</strong> <code>''</code> это валидная строка, но falsy — проверка <code>if (str)</code> отфильтрует ее.</p><p><strong>Boolean vs nullable:</strong> <code>if (flag)</code> где flag: boolean | undefined плохо — не отличить false от undefined.</p><p><strong>Числовой 0:</strong> Частая ошибка при работе с числами — 0 это валидное значение.</p><h4>Правильные альтернативы:</h4><p><strong>Явные проверки:</strong> <code>if (value !== null && value !== undefined)</code> — точно и понятно.</p><p><strong>Оператор ??:</strong> <code>value ?? defaultValue</code> — только для null/undefined, не для других falsy.</p><p><em>Совет:</em> Избегайте truthiness для чисел и строк, используйте явные проверки.</p>",
    difficulty: 'middle',
    tags: ['truthiness', 'сужение типов', 'falsy values', 'подводные камни']
  },
  {
    id: 54,
    question: "Что такое control flow analysis и как TypeScript отслеживает типы?",
    answer: "<p>Control flow analysis — это <strong>анализ потока выполнения</strong> для отслеживания типов:</p><h4>Основной принцип:</h4><p><strong>Отслеживание путей:</strong> TypeScript анализирует все возможные пути выполнения кода и знает тип переменной в каждой точке.</p><p><strong>Ветвление и объединение:</strong> После if-else потоки объединяются, тип становится union возможных вариантов.</p><h4>Примеры анализа:</h4><p><strong>If-else branches:</strong> В каждой ветке свой суженный тип, после ветвления — union.</p><p><strong>Return/throw:</strong> Если ветка завершается, следующий код знает, что проверка не прошла.</p><p><strong>While/for loops:</strong> Типы могут меняться внутри циклов на основе условий.</p><h4>Усложненные случаи:</h4><p><strong>Вложенные условия:</strong> TypeScript отслеживает сложные комбинации проверок.</p><p><strong>Assignments:</strong> Присваивание нового значения меняет тип переменной в этой точке.</p><h4>Ограничения:</h4><p><strong>Функции:</strong> TypeScript не анализирует код внутри вызываемых функций — только их сигнатуру.</p><p><strong>Сложная логика:</strong> Очень запутанный control flow может не анализироваться корректно.</p><p><strong>Мутации:</strong> Изменения через ссылки могут не отслеживаться.</p><h4>Практическое значение:</h4><p><strong>Естественный код:</strong> Пишем обычные проверки, получаем type safety автоматически.</p><p><em>Мощь:</em> Control flow analysis делает TypeScript умным без явных аннотаций.</p>",
    difficulty: 'senior',
    tags: ['control flow analysis', 'анализ кода', 'сужение типов', 'компилятор']
  },
  {
    id: 55,
    question: "Как работают assertion functions (asserts) для сужения типов?",
    answer: "<p>Assertion functions используют <strong>asserts keyword</strong> для гарантий о типе:</p><h4>Синтаксис asserts:</h4><p><strong>Asserts condition:</strong> <code>function assert(condition: any): asserts condition</code></p><p><strong>Asserts type predicate:</strong> <code>function assertIsString(value: unknown): asserts value is string</code></p><h4>Отличие от type guards:</h4><p><strong>Throw вместо return:</strong> Assertion функция выбрасывает ошибку, если проверка не прошла, а не возвращает boolean.</p><p><strong>Сужение в caller scope:</strong> После вызова assertion функции тип сужается в вызывающем коде.</p><h4>Применение:</h4><p><strong>Защита от null:</strong> <code>assertDefined(user)</code> — после этого user точно не null/undefined.</p><p><strong>Валидация:</strong> <code>assertIsValidConfig(config)</code> — гарантия структуры данных.</p><p><strong>Type refinement:</strong> Сужение типа без if-блоков, линейный код.</p><h4>Пример реализации:</h4><p><code>function assertIsString(value: unknown): asserts value is string {</code></p><p><code>  if (typeof value !== 'string') throw new Error('Not a string')</code></p><p><code>}</code></p><h4>Когда использовать:</h4><p><strong>Невозможные случаи:</strong> Когда значение должно быть определенного типа по логике, иначе это баг.</p><p><strong>Ранняя валидация:</strong> Проверка входных данных в начале функции.</p><p><em>Осторожность:</em> Asserts выбрасывает ошибки — используйте для действительно критичных проверок.</p>",
    difficulty: 'senior',
    tags: ['assertion functions', 'asserts', 'сужение типов', 'валидация']
  },
  {
    id: 56,
    question: "Какие проблемы возникают при сужении типов в асинхронном коде?",
    answer: "<p>Асинхронный код создает <strong>сложности для сужения типов</strong>:</p><h4>Потеря контекста:</h4><p><strong>Callbacks и promises:</strong> Внутри callback/then тип переменной может измениться во внешнем scope.</p><p><strong>Race conditions:</strong> TypeScript не отслеживает, что значение могло измениться между проверкой и использованием.</p><h4>Пример проблемы:</h4><p><code>if (user) {</code></p><p><code>  await delay(1000)</code></p><p><code>  console.log(user.name) // user может стать null!</code></p><p><code>}</code></p><p>TypeScript не знает, что user могла быть изменена в другом потоке.</p><h4>Решения:</h4><p><strong>Локальная копия:</strong> <code>const localUser = user</code> — захватываем значение перед async операцией.</p><p><strong>Проверка после await:</strong> Повторная проверка типа после асинхронных операций.</p><p><strong>Optional chaining:</strong> <code>user?.name</code> — безопасный доступ без предварительной проверки.</p><h4>Проблемы с Promise:</h4><p><strong>Тип внутри then:</strong> Сужение типа до then не работает внутри callback.</p><p><strong>Error handling:</strong> В catch блоке тип error всегда unknown, несмотря на проверки выше.</p><h4>Best practices:</h4><p><strong>Изолируйте проверки:</strong> Делайте type guards внутри async функций, а не перед вызовом.</p><p><em>Важно:</em> Помните, что async разрывает control flow для type narrowing.</p>",
    difficulty: 'senior',
    tags: ['async', 'сужение типов', 'проблемы', 'promises', 'race conditions']
  },
  {
    id: 57,
    question: "Как TypeScript обрабатывает never type в контексте сужения типов?",
    answer: "<p>Never type представляет <strong>невозможные или исчерпанные</strong> варианты:</p><h4>Появление never:</h4><p><strong>Exhaustive checking:</strong> Когда все варианты union обработаны, остается never.</p><p><strong>Противоречивые условия:</strong> <code>if (typeof x === 'string' && typeof x === 'number')</code> — тип внутри never.</p><h4>Проверка полноты обработки:</h4><p><strong>Switch exhaustiveness:</strong></p><p><code>switch (action.type) {</code></p><p><code>  case 'add': ...</code></p><p><code>  case 'remove': ...</code></p><p><code>  default: const _exhaustive: never = action // ошибка если забыли case</code></p><p><code>}</code></p><h4>Never в условиях:</h4><p><strong>Недостижимый код:</strong> После проверок, исключающих все варианты, тип становится never.</p><p><strong>Type guards цепочка:</strong> Последовательные проверки сужают union до never, если все варианты отсечены.</p><h4>Практическое применение:</h4><p><strong>Asserting exhaustiveness:</strong> Гарантия, что обработали все варианты discriminated union.</p><p><strong>Защита от рефакторинга:</strong> При добавлении нового варианта в union, код с never проверкой выдаст ошибку.</p><h4>Функции с never:</h4><p><strong>Не возвращают управление:</strong> <code>function fail(msg: string): never { throw new Error(msg) }</code></p><p><code>После вызова fail() TypeScript знает, что код дальше не выполняется.</code></p><p><em>Мощь:</em> Never помогает компилятору находить логические ошибки в обработке вариантов.</p>",
    difficulty: 'senior',
    tags: ['never', 'exhaustive checking', 'сужение типов', 'union types']
  },
  {
    id: 58,
    question: "Какие паттерны помогают эффективно сужать типы в сложных сценариях?",
    answer: "<p>Существуют <strong>проверенные паттерны</strong> для эффективного сужения:</p><h4>Early return pattern:</h4><p><strong>Ранний выход:</strong> Проверяем негативные случаи первыми и выходим — остальной код работает с суженным типом.</p><p><code>if (!user) return</code></p><p><code>// дальше user точно определен</code></p><h4>Exhaustive type guards:</h4><p><strong>Функции для каждого варианта:</strong> Создаем отдельные type guard для каждого типа в union.</p><p><strong>Композиция проверок:</strong> Комбинируем простые guards для сложных типов.</p><h4>Tagged unions pattern:</h4><p><strong>Добавление type поля:</strong> Явный discriminator делает сужение тривиальным.</p><p><strong>Enum для тегов:</strong> Использование enum вместо строк для type safety.</p><h4>Type predicate utilities:</h4><p><strong>Библиотека guards:</strong> Набор переиспользуемых type guard функций.</p><p><strong>Generic guards:</strong> <code>function isArrayOf&lt;T&gt;(guard: (x: any) => x is T): (arr: any) => arr is T[]</code></p><h4>Комбинация операторов:</h4><p><strong>Несколько проверок:</strong> <code>if (x && typeof x === 'object' && 'name' in x)</code> — последовательное сужение.</p><p><strong>Boolean narrowing:</strong> Использование && и || для сужения в одном выражении.</p><h4>Const assertions:</h4><p><strong>as const:</strong> Сужает литералы до конкретных значений вместо wide types.</p><p><em>Совет:</em> Выбирайте паттерны, которые делают намерения кода очевидными.</p>",
    difficulty: 'senior',
    tags: ['паттерны', 'сужение типов', 'best practices', 'type guards']
  },
  {
    id: 59,
    question: "Как работает сужение типов в switch statements и есть ли особенности?",
    answer: "<p>Switch statements предоставляют <strong>мощное сужение типов</strong> через case проверки:</p><h4>Базовое сужение:</h4><p><strong>Case по discriminator:</strong> <code>switch (result.type)</code> — каждый case сужает тип до соответствующего варианта union.</p><p><strong>Fall-through:</strong> TypeScript отслеживает, когда case проваливается в следующий без break.</p><h4>Exhaustiveness checking:</h4><p><strong>Default с never:</strong> <code>default: const _exhaustive: never = result</code> — проверка, что обработали все варианты.</p><p><strong>Ошибка при новых вариантах:</strong> Добавление нового типа в union вызовет ошибку в default.</p><h4>Особенности:</h4><p><strong>String/number literals:</strong> Switch отлично работает с literal union types.</p><p><strong>Множественные case:</strong> <code>case 'a': case 'b':</code> — TypeScript понимает union этих вариантов.</p><p><strong>Expression в case:</strong> Можно использовать сложные выражения, но сужение работает хуже.</p><h4>Проблемы:</h4><p><strong>Type widening:</strong> Без const assertions литералы могут расшириться до string/number.</p><p><strong>Object comparison:</strong> Switch использует ===, не подходит для сравнения объектов.</p><h4>Альтернатива switch:</h4><p><strong>Object mapping:</strong> <code>const handlers = { 'type1': () =&gt; ..., 'type2': () =&gt; ... }</code> — но теряем exhaustiveness checking.</p><p><em>Рекомендация:</em> Switch идеален для discriminated unions с string/number discriminator.</p>",
    difficulty: 'middle',
    tags: ['switch', 'сужение типов', 'discriminated unions', 'exhaustiveness']
  },
  {
    id: 60,
    question: "Почему TypeScript иногда не сужает типы и как это исправить?",
    answer: "<p>TypeScript имеет <strong>ограничения в анализе</strong>, которые мешают сужению:</p><h4>Частые причины:</h4><p><strong>Мутации через ссылки:</strong> TypeScript не отслеживает изменения объекта через другие ссылки.</p><p><strong>Callback scope:</strong> Внутри callbacks сужение из внешнего scope не работает.</p><p><strong>Сложная логика:</strong> Запутанные условия могут быть слишком сложны для анализа.</p><h4>Проблема с this:</h4><p><strong>Потеря контекста:</strong> <code>this</code> в методах может меняться, TypeScript не отслеживает.</p><p><strong>Arrow functions vs methods:</strong> Разное поведение this влияет на сужение.</p><h4>Array методы:</h4><p><strong>Filter не сужает:</strong> <code>array.filter(x =&gt; x !== null)</code> не убирает null из типа массива.</p><p><strong>Type predicate нужен:</strong> <code>array.filter((x): x is NonNull =&gt; x !== null)</code> — явный type guard.</p><h4>Решения:</h4><p><strong>Локальные переменные:</strong> Копируйте значение в local const перед проверками.</p><p><strong>Type assertions:</strong> Явно указывайте тип, если уверены — <code>value as SpecificType</code>.</p><p><strong>User-defined guards:</strong> Создавайте функции с type predicate для сложных проверок.</p><p><strong>Non-null assertion:</strong> <code>value!</code> — говорит, что значение точно не null, но опасно.</p><h4>Настройки компилятора:</h4><p><strong>strictNullChecks:</strong> Должен быть включен для правильной работы сужения.</p><p><em>Отладка:</em> Hover над переменной в IDE показывает, как TypeScript видит тип в этой точке.</p>",
    difficulty: 'senior',
    tags: ['проблемы', 'сужение типов', 'ограничения', 'решения', 'debugging']
  }
];
