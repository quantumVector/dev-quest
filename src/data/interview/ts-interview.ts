export interface TSQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const tsInterviewQuestions: TSQuestion[] = [
  {
    id: 1,
    question: "Какие основные преимущества TypeScript перед JavaScript вы можете назвать?",
    answer: "<p>TypeScript предоставляет несколько <strong>ключевых преимуществ</strong> по сравнению с обычным JavaScript:</p><h4>Статическая типизация:</h4><p><strong>Раннее обнаружение ошибок</strong> — большинство ошибок выявляются на этапе разработки, а не в production. Это особенно критично для крупных проектов.</p><h4>Улучшенная поддержка IDE:</h4><p><strong>Автодополнение и IntelliSense</strong> работают на порядок лучше благодаря информации о типах. Рефакторинг становится безопаснее и быстрее.</p><h4>Документация кода:</h4><p>Типы служат <strong>встроенной документацией</strong> — не нужно гадать, какие параметры принимает функция и что она возвращает.</p><h4>Масштабируемость:</h4><p>TypeScript делает код <strong>более предсказуемым</strong> в больших командах и проектах. Легче понимать код, написанный другими разработчиками.</p><h4>Современный JavaScript:</h4><p>Возможность использовать <strong>новейшие возможности JS</strong> с компиляцией в старые версии для совместимости.</p><p><em>Результат:</em> Меньше багов, быстрая разработка, лучшая поддержка кода.</p>",
    difficulty: 'junior',
    tags: ['преимущества', 'TypeScript', 'основы']
  },
  {
    id: 2,
    question: "Какие недостатки или сложности использования TypeScript вы можете выделить?",
    answer: "<p>При всех преимуществах, TypeScript имеет ряд <strong>недостатков и сложностей</strong>:</p><h4>Порог входа:</h4><p><strong>Кривая обучения</strong> — разработчикам нужно изучить систему типов, дженерики, advanced типы. Это требует времени.</p><h4>Время компиляции:</h4><p><strong>Дополнительный шаг сборки</strong> — код нужно компилировать перед запуском, что замедляет разработку больших проектов.</p><h4>Overhead для небольших проектов:</h4><p>Для <strong>маленьких скриптов или прототипов</strong> TypeScript может быть избыточным — больше времени на настройку, чем на реальную разработку.</p><h4>Ложное чувство безопасности:</h4><p>TypeScript проверяет типы только <strong>на этапе компиляции</strong> — runtime ошибки все еще возможны, особенно при работе с внешними API.</p><h4>Сложность типизации:</h4><p><strong>Типизация сложных библиотек</strong> может быть трудной. Иногда проще написать <code>any</code>, что сводит на нет преимущества TypeScript.</p><h4>Размер экосистемы:</h4><p>Не все библиотеки имеют <strong>качественные типы</strong> — приходится писать свои или использовать @types пакеты.</p>",
    difficulty: 'junior',
    tags: ['недостатки', 'TypeScript', 'сложности']
  },
  {
    id: 3,
    question: "Как TypeScript влияет на производительность разработки?",
    answer: "<p>Влияние TypeScript на производительность разработки <strong>неоднозначно</strong> и зависит от контекста:</p><h4>Замедление на старте:</h4><p><strong>Начальная настройка</strong> требует времени — конфигурация tsconfig, настройка путей, установка типов для библиотек.</p><p><strong>Написание типов</strong> замедляет первоначальную разработку — нужно явно описывать интерфейсы, типы параметров.</p><h4>Ускорение в долгосрочной перспективе:</h4><p><strong>Меньше времени на отладку</strong> — большинство ошибок ловятся до запуска приложения.</p><p><strong>Безопасный рефакторинг</strong> — изменения в коде сразу показывают, что сломалось. Не нужно искать все места использования вручную.</p><p><strong>Быстрая навигация</strong> — IDE мгновенно показывает определения, использования, сигнатуры функций.</p><h4>Факторы влияния:</h4><p><strong>Размер команды:</strong> В больших командах TypeScript ускоряет разработку значительно.</p><p><strong>Размер проекта:</strong> Для pet-проектов может быть overhead, для enterprise — необходимость.</p><p><em>Вывод:</em> Краткосрочно замедляет, долгосрочно ускоряет разработку.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'разработка', 'эффективность']
  },
  {
    id: 4,
    question: "В каких случаях использование TypeScript оправдано, а в каких — нет?",
    answer: "<p>Выбор TypeScript должен основываться на <strong>контексте проекта</strong>:</p><h4>TypeScript оправдан:</h4><p><strong>Крупные проекты:</strong> Где работает несколько разработчиков и кодовая база большая — типизация критична.</p><p><strong>Long-term проекты:</strong> Которые будут поддерживаться годами — типы служат документацией.</p><p><strong>Библиотеки и SDK:</strong> Публичные API выигрывают от типизации — пользователи получают автодополнение.</p><p><strong>Backend на Node.js:</strong> Где нет браузерной проверки и ошибки дороже.</p><p><strong>Работа с данными:</strong> Сложные data structures, API интеграции — типы предотвращают ошибки.</p><h4>TypeScript избыточен:</h4><p><strong>Прототипы и MVP:</strong> Когда важна скорость валидации идеи.</p><p><strong>Маленькие скрипты:</strong> Утилиты, однократные задачи — overhead не окупается.</p><p><strong>Простые landing pages:</strong> Минимум логики, много верстки.</p><p><strong>Команда не готова:</strong> Если разработчики не знают TypeScript — внедрение замедлит работу.</p><p><em>Золотое правило:</em> Если проект проживет дольше месяца и в нем больше 1000 строк — TypeScript оправдан.</p>",
    difficulty: 'middle',
    tags: ['применение', 'выбор технологии', 'контекст']
  },
  {
    id: 5,
    question: "Как TypeScript помогает в рефакторинге кода?",
    answer: "<p>TypeScript делает рефакторинг <strong>значительно безопаснее и быстрее</strong>:</p><h4>Автоматическое обнаружение проблем:</h4><p>При изменении сигнатуры функции или интерфейса TypeScript <strong>сразу показывает все места</strong>, где код сломался. Не нужно гадать или искать вручную.</p><h4>Уверенный rename:</h4><p><strong>Переименование переменных и функций</strong> работает безопасно — IDE находит все использования благодаря типам.</p><h4>Изменение структур данных:</h4><p>Если изменить интерфейс, компилятор <strong>укажет все места</strong>, где нужно обновить код для соответствия новой структуре.</p><h4>Удаление мертвого кода:</h4><p>TypeScript помогает найти <strong>неиспользуемый код</strong> — если функция нигде не вызывается, это видно по отсутствию ссылок.</p><h4>Безопасные эксперименты:</h4><p>Можно смело экспериментировать с архитектурой — <strong>типы сразу покажут</strong>, что сломалось и где нужны изменения.</p><p><em>Реальный пример:</em> Изменение API endpoint с 5 параметрами на объект с опциями — TypeScript покажет все 50+ вызовов, которые нужно обновить.</p>",
    difficulty: 'middle',
    tags: ['рефакторинг', 'поддержка кода', 'безопасность']
  },
  {
    id: 6,
    question: "Какие проблемы могут возникнуть при миграции JavaScript проекта на TypeScript?",
    answer: "<p>Миграция на TypeScript может встретить <strong>ряд серьезных вызовов</strong>:</p><h4>Технические сложности:</h4><p><strong>Legacy код:</strong> Старый JavaScript код может использовать паттерны, которые сложно типизировать — динамические свойства, monkey patching.</p><p><strong>Отсутствие типов для библиотек:</strong> Старые или малоизвестные библиотеки могут не иметь @types пакетов.</p><p><strong>Build процесс:</strong> Нужно настроить компиляцию, sourcemaps, интеграцию с существующими инструментами сборки.</p><h4>Временные затраты:</h4><p><strong>Постепенная миграция:</strong> Нельзя мигрировать все сразу — нужна стратегия постепенного перехода файл за файлом.</p><p><strong>Обучение команды:</strong> Разработчики должны изучить TypeScript, что отнимает время от основной работы.</p><h4>Организационные проблемы:</h4><p><strong>Сопротивление команды:</strong> Не все хотят менять привычный workflow.</p><p><strong>Снижение velocity:</strong> Первое время команда будет работать медленнее.</p><p><em>Решение:</em> Начинать с новых файлов, постепенно мигрировать критичные части, использовать <code>allowJs</code> для плавного перехода.</p>",
    difficulty: 'middle',
    tags: ['миграция', 'TypeScript', 'проблемы', 'переход']
  },
  {
    id: 7,
    question: "Как TypeScript влияет на размер финального бандла?",
    answer: "<p>Влияние TypeScript на размер бандла <strong>минимально или отсутствует</strong>:</p><h4>TypeScript компилируется в JavaScript:</h4><p>Типы существуют только <strong>на этапе разработки</strong> и полностью удаляются при компиляции. В production попадает чистый JavaScript.</p><h4>Потенциальное увеличение:</h4><p><strong>Polyfills и helper функции:</strong> TypeScript может добавлять вспомогательный код для эмуляции новых возможностей в старых браузерах — decorators, async/await.</p><p><strong>Импорт типов:</strong> Если случайно импортировать не только типы, но и runtime код из type-only модулей.</p><h4>Оптимизация:</h4><p><strong>importHelpers:</strong> Использование tslib для переиспользования helper функций вместо дублирования в каждом файле.</p><p><strong>Type-only imports:</strong> Явное указание <code>import type</code> гарантирует, что импорт не попадет в бандл.</p><p><strong>Tree shaking:</strong> Работает одинаково хорошо с TypeScript и JavaScript при правильной настройке.</p><p><em>Вывод:</em> TypeScript сам по себе не увеличивает размер бандла — важнее настройки компиляции и bundler'а.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'бандл', 'оптимизация']
  },
  {
    id: 8,
    question: "Какие альтернативы TypeScript существуют и в чем их отличия?",
    answer: "<p>Существует несколько <strong>альтернативных подходов</strong> к типизации JavaScript:</p><h4>Flow:</h4><p><strong>Разработан Facebook</strong> — похож на TypeScript, но менее популярен. Основное отличие — более строгая система типов, но меньше community поддержки.</p><h4>JSDoc:</h4><p><strong>Типизация через комментарии</strong> — позволяет добавлять типы в обычный JavaScript без компиляции. Поддерживается в VS Code, но менее мощная, чем TypeScript.</p><h4>ReScript (ex ReasonML):</h4><p><strong>Функциональный язык</strong>, компилирующийся в JavaScript — более строгая система типов, но радикально отличается синтаксисом.</p><h4>Dart:</h4><p><strong>Альтернативный язык</strong> от Google — собственная экосистема, используется в Flutter, но не популярен для веб-разработки.</p><h4>Vanilla JavaScript + ESLint:</h4><p><strong>Без явной типизации</strong> — полагается на линтинг и тесты. Подходит для небольших проектов.</p><p><em>Позиция TypeScript:</em> Наиболее популярная и поддерживаемая альтернатива с огромной экосистемой, постепенным adoption и отличной интеграцией с существующим JS.</p>",
    difficulty: 'senior',
    tags: ['альтернативы', 'сравнение', 'Flow', 'JSDoc']
  },
  {
    id: 9,
    question: "Как TypeScript справляется с динамической природой JavaScript?",
    answer: "<p>TypeScript предлагает <strong>компромисс между безопасностью и гибкостью</strong>:</p><h4>Escape hatches:</h4><p><strong>Type any:</strong> Позволяет отключить проверку типов когда это необходимо — работа с legacy кодом, сложные динамические структуры.</p><p><strong>Type unknown:</strong> Более безопасная альтернатива any — требует явной проверки перед использованием.</p><p><strong>Type assertions:</strong> Возможность явно указать тип, когда разработчик знает больше компилятора.</p><h4>Advanced типы:</h4><p><strong>Union types:</strong> Тип может быть одним из нескольких вариантов — моделирует динамическое поведение безопасно.</p><p><strong>Type guards:</strong> Сужение типов через runtime проверки — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Conditional types:</strong> Типы, которые меняются в зависимости от условий — мощный инструмент для сложной логики.</p><h4>Проблемные области:</h4><p><strong>Prototype manipulation:</strong> Динамическое добавление свойств сложно типизировать.</p><p><strong>eval и dynamic code:</strong> Невозможно статически проверить.</p><p><em>Философия:</em> TypeScript не борется с динамичностью JS, а предоставляет инструменты для безопасной работы с ней.</p>",
    difficulty: 'senior',
    tags: ['типизация', 'динамичность', 'гибкость', 'advanced types']
  },
  {
    id: 10,
    question: "Какие проблемы с типизацией третьесторонних библиотек вы встречали?",
    answer: "<p>Работа с типами сторонних библиотек часто вызывает <strong>специфические проблемы</strong>:</p><h4>Отсутствие типов:</h4><p><strong>Старые библиотеки</strong> могут не иметь TypeScript поддержки вообще — приходится писать свои <code>.d.ts</code> файлы или использовать <code>any</code>.</p><h4>Неточные типы:</h4><p><strong>@types пакеты</strong> могут отставать от реальной библиотеки или содержать ошибки. Типы пишут энтузиасты, не авторы библиотеки.</p><h4>Конфликты версий:</h4><p><strong>Несоответствие версий</strong> между библиотекой и @types пакетом может приводить к неправильным типам.</p><h4>Слишком строгие типы:</h4><p>Некоторые библиотеки типизированы <strong>слишком строго</strong>, не позволяя делать валидные, но не предусмотренные автором вещи.</p><h4>Generic hell:</h4><p><strong>Сложная generic типизация</strong> в библиотеках типа RxJS или Redux может быть трудна для понимания и использования.</p><h4>Решения:</h4><p>Использование <strong>module augmentation</strong> для расширения типов, создание своих type wrappers, contributing в DefinitelyTyped.</p><p><em>Практика:</em> Важно проверять качество типов библиотеки перед использованием в проекте.</p>",
    difficulty: 'senior',
    tags: ['библиотеки', 'типизация', 'проблемы', '@types']
  },
  {
    id: 11,
    question: "Как TypeScript влияет на время сборки проекта?",
    answer: "<p>TypeScript может <strong>заметно влиять на время сборки</strong>, особенно в больших проектах:</p><h4>Факторы замедления:</h4><p><strong>Type checking:</strong> Проверка типов требует времени — чем сложнее типы и больше файлов, тем дольше компиляция.</p><p><strong>Incremental compilation:</strong> Первая сборка может быть очень долгой, последующие быстрее благодаря кэшированию.</p><p><strong>Сложные типы:</strong> Advanced types, глубокие generic типы, сложные conditional types замедляют компиляцию значительно.</p><h4>Оптимизация:</h4><p><strong>Project references:</strong> Разделение проекта на подпроекты ускоряет сборку через параллелизацию.</p><p><strong>skipLibCheck:</strong> Пропуск проверки типов в node_modules ускоряет компиляцию, но может скрыть ошибки.</p><p><strong>Isolatedmodules:</strong> Упрощает компиляцию, позволяя обрабатывать файлы независимо.</p><p><strong>Использование esbuild/swc:</strong> Альтернативные компиляторы быстрее tsc, но не проверяют типы.</p><h4>Практический подход:</h4><p>Использовать <strong>type checking отдельно от сборки</strong> в development — сборщик компилирует без проверки типов, а tsc проверяет в фоне.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'сборка', 'оптимизация', 'компиляция']
  },
  {
    id: 12,
    question: "Какие проблемы может создать чрезмерное использование типа any?",
    answer: "<p>Злоупотребление <code>any</code> <strong>нивелирует преимущества TypeScript</strong>:</p><h4>Потеря безопасности типов:</h4><p><strong>Ошибки не ловятся:</strong> Компилятор не может предупредить о проблемах — any отключает всю проверку типов для этого значения.</p><p><strong>Цепная реакция:</strong> Any <em>распространяется</em> — если функция принимает any, её возвращаемое значение тоже становится any.</p><h4>Ухудшение developer experience:</h4><p><strong>Нет автодополнения:</strong> IDE не может подсказать доступные свойства и методы.</p><p><strong>Сложный рефакторинг:</strong> При изменении кода с any невозможно найти все затронутые места.</p><h4>Ложная безопасность:</h4><p><strong>Иллюзия типизации:</strong> Проект формально на TypeScript, но фактически работает как JavaScript без проверок.</p><h4>Технический долг:</h4><p><strong>Откладывание проблем:</strong> Any — это часто временное решение, которое становится постоянным.</p><h4>Альтернативы:</h4><p>Использовать <strong>unknown</strong> вместо any, писать конкретные типы, использовать union types для динамических значений.</p><p><em>Правило:</em> Каждый any в коде должен иметь обоснование и план по замене на конкретный тип.</p>",
    difficulty: 'middle',
    tags: ['any', 'типы', 'безопасность', 'best practices']
  },
  {
    id: 13,
    question: "Как TypeScript помогает в работе с большими командами разработчиков?",
    answer: "<p>TypeScript особенно ценен в <strong>командной разработке</strong>:</p><h4>Единое понимание кода:</h4><p><strong>Типы как контракты:</strong> Интерфейсы и типы служат соглашением между разработчиками — явно определяют, что ожидается и что возвращается.</p><p><strong>Самодокументирующийся код:</strong> Типы объясняют намерения без необходимости читать реализацию.</p><h4>Снижение code review нагрузки:</h4><p><strong>Меньше trivial ошибок:</strong> Компилятор ловит опечатки, неправильные типы, missing properties — ревьюеры могут фокусироваться на логике.</p><p><strong>Безопасные изменения API:</strong> Изменения в публичных интерфейсах сразу видны всей команде через ошибки компиляции.</p><h4>Onboarding новых разработчиков:</h4><p><strong>Быстрое понимание:</strong> Новички быстрее разбираются в кодовой базе благодаря типам и автодополнению.</p><p><strong>Меньше вопросов:</strong> IDE отвечает на многие вопросы о структурах данных и API.</p><h4>Предотвращение конфликтов:</h4><p><strong>Breaking changes видны сразу:</strong> Если один разработчик меняет интерфейс, другие сразу видят ошибки в своих ветках.</p><p><em>Эффект:</em> Команда работает быстрее и увереннее, коммуникация улучшается.</p>",
    difficulty: 'senior',
    tags: ['командная работа', 'масштабирование', 'collaboration']
  },
  {
    id: 14,
    question: "Какие проблемы возникают при использовании TypeScript в монорепозиториях?",
    answer: "<p>Монорепозитории с TypeScript имеют <strong>специфические вызовы</strong>:</p><h4>Сложность настройки:</h4><p><strong>Project references:</strong> Настройка зависимостей между пакетами требует внимательности — каждый подпроект нуждается в своем tsconfig.</p><p><strong>Path mapping:</strong> Сложная конфигурация путей для импортов между пакетами.</p><h4>Проблемы сборки:</h4><p><strong>Порядок компиляции:</strong> Пакеты должны компилироваться в правильном порядке зависимостей.</p><p><strong>Долгое время сборки:</strong> Проверка типов во всех пакетах может занимать значительное время.</p><p><strong>Incremental builds:</strong> Не всегда работают корректно, приходится делать полную пересборку.</p><h4>Version management:</h4><p><strong>Синхронизация версий TypeScript:</strong> Разные пакеты могут требовать разные версии, что создает конфликты.</p><p><strong>@types пакеты:</strong> Нужно следить за совместимостью типов между пакетами.</p><h4>Решения:</h4><p>Использование инструментов типа <strong>Turborepo, Nx</strong> для управления сборкой, правильная настройка project references, shared tsconfig для общих правил.</p><p><em>Рекомендация:</em> Инвестировать время в правильную настройку на старте проекта.</p>",
    difficulty: 'senior',
    tags: ['монорепозиторий', 'масштабирование', 'сложности', 'настройка']
  },
  {
    id: 15,
    question: "Как вы оцениваете будущее TypeScript в веб-разработке?",
    answer: "<p>TypeScript имеет <strong>перспективное будущее</strong> в веб-разработке:</p><h4>Текущие тренды:</h4><p><strong>Повсеместное принятие:</strong> Большинство популярных фреймворков и библиотек написаны на TypeScript или имеют first-class поддержку.</p><p><strong>Стандарт индустрии:</strong> В вакансиях TypeScript часто является требованием, а не плюсом.</p><h4>Развитие языка:</h4><p><strong>Type annotations proposal:</strong> Обсуждается возможность добавления синтаксиса типов напрямую в JavaScript — TypeScript может стать частью стандарта.</p><p><strong>Улучшение производительности:</strong> Работа над ускорением компиляции продолжается.</p><h4>Потенциальные вызовы:</h4><p><strong>Альтернативные подходы:</strong> JSDoc с TypeScript, новые инструменты типа Hegel могут составить конкуренцию.</p><p><strong>Усложнение языка:</strong> Каждая новая возможность делает систему типов сложнее.</p><h4>Вероятный сценарий:</h4><p>TypeScript останется <strong>доминирующим решением</strong> для типизации JavaScript на ближайшие 5-10 лет. Возможна более тесная интеграция с JavaScript стандартами.</p><p><em>Вывод:</em> Инвестиции в изучение TypeScript оправданы — он никуда не исчезнет.</p>",
    difficulty: 'senior',
    tags: ['будущее', 'тренды', 'индустрия', 'перспективы']
  },
  {
    id: 16,
    question: "Какие базовые типы данных доступны в TypeScript?",
    answer: "<p>TypeScript предоставляет <strong>богатый набор базовых типов</strong>, расширяющий JavaScript:</p><h4>Примитивные типы:</h4><p><strong>string, number, boolean</strong> — основные типы для текста, чисел и логических значений.</p><p><strong>null и undefined</strong> — представляют отсутствие значения, каждый со своей семантикой.</p><p><strong>symbol</strong> — уникальные неизменяемые значения, часто используются как ключи свойств.</p><p><strong>bigint</strong> — для работы с большими целыми числами, превышающими Number.MAX_SAFE_INTEGER.</p><h4>Специальные типы:</h4><p><strong>any</strong> — отключает проверку типов, любое значение допустимо.</p><p><strong>unknown</strong> — безопасная версия any, требует проверки перед использованием.</p><p><strong>void</strong> — отсутствие возвращаемого значения, обычно для функций.</p><p><strong>never</strong> — тип для значений, которые никогда не возникают.</p><h4>Составные типы:</h4><p><strong>Array и Tuple</strong> — для коллекций значений.</p><p><strong>Object</strong> — для любых объектных типов.</p><p><em>Важно:</em> Все эти типы существуют только на этапе компиляции и исчезают в runtime.</p>",
    difficulty: 'junior',
    tags: ['типы данных', 'примитивы', 'основы', 'базовые типы']
  },
  {
    id: 17,
    question: "Что такое тип tuple и как он отличается от массива?",
    answer: "<p>Tuple — это <strong>массив фиксированной длины</strong> с известными типами для каждого элемента:</p><h4>Основные отличия:</h4><p><strong>Фиксированная длина:</strong> Tuple имеет строго определенное количество элементов — <code>[string, number]</code> всегда содержит ровно 2 элемента.</p><p><strong>Разные типы элементов:</strong> Каждая позиция может иметь свой тип — <code>[string, number, boolean]</code>, в отличие от массива с единым типом.</p><p><strong>Позиционная типизация:</strong> Первый элемент строго string, второй — number. Доступ по индексу типизирован — <code>tuple[0]</code> это string.</p><h4>Использование:</h4><p><strong>Возврат множественных значений:</strong> <code>function useState(): [value, setValue]</code> — как в React hooks.</p><p><strong>Координаты и пары:</strong> <code>[number, number]</code> для точек, <code>[key, value]</code> для пар.</p><h4>Ограничения:</h4><p>Методы массива типа <strong>push</strong> могут нарушить структуру tuple в runtime — TypeScript не всегда может это предотвратить.</p><p><em>Практика:</em> Tuple удобен для небольших структурированных данных вместо создания отдельных интерфейсов.</p>",
    difficulty: 'junior',
    tags: ['tuple', 'массивы', 'типы данных', 'структуры']
  },
  {
    id: 18,
    question: "Чем отличается тип any от типа unknown и never?",
    answer: "<p>Эти три типа имеют <strong>фундаментально разное назначение</strong>:</p><h4>any — отключение проверки:</h4><p><strong>Любое значение допустимо</strong> — можно присвоить что угодно и делать с ним что угодно.</p><p><strong>Отключает type safety:</strong> Компилятор не проверяет операции с any.</p><p><strong>Заразный тип:</strong> Распространяется по коду, нивелируя пользу TypeScript.</p><h4>unknown — безопасный any:</h4><p><strong>Любое значение можно присвоить</strong>, но использовать напрямую нельзя.</p><p><strong>Требует проверки:</strong> Перед использованием нужен type guard — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Top type:</strong> Все типы совместимы с unknown, но unknown не совместим ни с чем без проверки.</p><h4>never — невозможное значение:</h4><p><strong>Нет значений этого типа</strong> — представляет недостижимый код.</p><p><strong>Bottom type:</strong> Подтип всех типов, но никакой тип не присваивается never.</p><p><strong>Используется для:</strong> Функций, которые никогда не возвращаются — бесконечные циклы, throw исключений.</p><p><em>Правило:</em> Предпочитайте unknown вместо any для действительно динамических значений.</p>",
    difficulty: 'middle',
    tags: ['any', 'unknown', 'never', 'типы', 'безопасность']
  },
  {
    id: 19,
    question: "Как использовать тип enum для определения перечисления значений?",
    answer: "<p>Enum позволяет определить <strong>набор именованных констант</strong>:</p><h4>Числовые enum:</h4><p><strong>По умолчанию</strong> — значения автоматически увеличиваются с 0: <code>enum Direction { Up, Down, Left, Right }</code></p><p><strong>Кастомные значения:</strong> Можно задать явно — <code>enum Status { Active = 1, Inactive = 0 }</code></p><h4>Строковые enum:</h4><p><strong>Явные строковые значения</strong> — <code>enum Color { Red = 'RED', Green = 'GREEN' }</code></p><p><strong>Преимущества:</strong> Более читаемы в runtime, лучше для отладки и логирования.</p><h4>Особенности:</h4><p><strong>Двунаправленное mapping</strong> у числовых enum — можно получить имя по значению: <code>Direction[0] === 'Up'</code></p><p><strong>Компилируются в объекты</strong> в JavaScript коде, увеличивают размер бандла.</p><h4>Альтернативы:</h4><p><strong>Const enum:</strong> Исчезает после компиляции, заменяется на значения — экономит место.</p><p><strong>Union literal types:</strong> <code>type Direction = 'up' | 'down'</code> — более современный подход, не добавляет runtime код.</p><p><em>Выбор:</em> Для новых проектов часто предпочитают union types вместо enum.</p>",
    difficulty: 'junior',
    tags: ['enum', 'константы', 'перечисления', 'типы']
  },
  {
    id: 20,
    question: "Что такое литеральные типы и где их можно применять?",
    answer: "<p>Литеральные типы — это <strong>конкретные значения как типы</strong>:</p><h4>Типы литералов:</h4><p><strong>Строковые литералы:</strong> <code>type Answer = 'yes' | 'no'</code> — переменная может быть только этими строками.</p><p><strong>Числовые литералы:</strong> <code>type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6</code> — только эти числа допустимы.</p><p><strong>Boolean литералы:</strong> <code>type Success = true</code> — только конкретное булево значение.</p><h4>Практическое применение:</h4><p><strong>Ограниченные наборы значений:</strong> Статусы заказов, HTTP методы, режимы работы приложения.</p><p><strong>Discriminated unions:</strong> <code>type Action = { type: 'add' } | { type: 'remove' }</code> — различение union типов по литеральному полю.</p><p><strong>Конфигурация:</strong> Явное указание допустимых опций — <code>env: 'development' | 'production'</code></p><h4>Преимущества:</h4><p><strong>Автодополнение:</strong> IDE показывает только допустимые значения.</p><p><strong>Защита от опечаток:</strong> <code>'prodaction'</code> вызовет ошибку компиляции.</p><p><strong>Type narrowing:</strong> TypeScript может сужать типы в условиях.</p><p><em>Практика:</em> Предпочитайте литеральные union типы перед enum для строковых констант.</p>",
    difficulty: 'middle',
    tags: ['литеральные типы', 'union types', 'константы', 'типизация']
  },
  {
    id: 21,
    question: "Как работает type assertion и когда его следует использовать?",
    answer: "<p>Type assertion — это способ <strong>явно указать тип</strong>, который знает разработчик, но не может вывести компилятор:</p><h4>Синтаксис:</h4><p><strong>Угловые скобки:</strong> <code>&lt;string&gt;someValue</code> — старый синтаксис, несовместим с JSX.</p><p><strong>as синтаксис:</strong> <code>someValue as string</code> — предпочтительный современный вариант.</p><h4>Когда использовать:</h4><p><strong>DOM элементы:</strong> <code>document.getElementById('input') as HTMLInputElement</code> — браузер знает тип, TypeScript нет.</p><p><strong>API ответы:</strong> Когда мы уверены в структуре данных, но TypeScript видит общий тип.</p><p><strong>Миграция кода:</strong> Временное решение при переходе с JavaScript.</p><h4>Опасности:</h4><p><strong>Обход проверки типов:</strong> Assertion не проверяет реальный тип в runtime — можно получить ошибку.</p><p><strong>Ложная уверенность:</strong> Разработчик может ошибаться в своих предположениях.</p><h4>Безопасные альтернативы:</h4><p><strong>Type guards:</strong> Использовать проверки вместо assertion.</p><p><strong>Проверка в runtime:</strong> Валидация данных перед использованием.</p><p><em>Правило:</em> Каждый assertion — потенциальный баг. Используйте только когда действительно уверены.</p>",
    difficulty: 'middle',
    tags: ['type assertion', 'приведение типов', 'безопасность', 'типизация']
  },
  {
    id: 22,
    question: "В чем разница между type и interface и когда использовать каждый?",
    answer: "<p>Type и interface имеют <strong>много общего, но разные возможности</strong>:</p><h4>Interface:</h4><p><strong>Declaration merging:</strong> Несколько объявлений с одним именем сливаются — полезно для расширения библиотечных типов.</p><p><strong>Extends наследование:</strong> <code>interface Admin extends User</code> — более явное расширение.</p><p><strong>Implements в классах:</strong> Классы могут реализовывать интерфейсы — <code>class User implements IUser</code></p><h4>Type:</h4><p><strong>Union и intersection types:</strong> <code>type Result = Success | Error</code> — interface так не умеет.</p><p><strong>Примитивы и литералы:</strong> <code>type ID = string | number</code> — alias для любых типов.</p><p><strong>Mapped и conditional types:</strong> Продвинутые трансформации типов.</p><h4>Когда что использовать:</h4><p><strong>Interface для объектов:</strong> Публичные API, React компоненты, структуры данных.</p><p><strong>Type для union:</strong> Комбинации типов, алиасы, сложные трансформации.</p><p><strong>Consistency:</strong> В одном проекте лучше придерживаться единого стиля.</p><p><em>Тренд:</em> Современная практика склоняется к использованию type для большей гибкости.</p>",
    difficulty: 'middle',
    tags: ['type', 'interface', 'различия', 'определение типов']
  },
  {
    id: 23,
    question: "Что такое type guards и как их создавать?",
    answer: "<p>Type guards — это <strong>механизм сужения типов</strong> через runtime проверки:</p><h4>Встроенные type guards:</h4><p><strong>typeof:</strong> <code>if (typeof value === 'string')</code> — для примитивов.</p><p><strong>instanceof:</strong> <code>if (error instanceof Error)</code> — для проверки классов.</p><p><strong>in оператор:</strong> <code>if ('message' in error)</code> — проверка наличия свойства.</p><h4>Пользовательские type guards:</h4><p><strong>Predicate функции:</strong> <code>function isString(value: unknown): value is string { return typeof value === 'string' }</code></p><p><strong>Возвращаемый тип</strong> <code>value is Type</code> сообщает TypeScript о сужении типа.</p><h4>Discriminated unions:</h4><p><strong>Тип с литеральным полем:</strong> <code>if (action.type === 'add')</code> — TypeScript понимает конкретный тип в этой ветке.</p><h4>Применение:</h4><p><strong>Работа с union types:</strong> Безопасное различение вариантов.</p><p><strong>Работа с unknown:</strong> Проверка перед использованием динамических данных.</p><p><strong>API responses:</strong> Валидация структуры данных от сервера.</p><p><em>Преимущество:</em> Type guards делают код и безопасным, и понятным для TypeScript.</p>",
    difficulty: 'middle',
    tags: ['type guards', 'сужение типов', 'проверки', 'безопасность']
  },
  {
    id: 24,
    question: "Как работают Generic типы и зачем они нужны?",
    answer: "<p>Generic типы позволяют создавать <strong>переиспользуемые компоненты</strong>, работающие с разными типами:</p><h4>Основная идея:</h4><p><strong>Параметризация типов:</strong> <code>Array&lt;T&gt;</code> — массив любого типа, где T — параметр типа.</p><p><strong>Type safety с гибкостью:</strong> Сохраняется связь между входными и выходными типами.</p><h4>Применение:</h4><p><strong>Функции:</strong> <code>function identity&lt;T&gt;(value: T): T</code> — возвращает тот же тип, что получила.</p><p><strong>Интерфейсы:</strong> <code>interface Box&lt;T&gt; { value: T }</code> — контейнер для любого типа.</p><p><strong>Классы:</strong> <code>class Storage&lt;T&gt;</code> — типизированное хранилище.</p><h4>Ограничения (constraints):</h4><p><strong>extends:</strong> <code>&lt;T extends HasId&gt;</code> — ограничивает T только типами с определенными свойствами.</p><p><strong>Множественные параметры:</strong> <code>&lt;K, V&gt;</code> — для Map-подобных структур.</p><h4>Вывод типов:</h4><p>TypeScript <strong>автоматически выводит</strong> T из аргументов — не всегда нужно явно указывать.</p><p><em>Цель:</em> Generic'и избавляют от дублирования кода и сохраняют type safety.</p>",
    difficulty: 'senior',
    tags: ['generics', 'параметризация', 'переиспользование', 'типизация']
  },
  {
    id: 25,
    question: "Что такое union и intersection types и как их применять?",
    answer: "<p>Union и intersection — это <strong>способы комбинирования типов</strong>:</p><h4>Union types (|):</h4><p><strong>Логическое ИЛИ:</strong> <code>string | number</code> — значение может быть одним из типов.</p><p><strong>Применение:</strong> Параметры, которые принимают разные типы, состояния с вариантами, опциональные значения.</p><p><strong>Type narrowing:</strong> Нужны проверки для безопасного использования — TypeScript не знает конкретный тип.</p><h4>Intersection types (&):</h4><p><strong>Логическое И:</strong> <code>User & Admin</code> — объект должен иметь свойства обоих типов.</p><p><strong>Применение:</strong> Миксины, композиция типов, расширение типов без наследования.</p><p><strong>Объединение свойств:</strong> Результирующий тип содержит все поля из обоих типов.</p><h4>Практические примеры:</h4><p><strong>Union для вариантов:</strong> <code>type Status = 'loading' | 'success' | 'error'</code></p><p><strong>Intersection для расширения:</strong> <code>type AdminUser = User & { role: 'admin' }</code></p><h4>Особенности:</h4><p><strong>Приоритет:</strong> Intersection имеет выше приоритет, чем union — скобки важны.</p><p><em>Комбинирование:</em> Можно создавать сложные типы — <code>(A & B) | (C & D)</code></p>",
    difficulty: 'middle',
    tags: ['union types', 'intersection types', 'комбинирование типов', 'композиция']
  },
  {
    id: 26,
    question: "Как работают mapped types и для чего их используют?",
    answer: "<p>Mapped types позволяют <strong>трансформировать существующие типы</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Итерация по ключам:</strong> <code>{ [K in keyof T]: T[K] }</code> — проходим по всем свойствам типа T.</p><p><strong>Трансформация типов:</strong> Можем изменить тип каждого свойства.</p><h4>Встроенные utility types:</h4><p><strong>Partial&lt;T&gt;:</strong> Делает все свойства опциональными — <code>{ [K in keyof T]?: T[K] }</code></p><p><strong>Required&lt;T&gt;:</strong> Делает все свойства обязательными — убирает знаки вопроса.</p><p><strong>Readonly&lt;T&gt;:</strong> Делает все свойства только для чтения — <code>readonly</code> перед каждым.</p><p><strong>Pick&lt;T, K&gt;:</strong> Выбирает только указанные ключи.</p><p><strong>Omit&lt;T, K&gt;:</strong> Исключает указанные ключи.</p><h4>Кастомные mapped types:</h4><p><strong>Префиксы/суффиксы:</strong> <code>type Getters&lt;T&gt; = { [K in keyof T as `get${K}`]: () =&gt; T[K] }</code></p><p><strong>Conditional mapping:</strong> Применение условий при трансформации.</p><h4>Применение:</h4><p>Создание вариаций типов без дублирования, форм с валидацией, API response типов.</p><p><em>Мощь:</em> Mapped types — основа для создания продвинутых utility типов.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'трансформация типов', 'utility types', 'продвинутые типы']
  },
  {
    id: 27,
    question: "Что такое conditional types и как их использовать?",
    answer: "<p>Conditional types позволяют типам <strong>зависеть от условий</strong>:</p><h4>Синтаксис:</h4><p><strong>Тернарный оператор для типов:</strong> <code>T extends U ? X : Y</code> — если T расширяет U, то X, иначе Y.</p><h4>Применение:</h4><p><strong>Извлечение типов:</strong> <code>type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never</code></p><p><strong>infer ключевое слово:</strong> Позволяет извлечь тип из структуры — тип возвращаемого значения, параметров функции.</p><p><strong>Фильтрация union types:</strong> <code>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T</code></p><h4>Встроенные utility types:</h4><p><strong>Exclude&lt;T, U&gt;:</strong> Исключает типы из union.</p><p><strong>Extract&lt;T, U&gt;:</strong> Извлекает только совпадающие типы.</p><p><strong>ReturnType&lt;T&gt;:</strong> Получает тип возвращаемого значения функции.</p><h4>Distributive conditionals:</h4><p><strong>Автоматическое распределение:</strong> Conditional type применяется к каждому члену union типа отдельно.</p><h4>Сложные сценарии:</h4><p>Рекурсивные типы, deep partial, вложенные условия.</p><p><em>Использование:</em> Для создания type-level логики и продвинутых трансформаций.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'продвинутые типы', 'type-level программирование', 'utility types']
  },
  {
    id: 28,
    question: "Как правильно типизировать функции и их параметры?",
    answer: "<p>Типизация функций включает <strong>несколько аспектов</strong>:</p><h4>Базовая типизация:</h4><p><strong>Параметры и возврат:</strong> <code>function add(a: number, b: number): number</code> — явные типы для всего.</p><p><strong>Стрелочные функции:</strong> <code>const add = (a: number, b: number): number =&gt; a + b</code></p><h4>Опциональные параметры:</h4><p><strong>Знак вопроса:</strong> <code>function log(message: string, level?: string)</code> — level может отсутствовать.</p><p><strong>Значения по умолчанию:</strong> <code>function greet(name = 'Guest')</code> — TypeScript выводит тип автоматически.</p><h4>Rest параметры:</h4><p><strong>Spread оператор:</strong> <code>function sum(...numbers: number[])</code> — массив параметров одного типа.</p><h4>Перегрузка функций:</h4><p><strong>Несколько сигнатур:</strong> Разные варианты вызова с разными типами параметров и возврата.</p><p><strong>Реализация:</strong> Одна реализация покрывает все варианты.</p><h4>Типы функций как параметры:</h4><p><strong>Callback типизация:</strong> <code>function map&lt;T, U&gt;(arr: T[], fn: (item: T) =&gt; U): U[]</code></p><p><strong>Function type:</strong> <code>type Handler = (event: Event) =&gt; void</code></p><p><em>Совет:</em> Избегайте <code>Function</code> типа — всегда указывайте конкретную сигнатуру.</p>",
    difficulty: 'middle',
    tags: ['функции', 'параметры', 'типизация', 'сигнатуры']
  },
  {
    id: 29,
    question: "Как работать с типами для асинхронного кода и Promise?",
    answer: "<p>Типизация асинхронного кода требует <strong>понимания Promise типов</strong>:</p><h4>Promise типизация:</h4><p><strong>Generic параметр:</strong> <code>Promise&lt;T&gt;</code> — T это тип разрешенного значения.</p><p><strong>Async функции:</strong> <code>async function fetchData(): Promise&lt;User&gt;</code> — возвращаемый тип всегда Promise.</p><h4>Обработка ошибок:</h4><p><strong>Try-catch:</strong> Тип в catch всегда <code>unknown</code> — нужен type guard для безопасной работы.</p><p><strong>Rejection типы:</strong> Promise технически может отклониться с любым типом, но TypeScript не проверяет это статически.</p><h4>Множественные промисы:</h4><p><strong>Promise.all:</strong> <code>Promise.all([promise1, promise2])</code> возвращает <code>Promise&lt;[Type1, Type2]&gt;</code> — tuple типов.</p><p><strong>Promise.race:</strong> Возвращает union тип всех возможных результатов.</p><h4>Async iterators:</h4><p><strong>AsyncIterable:</strong> <code>async function* generator(): AsyncIterableIterator&lt;number&gt;</code></p><h4>Практические паттерны:</h4><p><strong>Типизация API вызовов:</strong> Создание типов для response и error.</p><p><strong>Wrapper типы:</strong> <code>type AsyncResult&lt;T&gt; = { data: T | null; error: Error | null }</code></p><p><em>Важно:</em> Async/await не меняет принципы типизации, только упрощает синтаксис.</p>",
    difficulty: 'middle',
    tags: ['асинхронность', 'Promise', 'async/await', 'типизация']
  },
  {
    id: 30,
    question: "Как типизировать объекты с динамическими ключами?",
    answer: "<p>Динамические ключи требуют <strong>специальных подходов к типизации</strong>:</p><h4>Index signatures:</h4><p><strong>Базовый синтаксис:</strong> <code>{ [key: string]: number }</code> — любой строковый ключ ведет к числу.</p><p><strong>Ограничения ключей:</strong> Ключи могут быть только <code>string</code>, <code>number</code> или <code>symbol</code>.</p><h4>Record utility type:</h4><p><strong>Более явный синтаксис:</strong> <code>Record&lt;string, User&gt;</code> — объект где ключи строки, значения User.</p><p><strong>С литеральными типами:</strong> <code>Record&lt;'a' | 'b' | 'c', number&gt;</code> — только конкретные ключи.</p><h4>Смешанные типы:</h4><p><strong>Известные + динамические ключи:</strong> <code>interface Data { id: number; [key: string]: any }</code></p><p><strong>Проблема:</strong> Index signature должна быть совместима со всеми известными свойствами.</p><h4>Mapped types для динамики:</h4><p><strong>Условные ключи:</strong> <code>{ [K in keyof T]: T[K] extends string ? K : never }</code></p><h4>Практические случаи:</h4><p><strong>Словари и maps:</strong> Хранение данных по ключам.</p><p><strong>API responses:</strong> Когда структура не полностью известна.</p><p><strong>Конфигурационные объекты:</strong> С расширяемыми опциями.</p><p><em>Альтернатива:</em> Map&lt;K, V&gt; для действительно динамических структур лучше обычных объектов.</p>",
    difficulty: 'senior',
    tags: ['динамические ключи', 'index signature', 'Record', 'типизация объектов']
  },
  {
    id: 31,
    question: "В чем фундаментальное различие между interface и type в TypeScript?",
    answer: "<p>Interface и type имеют <strong>разную природу и возможности</strong>:</p><h4>Interface — для объектных структур:</h4><p><strong>Только объекты:</strong> Interface описывает исключительно форму объектов и не может быть алиасом для примитивов или union типов.</p><p><strong>Declaration merging:</strong> Повторное объявление interface с тем же именем <em>сливает</em> определения — это ключевое отличие.</p><p><strong>Расширение через extends:</strong> Явное наследование, более читаемое и понятное.</p><h4>Type — универсальный алиас:</h4><p><strong>Любые типы:</strong> Type может быть алиасом для чего угодно — примитивов, union, intersection, tuple, функций.</p><p><strong>Нет merging:</strong> Повторное объявление — ошибка. Защищает от случайных конфликтов.</p><p><strong>Более мощные трансформации:</strong> Поддерживает mapped types, conditional types, template literal types.</p><h4>Практическая разница:</h4><p><strong>Extends vs intersection:</strong> <code>interface Admin extends User</code> четче показывает намерение, чем <code>type Admin = User & AdminProps</code>.</p><p><em>Суть:</em> Interface — контракт для объектов, type — гибкий инструмент для любых типов.</p>",
    difficulty: 'middle',
    tags: ['interface', 'type', 'различия', 'определение типов']
  },
  {
    id: 32,
    question: "Когда следует использовать interface, а когда type?",
    answer: "<p>Выбор между interface и type зависит от <strong>конкретной задачи</strong>:</p><h4>Используйте interface когда:</h4><p><strong>Описываете публичные API:</strong> Библиотеки, компоненты, внешние контракты — interface явно показывает намерение.</p><p><strong>Работаете с классами:</strong> <code>class User implements IUser</code> — более естественная семантика.</p><p><strong>Нужно расширение извне:</strong> Declaration merging позволяет пользователям добавлять свойства к вашим типам.</p><p><strong>ООП паттерны:</strong> Наследование, полиморфизм — interface традиционно для этого.</p><h4>Используйте type когда:</h4><p><strong>Union или intersection:</strong> <code>type Status = 'active' | 'inactive'</code> — interface не может.</p><p><strong>Tuple типы:</strong> <code>type Point = [number, number]</code> — четкая структура.</p><p><strong>Mapped или conditional types:</strong> Продвинутые трансформации типов.</p><p><strong>Алиасы примитивов:</strong> <code>type ID = string | number</code></p><h4>Универсальное правило:</h4><p><strong>Согласованность:</strong> В одном проекте придерживайтесь единого стиля — либо interface-first, либо type-first.</p><p><em>Тренд:</em> Современные проекты чаще используют type для гибкости, но interface для React props и публичных API.</p>",
    difficulty: 'middle',
    tags: ['interface', 'type', 'выбор', 'best practices']
  },
  {
    id: 33,
    question: "Как работает declaration merging у интерфейсов и почему это важно?",
    answer: "<p>Declaration merging — это <strong>автоматическое объединение</strong> нескольких объявлений одного interface:</p><h4>Механизм работы:</h4><p><strong>Слияние определений:</strong> Если объявить interface дважды с одним именем, TypeScript объединит их свойства.</p><p><strong>Дополнение типов:</strong> Каждое новое объявление добавляет свойства, не перезаписывая существующие.</p><h4>Практическое применение:</h4><p><strong>Расширение библиотек:</strong> Можно добавить свойства к существующим типам — например, добавить поля в <code>Window</code> или расширить типы библиотеки.</p><p><strong>Module augmentation:</strong> <code>declare module 'library' { interface Config { myField: string } }</code> — расширяем чужие типы в своем коде.</p><p><strong>Глобальные расширения:</strong> Добавление методов к глобальным объектам безопасным способом.</p><h4>Когда это проблема:</h4><p><strong>Случайные конфликты:</strong> В больших проектах можно не заметить, что interface уже существует.</p><p><strong>Неявное поведение:</strong> Merging происходит автоматически, что может быть неочевидно.</p><p><em>Почему type не имеет merging:</em> Чтобы защитить от случайных переопределений — более строгая проверка.</p>",
    difficulty: 'senior',
    tags: ['interface', 'declaration merging', 'расширение типов', 'модули']
  },
  {
    id: 34,
    question: "Какие преимущества дают интерфейсы при работе с классами?",
    answer: "<p>Интерфейсы и классы имеют <strong>естественную совместимость</strong> в TypeScript:</p><h4>Implements ключевое слово:</h4><p><strong>Контракт для класса:</strong> <code>class User implements IUser</code> — класс обязан реализовать все свойства интерфейса.</p><p><strong>Множественная реализация:</strong> <code>class Admin implements IUser, IAdmin</code> — один класс может реализовывать несколько интерфейсов.</p><h4>Разделение контракта и реализации:</h4><p><strong>Dependency inversion:</strong> Код зависит от интерфейсов, а не конкретных классов — упрощает тестирование.</p><p><strong>Полиморфизм:</strong> Разные классы реализуют один интерфейс — работаем с абстракцией, не с конкретикой.</p><h4>Проверка на этапе компиляции:</h4><p><strong>Гарантия структуры:</strong> TypeScript проверит, что класс действительно реализует все требуемые члены интерфейса.</p><p><strong>Эволюция API:</strong> При изменении интерфейса все реализации получат ошибки компиляции — не забудете обновить.</p><h4>Отличие от type:</h4><p><strong>Implements vs type:</strong> С type можно, но <code>implements</code> семантически правильнее для контрактов классов.</p><p><em>Паттерн:</em> Interface для публичных контрактов, class для реализации — чистая архитектура.</p>",
    difficulty: 'middle',
    tags: ['interface', 'классы', 'implements', 'ООП']
  },
  {
    id: 35,
    question: "Можно ли расширять type и как это отличается от extends у interface?",
    answer: "<p>Type можно расширять, но <strong>механизм отличается</strong>:</p><h4>Расширение через intersection:</h4><p><strong>Оператор &:</strong> <code>type Admin = User & { role: 'admin' }</code> — объединение свойств двух типов.</p><p><strong>Результат:</strong> Новый тип содержит все свойства обоих типов.</p><h4>Отличия от interface extends:</h4><p><strong>Interface extends:</strong> <code>interface Admin extends User</code> — явное наследование с проверкой совместимости.</p><p><strong>Конфликты свойств:</strong> Extends выдаст ошибку при несовместимых типах одноименных свойств, intersection попытается их объединить.</p><p><strong>Читаемость:</strong> Extends более декларативен и понятен — «Admin это User плюс дополнительные свойства».</p><h4>Сложные сценарии:</h4><p><strong>Множественное расширение:</strong> <code>type SuperAdmin = User & Admin & Permissions</code> — можно комбинировать много типов.</p><p><strong>Union в intersection:</strong> <code>type Result = (Success | Error) & Timestamped</code> — смешивание подходов.</p><h4>Когда что использовать:</h4><p><strong>Extends для ясности:</strong> Когда важна явная иерархия типов.</p><p><strong>Intersection для композиции:</strong> Когда собираем тип из нескольких частей без строгой иерархии.</p><p><em>Нюанс:</em> Intersection может создавать невозможные типы при конфликтах — extends безопаснее.</p>",
    difficulty: 'senior',
    tags: ['type', 'interface', 'extends', 'intersection', 'расширение']
  },
  {
    id: 36,
    question: "Как типизировать опциональные свойства в интерфейсах?",
    answer: "<p>Опциональные свойства позволяют <strong>делать поля необязательными</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Знак вопроса:</strong> <code>interface User { name: string; email?: string }</code> — email может отсутствовать.</p><p><strong>Семантика:</strong> Опциональное свойство может быть <code>undefined</code> или присутствовать с указанным типом.</p><h4>Отличие от undefined union:</h4><p><strong>Optional property:</strong> <code>{ email?: string }</code> — свойство может отсутствовать в объекте.</p><p><strong>Explicit undefined:</strong> <code>{ email: string | undefined }</code> — свойство должно быть, но может быть undefined.</p><p><strong>Проверка наличия:</strong> <code>'email' in user</code> vs <code>user.email !== undefined</code> — разные проверки.</p><h4>Utility types:</h4><p><strong>Partial&lt;T&gt;:</strong> Делает все свойства опциональными — <code>Partial&lt;User&gt;</code> эквивалентно всем полям с <code>?</code></p><p><strong>Required&lt;T&gt;:</strong> Обратная операция — убирает все знаки вопроса.</p><h4>Практическое применение:</h4><p><strong>API параметры:</strong> Часть полей обязательна, часть опциональна.</p><p><strong>Конфигурационные объекты:</strong> Значения по умолчанию для отсутствующих полей.</p><p><strong>Частичные обновления:</strong> PATCH запросы, где можно обновить только некоторые поля.</p>",
    difficulty: 'junior',
    tags: ['interface', 'опциональные свойства', 'optional', 'типизация']
  },
  {
    id: 37,
    question: "Что такое readonly свойства и как они работают в интерфейсах?",
    answer: "<p>Readonly модификатор обеспечивает <strong>иммутабельность на уровне типов</strong>:</p><h4>Базовое использование:</h4><p><strong>Модификатор readonly:</strong> <code>interface User { readonly id: string }</code> — свойство нельзя переназначить после создания.</p><p><strong>Защита от изменений:</strong> Попытка присвоить новое значение вызовет ошибку компиляции.</p><h4>Важные нюансы:</h4><p><strong>Только на уровне типов:</strong> Readonly проверяется только при компиляции — в runtime ничто не мешает изменить свойство.</p><p><strong>Shallow readonly:</strong> Только само свойство readonly, вложенные объекты можно мутировать — <code>user.profile.name = 'New'</code> работает.</p><h4>Utility types:</h4><p><strong>Readonly&lt;T&gt;:</strong> Делает все свойства readonly — <code>Readonly&lt;User&gt;</code></p><p><strong>DeepReadonly:</strong> Нужен кастомный тип для рекурсивного readonly всех вложенных объектов.</p><h4>Применение:</h4><p><strong>ID и ключи:</strong> Поля, которые не должны меняться после создания.</p><p><strong>Конфигурация:</strong> Immutable настройки приложения.</p><p><strong>React props:</strong> Props компонентов обычно readonly.</p><h4>Readonly массивы:</h4><p><strong>ReadonlyArray&lt;T&gt;:</strong> Массив без методов мутации — <code>readonly string[]</code></p><p><em>Защита:</em> Readonly помогает предотвратить случайные мутации, но не гарантирует полную иммутабельность.</p>",
    difficulty: 'middle',
    tags: ['readonly', 'иммутабельность', 'interface', 'модификаторы']
  },
  {
    id: 38,
    question: "Как создавать индексные сигнатуры в интерфейсах?",
    answer: "<p>Индексные сигнатуры позволяют типизировать <strong>объекты с динамическими ключами</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>String index:</strong> <code>interface Dictionary { [key: string]: number }</code> — любой строковый ключ ведет к числу.</p><p><strong>Number index:</strong> <code>interface List { [index: number]: string }</code> — числовые индексы, как в массивах.</p><h4>Ограничения:</h4><p><strong>Типы ключей:</strong> Можно использовать только <code>string</code>, <code>number</code> или <code>symbol</code> (с ES2015).</p><p><strong>Совместимость свойств:</strong> Все известные свойства должны быть совместимы с типом индексной сигнатуры.</p><h4>Смешанные определения:</h4><p><strong>Известные + динамические:</strong> <code>interface Config { name: string; [key: string]: string | number }</code></p><p><strong>Проблема:</strong> Индексная сигнатура должна покрывать все свойства — <code>name</code> должен быть совместим с <code>string | number</code>.</p><h4>Альтернативы:</h4><p><strong>Record type:</strong> <code>Record&lt;string, User&gt;</code> — более явный и современный подход.</p><p><strong>Map:</strong> Для действительно динамических структур Map&lt;K, V&gt; лучше объектов.</p><h4>Применение:</h4><p><strong>Словари:</strong> Хранение данных по строковым ключам.</p><p><strong>JSON объекты:</strong> Динамическая структура из API.</p><p><em>Осторожность:</em> Индексные сигнатуры ослабляют type safety — используйте когда действительно нужна динамичность.</p>",
    difficulty: 'middle',
    tags: ['index signature', 'динамические ключи', 'interface', 'типизация']
  },
  {
    id: 39,
    question: "Можно ли описать функцию через interface и как это сделать?",
    answer: "<p>Interface может описывать <strong>форму функции</strong> через call signature:</p><h4>Call signature синтаксис:</h4><p><strong>Функция как объект:</strong> <code>interface Greeter { (name: string): string }</code> — интерфейс описывает функцию.</p><p><strong>Использование:</strong> <code>const greet: Greeter = (name) =&gt; `Hello, ${name}`</code></p><h4>Функции с дополнительными свойствами:</h4><p><strong>Callable objects:</strong> Функция может иметь свои свойства — <code>interface Counter { (): number; reset(): void }</code></p><p><strong>Практика:</strong> Функция-счетчик с методом reset — паттерн из jQuery и других библиотек.</p><h4>Отличие от type:</h4><p><strong>Type alias:</strong> <code>type Greeter = (name: string) =&gt; string</code> — более краткая запись.</p><p><strong>Выбор подхода:</strong> Type предпочтительнее для простых функций, interface когда нужны дополнительные свойства.</p><h4>Множественные сигнатуры:</h4><p><strong>Overloading:</strong> Interface может описать несколько вариантов вызова функции с разными параметрами.</p><h4>Применение:</h4><p><strong>Callbacks:</strong> Типизация функций обратного вызова.</p><p><strong>Factory функции:</strong> С дополнительными методами и свойствами.</p><p><em>Совет:</em> Для простых функций используйте type, для сложных с методами — interface.</p>",
    difficulty: 'middle',
    tags: ['interface', 'функции', 'call signature', 'типизация']
  },
  {
    id: 40,
    question: "Как работают generic параметры в интерфейсах?",
    answer: "<p>Generic параметры делают интерфейсы <strong>переиспользуемыми и гибкими</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Параметр типа:</strong> <code>interface Box&lt;T&gt; { value: T }</code> — T будет заменен конкретным типом при использовании.</p><p><strong>Использование:</strong> <code>const numberBox: Box&lt;number&gt; = { value: 42 }</code></p><h4>Множественные параметры:</h4><p><strong>Несколько generic:</strong> <code>interface Pair&lt;K, V&gt; { key: K; value: V }</code> — для map-подобных структур.</p><p><strong>Связь типов:</strong> Generic параметры могут зависеть друг от друга.</p><h4>Ограничения (constraints):</h4><p><strong>Extends constraint:</strong> <code>interface Repository&lt;T extends { id: string }&gt;</code> — T должен иметь поле id.</p><p><strong>Использование:</strong> Гарантирует, что тип имеет нужные свойства для работы интерфейса.</p><h4>Default типы:</h4><p><strong>Значение по умолчанию:</strong> <code>interface Response&lt;T = unknown&gt;</code> — если не указан, используется unknown.</p><h4>Применение:</h4><p><strong>Контейнеры данных:</strong> Box, Option, Result — обертки над значениями.</p><p><strong>API responses:</strong> <code>ApiResponse&lt;User&gt;</code> — общая структура с generic данными.</p><p><strong>Репозитории:</strong> CRUD операции для любых сущностей с id.</p><p><em>Мощь:</em> Generic делают один интерфейс применимым к множеству типов безопасно.</p>",
    difficulty: 'senior',
    tags: ['interface', 'generics', 'параметризация', 'типизация']
  },
  {
    id: 41,
    question: "Что такое excess property checking и как он работает с интерфейсами?",
    answer: "<p>Excess property checking — это <strong>дополнительная проверка</strong> при прямом присваивании литералов:</p><h4>Механизм работы:</h4><p><strong>Литеральная проверка:</strong> При присваивании объектного литерала TypeScript проверяет, нет ли лишних свойств.</p><p><strong>Только для литералов:</strong> Проверка срабатывает только при прямом присваивании — <code>const user: User = { name: 'John', extra: 'oops' }</code> выдаст ошибку.</p><h4>Почему это важно:</h4><p><strong>Защита от опечаток:</strong> Помогает поймать ошибки типа <code>usrName</code> вместо <code>userName</code>.</p><p><strong>API контракты:</strong> Гарантирует, что клиент не отправляет неожиданные поля.</p><h4>Обход проверки:</h4><p><strong>Через переменную:</strong> <code>const data = { name: 'John', extra: 'ok' }; const user: User = data</code> — проверка не срабатывает.</p><p><strong>Type assertion:</strong> <code>const user = { extra: 'ok' } as User</code> — отключает проверку явно.</p><p><strong>Index signature:</strong> <code>[key: string]: any</code> в интерфейсе разрешает любые дополнительные свойства.</p><h4>Практические случаи:</h4><p><strong>Проблема с React props:</strong> Excess properties могут вызвать ошибки при передаче spread props.</p><p><strong>API интеграции:</strong> Сервер может вернуть дополнительные поля — сохранение в переменной помогает.</p><p><em>Философия:</em> Строгая проверка для новых объектов, гибкость для существующих данных.</p>",
    difficulty: 'senior',
    tags: ['excess property checking', 'интерфейсы', 'проверка типов', 'строгость']
  },
  {
    id: 42,
    question: "Как использовать extends для условного расширения интерфейсов?",
    answer: "<p>Extends в интерфейсах обеспечивает <strong>наследование и композицию</strong>:</p><h4>Базовое наследование:</h4><p><strong>Один родитель:</strong> <code>interface Admin extends User { role: 'admin' }</code> — наследует все свойства User плюс добавляет свои.</p><p><strong>Проверка совместимости:</strong> TypeScript проверит, что нет конфликтов типов одноименных свойств.</p><h4>Множественное наследование:</h4><p><strong>Несколько родителей:</strong> <code>interface SuperUser extends User, Admin, Permissions</code> — комбинация нескольких интерфейсов.</p><p><strong>Разрешение конфликтов:</strong> Если свойства совпадают, их типы должны быть совместимы.</p><h4>Переопределение свойств:</h4><p><strong>Сужение типа:</strong> Можно сузить тип свойства — если родитель имеет <code>string | number</code>, потомок может указать только <code>string</code>.</p><p><strong>Расширение нельзя:</strong> Нельзя расширить тип свойства — это вызовет ошибку.</p><h4>Generic extends:</h4><p><strong>Условное расширение:</strong> <code>interface Repository&lt;T extends Entity&gt; extends BaseRepo</code> — комбинация generic и наследования.</p><h4>Применение:</h4><p><strong>Иерархии типов:</strong> User → Customer → PremiumCustomer — построение type hierarchy.</p><p><strong>Миксины:</strong> Комбинация нескольких интерфейсов для создания составных типов.</p><p><em>Преимущество:</em> Явная иерархия типов облегчает понимание и рефакторинг кода.</p>",
    difficulty: 'middle',
    tags: ['extends', 'наследование', 'interface', 'иерархия типов']
  },
  {
    id: 43,
    question: "Как типизировать методы в интерфейсах и какие есть варианты синтаксиса?",
    answer: "<p>TypeScript предлагает <strong>два способа описания методов</strong> в интерфейсах:</p><h4>Method syntax:</h4><p><strong>Краткая форма:</strong> <code>interface User { greet(name: string): void }</code> — метод как часть интерфейса.</p><p><strong>Семантика:</strong> Выглядит как классовый метод, привычнее для ООП.</p><h4>Property function syntax:</h4><p><strong>Функция как свойство:</strong> <code>interface User { greet: (name: string) =&gt; void }</code> — свойство, которое является функцией.</p><p><strong>Стрелочная функция:</strong> Явно показывает, что это функциональное свойство.</p><h4>Различия:</h4><p><strong>Strictness:</strong> Method syntax менее строгий при проверке — позволяет больше вариантов реализации.</p><p><strong>This binding:</strong> В классах method syntax правильно обрабатывает <code>this</code>, property function может требовать bind.</p><p><strong>Overloading:</strong> Method syntax поддерживает перегрузку методов, property function — нет.</p><h4>Когда что использовать:</h4><p><strong>Method syntax:</strong> Для интерфейсов классов, когда нужна перегрузка, в ООП контексте.</p><p><strong>Property function:</strong> Для чистых функций, callbacks, когда важна явная сигнатура.</p><h4>Опциональные методы:</h4><p><strong>Знак вопроса:</strong> <code>interface Logger { debug?(message: string): void }</code> — метод может отсутствовать.</p><p><em>Consistency:</em> Выберите один стиль и придерживайтесь его в проекте.</p>",
    difficulty: 'middle',
    tags: ['методы', 'interface', 'функции', 'синтаксис']
  },
  {
    id: 44,
    question: "Что такое hybrid types и как создавать интерфейсы для них?",
    answer: "<p>Hybrid types — это объекты, которые <strong>одновременно функции и имеют свойства</strong>:</p><h4>Концепция:</h4><p><strong>Callable + properties:</strong> Объект можно вызвать как функцию И он имеет свои методы/свойства.</p><p><strong>JavaScript реальность:</strong> jQuery, lodash — функции с дополнительными методами.</p><h4>Синтаксис в интерфейсах:</h4><p><strong>Call signature + properties:</strong></p><p><code>interface Counter {</code></p><p><code>  (start: number): string</code></p><p><code>  interval: number</code></p><p><code>  reset(): void</code></p><p><code>}</code></p><p>Объект Counter можно вызвать, и у него есть свойство interval и метод reset.</p><h4>Реализация:</h4><p><strong>Создание объекта:</strong> Функция с добавленными свойствами — <code>const counter = ((start) =&gt; '') as Counter; counter.interval = 1000;</code></p><p><strong>Проблема типизации:</strong> Нужны type assertions для создания таких объектов.</p><h4>Примеры из реальности:</h4><p><strong>jQuery:</strong> <code>$</code> — функция с огромным количеством методов.</p><p><strong>Express middleware:</strong> Функции с дополнительными свойствами конфигурации.</p><h4>Современная альтернатива:</h4><p><strong>Объект с методом call:</strong> Обычный объект с явным методом вместо callable — проще и понятнее.</p><p><em>Применение:</em> Используется редко, в основном при типизации legacy библиотек.</p>",
    difficulty: 'senior',
    tags: ['hybrid types', 'callable objects', 'interface', 'продвинутые типы']
  },
  {
    id: 45,
    question: "Как правильно типизировать this в методах интерфейсов?",
    answer: "<p>TypeScript позволяет <strong>явно типизировать this</strong> для методов:</p><h4>This параметр:</h4><p><strong>Явный this:</strong> <code>interface Chainable { setValue(this: Chainable, value: string): this }</code></p><p><strong>Первый параметр:</strong> <code>this</code> указывается первым, но не считается реальным параметром функции.</p><h4>Return this для chaining:</h4><p><strong>Fluent interface:</strong> Методы возвращают <code>this</code> для цепочки вызовов — <code>obj.setValue('a').setValue('b')</code></p><p><strong>Полиморфный this:</strong> <code>this</code> как возвращаемый тип правильно работает с наследованием.</p><h4>ThisType utility:</h4><p><strong>Контекст для объектов:</strong> <code>type ObjectDescriptor&lt;D&gt; = { [key: string]: Function } & ThisType&lt;D&gt;</code></p><p><strong>Использование:</strong> Устанавливает тип <code>this</code> для всех методов объекта.</p><h4>Проблемы с this:</h4><p><strong>Arrow functions:</strong> Не имеют своего <code>this</code> — могут вызвать проблемы в классах.</p><p><strong>Bind потеря типа:</strong> <code>.bind()</code> может потерять правильный тип this.</p><h4>Практическое применение:</h4><p><strong>Builder pattern:</strong> Методы возвращают this для построения объекта цепочкой.</p><p><strong>Миксины и композиция:</strong> Правильная типизация this при комбинировании классов.</p><p><em>Важность:</em> Правильный this критичен для type safety в ООП паттернах.</p>",
    difficulty: 'senior',
    tags: ['this', 'методы', 'interface', 'контекст', 'типизация']
  },
  {
    id: 46,
    question: "Что такое type narrowing (сужение типов) в TypeScript и зачем оно нужно?",
    answer: "<p>Type narrowing — это процесс <strong>уточнения типа</strong> из более широкого к более конкретному:</p><h4>Суть механизма:</h4><p><strong>От общего к частному:</strong> TypeScript анализирует код и понимает, что внутри определенной ветки тип более специфичен.</p><p><strong>Control flow analysis:</strong> Компилятор отслеживает поток выполнения и сужает типы на основе проверок.</p><h4>Зачем это нужно:</h4><p><strong>Работа с union types:</strong> Когда переменная может быть <code>string | number</code>, нужно сузить до конкретного типа для безопасных операций.</p><p><strong>Устранение неопределенности:</strong> После проверки <code>if (x !== null)</code> TypeScript знает, что в этой ветке x точно не null.</p><h4>Базовый пример:</h4><p><strong>Проверка typeof:</strong> <code>if (typeof value === 'string')</code> — внутри блока TypeScript знает, что value это string.</p><p><strong>Автоматическое сужение:</strong> Не нужны type assertions, компилятор сам понимает.</p><h4>Преимущества:</h4><p><strong>Type safety без избыточности:</strong> Пишем естественные проверки, получаем строгую типизацию.</p><p><strong>Меньше ошибок:</strong> Компилятор предотвращает вызов методов на неправильных типах.</p><p><em>Философия:</em> TypeScript понимает JavaScript идиомы и делает их type-safe.</p>",
    difficulty: 'junior',
    tags: ['type narrowing', 'сужение типов', 'основы', 'union types']
  },
  {
    id: 47,
    question: "Как работает сужение типов через typeof и каковы его ограничения?",
    answer: "<p>Typeof — это <strong>базовый type guard</strong> для примитивных типов:</p><h4>Принцип работы:</h4><p><strong>Проверка примитива:</strong> <code>if (typeof value === 'string')</code> — TypeScript понимает, что внутри value строго string.</p><p><strong>Поддерживаемые типы:</strong> 'string', 'number', 'boolean', 'symbol', 'undefined', 'object', 'function', 'bigint'.</p><h4>Ограничения typeof:</h4><p><strong>Проблема с null:</strong> <code>typeof null === 'object'</code> — историческая особенность JavaScript, требует дополнительной проверки.</p><p><strong>Все объекты одинаковы:</strong> <code>typeof [] === 'object'</code>, <code>typeof {} === 'object'</code> — не различает конкретные типы объектов.</p><p><strong>Классы как функции:</strong> <code>typeof MyClass === 'function'</code> — не подходит для проверки экземпляров.</p><h4>Практические паттерны:</h4><p><strong>Защита от null:</strong> <code>if (value !== null && typeof value === 'object')</code> — правильная проверка объекта.</p><p><strong>Проверка функций:</strong> <code>typeof callback === 'function'</code> — безопасный вызов колбэков.</p><h4>Когда использовать:</h4><p>Идеально для <strong>примитивных типов</strong>, для объектов нужны другие guards.</p><p><em>Совет:</em> Typeof отлично работает с union примитивов — <code>string | number | boolean</code></p>",
    difficulty: 'junior',
    tags: ['typeof', 'type guard', 'сужение типов', 'примитивы']
  },
  {
    id: 48,
    question: "Чем instanceof отличается от typeof и когда его использовать?",
    answer: "<p>Instanceof проверяет <strong>принадлежность к классу</strong>, в отличие от typeof:</p><h4>Механизм работы:</h4><p><strong>Проверка прототипа:</strong> <code>value instanceof Date</code> — проверяет, есть ли Date в цепочке прототипов.</p><p><strong>Для классов и конструкторов:</strong> Работает с классами, встроенными конструкторами (Date, Array, Error).</p><h4>Отличия от typeof:</h4><p><strong>Конкретные типы:</strong> Instanceof различает <code>Array</code> от обычного <code>Object</code>, чего typeof не умеет.</p><p><strong>Иерархия классов:</strong> <code>admin instanceof User</code> — работает с наследованием.</p><p><strong>Runtime проверка:</strong> Instanceof смотрит на реальный объект, а typeof на примитивный тип.</p><h4>Ограничения:</h4><p><strong>Не работает с интерфейсами:</strong> TypeScript интерфейсы существуют только на этапе компиляции.</p><p><strong>Проблемы с разными realms:</strong> iframe или разные контексты выполнения могут ломать instanceof.</p><p><strong>Примитивы:</strong> <code>'text' instanceof String === false</code> — не работает с литералами примитивов.</p><h4>Применение:</h4><p><strong>Обработка ошибок:</strong> <code>if (error instanceof ApiError)</code> — различение типов ошибок.</p><p><strong>Полиморфизм:</strong> Проверка конкретного класса в иерархии.</p><p><em>Правило:</em> Typeof для примитивов, instanceof для объектов и классов.</p>",
    difficulty: 'middle',
    tags: ['instanceof', 'type guard', 'классы', 'сужение типов']
  },
  {
    id: 49,
    question: "Как работает оператор in для сужения типов и какие у него особенности?",
    answer: "<p>Оператор in проверяет <strong>наличие свойства</strong> в объекте:</p><h4>Базовое использование:</h4><p><strong>Проверка свойства:</strong> <code>if ('message' in error)</code> — TypeScript понимает, что внутри error имеет свойство message.</p><p><strong>Работа с объектами:</strong> Проверяет как собственные, так и унаследованные свойства.</p><h4>Discriminated unions:</h4><p><strong>Различение типов:</strong> <code>if ('success' in response)</code> — различает Success от Error response по наличию поля.</p><p><strong>Эффективный паттерн:</strong> Добавление discriminator поля специально для различения union типов.</p><h4>Особенности:</h4><p><strong>Проверяет всю цепочку:</strong> In смотрит не только на собственные свойства, но и прототип.</p><p><strong>Runtime проверка:</strong> Реально проверяет объект, не только типы.</p><p><strong>Опциональные свойства:</strong> <code>in</code> отличает отсутствие свойства от <code>undefined</code> значения.</p><h4>Проблемы:</h4><p><strong>Ложные срабатывания:</strong> Если свойство есть в прототипе случайно, проверка пройдет.</p><p><strong>Строковые ключи:</strong> Нужно следить за опечатками — <code>'mesage' in error</code> не выдаст ошибку компиляции.</p><h4>Применение:</h4><p><strong>API responses:</strong> Различение типов ответов от сервера.</p><p><strong>Type guards:</strong> Создание функций проверки типов.</p><p><em>Совет:</em> Комбинируйте с literal types для надежных discriminated unions.</p>",
    difficulty: 'middle',
    tags: ['in operator', 'type guard', 'свойства', 'discriminated unions']
  },
  {
    id: 50,
    question: "Что такое user-defined type guards и как их создавать?",
    answer: "<p>User-defined type guards — это <strong>функции с type predicate</strong>, которые выполняют кастомную проверку:</p><h4>Синтаксис type predicate:</h4><p><strong>Возвращаемый тип:</strong> <code>function isString(value: unknown): value is string</code></p><p><strong>value is Type:</strong> Специальный синтаксис, сообщающий TypeScript о сужении типа.</p><h4>Создание type guard:</h4><p><strong>Реализация проверки:</strong> Внутри функции выполняем runtime проверки — typeof, instanceof, проверку свойств.</p><p><strong>Boolean недостаточно:</strong> Просто <code>return typeof value === 'string'</code> с типом boolean не сужает тип.</p><h4>Сложные проверки:</h4><p><strong>Множественные условия:</strong> Можем комбинировать проверки для сложных типов — наличие свойств, их типы, структура.</p><p><strong>Валидация структуры:</strong> <code>function isUser(obj: any): obj is User { return obj && typeof obj.name === 'string' && typeof obj.age === 'number' }</code></p><h4>Применение:</h4><p><strong>API responses:</strong> Проверка данных от сервера перед использованием.</p><p><strong>Union types:</strong> Различение вариантов в сложных union.</p><p><strong>Unknown типы:</strong> Безопасная работа с неизвестными данными.</p><h4>Важные моменты:</h4><p><strong>Честная реализация:</strong> Функция должна действительно проверять тип — лживый type guard приведет к runtime ошибкам.</p><p><em>Мощь:</em> Type guards делают динамические проверки type-safe.</p>",
    difficulty: 'middle',
    tags: ['type guards', 'type predicate', 'пользовательские проверки', 'сужение типов']
  },
  {
    id: 51,
    question: "Как работают discriminated unions и почему они важны для сужения типов?",
    answer: "<p>Discriminated unions используют <strong>литеральное поле для различения</strong> вариантов:</p><h4>Структура паттерна:</h4><p><strong>Общее поле-discriminator:</strong> Все варианты union имеют одно поле с литеральным типом — обычно <code>type</code> или <code>kind</code>.</p><p><strong>Уникальные значения:</strong> Каждый вариант имеет свое уникальное значение discriminator'а.</p><h4>Пример:</h4><p><code>type Success = { type: 'success'; data: User }</code></p><p><code>type Error = { type: 'error'; message: string }</code></p><p><code>type Result = Success | Error</code></p><p>Проверка <code>if (result.type === 'success')</code> автоматически сужает тип до Success.</p><h4>Преимущества:</h4><p><strong>Exhaustiveness checking:</strong> TypeScript может проверить, что обработаны все варианты — забыли case, получите ошибку.</p><p><strong>Автоматическое сужение:</strong> Не нужны сложные type guards, простая проверка discriminator'а.</p><p><strong>Читаемость:</strong> Явная структура данных, понятно какие варианты существуют.</p><h4>Применение:</h4><p><strong>State machines:</strong> Разные состояния приложения с разными данными.</p><p><strong>API responses:</strong> Success/Error результаты с разной структурой.</p><p><strong>Redux actions:</strong> Действия с type полем и разными payloads.</p><p><em>Best practice:</em> Используйте discriminated unions вместо опциональных полей для различных вариантов.</p>",
    difficulty: 'middle',
    tags: ['discriminated unions', 'type narrowing', 'паттерны', 'union types']
  },
  {
    id: 52,
    question: "Что такое equality narrowing и как TypeScript использует проверки на равенство?",
    answer: "<p>Equality narrowing — это сужение типов через <strong>проверки на равенство</strong>:</p><h4>Принцип работы:</h4><p><strong>Сравнение с известным типом:</strong> <code>if (x === y)</code> — если y имеет конкретный тип, TypeScript понимает, что x тоже этого типа.</p><p><strong>Strict и loose equality:</strong> TypeScript анализирует как <code>===</code>, так и <code>==</code>, но строгое равенство предпочтительнее.</p><h4>Проверка на null/undefined:</h4><p><strong>Отсечение null:</strong> <code>if (value !== null)</code> — сужает тип, исключая null.</p><p><strong>Truthiness недостаточно:</strong> <code>if (value)</code> сужает меньше, чем явная проверка — могут остаться falsy значения.</p><h4>Сравнение с литералами:</h4><p><strong>Discriminator проверка:</strong> <code>if (action.type === 'ADD')</code> — сужает до конкретного варианта union.</p><p><strong>Enum значения:</strong> Сравнение с enum тоже сужает тип.</p><h4>Двустороннее сужение:</h4><p><strong>Обе переменные:</strong> <code>if (a === b)</code> сужает типы обеих переменных на основе друг друга.</p><h4>Особенности:</h4><p><strong>Control flow aware:</strong> Работает с else ветками — в else тип исключает проверенное значение.</p><p><strong>Switch statements:</strong> Case проверки также сужают типы.</p><p><em>Практика:</em> Используйте строгие проверки (<code>===</code>, <code>!==</code>) для надежного сужения.</p>",
    difficulty: 'middle',
    tags: ['equality narrowing', 'сравнение', 'сужение типов', 'control flow']
  },
  {
    id: 53,
    question: "Как работает truthiness narrowing и каковы его подводные камни?",
    answer: "<p>Truthiness narrowing основан на <strong>JavaScript правилах приведения к boolean</strong>:</p><h4>Механизм:</h4><p><strong>Проверка в условии:</strong> <code>if (value)</code> — TypeScript понимает, что внутри value не является falsy.</p><p><strong>Исключает null и undefined:</strong> После проверки тип сужается, убирая эти значения.</p><h4>Falsy значения в JavaScript:</h4><p><strong>Полный список:</strong> <code>false</code>, <code>0</code>, <code>-0</code>, <code>0n</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code></p><p><strong>Проблема с числами:</strong> <code>if (count)</code> не сработает для 0, хотя это валидное число.</p><h4>Подводные камни:</h4><p><strong>Пустая строка:</strong> <code>''</code> это валидная строка, но falsy — проверка <code>if (str)</code> отфильтрует ее.</p><p><strong>Boolean vs nullable:</strong> <code>if (flag)</code> где flag: boolean | undefined плохо — не отличить false от undefined.</p><p><strong>Числовой 0:</strong> Частая ошибка при работе с числами — 0 это валидное значение.</p><h4>Правильные альтернативы:</h4><p><strong>Явные проверки:</strong> <code>if (value !== null && value !== undefined)</code> — точно и понятно.</p><p><strong>Оператор ??:</strong> <code>value ?? defaultValue</code> — только для null/undefined, не для других falsy.</p><p><em>Совет:</em> Избегайте truthiness для чисел и строк, используйте явные проверки.</p>",
    difficulty: 'middle',
    tags: ['truthiness', 'сужение типов', 'falsy values', 'подводные камни']
  },
  {
    id: 54,
    question: "Что такое control flow analysis и как TypeScript отслеживает типы?",
    answer: "<p>Control flow analysis — это <strong>анализ потока выполнения</strong> для отслеживания типов:</p><h4>Основной принцип:</h4><p><strong>Отслеживание путей:</strong> TypeScript анализирует все возможные пути выполнения кода и знает тип переменной в каждой точке.</p><p><strong>Ветвление и объединение:</strong> После if-else потоки объединяются, тип становится union возможных вариантов.</p><h4>Примеры анализа:</h4><p><strong>If-else branches:</strong> В каждой ветке свой суженный тип, после ветвления — union.</p><p><strong>Return/throw:</strong> Если ветка завершается, следующий код знает, что проверка не прошла.</p><p><strong>While/for loops:</strong> Типы могут меняться внутри циклов на основе условий.</p><h4>Усложненные случаи:</h4><p><strong>Вложенные условия:</strong> TypeScript отслеживает сложные комбинации проверок.</p><p><strong>Assignments:</strong> Присваивание нового значения меняет тип переменной в этой точке.</p><h4>Ограничения:</h4><p><strong>Функции:</strong> TypeScript не анализирует код внутри вызываемых функций — только их сигнатуру.</p><p><strong>Сложная логика:</strong> Очень запутанный control flow может не анализироваться корректно.</p><p><strong>Мутации:</strong> Изменения через ссылки могут не отслеживаться.</p><h4>Практическое значение:</h4><p><strong>Естественный код:</strong> Пишем обычные проверки, получаем type safety автоматически.</p><p><em>Мощь:</em> Control flow analysis делает TypeScript умным без явных аннотаций.</p>",
    difficulty: 'senior',
    tags: ['control flow analysis', 'анализ кода', 'сужение типов', 'компилятор']
  },
  {
    id: 55,
    question: "Как работают assertion functions (asserts) для сужения типов?",
    answer: "<p>Assertion functions используют <strong>asserts keyword</strong> для гарантий о типе:</p><h4>Синтаксис asserts:</h4><p><strong>Asserts condition:</strong> <code>function assert(condition: any): asserts condition</code></p><p><strong>Asserts type predicate:</strong> <code>function assertIsString(value: unknown): asserts value is string</code></p><h4>Отличие от type guards:</h4><p><strong>Throw вместо return:</strong> Assertion функция выбрасывает ошибку, если проверка не прошла, а не возвращает boolean.</p><p><strong>Сужение в caller scope:</strong> После вызова assertion функции тип сужается в вызывающем коде.</p><h4>Применение:</h4><p><strong>Защита от null:</strong> <code>assertDefined(user)</code> — после этого user точно не null/undefined.</p><p><strong>Валидация:</strong> <code>assertIsValidConfig(config)</code> — гарантия структуры данных.</p><p><strong>Type refinement:</strong> Сужение типа без if-блоков, линейный код.</p><h4>Пример реализации:</h4><p><code>function assertIsString(value: unknown): asserts value is string {</code></p><p><code>  if (typeof value !== 'string') throw new Error('Not a string')</code></p><p><code>}</code></p><h4>Когда использовать:</h4><p><strong>Невозможные случаи:</strong> Когда значение должно быть определенного типа по логике, иначе это баг.</p><p><strong>Ранняя валидация:</strong> Проверка входных данных в начале функции.</p><p><em>Осторожность:</em> Asserts выбрасывает ошибки — используйте для действительно критичных проверок.</p>",
    difficulty: 'senior',
    tags: ['assertion functions', 'asserts', 'сужение типов', 'валидация']
  },
  {
    id: 56,
    question: "Какие проблемы возникают при сужении типов в асинхронном коде?",
    answer: "<p>Асинхронный код создает <strong>сложности для сужения типов</strong>:</p><h4>Потеря контекста:</h4><p><strong>Callbacks и promises:</strong> Внутри callback/then тип переменной может измениться во внешнем scope.</p><p><strong>Race conditions:</strong> TypeScript не отслеживает, что значение могло измениться между проверкой и использованием.</p><h4>Пример проблемы:</h4><p><code>if (user) {</code></p><p><code>  await delay(1000)</code></p><p><code>  console.log(user.name) // user может стать null!</code></p><p><code>}</code></p><p>TypeScript не знает, что user могла быть изменена в другом потоке.</p><h4>Решения:</h4><p><strong>Локальная копия:</strong> <code>const localUser = user</code> — захватываем значение перед async операцией.</p><p><strong>Проверка после await:</strong> Повторная проверка типа после асинхронных операций.</p><p><strong>Optional chaining:</strong> <code>user?.name</code> — безопасный доступ без предварительной проверки.</p><h4>Проблемы с Promise:</h4><p><strong>Тип внутри then:</strong> Сужение типа до then не работает внутри callback.</p><p><strong>Error handling:</strong> В catch блоке тип error всегда unknown, несмотря на проверки выше.</p><h4>Best practices:</h4><p><strong>Изолируйте проверки:</strong> Делайте type guards внутри async функций, а не перед вызовом.</p><p><em>Важно:</em> Помните, что async разрывает control flow для type narrowing.</p>",
    difficulty: 'senior',
    tags: ['async', 'сужение типов', 'проблемы', 'promises', 'race conditions']
  },
  {
    id: 57,
    question: "Как TypeScript обрабатывает never type в контексте сужения типов?",
    answer: "<p>Never type представляет <strong>невозможные или исчерпанные</strong> варианты:</p><h4>Появление never:</h4><p><strong>Exhaustive checking:</strong> Когда все варианты union обработаны, остается never.</p><p><strong>Противоречивые условия:</strong> <code>if (typeof x === 'string' && typeof x === 'number')</code> — тип внутри never.</p><h4>Проверка полноты обработки:</h4><p><strong>Switch exhaustiveness:</strong></p><p><code>switch (action.type) {</code></p><p><code>  case 'add': ...</code></p><p><code>  case 'remove': ...</code></p><p><code>  default: const _exhaustive: never = action // ошибка если забыли case</code></p><p><code>}</code></p><h4>Never в условиях:</h4><p><strong>Недостижимый код:</strong> После проверок, исключающих все варианты, тип становится never.</p><p><strong>Type guards цепочка:</strong> Последовательные проверки сужают union до never, если все варианты отсечены.</p><h4>Практическое применение:</h4><p><strong>Asserting exhaustiveness:</strong> Гарантия, что обработали все варианты discriminated union.</p><p><strong>Защита от рефакторинга:</strong> При добавлении нового варианта в union, код с never проверкой выдаст ошибку.</p><h4>Функции с never:</h4><p><strong>Не возвращают управление:</strong> <code>function fail(msg: string): never { throw new Error(msg) }</code></p><p><code>После вызова fail() TypeScript знает, что код дальше не выполняется.</code></p><p><em>Мощь:</em> Never помогает компилятору находить логические ошибки в обработке вариантов.</p>",
    difficulty: 'senior',
    tags: ['never', 'exhaustive checking', 'сужение типов', 'union types']
  },
  {
    id: 58,
    question: "Какие паттерны помогают эффективно сужать типы в сложных сценариях?",
    answer: "<p>Существуют <strong>проверенные паттерны</strong> для эффективного сужения:</p><h4>Early return pattern:</h4><p><strong>Ранний выход:</strong> Проверяем негативные случаи первыми и выходим — остальной код работает с суженным типом.</p><p><code>if (!user) return</code></p><p><code>// дальше user точно определен</code></p><h4>Exhaustive type guards:</h4><p><strong>Функции для каждого варианта:</strong> Создаем отдельные type guard для каждого типа в union.</p><p><strong>Композиция проверок:</strong> Комбинируем простые guards для сложных типов.</p><h4>Tagged unions pattern:</h4><p><strong>Добавление type поля:</strong> Явный discriminator делает сужение тривиальным.</p><p><strong>Enum для тегов:</strong> Использование enum вместо строк для type safety.</p><h4>Type predicate utilities:</h4><p><strong>Библиотека guards:</strong> Набор переиспользуемых type guard функций.</p><p><strong>Generic guards:</strong> <code>function isArrayOf&lt;T&gt;(guard: (x: any) => x is T): (arr: any) => arr is T[]</code></p><h4>Комбинация операторов:</h4><p><strong>Несколько проверок:</strong> <code>if (x && typeof x === 'object' && 'name' in x)</code> — последовательное сужение.</p><p><strong>Boolean narrowing:</strong> Использование && и || для сужения в одном выражении.</p><h4>Const assertions:</h4><p><strong>as const:</strong> Сужает литералы до конкретных значений вместо wide types.</p><p><em>Совет:</em> Выбирайте паттерны, которые делают намерения кода очевидными.</p>",
    difficulty: 'senior',
    tags: ['паттерны', 'сужение типов', 'best practices', 'type guards']
  },
  {
    id: 59,
    question: "Как работает сужение типов в switch statements и есть ли особенности?",
    answer: "<p>Switch statements предоставляют <strong>мощное сужение типов</strong> через case проверки:</p><h4>Базовое сужение:</h4><p><strong>Case по discriminator:</strong> <code>switch (result.type)</code> — каждый case сужает тип до соответствующего варианта union.</p><p><strong>Fall-through:</strong> TypeScript отслеживает, когда case проваливается в следующий без break.</p><h4>Exhaustiveness checking:</h4><p><strong>Default с never:</strong> <code>default: const _exhaustive: never = result</code> — проверка, что обработали все варианты.</p><p><strong>Ошибка при новых вариантах:</strong> Добавление нового типа в union вызовет ошибку в default.</p><h4>Особенности:</h4><p><strong>String/number literals:</strong> Switch отлично работает с literal union types.</p><p><strong>Множественные case:</strong> <code>case 'a': case 'b':</code> — TypeScript понимает union этих вариантов.</p><p><strong>Expression в case:</strong> Можно использовать сложные выражения, но сужение работает хуже.</p><h4>Проблемы:</h4><p><strong>Type widening:</strong> Без const assertions литералы могут расшириться до string/number.</p><p><strong>Object comparison:</strong> Switch использует ===, не подходит для сравнения объектов.</p><h4>Альтернатива switch:</h4><p><strong>Object mapping:</strong> <code>const handlers = { 'type1': () =&gt; ..., 'type2': () =&gt; ... }</code> — но теряем exhaustiveness checking.</p><p><em>Рекомендация:</em> Switch идеален для discriminated unions с string/number discriminator.</p>",
    difficulty: 'middle',
    tags: ['switch', 'сужение типов', 'discriminated unions', 'exhaustiveness']
  },
  {
    id: 60,
    question: "Почему TypeScript иногда не сужает типы и как это исправить?",
    answer: "<p>TypeScript имеет <strong>ограничения в анализе</strong>, которые мешают сужению:</p><h4>Частые причины:</h4><p><strong>Мутации через ссылки:</strong> TypeScript не отслеживает изменения объекта через другие ссылки.</p><p><strong>Callback scope:</strong> Внутри callbacks сужение из внешнего scope не работает.</p><p><strong>Сложная логика:</strong> Запутанные условия могут быть слишком сложны для анализа.</p><h4>Проблема с this:</h4><p><strong>Потеря контекста:</strong> <code>this</code> в методах может меняться, TypeScript не отслеживает.</p><p><strong>Arrow functions vs methods:</strong> Разное поведение this влияет на сужение.</p><h4>Array методы:</h4><p><strong>Filter не сужает:</strong> <code>array.filter(x =&gt; x !== null)</code> не убирает null из типа массива.</p><p><strong>Type predicate нужен:</strong> <code>array.filter((x): x is NonNull =&gt; x !== null)</code> — явный type guard.</p><h4>Решения:</h4><p><strong>Локальные переменные:</strong> Копируйте значение в local const перед проверками.</p><p><strong>Type assertions:</strong> Явно указывайте тип, если уверены — <code>value as SpecificType</code>.</p><p><strong>User-defined guards:</strong> Создавайте функции с type predicate для сложных проверок.</p><p><strong>Non-null assertion:</strong> <code>value!</code> — говорит, что значение точно не null, но опасно.</p><h4>Настройки компилятора:</h4><p><strong>strictNullChecks:</strong> Должен быть включен для правильной работы сужения.</p><p><em>Отладка:</em> Hover над переменной в IDE показывает, как TypeScript видит тип в этой точке.</p>",
    difficulty: 'senior',
    tags: ['проблемы', 'сужение типов', 'ограничения', 'решения', 'debugging']
  },
  {
    id: 61,
    question: "Что такое type casting (приведение типов) и зачем оно нужно в TypeScript?",
    answer: "<p>Type casting — это <strong>явное указание типа</strong> переменной, когда разработчик знает больше компилятора:</p><h4>Суть механизма:</h4><p><strong>Override проверки:</strong> Говорим TypeScript «доверься мне, я знаю что это за тип» — компилятор перестает проверять.</p><p><strong>Compile-time only:</strong> Casting существует только при компиляции — в runtime никаких преобразований не происходит.</p><h4>Когда необходимо:</h4><p><strong>Работа с DOM:</strong> <code>document.getElementById()</code> возвращает общий HTMLElement, но мы знаем что это input.</p><p><strong>API responses:</strong> Получаем <code>any</code> или <code>unknown</code> от сервера, но знаем структуру данных.</p><p><strong>Legacy код:</strong> Интеграция с JavaScript кодом без типов.</p><h4>Опасность:</h4><p><strong>Нет runtime проверки:</strong> Если ошиблись с типом, получим ошибку в production.</p><p><strong>Обход type safety:</strong> Casting отключает защиту TypeScript — используйте осторожно.</p><p><em>Альтернатива:</em> Type guards и проверки предпочтительнее casting'а когда возможно.</p>",
    difficulty: 'junior',
    tags: ['type casting', 'приведение типов', 'основы', 'type safety']
  },
  {
    id: 62,
    question: "Какие существуют способы синтаксиса для type casting?",
    answer: "<p>TypeScript предлагает <strong>два синтаксиса</strong> для приведения типов:</p><h4>Angle-bracket синтаксис:</h4><p><strong>Угловые скобки:</strong> <code>&lt;HTMLInputElement&gt;element</code> — старый стиль из ранних версий TypeScript.</p><p><strong>Проблема с JSX:</strong> Конфликтует с React JSX синтаксисом — <code>&lt;Component&gt;</code> воспринимается как элемент.</p><p><strong>Не рекомендуется:</strong> В современных проектах практически не используется.</p><h4>as синтаксис:</h4><p><strong>Ключевое слово as:</strong> <code>element as HTMLInputElement</code> — современный и предпочтительный способ.</p><p><strong>Совместимость с JSX:</strong> Работает везде, включая .tsx файлы.</p><p><strong>Читаемость:</strong> Более явный и понятный — «element как HTMLInputElement».</p><h4>Функциональная эквивалентность:</h4><p><strong>Одинаковый результат:</strong> Оба способа делают абсолютно одно и то же — меняют тип на уровне компилятора.</p><p><strong>Выбор стиля:</strong> В новых проектах всегда используйте <code>as</code> синтаксис.</p><p><em>Правило:</em> Если работаете с React или современным TypeScript — только <code>as</code> синтаксис.</p>",
    difficulty: 'junior',
    tags: ['type casting', 'синтаксис', 'as', 'angle brackets']
  },
  {
    id: 63,
    question: "В чем разница между type assertion и type casting?",
    answer: "<p>Технически это <strong>разные концепции</strong>, хотя часто используются как синонимы:</p><h4>Type assertion (TypeScript):</h4><p><strong>Утверждение типа:</strong> «Я утверждаю, что это имеет такой-то тип» — не преобразует данные.</p><p><strong>Compile-time only:</strong> Существует только на этапе компиляции, исчезает в JavaScript.</p><p><strong>Не проверяет:</strong> TypeScript не валидирует, действительно ли данные соответствуют заявленному типу.</p><h4>Type casting (общее понятие):</h4><p><strong>Преобразование типов:</strong> В других языках — реальное преобразование данных в runtime.</p><p><strong>JavaScript приведение:</strong> <code>Number('42')</code>, <code>String(value)</code> — настоящий casting с преобразованием.</p><h4>TypeScript терминология:</h4><p><strong>Предпочтительно:</strong> В TypeScript правильнее говорить «type assertion», не «type casting».</p><p><strong>Но на практике:</strong> Термины смешиваются, оба понимаются в контексте TypeScript.</p><h4>Критическое отличие:</h4><p><code>value as string</code> — type assertion, не меняет данные.</p><p><code>String(value)</code> — реальное преобразование в строку в runtime.</p><p><em>Важно:</em> TypeScript assertions не защищают от runtime ошибок.</p>",
    difficulty: 'middle',
    tags: ['type assertion', 'type casting', 'терминология', 'различия']
  },
  {
    id: 64,
    question: "Что такое double assertion и когда его использовать?",
    answer: "<p>Double assertion — это <strong>двойное приведение через unknown</strong> для несовместимых типов:</p><h4>Проблема прямого casting:</h4><p><strong>Несовместимые типы:</strong> <code>string as number</code> выдаст ошибку — типы не имеют пересечений.</p><p><strong>TypeScript защита:</strong> Компилятор не позволяет явно опасные assertion.</p><h4>Синтаксис double assertion:</h4><p><strong>Через unknown:</strong> <code>value as unknown as TargetType</code> — сначала в unknown, потом в нужный тип.</p><p><strong>Обход проверки:</strong> Unknown совместим со всеми типами, что позволяет обойти ограничения.</p><h4>Когда использовать:</h4><p><strong>Миграция кода:</strong> Временное решение при переходе с JavaScript.</p><p><strong>Работа с any:</strong> Когда получили any и хотим конкретный тип.</p><p><strong>Тестирование:</strong> Создание тестовых данных с неправильными типами.</p><h4>Опасность:</h4><p><strong>Красный флаг:</strong> Double assertion почти всегда признак проблем в типизации.</p><p><strong>Скрывает ошибки:</strong> Отключает все проверки TypeScript — гарантированный способ получить runtime ошибку.</p><p><em>Правило:</em> Если нужен double assertion — пересмотрите архитектуру типов.</p>",
    difficulty: 'senior',
    tags: ['double assertion', 'unknown', 'приведение типов', 'антипаттерны']
  },
  {
    id: 65,
    question: "Как работает const assertion и чем отличается от обычного as?",
    answer: "<p>Const assertion — это <strong>специальный вид assertion</strong> с ключевым словом const:</p><h4>Синтаксис:</h4><p><strong>as const:</strong> <code>const colors = ['red', 'green'] as const</code> — делает значение readonly и сужает литералы.</p><p><strong>На любом уровне:</strong> Можно применять к объектам, массивам, примитивам.</p><h4>Эффекты const assertion:</h4><p><strong>Literal types:</strong> <code>'red'</code> остается типом <code>'red'</code>, не расширяется до <code>string</code>.</p><p><strong>Readonly свойства:</strong> Все свойства объекта и элементы массива становятся readonly.</p><p><strong>Readonly массивы:</strong> <code>readonly ['red', 'green']</code> — нельзя мутировать.</p><h4>Практическое применение:</h4><p><strong>Конфигурационные объекты:</strong> Неизменяемые настройки с точными типами.</p><p><strong>Tuple вместо array:</strong> <code>[1, 2] as const</code> становится <code>readonly [1, 2]</code>, не <code>number[]</code>.</p><p><strong>Enum альтернатива:</strong> <code>const Status = { Active: 'active', Inactive: 'inactive' } as const</code></p><h4>Отличие от обычного as:</h4><p><strong>Обычный as:</strong> Меняет тип на указанный.</p><p><strong>as const:</strong> Максимально сужает тип и добавляет readonly.</p><p><em>Best practice:</em> Используйте as const для констант, которые не должны меняться.</p>",
    difficulty: 'middle',
    tags: ['const assertion', 'as const', 'literal types', 'readonly']
  },
  {
    id: 66,
    question: "Что такое non-null assertion operator и когда его применять?",
    answer: "<p>Non-null assertion — это <strong>восклицательный знак</strong> для утверждения, что значение не null/undefined:</p><h4>Синтаксис:</h4><p><strong>Постфиксный !:</strong> <code>user!.name</code> — говорим TypeScript, что user точно определен.</p><p><strong>Убирает nullable:</strong> Из типа <code>User | null</code> делает просто <code>User</code>.</p><h4>Когда использовать:</h4><p><strong>После проверок:</strong> Когда мы проверили значение логикой, но TypeScript не понял.</p><p><strong>Инициализация в конструкторе:</strong> Поле класса инициализируется не в месте объявления, но точно до использования.</p><p><strong>DOM гарантии:</strong> <code>document.getElementById('app')!</code> — знаем, что элемент существует.</p><h4>Опасность:</h4><p><strong>Обход проверки:</strong> Компилятор не проверяет — если ошиблись, получим runtime ошибку.</p><p><strong>Скрывает проблемы:</strong> Может маскировать реальные баги с null/undefined.</p><p><strong>Не проверяет runtime:</strong> <code>null!.property</code> скомпилируется, но упадет при выполнении.</p><h4>Альтернативы:</h4><p><strong>Optional chaining:</strong> <code>user?.name</code> — безопаснее, проверяет в runtime.</p><p><strong>Nullish coalescing:</strong> <code>user ?? defaultUser</code> — предоставляет fallback.</p><p><em>Совет:</em> Используйте ! только когда абсолютно уверены, иначе предпочтите ?. и ??</p>",
    difficulty: 'middle',
    tags: ['non-null assertion', '!', 'null', 'undefined', 'операторы']
  },
  {
    id: 67,
    question: "Как безопасно приводить типы при работе с DOM?",
    answer: "<p>DOM типизация требует <strong>баланса между удобством и безопасностью</strong>:</p><h4>Проблема с DOM:</h4><p><strong>Общие типы:</strong> <code>getElementById</code> возвращает <code>HTMLElement | null</code>, не конкретный элемент.</p><p><strong>Потеря информации:</strong> Не знаем методы конкретного элемента — <code>.value</code> у input недоступен.</p><h4>Небезопасный способ:</h4><p><strong>Прямой casting:</strong> <code>document.getElementById('input') as HTMLInputElement</code></p><p><strong>Риск:</strong> Если элемент не input или не существует — runtime ошибка.</p><h4>Безопасные подходы:</h4><p><strong>Проверка instanceof:</strong> <code>if (el instanceof HTMLInputElement) { el.value }</code> — type guard с проверкой.</p><p><strong>Type guard функция:</strong> <code>function isInput(el: HTMLElement | null): el is HTMLInputElement { return el instanceof HTMLInputElement }</code></p><p><strong>Optional chaining с as:</strong> <code>(document.getElementById('input') as HTMLInputElement | null)?.value</code></p><h4>Defensive coding:</h4><p><strong>Всегда проверяйте null:</strong> <code>const input = document.getElementById('input'); if (!input) return;</code></p><p><strong>Assertion после проверки:</strong> Проверили существование, потом cast.</p><p><em>Best practice:</em> Комбинируйте type assertions с runtime проверками для настоящей безопасности.</p>",
    difficulty: 'middle',
    tags: ['DOM', 'type casting', 'HTMLElement', 'безопасность']
  },
  {
    id: 68,
    question: "Можно ли использовать type casting для изменения структуры объекта?",
    answer: "<p>Type casting <strong>не изменяет данные</strong>, только их тип на уровне компилятора:</p><h4>Распространенное заблуждение:</h4><p><strong>Casting ≠ преобразование:</strong> <code>obj as NewType</code> не добавляет/удаляет свойства объекта.</p><p><strong>Только аннотация:</strong> Это инструкция компилятору, как интерпретировать тип, не runtime операция.</p><h4>Что действительно происходит:</h4><p><code>interface A { x: number }</code></p><p><code>interface B { x: number, y: string }</code></p><p><code>const a: A = { x: 1 }</code></p><p><code>const b = a as B // компилируется, но y отсутствует в runtime!</code></p><p><code>console.log(b.y) // undefined, не ошибка компиляции</code></p><h4>Правильные способы преобразования:</h4><p><strong>Создание нового объекта:</strong> <code>const b: B = { ...a, y: 'value' }</code> — реальное добавление свойства.</p><p><strong>Object.assign:</strong> <code>Object.assign({}, a, { y: 'value' })</code></p><p><strong>Маппинг функции:</strong> Явная трансформация данных с новым типом.</p><h4>Опасность:</h4><p><strong>Ложная уверенность:</strong> TypeScript думает что свойство есть, runtime говорит обратное.</p><p><strong>Проблемы в production:</strong> Код компилируется, но падает при выполнении.</p><p><em>Правило:</em> Type casting для типов, Object spreading/mapping для данных.</p>",
    difficulty: 'middle',
    tags: ['type casting', 'объекты', 'заблуждения', 'преобразования']
  },
  {
    id: 69,
    question: "Как работает casting с generics и какие есть подводные камни?",
    answer: "<p>Casting с generic типами имеет <strong>специфические сложности</strong>:</p><h4>Generic type erasure:</h4><p><strong>Информация о T теряется:</strong> В runtime generic параметры не существуют — <code>Array&lt;string&gt;</code> становится просто Array.</p><p><strong>Нельзя проверить instanceof:</strong> <code>value instanceof T</code> не работает — T это compile-time конструкция.</p><h4>Casting внутри generic функций:</h4><p><strong>Проблема с unknown:</strong> <code>function cast&lt;T&gt;(value: unknown): T { return value as T }</code> — компилируется, но опасно.</p><p><strong>Нет проверки соответствия:</strong> TypeScript не может проверить, что unknown действительно совместим с T.</p><h4>Практические паттерны:</h4><p><strong>Constrained generics:</strong> <code>function cast&lt;T extends object&gt;(value: unknown): T</code> — хоть какие-то гарантии.</p><p><strong>Type guard с generics:</strong> Передавать guard функцию как параметр — <code>function parse&lt;T&gt;(data: unknown, guard: (x: any) => x is T): T</code></p><h4>JSON.parse проблема:</h4><p><strong>Популярный антипаттерн:</strong> <code>JSON.parse(str) as MyType</code> — никакой проверки структуры.</p><p><strong>Правильный подход:</strong> Validation libraries (Zod, io-ts) для runtime проверки.</p><h4>Совет:</h4><p><strong>Generic casting = доверие:</strong> По сути отключаете type safety, используйте крайне осторожно.</p><p><em>Best practice:</em> Комбинируйте generic constraints с runtime валидацией.</p>",
    difficulty: 'senior',
    tags: ['generics', 'type casting', 'type erasure', 'подводные камни']
  },
  {
    id: 70,
    question: "Что такое satisfies оператор и чем он лучше as для проверки типов?",
    answer: "<p>Satisfies — это <strong>новый оператор (TS 4.9+)</strong> для проверки без изменения типа:</p><h4>Проблема с as:</h4><p><strong>Теряет точность:</strong> <code>const config = { port: 3000 } as Config</code> — тип становится широким Config.</p><p><strong>Нельзя вывести:</strong> TypeScript больше не знает точные значения свойств.</p><h4>Работа satisfies:</h4><p><strong>Проверка + вывод:</strong> <code>const config = { port: 3000 } satisfies Config</code> — проверяет соответствие, но сохраняет literal типы.</p><p><strong>Лучшее из двух миров:</strong> Type safety проверки И точные выведенные типы.</p><h4>Практические примеры:</h4><p><strong>Конфигурация:</strong> <code>const palette = { red: [255, 0, 0], blue: 'blue' } satisfies Record&lt;string, string | RGB&gt;</code></p><p>TypeScript проверит структуру, но сохранит <code>palette.red[0]</code> как number, не <code>string | number</code>.</p><h4>Когда использовать:</h4><p><strong>Вместо as:</strong> Когда хотите проверить тип, но не потерять информацию.</p><p><strong>Конфигурационные объекты:</strong> Проверка структуры с сохранением literal типов.</p><p><strong>Константы:</strong> Валидация без расширения до общих типов.</p><h4>Ограничения:</h4><p><strong>Только проверка:</strong> Не приводит тип, только валидирует — для реального casting нужен as.</p><p><em>Совет:</em> Предпочитайте satisfies вместо as когда нужна только валидация.</p>",
    difficulty: 'senior',
    tags: ['satisfies', 'type checking', 'type inference', 'новые возможности']
  },
  {
    id: 71,
    question: "Как правильно типизировать результаты JSON.parse?",
    answer: "<p>JSON.parse возвращает <strong>any</strong>, что требует правильной обработки типов:</p><h4>Наивный подход:</h4><p><strong>Прямой casting:</strong> <code>const user = JSON.parse(json) as User</code></p><p><strong>Проблема:</strong> Никакой проверки — если JSON не соответствует User, получим runtime ошибки.</p><h4>Unknown вместо any:</h4><p><strong>Безопаснее:</strong> <code>const data: unknown = JSON.parse(json)</code></p><p><strong>Требует проверки:</strong> Дальше нужен type guard перед использованием.</p><h4>Type guard валидация:</h4><p><code>function isUser(data: unknown): data is User {</code></p><p><code>  return typeof data === 'object' && data !== null &&</code></p><p><code>    'name' in data && typeof data.name === 'string'</code></p><p><code>}</code></p><p>Проверяем структуру перед приведением типа.</p><h4>Validation библиотеки:</h4><p><strong>Zod:</strong> <code>const UserSchema = z.object({ name: z.string() }); const user = UserSchema.parse(JSON.parse(json))</code></p><p><strong>io-ts, yup, joi:</strong> Декларативная схема с runtime проверкой.</p><p><strong>Преимущества:</strong> Автоматическая валидация, понятные ошибки, type inference.</p><h4>Try-catch обработка:</h4><p><strong>Всегда оборачивайте:</strong> JSON.parse может выбросить SyntaxError.</p><p><strong>Комбинируйте проверки:</strong> Валидный JSON ≠ правильная структура данных.</p><p><em>Best practice:</em> Никогда не доверяйте JSON.parse без валидации.</p>",
    difficulty: 'middle',
    tags: ['JSON.parse', 'валидация', 'runtime проверки', 'type safety']
  },
  {
    id: 72,
    question: "Какие проблемы возникают при casting между классами?",
    answer: "<p>Casting между классами имеет <strong>уникальные сложности</strong>:</p><h4>Структурная типизация:</h4><p><strong>TypeScript не номинальный:</strong> Классы проверяются по структуре, не по имени.</p><p><code>class A { x: number }</code></p><p><code>class B { x: number }</code></p><p><code>const a: A = new B() // работает!</code></p><h4>Проблемы с методами:</h4><p><strong>Методы как свойства:</strong> Casting не создает методы класса.</p><p><code>const fakeUser = { name: 'John' } as User</code></p><p><code>fakeUser.greet() // ошибка в runtime, метод не существует</code></p><h4>Private поля игнорируются:</h4><p><strong>Compile-time only:</strong> <code>private</code> и <code>protected</code> не проверяются при casting.</p><p><strong>Можно обойти:</strong> <code>obj as any as PrivateClass</code> даст доступ к приватным полям.</p><h4>Instanceof vs as:</h4><p><strong>Instanceof правильнее:</strong> Проверяет реальную принадлежность к классу.</p><p><strong>As только типы:</strong> Не гарантирует что объект создан через конструктор.</p><h4>Правильный подход:</h4><p><strong>Фабрики:</strong> <code>static from(data: any): User { return new User(data.name) }</code></p><p><strong>Instanceof guards:</strong> Проверка перед использованием методов класса.</p><p><strong>Не используйте casting:</strong> Для классов лучше создавать новые экземпляры.</p><p><em>Правило:</em> Classes для runtime поведения, interfaces для type checking.</p>",
    difficulty: 'senior',
    tags: ['классы', 'type casting', 'методы', 'instanceof', 'проблемы']
  },
  {
    id: 73,
    question: "Как работает casting с union и intersection типами?",
    answer: "<p>Casting с композитными типами имеет <strong>специфические правила</strong>:</p><h4>Casting к union type:</h4><p><strong>Расширение типа:</strong> <code>const str: string = 'text'; const union = str as string | number</code> — всегда безопасно.</p><p><strong>Добавляет возможности:</strong> Тип становится менее конкретным, но TypeScript разрешает.</p><h4>Casting от union type:</h4><p><strong>Сужение типа:</strong> <code>const union: string | number = getValue(); const str = union as string</code></p><p><strong>Опасно:</strong> Если union на самом деле number, получим ошибку при использовании как string.</p><p><strong>Лучше type guard:</strong> <code>if (typeof union === 'string')</code> — безопасное сужение.</p><h4>Intersection types:</h4><p><strong>Требует все свойства:</strong> <code>type Combined = A & B; const obj = {} as Combined</code></p><p><strong>Фейковый объект:</strong> TypeScript думает что есть все свойства, но их нет в runtime.</p><p><strong>Проблема доступа:</strong> <code>obj.propertyFromA</code> будет undefined.</p><h4>Частичный casting:</h4><p><strong>Pick и Omit:</strong> <code>const partial = full as Pick&lt;Full, 'name' | 'age'&gt;</code></p><p><strong>Теряет свойства:</strong> TypeScript больше не видит остальные поля.</p><h4>Паттерн защиты:</h4><p><strong>Проверка перед casting:</strong> Убедитесь что объект действительно соответствует целевому типу.</p><p><em>Совет:</em> Union сужайте через guards, intersection собирайте реальными объектами.</p>",
    difficulty: 'senior',
    tags: ['union types', 'intersection types', 'type casting', 'композиция типов']
  },
  {
    id: 74,
    question: "В чем опасность чрезмерного использования type assertions?",
    answer: "<p>Злоупотребление type assertions <strong>подрывает всю систему типов</strong>:</p><h4>Потеря type safety:</h4><p><strong>Обход компилятора:</strong> Каждый as говорит «не проверяй это» — TypeScript перестает защищать.</p><p><strong>Скрытые баги:</strong> Ошибки типов переносятся в runtime, где их сложнее отлаживать.</p><h4>Технический долг:</h4><p><strong>Временные решения:</strong> «Потом исправлю» превращается в постоянные assertions по всему коду.</p><p><strong>Цепная реакция:</strong> Один неправильный assertion требует следующих для совместимости.</p><p><strong>Сложный рефакторинг:</strong> При изменении типов assertions скрывают реальные проблемы.</p><h4>Проблемы в команде:</h4><p><strong>Потеря доверия:</strong> Если типы не надежны, зачем вообще TypeScript?</p><p><strong>Непонятный код:</strong> As маскирует реальную структуру данных.</p><h4>Симптомы переизбытка:</h4><p>Assertions в большинстве функций, множественные as в цепочках, частый double assertion.</p><h4>Правильный подход:</h4><p><strong>Исправляйте типы:</strong> Вместо assertion улучшите определения типов.</p><p><strong>Type guards:</strong> Используйте проверки вместо утверждений.</p><p><strong>Validation:</strong> Runtime проверки для внешних данных.</p><p><strong>Code review:</strong> Каждый as должен иметь обоснование.</p><p><em>Правило:</em> Если проект полон as, проблема в архитектуре типов, не в строгости TypeScript.</p>",
    difficulty: 'senior',
    tags: ['type assertions', 'антипаттерны', 'технический долг', 'best practices']
  },
  {
    id: 75,
    question: "Как правильно использовать type casting при работе с внешними API?",
    answer: "<p>API responses требуют <strong>многоуровневой стратегии</strong> типизации:</p><h4>Неправильный подход:</h4><p><strong>Наивный casting:</strong> <code>const data = await fetch(url).then(r =&gt; r.json()) as ApiResponse</code></p><p><strong>Проблемы:</strong> Никакой гарантии что API вернул ожидаемую структуру, изменения API ломают код молча.</p><h4>Многоуровневая защита:</h4><p><strong>1. Unknown первым:</strong> <code>const raw: unknown = await response.json()</code></p><p><strong>2. Runtime валидация:</strong> Проверка структуры через type guard или validation library.</p><p><strong>3. Type assertion после проверки:</strong> Только если валидация прошла.</p><h4>Validation libraries паттерн:</h4><p><code>const ApiResponseSchema = z.object({ data: z.array(...), status: z.string() })</code></p><p><code>const validated = ApiResponseSchema.parse(raw)</code></p><p>Автоматическая type inference + runtime проверка.</p><h4>Error handling:</h4><p><strong>Try-catch обязателен:</strong> API может вернуть невалидный JSON или неожиданную структуру.</p><p><strong>Fallback стратегия:</strong> Что делать если валидация не прошла — дефолтные значения или ошибка?</p><h4>Версионирование API:</h4><p><strong>Разные типы для версий:</strong> <code>ApiResponseV1</code>, <code>ApiResponseV2</code></p><p><strong>Миграционная логика:</strong> Проверка версии и соответствующая обработка.</p><h4>Best practices:</h4><p>Никогда не доверяйте внешним данным, всегда валидируйте, используйте branded types для validated data.</p><p><em>Золотое правило:</em> Граница приложения = граница доверия типам.</p>",
    difficulty: 'senior',
    tags: ['API', 'валидация', 'внешние данные', 'runtime проверки', 'безопасность']
  },
  {
    id: 76,
    question: "Что такое обобщения (generics) в TypeScript и зачем они нужны?",
    answer: "<p>Generics — это <strong>параметризация типов</strong>, позволяющая создавать переиспользуемый код:</p><h4>Суть концепции:</h4><p><strong>Типы как параметры:</strong> Подобно тому как функции принимают значения, generics принимают типы — <code>Array&lt;T&gt;</code> работает с любым типом T.</p><p><strong>Сохранение связи типов:</strong> Входной и выходной типы связаны — если передали string, получите string обратно.</p><h4>Зачем нужны:</h4><p><strong>Переиспользование кода:</strong> Одна функция работает с разными типами без дублирования.</p><p><strong>Type safety:</strong> В отличие от any, generics сохраняют информацию о типах и ловят ошибки.</p><p><strong>Автодополнение:</strong> IDE знает точный тип на основе переданного параметра.</p><h4>Без generics vs с generics:</h4><p><strong>Плохо:</strong> <code>function identity(value: any): any</code> — теряем тип.</p><p><strong>Хорошо:</strong> <code>function identity&lt;T&gt;(value: T): T</code> — тип сохраняется.</p><h4>Реальный пример:</h4><p>Массивы — <code>Array&lt;number&gt;</code> гарантирует что методы типа <code>map</code>, <code>filter</code> работают с числами и возвращают числа.</p><p><em>Философия:</em> Generics = писать меньше кода, получать больше type safety.</p>",
    difficulty: 'junior',
    tags: ['generics', 'основы', 'параметризация', 'переиспользование']
  },
  {
    id: 77,
    question: "Как объявить обобщенную функцию в TypeScript?",
    answer: "<p>Объявление generic функций имеет <strong>несколько синтаксических вариантов</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Угловые скобки после имени:</strong> <code>function wrap&lt;T&gt;(value: T): { data: T }</code></p><p><strong>Параметр типа T:</strong> Может быть любая буква, но T (Type) — конвенция для единственного параметра.</p><h4>Стрелочные функции:</h4><p><strong>Перед параметрами:</strong> <code>const wrap = &lt;T&gt;(value: T): { data: T } =&gt; ({ data: value })</code></p><p><strong>TSX конфликт:</strong> В .tsx файлах <code>&lt;T&gt;</code> может восприниматься как JSX — используйте <code>&lt;T,&gt;</code> или <code>&lt;T extends unknown&gt;</code></p><h4>Множественные параметры:</h4><p><strong>Несколько типов:</strong> <code>function pair&lt;K, V&gt;(key: K, value: V): [K, V]</code></p><p><strong>Именование:</strong> K для Key, V для Value, T для Type, U для второго типа — распространенные конвенции.</p><h4>Вызов функции:</h4><p><strong>Явное указание:</strong> <code>wrap&lt;string&gt;('hello')</code></p><p><strong>Type inference:</strong> <code>wrap('hello')</code> — TypeScript выводит T = string автоматически.</p><p><em>Best practice:</em> Полагайтесь на type inference, явно указывайте только когда необходимо.</p>",
    difficulty: 'junior',
    tags: ['generics', 'функции', 'синтаксис', 'объявление']
  },
  {
    id: 78,
    question: "Какие преимущества дают generics при работе с типами данных?",
    answer: "<p>Generics предоставляют <strong>ключевые преимущества</strong> для type-safe кода:</p><h4>Сохранение точности типов:</h4><p><strong>Не теряем информацию:</strong> <code>Array&lt;User&gt;.map</code> возвращает то, что мы указали, не просто any[].</p><p><strong>Связь типов:</strong> Если входной параметр string, TypeScript знает что возврат тоже связан со string.</p><h4>Предотвращение дублирования:</h4><p><strong>Один код для всех типов:</strong> Вместо <code>wrapString</code>, <code>wrapNumber</code> — один <code>wrap&lt;T&gt;</code>.</p><p><strong>DRY принцип:</strong> Меньше кода = меньше багов, проще поддержка.</p><h4>Рефакторинг и масштабирование:</h4><p><strong>Изменения в одном месте:</strong> Generic функцию легко расширить или изменить для всех типов сразу.</p><p><strong>Добавление типов:</strong> Новые типы работают автоматически без изменения кода.</p><h4>IntelliSense и автодополнение:</h4><p><strong>IDE понимает контекст:</strong> Подсказки методов соответствуют конкретному типу T.</p><p><strong>Меньше ошибок:</strong> Автодополнение предотвращает опечатки и неправильные вызовы.</p><h4>Compile-time проверки:</h4><p><strong>Ошибки до runtime:</strong> Неправильное использование типа ловится компилятором.</p><p><em>Результат:</em> Гибкость JavaScript + безопасность статической типизации.</p>",
    difficulty: 'middle',
    tags: ['generics', 'преимущества', 'type safety', 'переиспользование']
  },
  {
    id: 79,
    question: "Как использовать generic constraints (ограничения) с extends?",
    answer: "<p>Constraints позволяют <strong>ограничить возможные типы</strong> для generic параметра:</p><h4>Базовый синтаксис:</h4><p><strong>Extends ключевое слово:</strong> <code>function getProperty&lt;T extends object&gt;(obj: T)</code></p><p><strong>Ограничение:</strong> T может быть только типом, который extends object — примитивы не подойдут.</p><h4>Зачем ограничения:</h4><p><strong>Доступ к свойствам:</strong> Без constraint мы не можем обращаться к свойствам T — TypeScript не знает что они есть.</p><p><strong>Гарантия структуры:</strong> <code>&lt;T extends { id: string }&gt;</code> — уверены что у T есть поле id.</p><h4>Типичные примеры:</h4><p><strong>Объекты с id:</strong> <code>&lt;T extends { id: number }&gt;</code> — для функций работы с сущностями.</p><p><strong>Массивы:</strong> <code>&lt;T extends any[]&gt;</code> — гарантия что T это массив.</p><p><strong>Функции:</strong> <code>&lt;T extends (...args: any[]) =&gt; any&gt;</code> — T должна быть функцией.</p><h4>Множественные ограничения:</h4><p><strong>Intersection в constraint:</strong> <code>&lt;T extends User & Timestamped&gt;</code> — T должен удовлетворять обоим типам.</p><h4>keyof в constraints:</h4><p><strong>Ключи объекта:</strong> <code>&lt;T, K extends keyof T&gt;</code> — K может быть только ключом из T.</p><p><em>Применение:</em> Constraints делают generics одновременно гибкими и безопасными.</p>",
    difficulty: 'middle',
    tags: ['generics', 'constraints', 'extends', 'ограничения']
  },
  {
    id: 80,
    question: "Как работает keyof с generics и какие паттерны это открывает?",
    answer: "<p>Keyof с generics создает <strong>мощные type-safe паттерны</strong>:</p><h4>Базовое использование:</h4><p><strong>Keyof оператор:</strong> <code>&lt;T, K extends keyof T&gt;</code> — K может быть только существующим ключом T.</p><p><strong>Type-safe доступ:</strong> <code>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K]</code></p><h4>Защита от ошибок:</h4><p><strong>Автодополнение ключей:</strong> IDE показывает только реальные свойства объекта.</p><p><strong>Compile-time проверка:</strong> <code>getProperty(user, 'wrongKey')</code> — ошибка компиляции.</p><h4>Паттерн Pick:</h4><p><code>function pick&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): Pick&lt;T, K&gt;</code></p><p>Выбираем подмножество свойств с сохранением типов.</p><h4>Обновление объектов:</h4><p><code>function update&lt;T, K extends keyof T&gt;(obj: T, key: K, value: T[K]): T</code></p><p>Значение должно соответствовать типу свойства.</p><h4>Mapped types с keyof:</h4><p><strong>Трансформация всех ключей:</strong> <code>type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] }</code></p><p><strong>Conditional обработка:</strong> Разная логика для разных типов свойств.</p><h4>Практическое применение:</h4><p>Создание type-safe форм, валидаторов, ORM queries, Redux reducers.</p><p><em>Мощь:</em> Keyof + generics = type safety для динамической работы с объектами.</p>",
    difficulty: 'middle',
    tags: ['generics', 'keyof', 'type safety', 'паттерны']
  },
  {
    id: 81,
    question: "Что такое generic interfaces и классы, как их создавать?",
    answer: "<p>Generic interfaces и классы позволяют <strong>параметризовать структуры данных</strong>:</p><h4>Generic интерфейсы:</h4><p><strong>Синтаксис:</strong> <code>interface Box&lt;T&gt; { value: T; isEmpty: boolean }</code></p><p><strong>Использование:</strong> <code>const numberBox: Box&lt;number&gt; = { value: 42, isEmpty: false }</code></p><p><strong>Множественные параметры:</strong> <code>interface Pair&lt;K, V&gt; { key: K; value: V }</code></p><h4>Generic классы:</h4><p><strong>Объявление:</strong> <code>class Storage&lt;T&gt; { private items: T[] = [] }</code></p><p><strong>Методы используют T:</strong> <code>add(item: T): void { this.items.push(item) }</code></p><p><strong>Инстанцирование:</strong> <code>const userStorage = new Storage&lt;User&gt;()</code></p><h4>Generic в методах класса:</h4><p><strong>Дополнительные параметры:</strong> Метод может иметь свой generic помимо класса.</p><p><code>class Container&lt;T&gt; { transform&lt;U&gt;(fn: (item: T) =&gt; U): Container&lt;U&gt; }</code></p><h4>Constraints в классах:</h4><p><strong>Ограничение типа:</strong> <code>class Repository&lt;T extends { id: string }&gt;</code></p><p><strong>Доступ к свойствам:</strong> Можем использовать obj.id внутри класса.</p><h4>Default generic параметры:</h4><p><strong>Значения по умолчанию:</strong> <code>interface Response&lt;T = unknown&gt;</code></p><p><em>Применение:</em> Контейнеры данных, коллекции, обертки, репозитории.</p>",
    difficulty: 'middle',
    tags: ['generics', 'interfaces', 'классы', 'структуры данных']
  },
  {
    id: 82,
    question: "Как работает type inference для generics и когда нужно явное указание?",
    answer: "<p>Type inference для generics — это <strong>автоматический вывод типов</strong> компилятором:</p><h4>Автоматический вывод:</h4><p><strong>Из аргументов:</strong> <code>function identity&lt;T&gt;(x: T): T</code> — вызов <code>identity('hello')</code> выводит T = string.</p><p><strong>Самый специфичный тип:</strong> TypeScript выбирает наиболее точный тип из возможных.</p><h4>Когда inference работает отлично:</h4><p><strong>Простые случаи:</strong> Один параметр, очевидная связь типов.</p><p><strong>Array методы:</strong> <code>[1, 2, 3].map(x =&gt; x * 2)</code> — все типы выводятся автоматически.</p><h4>Когда нужно явное указание:</h4><p><strong>Литералы расширяются:</strong> <code>const arr = [1, 2]</code> выводится как number[], не [1, 2].</p><p><strong>Пустые структуры:</strong> <code>useState()</code> без аргумента не может вывести тип — нужен <code>useState&lt;User&gt;()</code></p><p><strong>Неоднозначность:</strong> Когда возможно несколько типов, TypeScript выберет wider type.</p><h4>Partial inference:</h4><p><strong>Часть выводится, часть указывается:</strong> <code>create&lt;User&gt;({ name: 'John' })</code> — User указали, структуру аргумента TypeScript проверит сам.</p><h4>Проблемы с inference:</h4><p><strong>Too wide:</strong> <code>const config = { port: 3000 }</code> — port становится number, не 3000.</p><p><strong>Решение:</strong> as const или explicit type annotation.</p><p><em>Правило:</em> Полагайтесь на inference, уточняйте только когда результат слишком широкий или неверный.</p>",
    difficulty: 'middle',
    tags: ['generics', 'type inference', 'вывод типов', 'автоматизация']
  },
  {
    id: 83,
    question: "Что такое generic type aliases и как они отличаются от интерфейсов?",
    answer: "<p>Generic type aliases — это <strong>параметризованные псевдонимы типов</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Type с параметром:</strong> <code>type Result&lt;T&gt; = { success: true; data: T } | { success: false; error: string }</code></p><p><strong>Использование:</strong> <code>const res: Result&lt;User&gt; = ...</code></p><h4>Отличия от generic интерфейсов:</h4><p><strong>Union и intersection:</strong> Type может быть union/intersection, interface только для объектов.</p><p><strong>Mapped types:</strong> <code>type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] }</code> — невозможно в interface.</p><p><strong>Conditional types:</strong> <code>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T</code> — только в type.</p><h4>Когда использовать type:</h4><p><strong>Utility types:</strong> Трансформации и вычисления типов.</p><p><strong>Union результаты:</strong> <code>Result&lt;T&gt;</code>, <code>Option&lt;T&gt;</code> паттерны.</p><p><strong>Tuple types:</strong> <code>type Pair&lt;T&gt; = [T, T]</code></p><h4>Когда использовать interface:</h4><p><strong>Объектные структуры:</strong> Props компонентов, API contracts.</p><p><strong>Extends наследование:</strong> Когда важна явная иерархия.</p><p><strong>Declaration merging:</strong> Расширение библиотечных типов.</p><h4>Комбинирование:</h4><p><strong>Type использует interface:</strong> <code>type WithId&lt;T&gt; = T & { id: string }</code></p><p><em>Практика:</em> Type для сложных преобразований, interface для контрактов.</p>",
    difficulty: 'middle',
    tags: ['generics', 'type aliases', 'interface', 'различия']
  },
  {
    id: 84,
    question: "Какие проблемы возникают с generics и как их решать?",
    answer: "<p>Generics имеют <strong>типичные подводные камни</strong>:</p><h4>Type erasure:</h4><p><strong>Generics исчезают в runtime:</strong> <code>function check&lt;T&gt;(value: any): value is T</code> — невозможно проверить instanceof T.</p><p><strong>Решение:</strong> Передавать guard функцию или class reference как параметр.</p><h4>Too generic код:</h4><p><strong>Избыточная абстракция:</strong> <code>&lt;T, U, V, W&gt;</code> — код становится нечитаемым.</p><p><strong>Решение:</strong> Упростить, использовать промежуточные типы, добавить constraints.</p><h4>Inference не работает:</h4><p><strong>Сложные случаи:</strong> TypeScript не может вывести тип из контекста.</p><p><strong>Решение:</strong> Явное указание типа или реструктуризация кода для лучшего inference.</p><h4>Generic hell:</h4><p><strong>Глубокая вложенность:</strong> <code>Promise&lt;Result&lt;Either&lt;Error, User&gt;&gt;&gt;</code> — трудно читать и дебажить.</p><p><strong>Решение:</strong> Type aliases для промежуточных типов, упрощение структуры.</p><h4>Конфликт constraints:</h4><p><strong>Противоречивые ограничения:</strong> <code>&lt;T extends A & B&gt;</code> где A и B несовместимы.</p><p><strong>Решение:</strong> Пересмотреть архитектуру типов, возможно нужен union вместо intersection.</p><h4>Performance компиляции:</h4><p><strong>Сложные generics:</strong> Замедляют проверку типов в больших проектах.</p><p><strong>Решение:</strong> Упростить типы, использовать type aliases, избегать глубокой рекурсии.</p><p><em>Совет:</em> Generics должны упрощать, не усложнять код.</p>",
    difficulty: 'senior',
    tags: ['generics', 'проблемы', 'решения', 'подводные камни']
  },
  {
    id: 85,
    question: "Как создавать conditional types с generics?",
    answer: "<p>Conditional types с generics создают <strong>динамическую логику типов</strong>:</p><h4>Базовый синтаксис:</h4><p><strong>Тернарный для типов:</strong> <code>type IsString&lt;T&gt; = T extends string ? true : false</code></p><p><strong>Проверка и выбор:</strong> Если T расширяет string, тип true, иначе false.</p><h4>Извлечение типов с infer:</h4><p><strong>Infer ключевое слово:</strong> <code>type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never</code></p><p><strong>Захват типа:</strong> Infer R захватывает тип возвращаемого значения функции.</p><h4>Distributive conditionals:</h4><p><strong>Автораспределение union:</strong> <code>type ToArray&lt;T&gt; = T extends any ? T[] : never</code></p><p><code>ToArray&lt;string | number&gt;</code> становится <code>string[] | number[]</code>, не <code>(string | number)[]</code></p><h4>Практические примеры:</h4><p><strong>NonNullable:</strong> <code>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T</code></p><p><strong>Unwrap Promise:</strong> <code>type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T</code></p><h4>Nested conditions:</h4><p><strong>Множественные проверки:</strong> <code>T extends A ? X : T extends B ? Y : Z</code></p><p><strong>Сложная логика:</strong> Можно строить деревья условий для детального вывода типов.</p><p><em>Применение:</em> Utility types, трансформации типов, type-level программирование.</p>",
    difficulty: 'senior',
    tags: ['generics', 'conditional types', 'infer', 'продвинутые типы']
  },
  {
    id: 86,
    question: "Когда использовать generics, а когда union types?",
    answer: "<p>Выбор между generics и union зависит от <strong>характера задачи</strong>:</p><h4>Используйте generics когда:</h4><p><strong>Связь входа и выхода:</strong> Функция должна вернуть тот же тип, что получила — <code>identity&lt;T&gt;(x: T): T</code></p><p><strong>Переиспользование структур:</strong> <code>Box&lt;T&gt;</code> работает с любым типом контента.</p><p><strong>Сохранение точности:</strong> Нужно знать конкретный тип, не просто «один из нескольких».</p><h4>Используйте union когда:</h4><p><strong>Фиксированный набор вариантов:</strong> <code>type Status = 'pending' | 'success' | 'error'</code></p><p><strong>Discriminated unions:</strong> Разные структуры данных с общим discriminator полем.</p><p><strong>Ограниченный выбор:</strong> Параметр может быть только одним из конкретных типов.</p><h4>Примеры сравнения:</h4><p><strong>Generic:</strong> <code>function parse&lt;T&gt;(schema: Schema&lt;T&gt;, data: unknown): T</code> — тип определяется схемой.</p><p><strong>Union:</strong> <code>function format(value: string | number | Date): string</code> — известный набор входных типов.</p><h4>Комбинирование:</h4><p><strong>Generic с union constraint:</strong> <code>&lt;T extends 'a' | 'b' | 'c'&gt;</code> — лучшее из обоих миров.</p><h4>Ошибочный выбор:</h4><p><strong>Generic вместо union:</strong> Если вариантов мало и фиксировано — union проще.</p><p><strong>Union вместо generic:</strong> Теряем связь типов и точность.</p><p><em>Правило:</em> Generics для гибкости и связи типов, union для конкретных вариантов.</p>",
    difficulty: 'middle',
    tags: ['generics', 'union types', 'выбор', 'сравнение']
  },
  {
    id: 87,
    question: "Что такое generic variance и как она проявляется в TypeScript?",
    answer: "<p>Variance описывает <strong>правила совместимости generic типов</strong>:</p><h4>Типы variance:</h4><p><strong>Covariance (ковариантность):</strong> Если A подтип B, то <code>Generic&lt;A&gt;</code> подтип <code>Generic&lt;B&gt;</code></p><p><strong>Contravariance:</strong> Обратная связь — используется для параметров функций.</p><p><strong>Invariance:</strong> Никакой связи — типы должны совпадать точно.</p><h4>TypeScript поведение:</h4><p><strong>Structural typing:</strong> TypeScript проверяет структурную совместимость, не nominal.</p><p><strong>Arrays covariant:</strong> <code>Dog[]</code> можно присвоить <code>Animal[]</code> — но это опасно для мутаций.</p><p><strong>Functions contravariant:</strong> Параметры функций проверяются в обратном направлении.</p><h4>Проблемы с мутациями:</h4><p><code>const animals: Animal[] = dogs</code></p><p><code>animals.push(new Cat()) // dogs теперь содержит Cat!</code></p><p>TypeScript разрешает это для удобства, но это type unsound.</p><h4>Практические последствия:</h4><p><strong>Readonly для safety:</strong> <code>readonly T[]</code> безопасно ковариантен — нет мутаций.</p><p><strong>Careful с присваиваниями:</strong> Не мутируйте массивы после приведения к более общему типу.</p><h4>strictFunctionTypes:</h4><p><strong>Stricter проверка:</strong> Более правильная проверка variance для функций.</p><p><em>Важно:</em> TypeScript выбирает практичность над теоретической правильностью для arrays.</p>",
    difficulty: 'senior',
    tags: ['generics', 'variance', 'type theory', 'совместимость типов']
  },
  {
    id: 88,
    question: "Как работают default generic parameters и когда их использовать?",
    answer: "<p>Default параметры позволяют <strong>задать тип по умолчанию</strong> для generics:</p><h4>Синтаксис:</h4><p><strong>Значение по умолчанию:</strong> <code>interface Response&lt;T = unknown&gt; { data: T; status: number }</code></p><p><strong>Использование:</strong> <code>Response</code> без параметра использует unknown, <code>Response&lt;User&gt;</code> использует User.</p><h4>Множественные параметры:</h4><p><strong>Цепочка defaults:</strong> <code>&lt;T = string, U = T&gt;</code> — U по умолчанию равен T.</p><p><strong>Порядок важен:</strong> Параметры с defaults должны идти после обязательных.</p><h4>Когда использовать:</h4><p><strong>Частый случай:</strong> <code>&lt;T = any&gt;</code> когда тип обычно any, но можно уточнить.</p><p><strong>Backward compatibility:</strong> Добавление generic к существующему типу без breaking changes.</p><p><strong>Convenience:</strong> Упрощение использования для типичных сценариев.</p><h4>Примеры из практики:</h4><p><strong>React setState:</strong> <code>useState&lt;T = undefined&gt;</code> — можно не указывать если undefined.</p><p><strong>Event handlers:</strong> <code>Handler&lt;E = Event&gt;</code> — общий Event по умолчанию.</p><h4>Паттерн с unknown:</h4><p><strong>Безопасный default:</strong> <code>&lt;T = unknown&gt;</code> заставляет проверять тип, но можно использовать без параметра.</p><p><strong>Лучше чем any:</strong> Unknown требует type guard, any отключает проверки.</p><p><em>Best practice:</em> Используйте unknown или never как default, не any.</p>",
    difficulty: 'middle',
    tags: ['generics', 'default parameters', 'удобство', 'API design']
  },
  {
    id: 89,
    question: "Какие advanced паттерны с generics существуют в TypeScript?",
    answer: "<p>TypeScript поддерживает <strong>сложные паттерны</strong> работы с generics:</p><h4>Recursive generics:</h4><p><strong>Рекурсивные определения:</strong> <code>type DeepReadonly&lt;T&gt; = { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; }</code></p><p><strong>Deep transformations:</strong> Применение трансформации ко всем вложенным уровням.</p><h4>Higher-order generics:</h4><p><strong>Generic принимает generic:</strong> <code>type Apply&lt;T, F&lt;_&gt;&gt; = F&lt;T&gt;</code></p><p><strong>Type-level функции:</strong> Generics как параметры других generics.</p><h4>Template literal types:</h4><p><strong>Строковые манипуляции:</strong> <code>type EventName&lt;T&gt; = `on${Capitalize&lt;T&gt;}`</code></p><p><strong>Dynamic keys:</strong> Создание типов на основе строковых операций.</p><h4>Generic builder pattern:</h4><p><strong>Fluent interface:</strong> <code>class Builder&lt;T&gt; { add&lt;K extends keyof T&gt;(key: K, value: T[K]): Builder&lt;T&gt; }</code></p><p><strong>Accumulating types:</strong> Тип растет с каждым вызовом метода.</p><h4>Phantom types:</h4><p><strong>Nominal typing через brand:</strong> <code>type UserId = string & { __brand: 'UserId' }</code></p><p><strong>Compile-time tags:</strong> Различение типов с одинаковой структурой.</p><h4>Utility functions паттерны:</h4><p><strong>Композиция трансформаций:</strong> Combine Pick, Omit, Partial в сложные типы.</p><p><strong>Conditional распределение:</strong> Применение разной логики к разным членам union.</p><p><em>Осторожность:</em> Advanced паттерны мощны, но могут усложнить понимание кода.</p>",
    difficulty: 'senior',
    tags: ['generics', 'advanced patterns', 'recursive types', 'template literals']
  },
  {
    id: 90,
    question: "Когда следует предпочесть явные типы вместо generics?",
    answer: "<p>Generics не всегда лучший выбор — есть <strong>ситуации для явных типов</strong>:</p><h4>Простые случаи:</h4><p><strong>Один тип использования:</strong> Если функция реально работает только с User, зачем generic?</p><p><strong>Переусложнение:</strong> <code>&lt;T&gt;</code> для функции используемой в одном месте — overkill.</p><h4>Ограниченный набор типов:</h4><p><strong>Известные варианты:</strong> Вместо <code>&lt;T extends string | number&gt;</code> проще overloads.</p><p><strong>Разная логика:</strong> Если для каждого типа своя реализация — generic не поможет.</p><h4>Читаемость кода:</h4><p><strong>Team understanding:</strong> Не все в команде понимают продвинутые generics.</p><p><strong>Maintenance:</strong> Явные типы проще дебажить и изменять.</p><h4>Performance concerns:</h4><p><strong>Compile time:</strong> Сложные generics замедляют проверку типов.</p><p><strong>IDE lag:</strong> Глубокие generic типы тормозят IntelliSense.</p><h4>Правильный баланс:</h4><p><strong>Generics для библиотек:</strong> Публичный API должен быть гибким.</p><p><strong>Explicit для приложений:</strong> Внутренний код может быть конкретным.</p><p><strong>Прагматизм:</strong> Добавляйте generic только когда реальная польза от переиспользования.</p><h4>Code review вопросы:</h4><p>Нужен ли generic? Будет ли код использоваться с разными типами? Делает ли generic код понятнее?</p><p><em>Золотое правило:</em> Используйте simplest solution that works — generic не всегда проще.</p>",
    difficulty: 'middle',
    tags: ['generics', 'явные типы', 'выбор подхода', 'прагматизм', 'читаемость']
  },
  {
    id: 91,
    question: "Что такое mapped types и какую проблему они решают?",
    answer: "<p>Mapped types — это <strong>механизм трансформации типов</strong> через итерацию по ключам:</p><h4>Суть концепции:</h4><p><strong>Преобразование существующих типов:</strong> Берем один тип и создаем новый, применяя трансформацию к каждому свойству.</p><p><strong>Синтаксис итерации:</strong> <code>[K in keyof T]</code> — проходим по всем ключам типа T.</p><h4>Какую проблему решают:</h4><p><strong>Избегаем дублирования:</strong> Вместо создания Readonly версии каждого типа вручную — одна трансформация для всех.</p><p><strong>Связь между типами:</strong> Изменение исходного типа автоматически обновляет производные.</p><p><strong>DRY для типов:</strong> Один паттерн применяется к множеству типов.</p><h4>Базовый пример:</h4><p><code>type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] }</code></p><p>Из любого типа делаем версию с readonly свойствами.</p><h4>Применение:</h4><p><strong>Utility types:</strong> Partial, Required, Pick, Omit — все построены на mapped types.</p><p><strong>Формы и валидация:</strong> Создание типов для errors, touched fields.</p><p><em>Философия:</em> Type-level программирование — код генерирует типы динамически.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'основы', 'трансформация типов', 'utility types']
  },
  {
    id: 92,
    question: "Как работает базовый синтаксис mapped types с keyof?",
    answer: "<p>Базовый синтаксис mapped types состоит из <strong>нескольких ключевых элементов</strong>:</p><h4>Структура синтаксиса:</h4><p><strong>Квадратные скобки:</strong> <code>{ [K in Keys]: Type }</code> — определяют mapping.</p><p><strong>in оператор:</strong> Итерация по union типу ключей.</p><p><strong>keyof оператор:</strong> <code>keyof T</code> — получаем union всех ключей типа T.</p><h4>Пошаговый разбор:</h4><p><code>type MyPartial&lt;T&gt; = {</code></p><p><code>  [K in keyof T]?: T[K]</code></p><p><code>}</code></p><p><strong>K in keyof T:</strong> K принимает каждый ключ из T по очереди.</p><p><strong>T[K]:</strong> Indexed access — получаем тип свойства K в T.</p><p><strong>?:</strong> Модификатор делает свойство опциональным.</p><h4>Что происходит:</h4><p><strong>Для каждого ключа:</strong> TypeScript создает новое свойство с тем же именем.</p><p><strong>Тип свойства:</strong> Берется из исходного типа через indexed access.</p><h4>Визуализация:</h4><p>Если <code>User = { name: string; age: number }</code></p><p>То <code>Partial&lt;User&gt;</code> развернется в <code>{ name?: string; age?: number }</code></p><p><em>Ключ к пониманию:</em> Mapped types — это цикл for по ключам типа.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'синтаксис', 'keyof', 'трансформация']
  },
  {
    id: 93,
    question: "Как создать свою реализацию Pick utility type?",
    answer: "<p>Pick создается через <strong>mapped type с фильтрацией ключей</strong>:</p><h4>Реализация Pick:</h4><p><code>type MyPick&lt;T, K extends keyof T&gt; = {</code></p><p><code>  [P in K]: T[P]</code></p><p><code>}</code></p><h4>Разбор компонентов:</h4><p><strong>Два generic параметра:</strong> T — исходный тип, K — ключи которые нужно выбрать.</p><p><strong>Constraint K extends keyof T:</strong> Гарантирует что выбираем только существующие ключи.</p><p><strong>[P in K]:</strong> Итерируемся только по переданным ключам K, не по всем keyof T.</p><p><strong>T[P]:</strong> Берем оригинальный тип свойства из T.</p><h4>Как работает:</h4><p><code>interface User { name: string; age: number; email: string }</code></p><p><code>type UserName = MyPick&lt;User, 'name' | 'age'&gt;</code></p><p>Результат: <code>{ name: string; age: number }</code></p><h4>Защита от ошибок:</h4><p><strong>Constraint проверяет:</strong> <code>MyPick&lt;User, 'wrong'&gt;</code> — ошибка компиляции.</p><p><strong>Type safety:</strong> Нельзя выбрать несуществующие ключи.</p><h4>Зачем своя реализация:</h4><p>Понимание механики, кастомные модификации, educational purposes.</p><p><em>Применение:</em> Создание подтипов с выборочными полями для API, форм.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'Pick', 'utility types', 'реализация']
  },
  {
    id: 94,
    question: "Как реализовать Omit utility type через mapped types?",
    answer: "<p>Omit — это <strong>обратная Pick</strong>, исключающая указанные ключи:</p><h4>Первый подход — через Pick и Exclude:</h4><p><code>type MyOmit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code></p><p><strong>Exclude&lt;keyof T, K&gt;:</strong> Из всех ключей T исключаем K.</p><p><strong>Pick выбирает:</strong> Оставшиеся ключи.</p><h4>Второй подход — чистый mapped type:</h4><p><code>type MyOmit&lt;T, K extends keyof any&gt; = {</code></p><p><code>  [P in keyof T as P extends K ? never : P]: T[P]</code></p><p><code>}</code></p><p><strong>Key remapping с as:</strong> <code>P as NewKey</code> — меняем имя ключа.</p><p><strong>Conditional для фильтрации:</strong> Если P входит в K — возвращаем never (ключ исключается).</p><h4>Как работает as clause:</h4><p><strong>Never ключи удаляются:</strong> TypeScript игнорирует свойства с never ключами.</p><p><strong>Иначе P:</strong> Оставляем оригинальное имя ключа.</p><h4>Разница в constraints:</h4><p><strong>extends keyof any:</strong> Более гибкий — K может быть строковым literal, не обязательно ключом T.</p><p><strong>extends keyof T:</strong> Строже — только существующие ключи.</p><h4>Пример использования:</h4><p><code>type UserWithoutEmail = MyOmit&lt;User, 'email'&gt;</code></p><p><em>Выбор подхода:</em> Через Pick проще, чистый mapped type — показывает понимание механики.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'Omit', 'key remapping', 'реализация']
  },
  {
    id: 95,
    question: "Что такое модификаторы в mapped types и как их использовать?",
    answer: "<p>Модификаторы позволяют <strong>изменять свойства</strong> при маппинге:</p><h4>Доступные модификаторы:</h4><p><strong>readonly:</strong> <code>{ readonly [K in keyof T]: T[K] }</code> — делает свойства неизменяемыми.</p><p><strong>?:</strong> <code>{ [K in keyof T]?: T[K] }</code> — делает свойства опциональными.</p><p><strong>- (minus):</strong> Удаление модификатора — <code>-readonly</code>, <code>-?</code></p><h4>Добавление модификаторов:</h4><p><strong>Partial:</strong> <code>{ [K in keyof T]?: T[K] }</code> — все опциональные.</p><p><strong>Readonly:</strong> <code>{ readonly [K in keyof T]: T[K] }</code> — все readonly.</p><h4>Удаление модификаторов:</h4><p><strong>Required:</strong> <code>{ [K in keyof T]-?: T[K] }</code> — убираем знаки вопроса, все обязательные.</p><p><strong>Mutable:</strong> <code>{ -readonly [K in keyof T]: T[K] }</code> — убираем readonly.</p><h4>Комбинирование:</h4><p><code>type RequiredAndMutable&lt;T&gt; = {</code></p><p><code>  -readonly [K in keyof T]-?: T[K]</code></p><p><code>}</code></p><p>Убираем оба модификатора одновременно.</p><h4>Практические примеры:</h4><p><strong>Form states:</strong> Partial для optional updates, Required для submit validation.</p><p><strong>Immutable data:</strong> Readonly для store state, Mutable для drafts.</p><p><em>Мощь:</em> Модификаторы дают тонкий контроль над свойствами при трансформации.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'модификаторы', 'readonly', 'optional']
  },
  {
    id: 96,
    question: "Как работает key remapping с as clause в mapped types?",
    answer: "<p>Key remapping позволяет <strong>изменять имена ключей</strong> при маппинге:</p><h4>Базовый синтаксис:</h4><p><strong>as clause:</strong> <code>[K in keyof T as NewK]: T[K]</code></p><p><strong>Трансформация имени:</strong> NewK вычисляется для каждого оригинального ключа K.</p><h4>Типичные паттерны:</h4><p><strong>Добавление префикса:</strong></p><p><code>type Getters&lt;T&gt; = {</code></p><p><code>  [K in keyof T as `get${Capitalize&lt;string & K&gt;}`]: () =&gt; T[K]</code></p><p><code>}</code></p><p>Из <code>{ name: string }</code> получаем <code>{ getName: () =&gt; string }</code></p><h4>Фильтрация ключей:</h4><p><strong>Never для исключения:</strong></p><p><code>[K in keyof T as T[K] extends Function ? never : K]</code></p><p>Оставляем только не-функциональные свойства.</p><h4>Conditional remapping:</h4><p><strong>Разные имена для разных типов:</strong></p><p><code>[K in keyof T as T[K] extends string ? `str${K}` : K]</code></p><p>Строковые свойства получают префикс, остальные без изменений.</p><h4>Template literal types:</h4><p><strong>Динамические имена:</strong> Комбинирование строк, капитализация, camelCase/snake_case преобразования.</p><h4>Практическое применение:</h4><p><strong>Event handlers:</strong> <code>onChange</code> → <code>handleChange</code></p><p><strong>API mapping:</strong> snake_case → camelCase</p><p><em>Мощь:</em> Key remapping превращает mapped types в полноценный инструмент генерации типов.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'key remapping', 'as clause', 'template literals']
  },
  {
    id: 97,
    question: "Как создать mapped type для глубокой трансформации вложенных объектов?",
    answer: "<p>Глубокая трансформация требует <strong>рекурсивных mapped types</strong>:</p><h4>DeepPartial реализация:</h4><p><code>type DeepPartial&lt;T&gt; = {</code></p><p><code>  [K in keyof T]?: T[K] extends object ? DeepPartial&lt;T[K]&gt; : T[K]</code></p><p><code>}</code></p><p><strong>Conditional проверка:</strong> Если свойство объект — рекурсивно применяем DeepPartial.</p><p><strong>Иначе оставляем как есть:</strong> Примитивы не нуждаются в рекурсии.</p><h4>DeepReadonly:</h4><p><code>type DeepReadonly&lt;T&gt; = {</code></p><p><code>  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K]</code></p><p><code>}</code></p><p>Readonly применяется на всех уровнях вложенности.</p><h4>Проблемы с массивами:</h4><p><strong>Array это object:</strong> Наивная реализация сломает массивы.</p><p><strong>Правильная проверка:</strong></p><p><code>T[K] extends Array&lt;infer U&gt; ? ReadonlyArray&lt;DeepReadonly&lt;U&gt;&gt; : ...</code></p><h4>Ограничения рекурсии:</h4><p><strong>Infinite depth:</strong> TypeScript имеет лимит глубины рекурсии типов.</p><p><strong>Performance:</strong> Глубокие рекурсивные типы замедляют компиляцию.</p><h4>Защита от циклических ссылок:</h4><p><strong>Проблема:</strong> Объект ссылается сам на себя — бесконечная рекурсия.</p><p><strong>Решение:</strong> TypeScript обрывает на определенной глубине, но это может быть неожиданно.</p><p><em>Применение:</em> Immutable data structures, конфигурации, API responses.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'рекурсия', 'deep transformation', 'вложенность']
  },
  {
    id: 98,
    question: "Как работают mapped types с union types?",
    answer: "<p>Mapped types и unions комбинируются <strong>особым образом</strong>:</p><h4>Distributive behavior:</h4><p><strong>Mapped type над union:</strong></p><p><code>type Boxed&lt;T&gt; = { [K in keyof T]: T[K] }</code></p><p><code>type Result = Boxed&lt;A | B&gt;</code></p><p><strong>Результат:</strong> <code>Boxed&lt;A&gt; | Boxed&lt;B&gt;</code> — mapped type применяется к каждому члену union отдельно.</p><h4>Union в ключах:</h4><p><strong>Создание нескольких свойств:</strong></p><p><code>type Events = {</code></p><p><code>  [K in 'click' | 'focus' | 'blur']: (event: Event) =&gt; void</code></p><p><code>}</code></p><p>Результат: объект с тремя свойствами.</p><h4>Комбинирование с discriminated unions:</h4><p><strong>Разные трансформации:</strong></p><p><code>type Action = { type: 'add', payload: number } | { type: 'remove' }</code></p><p><code>type Handlers = {</code></p><p><code>  [K in Action['type']]: (action: Extract&lt;Action, { type: K }&gt;) =&gt; void</code></p><p><code>}</code></p><p>Создаем handler для каждого типа action.</p><h4>Filtering union members:</h4><p><strong>Exclude с never:</strong></p><p><code>[K in keyof T as T[K] extends Function ? never : K]</code></p><p>Исключаем функциональные свойства из union ключей.</p><h4>Практические паттерны:</h4><p><strong>State machines:</strong> Типы для каждого состояния.</p><p><strong>Event systems:</strong> Handlers для всех типов событий.</p><p><em>Особенность:</em> Distributive mapping мощен для создания связанных типов из unions.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'union types', 'distributive', 'паттерны']
  },
  {
    id: 99,
    question: "Как создать mapped type, который делает определенные свойства обязательными?",
    answer: "<p>Выборочная модификация свойств требует <strong>комбинации техник</strong>:</p><h4>RequiredKeys utility:</h4><p><code>type RequiredKeys&lt;T, K extends keyof T&gt; = T & {</code></p><p><code>  [P in K]-?: T[P]</code></p><p><code>}</code></p><p><strong>Intersection с required:</strong> Комбинируем оригинальный тип с версией где указанные ключи обязательны.</p><p><strong>-? модификатор:</strong> Убирает опциональность только для выбранных ключей.</p><h4>Альтернативный подход:</h4><p><code>type RequiredKeys&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; & Required&lt;Pick&lt;T, K&gt;&gt;</code></p><p><strong>Разделение:</strong> Отделяем обязательные ключи от остальных.</p><p><strong>Required для части:</strong> Применяем Required только к K.</p><p><strong>Объединяем обратно:</strong> Intersection собирает все вместе.</p><h4>Пример использования:</h4><p><code>interface User {</code></p><p><code>  name?: string</code></p><p><code>  email?: string</code></p><p><code>  age?: number</code></p><p><code>}</code></p><p><code>type UserWithEmail = RequiredKeys&lt;User, 'email'&gt;</code></p><p>Email обязателен, остальные опциональны.</p><h4>Обратный паттерн — OptionalKeys:</h4><p><code>type OptionalKeys&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; & Partial&lt;Pick&lt;T, K&gt;&gt;</code></p><p>Делает выбранные ключи опциональными.</p><p><em>Применение:</em> API endpoints с обязательными параметрами, форма с required полями.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'partial modification', 'Required', 'Pick']
  },
  {
    id: 100,
    question: "Какие проблемы возникают при работе с mapped types и как их решать?",
    answer: "<p>Mapped types имеют <strong>типичные подводные камни</strong>:</p><h4>Потеря index signatures:</h4><p><strong>Проблема:</strong> Mapped type удаляет index signature из исходного типа.</p><p><code>type T = { [key: string]: any; name: string }</code></p><p><code>Partial&lt;T&gt;</code> потеряет <code>[key: string]</code></p><p><strong>Решение:</strong> Явное сохранение — комбинировать mapped type с index signature.</p><h4>Mapped type над never:</h4><p><strong>Результат:</strong> <code>{ [K in keyof never]: any }</code> дает пустой объект <code>{}</code></p><p><strong>Неочевидность:</strong> Может быть неожиданным в сложных условиях.</p><h4>Сохранение модификаторов:</h4><p><strong>Implicit copy:</strong> Mapped type копирует readonly и optional по умолчанию.</p><p><strong>Явное указание:</strong> Если нужно изменить — используйте модификаторы +/- явно.</p><h4>Performance проблемы:</h4><p><strong>Глубокие transformations:</strong> Рекурсивные mapped types замедляют компиляцию.</p><p><strong>Решение:</strong> Ограничивать глубину, использовать type caching.</p><h4>Проблемы с методами:</h4><p><strong>Потеря this контекста:</strong> Mapped types могут сломать правильный тип this в методах.</p><p><strong>Решение:</strong> Аккуратно с трансформацией функций, возможно нужны специальные условия.</p><h4>Циклические типы:</h4><p><strong>Рекурсия на себя:</strong> TypeScript может зациклиться или обрезать глубину.</p><p><strong>Защита:</strong> Добавлять depth counter или использовать утилиты типа ts-toolbelt.</p><p><em>Отладка:</em> Hover over в IDE показывает результирующий тип — проверяйте что получилось.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'проблемы', 'решения', 'подводные камни']
  },
  {
    id: 101,
    question: "Как использовать mapped types для создания типов событий и handlers?",
    answer: "<p>Mapped types идеально подходят для <strong>type-safe event систем</strong>:</p><h4>События с разными payload:</h4><p><code>interface EventPayloads {</code></p><p><code>  click: { x: number; y: number }</code></p><p><code>  focus: { elementId: string }</code></p><p><code>  keypress: { key: string; code: number }</code></p><p><code>}</code></p><h4>Handlers из событий:</h4><p><code>type EventHandlers = {</code></p><p><code>  [K in keyof EventPayloads]: (payload: EventPayloads[K]) =&gt; void</code></p><p><code>}</code></p><p>Результат: каждый handler типизирован своим payload.</p><h4>Event emitter типизация:</h4><p><code>class TypedEmitter&lt;Events&gt; {</code></p><p><code>  on&lt;K extends keyof Events&gt;(event: K, handler: (payload: Events[K]) =&gt; void) {}</code></p><p><code>  emit&lt;K extends keyof Events&gt;(event: K, payload: Events[K]) {}</code></p><p><code>}</code></p><p><strong>Type safety:</strong> Нельзя передать wrong payload для события.</p><h4>Добавление префиксов:</h4><p><code>type OnHandlers = {</code></p><p><code>  [K in keyof Events as `on${Capitalize&lt;string & K&gt;}`]: (e: Events[K]) =&gt; void</code></p><p><code>}</code></p><p><code>click</code> → <code>onClick</code>, автоматически для всех событий.</p><h4>Практическое применение:</h4><p><strong>React synthetic events:</strong> Типизация кастомных событий компонентов.</p><p><strong>WebSocket messages:</strong> Разные типы сообщений с правильными payload.</p><p><strong>Redux actions:</strong> Type-safe dispatch и reducers.</p><p><em>Преимущество:</em> Добавили событие — handlers обновились автоматически.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'события', 'handlers', 'type safety', 'паттерны']
  },
  {
    id: 102,
    question: "Как комбинировать mapped types с conditional types для сложных трансформаций?",
    answer: "<p>Комбинация mapped и conditional types дает <strong>максимальную гибкость</strong>:</p><h4>Разная обработка по типу:</h4><p><code>type Stringify&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: T[K] extends string ? T[K] :</code></p><p><code>                   T[K] extends number ? `${T[K]}` :</code></p><p><code>                   T[K] extends boolean ? 'true' | 'false' : never</code></p><p><code>}</code></p><p>Разные типы конвертируются в строки по-разному.</p><h4>Фильтрация по типу значения:</h4><p><code>type FunctionPropertyNames&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: T[K] extends Function ? K : never</code></p><p><code>}[keyof T]</code></p><p><strong>Трюк [keyof T]:</strong> Извлекаем union значений, never исключаются.</p><h4>Nullable filtering:</h4><p><code>type NonNullableProps&lt;T&gt; = {</code></p><p><code>  [K in keyof T as T[K] extends null | undefined ? never : K]: T[K]</code></p><p><code>}</code></p><p>Исключаем nullable свойства при маппинге.</p><h4>Nested conditional transformations:</h4><p><code>type DeepNonNullable&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: T[K] extends object ? DeepNonNullable&lt;T[K]&gt; :</code></p><p><code>                   T[K] extends null | undefined ? never : T[K]</code></p><p><code>}</code></p><p>Рекурсивно убираем nullable на всех уровнях.</p><h4>Практические примеры:</h4><p><strong>Serialization:</strong> Преобразование типов для JSON.</p><p><strong>API typing:</strong> Разные transformations для request/response.</p><p><strong>Form validation:</strong> Error types для разных типов полей.</p><p><em>Мощь:</em> Unlimited возможности для type-level программирования.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'conditional types', 'комбинирование', 'advanced']
  },
  {
    id: 103,
    question: "Как mapped types помогают в создании type-safe форм и validation?",
    answer: "<p>Mapped types создают <strong>связанные типы для форм</strong> автоматически:</p><h4>Form state из модели:</h4><p><code>interface User {</code></p><p><code>  name: string</code></p><p><code>  email: string</code></p><p><code>  age: number</code></p><p><code>}</code></p><p><code>type FormState&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: { value: T[K]; error: string | null; touched: boolean }</code></p><p><code>}</code></p><p>Каждое поле получает state для validation.</p><h4>Validation errors:</h4><p><code>type FormErrors&lt;T&gt; = {</code></p><p><code>  [K in keyof T]?: string</code></p><p><code>}</code></p><p>Опциональные ошибки для каждого поля.</p><h4>Touched fields tracking:</h4><p><code>type FormTouched&lt;T&gt; = {</code></p><p><code>  [K in keyof T]?: boolean</code></p><p><code>}</code></p><p>Отслеживание взаимодействия с полями.</p><h4>Validators mapping:</h4><p><code>type FormValidators&lt;T&gt; = {</code></p><p><code>  [K in keyof T]?: (value: T[K]) =&gt; string | null</code></p><p><code>}</code></p><p>Функции валидации типизированы правильным типом значения.</p><h4>Default values:</h4><p><code>type FormDefaults&lt;T&gt; = {</code></p><p><code>  [K in keyof T]?: T[K]</code></p><p><code>}</code></p><p>Начальные значения с правильными типами.</p><h4>Преимущества:</h4><p><strong>Автоматическая синхронизация:</strong> Изменили модель — формы обновились.</p><p><strong>Type safety:</strong> Нельзя создать error для несуществующего поля.</p><p><strong>IntelliSense:</strong> Автодополнение для всех полей формы.</p><p><em>Применение:</em> React Hook Form, Formik, кастомные form libraries.</p>",
    difficulty: 'middle',
    tags: ['mapped types', 'формы', 'validation', 'React', 'практика']
  },
  {
    id: 104,
    question: "Какие паттерны mapped types используются в популярных библиотеках?",
    answer: "<p>Популярные библиотеки активно используют <strong>advanced mapped types паттерны</strong>:</p><h4>React Query:</h4><p><strong>Query keys mapping:</strong></p><p><code>type QueryResult&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: UseQueryResult&lt;T[K]&gt;</code></p><p><code>}</code></p><p>Каждый query key → правильный тип результата.</p><h4>Redux Toolkit:</h4><p><strong>Action creators из reducers:</strong></p><p><code>type ActionCreators&lt;Reducers&gt; = {</code></p><p><code>  [K in keyof Reducers]: Reducers[K] extends (state: any, action: infer A) =&gt; any ? A : never</code></p><p><code>}</code></p><p>Автоматический вывод action types из reducers.</p><h4>Prisma ORM:</h4><p><strong>Select и include:</strong> Mapped types для выбора полей и связей в запросах.</p><p><strong>Partial updates:</strong> <code>UpdateInput&lt;Model&gt;</code> — все поля опциональны с правильными типами.</p><h4>tRPC:</h4><p><strong>Router type inference:</strong> Mapped types создают client types из server router definition.</p><p><strong>End-to-end type safety:</strong> Изменение API автоматически обновляет client types.</p><h4>Zod validation:</h4><p><strong>Schema to TypeScript:</strong> <code>z.infer&lt;Schema&gt;</code> использует mapped types для извлечения TypeScript типа из Zod схемы.</p><h4>Общие паттерны:</h4><p><strong>API client generation:</strong> Types из OpenAPI specs.</p><p><strong>GraphQL codegen:</strong> Schema → TypeScript types.</p><p><em>Тренд:</em> Mapped types — foundation для type-safe runtime-to-compile-time bridges.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'библиотеки', 'паттерны', 'real world', 'примеры']
  },
  {
    id: 105,
    question: "Каковы ограничения и performance considerations для mapped types?",
    answer: "<p>Mapped types имеют <strong>практические ограничения</strong>:</p><h4>Глубина рекурсии:</h4><p><strong>TypeScript limit:</strong> Существует максимальная глубина рекурсивных типов (~50 уровней).</p><p><strong>Проблема:</strong> <code>DeepReadonly</code> на очень вложенных структурах может hit the limit.</p><p><strong>Решение:</strong> Явное ограничение глубины или использование более простых типов.</p><h4>Compile time performance:</h4><p><strong>Сложные mapped types медленны:</strong> Комбинация recursive + conditional + template literals замедляет tsc значительно.</p><p><strong>Измерение:</strong> Проверяйте время компиляции при добавлении сложных типов.</p><p><strong>Оптимизация:</strong> Type caching через type aliases, упрощение условий.</p><h4>Потеря информации:</h4><p><strong>Index signatures:</strong> Теряются при некоторых трансформациях.</p><p><strong>Методы с this:</strong> Могут сломаться при маппинге.</p><p><strong>Brands и nominal types:</strong> Теряются при mapped трансформациях.</p><h4>IDE performance:</h4><p><strong>IntelliSense lag:</strong> Очень сложные mapped types тормозят автодополнение.</p><p><strong>Hover tooltips:</strong> Развернутые типы могут быть огромными и нечитаемыми.</p><h4>Best practices:</h4><p><strong>Используйте умеренно:</strong> Не создавайте mapped types где можно обойтись проще.</p><p><strong>Тестируйте performance:</strong> Проверяйте влияние на compile time.</p><p><strong>Документируйте сложные типы:</strong> Комментарии объясняют что делает mapped type.</p><p><em>Balance:</em> Мощь mapped types vs простота и производительность.</p>",
    difficulty: 'senior',
    tags: ['mapped types', 'ограничения', 'performance', 'оптимизация', 'best practices']
  },
  {
    id: 106,
    question: "Что такое conditional types в TypeScript и чем они отличаются от обычных типов?",
    answer: "<p>Conditional types — это <strong>типы с условной логикой</strong>, позволяющие выбирать тип на основе условия:</p><h4>Суть механизма:</h4><p><strong>Тернарный оператор для типов:</strong> <code>T extends U ? X : Y</code> — если T расширяет U, результат X, иначе Y.</p><p><strong>Вычисление на этапе компиляции:</strong> TypeScript анализирует условие и выбирает соответствующий тип.</p><h4>Отличие от обычных типов:</h4><p><strong>Обычные типы статичны:</strong> <code>type Result = string</code> — всегда string.</p><p><strong>Conditional динамичны:</strong> <code>type Result&lt;T&gt; = T extends string ? number : boolean</code> — тип зависит от T.</p><h4>Зачем нужны:</h4><p><strong>Type-level логика:</strong> Принимать решения о типах на основе других типов.</p><p><strong>Гибкие API:</strong> Разные возвращаемые типы в зависимости от входных параметров.</p><p><strong>Utility types:</strong> Основа для Pick, Omit, ReturnType и других встроенных утилит.</p><h4>Базовый пример:</h4><p><code>type IsString&lt;T&gt; = T extends string ? 'yes' : 'no'</code></p><p><code>type A = IsString&lt;string&gt; // 'yes'</code></p><p><code>type B = IsString&lt;number&gt; // 'no'</code></p><p><em>Философия:</em> Conditional types делают TypeScript языком программирования на уровне типов.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'основы', 'extends', 'type-level программирование']
  },
  {
    id: 107,
    question: "Как работает extends в контексте conditional types?",
    answer: "<p>Extends в conditional types — это <strong>проверка на совместимость</strong> типов:</p><h4>Механизм проверки:</h4><p><strong>T extends U:</strong> Проверяет, является ли T подтипом U или совместим ли с ним.</p><p><strong>Структурная совместимость:</strong> TypeScript смотрит на структуру, не на имена типов.</p><h4>Что значит 'extends':</h4><p><strong>Для примитивов:</strong> <code>string extends string | number</code> — true, string входит в union.</p><p><strong>Для объектов:</strong> <code>{ a: string, b: number } extends { a: string }</code> — true, есть все обязательные свойства.</p><p><strong>Для функций:</strong> Проверка совместимости сигнатур с учетом contravariance параметров.</p><h4>Отличие от обычного extends:</h4><p><strong>В интерфейсах:</strong> Extends означает наследование — добавление свойств.</p><p><strong>В conditional:</strong> Extends — это проверка, является ли тип подтипом.</p><h4>Примеры проверок:</h4><p><code>'hello' extends string</code> — true (literal расширяет base type)</p><p><code>never extends string</code> — true (never подтип всего)</p><p><code>string extends 'hello'</code> — false (base type не расширяет literal)</p><h4>С generics:</h4><p><strong>Проверка параметра:</strong> <code>T extends object ? 'object' : 'primitive'</code> — различаем объекты и примитивы.</p><p><em>Важно:</em> Extends проверяет assignability — можно ли T присвоить U.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'extends', 'совместимость типов', 'type checking']
  },
  {
    id: 108,
    question: "Что такое distributive conditional types и как они работают?",
    answer: "<p>Distributive conditional types автоматически <strong>распределяются по union типам</strong>:</p><h4>Механизм распределения:</h4><p><strong>Naked type parameter:</strong> Если T не обернут (например <code>T extends U</code>, не <code>[T] extends [U]</code>), conditional распределяется.</p><p><strong>Применение к каждому:</strong> <code>T extends U ? X : Y</code> где T — union, применится к каждому члену отдельно.</p><h4>Пример распределения:</h4><p><code>type ToArray&lt;T&gt; = T extends any ? T[] : never</code></p><p><code>type Result = ToArray&lt;string | number&gt;</code></p><p><strong>Результат:</strong> <code>string[] | number[]</code>, не <code>(string | number)[]</code></p><h4>Как это работает:</h4><p><strong>Шаг 1:</strong> TypeScript видит union в naked параметре.</p><p><strong>Шаг 2:</strong> Разбивает на <code>ToArray&lt;string&gt; | ToArray&lt;number&gt;</code></p><p><strong>Шаг 3:</strong> Вычисляет каждый отдельно и объединяет результаты.</p><h4>Отключение распределения:</h4><p><strong>Обернуть в tuple:</strong> <code>[T] extends [U] ? X : Y</code> — больше не распределяется.</p><p><code>type NoDistribute&lt;T&gt; = [T] extends [any] ? T[] : never</code></p><p><code>NoDistribute&lt;string | number&gt;</code> даст <code>(string | number)[]</code></p><h4>Практическое применение:</h4><p><strong>Фильтрация union:</strong> Exclude, Extract используют distributive поведение.</p><p><strong>Трансформация вариантов:</strong> Разная обработка для каждого типа в union.</p><p><em>Ключевое:</em> Distributive — это default поведение, его нужно явно отключать если не нужно.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'distributive', 'union types', 'распределение']
  },
  {
    id: 109,
    question: "Что такое infer ключевое слово и как его использовать?",
    answer: "<p>Infer позволяет <strong>извлекать и захватывать типы</strong> внутри conditional types:</p><h4>Базовый синтаксис:</h4><p><strong>Объявление переменной типа:</strong> <code>T extends SomeType&lt;infer U&gt; ? U : never</code></p><p><strong>Захват типа:</strong> U становится извлеченным типом из структуры.</p><h4>Классический пример — ReturnType:</h4><p><code>type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never</code></p><p><strong>Проверка функции:</strong> T extends функцию?</p><p><strong>Захват возврата:</strong> infer R захватывает тип возвращаемого значения.</p><p><strong>Результат:</strong> R если функция, never если нет.</p><h4>Извлечение из массивов:</h4><p><code>type ElementType&lt;T&gt; = T extends (infer U)[] ? U : never</code></p><p><code>ElementType&lt;string[]&gt;</code> даст <code>string</code></p><h4>Множественные infer:</h4><p><strong>Несколько захватов:</strong> <code>T extends (infer A, infer B) =&gt; infer C</code></p><p><strong>Разные позиции:</strong> Можно захватывать параметры, возврат, элементы tuple одновременно.</p><h4>Особенности:</h4><p><strong>Область видимости:</strong> Infer переменная доступна только в true ветке conditional.</p><p><strong>Вывод типа:</strong> TypeScript сам определяет наиболее подходящий тип для infer.</p><p><em>Применение:</em> Извлечение типов из Promise, функций, массивов, generic типов.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'infer', 'извлечение типов', 'type inference']
  },
  {
    id: 110,
    question: "Как создать тип Flatten для распаковки массивов и примитивов?",
    answer: "<p>Flatten использует <strong>conditional type для различения массивов</strong>:</p><h4>Базовая реализация:</h4><p><code>type Flatten&lt;T&gt; = T extends any[] ? T[number] : T</code></p><p><strong>Проверка массива:</strong> T extends any[] — является ли T массивом.</p><p><strong>Извлечение элемента:</strong> T[number] — тип элементов массива.</p><p><strong>Иначе как есть:</strong> Примитив остается без изменений.</p><h4>Как работает T[number]:</h4><p><strong>Indexed access:</strong> [number] получает тип всех числовых индексов массива.</p><p><strong>Для массива:</strong> <code>string[][number]</code> даст <code>string</code></p><p><strong>Union элементов:</strong> <code>[string, number][number]</code> даст <code>string | number</code></p><h4>Примеры использования:</h4><p><code>Flatten&lt;string[]&gt;</code> → <code>string</code></p><p><code>Flatten&lt;number&gt;</code> → <code>number</code></p><p><code>Flatten&lt;[boolean, string]&gt;</code> → <code>boolean | string</code></p><h4>Альтернатива с infer:</h4><p><code>type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T</code></p><p><strong>Более явно:</strong> Захватываем тип элемента через infer.</p><p><strong>Эквивалентно:</strong> Работает так же, но синтаксис другой.</p><h4>Deep Flatten:</h4><p>Для рекурсивной распаковки вложенных массивов нужна рекурсия — <code>T extends Array&lt;infer U&gt; ? Flatten&lt;U&gt; : T</code></p><p><em>Применение:</em> Работа с динамическими данными, утилиты для массивов.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'Flatten', 'массивы', 'indexed access', 'практика']
  },
  {
    id: 111,
    question: "Как использовать conditional types для фильтрации union типов?",
    answer: "<p>Conditional types идеальны для <strong>фильтрации членов union</strong>:</p><h4>Exclude реализация:</h4><p><code>type MyExclude&lt;T, U&gt; = T extends U ? never : T</code></p><p><strong>Distributive применение:</strong> Проверяется каждый член T отдельно.</p><p><strong>Never исключает:</strong> Члены расширяющие U становятся never и удаляются из union.</p><h4>Пример работы:</h4><p><code>type Result = MyExclude&lt;'a' | 'b' | 'c', 'a' | 'c'&gt;</code></p><p><strong>Распределение:</strong> <code>('a' extends 'a'|'c' ? never : 'a') | ('b' extends ...) | ('c' extends ...)</code></p><p><strong>Результат:</strong> <code>never | 'b' | never</code> = <code>'b'</code></p><h4>Extract реализация:</h4><p><code>type MyExtract&lt;T, U&gt; = T extends U ? T : never</code></p><p><strong>Обратная логика:</strong> Оставляем только совпадающие типы.</p><h4>NonNullable:</h4><p><code>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T</code></p><p>Убираем null и undefined из union.</p><h4>Фильтрация по структуре:</h4><p><code>type FilterByType&lt;T, U&gt; = T extends U ? T : never</code></p><p>Оставляем только типы совместимые с U.</p><h4>Практические паттерны:</h4><p><strong>Функции из объекта:</strong> Оставить только функциональные свойства.</p><p><strong>Опциональные поля:</strong> Извлечь только optional свойства.</p><p><em>Мощь:</em> Distributive поведение делает фильтрацию тривиальной.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'фильтрация', 'union types', 'Exclude', 'Extract']
  },
  {
    id: 112,
    question: "Как создать условный тип для извлечения типа возвращаемого значения Promise?",
    answer: "<p>Unwrapping Promise требует <strong>вложенных conditional с infer</strong>:</p><h4>Базовая реализация Awaited:</h4><p><code>type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T</code></p><p><strong>Проверка Promise:</strong> Является ли T промисом.</p><p><strong>Извлечение типа:</strong> infer U захватывает тип resolved значения.</p><p><strong>Иначе как есть:</strong> Не промис возвращается без изменений.</p><h4>Проблема с вложенными Promise:</h4><p><code>Promise&lt;Promise&lt;string&gt;&gt;</code> распакуется только на один уровень.</p><p><strong>Результат:</strong> <code>Promise&lt;string&gt;</code>, не <code>string</code></p><h4>Рекурсивный Awaited:</h4><p><code>type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? Awaited&lt;U&gt; : T</code></p><p><strong>Рекурсивный вызов:</strong> Продолжаем unwrap пока не останется Promise.</p><p><strong>Глубокая распаковка:</strong> <code>Promise&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;</code> → <code>string</code></p><h4>Edge cases:</h4><p><strong>PromiseLike:</strong> <code>T extends PromiseLike&lt;infer U&gt;</code> — для thenable объектов.</p><p><strong>Never и unknown:</strong> Обработка специальных типов.</p><h4>Примеры использования:</h4><p><code>type Result = Awaited&lt;Promise&lt;User&gt;&gt;</code> → <code>User</code></p><p><code>type DeepResult = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;</code> → <code>number</code></p><p><em>Применение:</em> Типизация async функций, wrapper типов для промисов.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'Promise', 'Awaited', 'infer', 'рекурсия']
  },
  {
    id: 113,
    question: "Как работают вложенные conditional types и какие паттерны они открывают?",
    answer: "<p>Вложенные conditional создают <strong>сложные деревья решений</strong> для типов:</p><h4>Базовая структура:</h4><p><code>type Check&lt;T&gt; = T extends A ? X : T extends B ? Y : T extends C ? Z : Default</code></p><p><strong>Цепочка проверок:</strong> Последовательно проверяем условия.</p><p><strong>Else-if паттерн:</strong> Как switch для типов.</p><h4>Классификация типов:</h4><p><code>type TypeName&lt;T&gt; =</code></p><p><code>  T extends string ? 'string' :</code></p><p><code>  T extends number ? 'number' :</code></p><p><code>  T extends boolean ? 'boolean' :</code></p><p><code>  T extends Function ? 'function' : 'object'</code></p><h4>Глубокая проверка структуры:</h4><p><code>type DeepCheck&lt;T&gt; =</code></p><p><code>  T extends Array&lt;infer U&gt; ? DeepCheck&lt;U&gt;[] :</code></p><p><code>  T extends object ? { [K in keyof T]: DeepCheck&lt;T[K]&gt; } : T</code></p><p>Рекурсивная трансформация всех уровней.</p><h4>Комбинация с mapped types:</h4><p><strong>Conditional в mapping:</strong> Разная обработка свойств по их типу.</p><p><strong>Nested transformations:</strong> Mapped внутри conditional внутри mapped.</p><h4>Практические паттерны:</h4><p><strong>Type routing:</strong> Разные типы для разных входных данных.</p><p><strong>Validation types:</strong> Проверка корректности структуры данных на уровне типов.</p><p><strong>Serialization:</strong> Определение как сериализовать разные типы.</p><h4>Ограничения:</h4><p><strong>Читаемость:</strong> Глубокие вложения сложны для понимания.</p><p><strong>Performance:</strong> Замедляют компиляцию при излишней сложности.</p><p><em>Совет:</em> Используйте промежуточные type aliases для упрощения сложных conditional.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'вложенность', 'паттерны', 'сложные типы']
  },
  {
    id: 114,
    question: "Как создать conditional type для определения readonly свойств объекта?",
    answer: "<p>Определение readonly требует <strong>проверки модификаторов</strong> через conditional:</p><h4>ReadonlyKeys реализация:</h4><p><code>type ReadonlyKeys&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: Equal&lt;Pick&lt;T, K&gt;, Readonly&lt;Pick&lt;T, K&gt;&gt;&gt; extends true ? K : never</code></p><p><code>}[keyof T]</code></p><p><strong>Проверка equality:</strong> Сравниваем оригинальное и readonly свойство.</p><p><strong>Извлечение ключей:</strong> [keyof T] превращает mapped type в union ключей.</p><h4>Вспомогательный Equal type:</h4><p><code>type Equal&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : false</code></p><p><strong>Точная проверка:</strong> Проверяет полную эквивалентность типов.</p><h4>Альтернативный подход:</h4><p>Использовать <code>-readonly</code> в mapped type и проверять изменения.</p><h4>WritableKeys:</h4><p><code>type WritableKeys&lt;T&gt; = {</code></p><p><code>  [K in keyof T]: Equal&lt;Pick&lt;T, K&gt;, Readonly&lt;Pick&lt;T, K&gt;&gt;&gt; extends false ? K : never</code></p><p><code>}[keyof T]</code></p><p>Обратная логика для writable свойств.</p><h4>Применение:</h4><p><strong>Фильтрация объекта:</strong> <code>Pick&lt;T, ReadonlyKeys&lt;T&gt;&gt;</code> — только readonly свойства.</p><p><strong>Validation:</strong> Проверка что все нужные поля readonly.</p><p><em>Сложность:</em> TypeScript не предоставляет прямого способа проверки модификаторов.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'readonly', 'модификаторы', 'проверка свойств']
  },
  {
    id: 115,
    question: "Как использовать conditional types для создания type-safe builder pattern?",
    answer: "<p>Builder pattern с conditional создает <strong>типы зависящие от вызовов</strong>:</p><h4>Accumulating type паттерн:</h4><p><code>type Builder&lt;T = {}&gt; = {</code></p><p><code>  set&lt;K extends string, V&gt;(key: K, value: V): Builder&lt;T & Record&lt;K, V&gt;&gt;</code></p><p><code>  build(): T</code></p><p><code>}</code></p><p><strong>Generic accumulator:</strong> T накапливает добавленные свойства.</p><p><strong>Intersection расширяет:</strong> Каждый set добавляет новое поле.</p><h4>Conditional для обязательных полей:</h4><p><code>type RequiredBuilder&lt;T, Required extends keyof T&gt; = {</code></p><p><code>  set&lt;K extends keyof T&gt;(key: K, value: T[K]): RequiredBuilder&lt;T, Exclude&lt;Required, K&gt;&gt;</code></p><p><code>  build(): Required extends never ? T : 'Missing required fields'</code></p><p><code>}</code></p><p><strong>Отслеживание required:</strong> Generic Required уменьшается с каждым set.</p><p><strong>Conditional build:</strong> build работает только когда Required = never.</p><h4>Readonly после build:</h4><p><code>build(): Readonly&lt;T&gt;</code></p><p>Результат иммутабелен после построения.</p><h4>Опциональные методы:</h4><p><code>type ConditionalMethods&lt;T&gt; =</code></p><p><code>  'email' extends keyof T ? { sendEmail(): void } : {}</code></p><p>Методы появляются только при наличии полей.</p><h4>Практический пример:</h4><p>Каждый метод возвращает новый тип, TypeScript отслеживает что было установлено.</p><p><em>Преимущество:</em> Compile-time проверка что все обязательные поля заполнены.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'builder pattern', 'type safety', 'паттерны']
  },
  {
    id: 116,
    question: "Какие проблемы возникают при работе с conditional types и как их решать?",
    answer: "<p>Conditional types имеют <strong>специфические подводные камни</strong>:</p><h4>Circular constraints:</h4><p><strong>Проблема:</strong> <code>type A&lt;T&gt; = T extends A&lt;T&gt; ? X : Y</code> — циклическая ссылка.</p><p><strong>Ошибка компиляции:</strong> TypeScript не может разрешить такие типы.</p><p><strong>Решение:</strong> Пересмотреть логику, использовать промежуточные типы.</p><h4>Too complex для inference:</h4><p><strong>TypeScript сдается:</strong> Очень сложные conditional могут не выводиться автоматически.</p><p><strong>Решение:</strong> Явное указание generic параметров, упрощение типов.</p><h4>Unexpected distributive behavior:</h4><p><strong>Union распределяется:</strong> Когда не нужно, получаем неожиданные результаты.</p><p><strong>Решение:</strong> Оборачивать в tuple — <code>[T] extends [U]</code></p><h4>Never edge cases:</h4><p><strong>Never extends everything:</strong> <code>never extends any</code> всегда true.</p><p><strong>Пустой union:</strong> Distributive conditional над never дает never.</p><p><strong>Решение:</strong> Явная проверка на never если это важно.</p><h4>Performance degradation:</h4><p><strong>Глубокие conditional медленны:</strong> Особенно с рекурсией и infer.</p><p><strong>IDE lag:</strong> Hover tooltips могут тормозить.</p><p><strong>Решение:</strong> Кэширование через type aliases, ограничение глубины.</p><h4>Debugging сложность:</h4><p><strong>Неочевидные результаты:</strong> Трудно понять почему тип такой.</p><p><strong>Решение:</strong> Разбивать на промежуточные типы, тестировать отдельно.</p><p><em>Best practice:</em> Держите conditional types максимально простыми и понятными.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'проблемы', 'решения', 'debugging', 'performance']
  },
  {
    id: 117,
    question: "Как создать conditional type для проверки равенства типов?",
    answer: "<p>Проверка точного равенства типов требует <strong>специальной техники</strong>:</p><h4>Наивный подход не работает:</h4><p><code>T extends U && U extends T</code> недостаточно — <code>any</code> проходит все проверки.</p><h4>Правильная реализация IsEqual:</h4><p><code>type IsEqual&lt;X, Y&gt; =</code></p><p><code>  (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2)</code></p><p><code>    ? true : false</code></p><p><strong>Generic функции:</strong> Создаем два типа функций с conditional.</p><p><strong>Structural equality:</strong> Функции равны только если X и Y полностью идентичны.</p><h4>Почему это работает:</h4><p><strong>Contravariance:</strong> TypeScript проверяет функции особым образом.</p><p><strong>Exact match:</strong> Даже <code>any</code> и <code>unknown</code> различаются.</p><h4>Примеры использования:</h4><p><code>IsEqual&lt;string, string&gt;</code> → <code>true</code></p><p><code>IsEqual&lt;string, any&gt;</code> → <code>false</code></p><p><code>IsEqual&lt;{ a: string }, { a: string }&gt;</code> → <code>true</code></p><h4>Применение:</h4><p><strong>Тестирование типов:</strong> Проверка что utility type дает правильный результат.</p><p><strong>Conditional логика:</strong> Разное поведение для точно совпадающих типов.</p><p><strong>Type assertions:</strong> Compile-time проверки корректности типов.</p><h4>Ограничения:</h4><p><strong>Complex types:</strong> Для очень сложных типов может не работать идеально.</p><p><em>Использование:</em> Редко в production коде, часто в type testing libraries.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'equality', 'проверка типов', 'advanced']
  },
  {
    id: 118,
    question: "Как работает never в контексте conditional types?",
    answer: "<p>Never в conditional types имеет <strong>специальное поведение</strong>:</p><h4>Never как bottom type:</h4><p><strong>Подтип всех типов:</strong> <code>never extends any</code> всегда true.</p><p><strong>Ничто не extends never:</strong> <code>string extends never</code> всегда false (кроме самого never).</p><h4>Distributive и never:</h4><p><strong>Пустой union:</strong> <code>T extends U ? X : Y</code> где T = never → результат never.</p><p><strong>Не распределяется:</strong> Never union пуст, нечего распределять.</p><p><strong>Пример:</strong> <code>Exclude&lt;never, any&gt;</code> → <code>never</code></p><h4>Never для исключения:</h4><p><strong>В mapped types:</strong> Ключи с never значением удаляются.</p><p><strong>В unions:</strong> Never исчезает из union — <code>string | never</code> = <code>string</code></p><h4>Проверка на never:</h4><p><code>type IsNever&lt;T&gt; = [T] extends [never] ? true : false</code></p><p><strong>Обертка в tuple:</strong> Иначе distributive поведение даст неправильный результат.</p><h4>Практические паттерны:</h4><p><strong>Фильтрация:</strong> Возврат never удаляет элементы из результата.</p><p><strong>Exhaustive checking:</strong> После обработки всех вариантов остается never.</p><p><strong>Impossible states:</strong> Never маркирует недостижимые состояния.</p><h4>Edge case:</h4><p><code>never extends never</code> → true, но distributive над never → never</p><p><em>Важно:</em> Never — это отсутствие типа, empty set в теории типов.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'never', 'distributive', 'edge cases']
  },
  {
    id: 119,
    question: "Как использовать conditional types для создания branded types?",
    answer: "<p>Conditional types помогают создавать <strong>nominal typing через brands</strong>:</p><h4>Базовая brand структура:</h4><p><code>type Brand&lt;T, B&gt; = T & { __brand: B }</code></p><p><strong>Phantom field:</strong> __brand существует только на уровне типов.</p><p><strong>Nominal typing:</strong> Два типа с разными brands различаются.</p><h4>Conditional для брендирования:</h4><p><code>type Branded&lt;T, B&gt; =</code></p><p><code>  T extends string | number ? T & { __brand: B } : never</code></p><p><strong>Ограничение типов:</strong> Только примитивы могут быть branded.</p><h4>Smart constructor:</h4><p><code>type UserId = Branded&lt;string, 'UserId'&gt;</code></p><p><code>type PostId = Branded&lt;string, 'PostId'&gt;</code></p><p><strong>Type safety:</strong> <code>UserId</code> нельзя присвоить <code>PostId</code> несмотря на одинаковую структуру.</p><h4>Conditional unwrapping:</h4><p><code>type Unbrand&lt;T&gt; =</code></p><p><code>  T extends Brand&lt;infer U, any&gt; ? U : T</code></p><p>Извлекаем оригинальный тип из branded.</p><h4>Validation через conditional:</h4><p><code>type ValidEmail&lt;T&gt; =</code></p><p><code>  T extends `${string}@${string}.${string}` ? Branded&lt;T, 'Email'&gt; : never</code></p><p>Template literal проверяет формат email.</p><h4>Практическое применение:</h4><p><strong>IDs различных сущностей:</strong> UserId, ProductId — нельзя перепутать.</p><p><strong>Validated strings:</strong> Email, URL, UUID с проверкой формата.</p><p><em>Преимущество:</em> Compile-time защита от смешивания похожих но разных типов.</p>",
    difficulty: 'senior',
    tags: ['conditional types', 'branded types', 'nominal typing', 'type safety']
  },
  {
    id: 120,
    question: "Когда следует использовать conditional types вместо union types или overloads?",
    answer: "<p>Выбор между подходами зависит от <strong>характера задачи</strong>:</p><h4>Используйте conditional когда:</h4><p><strong>Связь входа и выхода:</strong> Тип возврата зависит от типа параметра динамически.</p><p><strong>Трансформация типов:</strong> Нужно преобразовать один тип в другой на основе условий.</p><p><strong>Generic constraints:</strong> Разные ограничения для разных случаев.</p><h4>Используйте union когда:</h4><p><strong>Фиксированный набор:</strong> Значение может быть одним из известных вариантов.</p><p><strong>Discriminated unions:</strong> Разные структуры с общим discriminator полем.</p><p><strong>Простота важнее:</strong> Union проще понять и поддерживать.</p><h4>Используйте overloads когда:</h4><p><strong>Разная логика:</strong> Каждый вариант параметров имеет свою реализацию.</p><p><strong>Читаемость API:</strong> Overloads четко показывают все варианты использования.</p><p><strong>Документация:</strong> IDE показывает каждую сигнатуру отдельно.</p><h4>Сравнение примеров:</h4><p><strong>Conditional:</strong> <code>T extends string ? number : boolean</code> — динамический выбор.</p><p><strong>Union:</strong> <code>string | number</code> — статичный набор.</p><p><strong>Overload:</strong> <code>fn(x: string): number; fn(x: number): boolean</code> — явные варианты.</p><h4>Комбинирование:</h4><p>Можно использовать conditional внутри overload или для генерации union типов.</p><p><em>Правило:</em> Conditional для type-level логики, union/overload для явных вариантов API.</p>",
    difficulty: 'middle',
    tags: ['conditional types', 'union types', 'overloads', 'выбор подхода', 'сравнение']
  }
];
