export interface TSQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const tsInterviewQuestions: TSQuestion[] = [
  {
    id: 1,
    question: "Какие основные преимущества TypeScript перед JavaScript вы можете назвать?",
    answer: "<p>TypeScript предоставляет несколько <strong>ключевых преимуществ</strong> по сравнению с обычным JavaScript:</p><h4>Статическая типизация:</h4><p><strong>Раннее обнаружение ошибок</strong> — большинство ошибок выявляются на этапе разработки, а не в production. Это особенно критично для крупных проектов.</p><h4>Улучшенная поддержка IDE:</h4><p><strong>Автодополнение и IntelliSense</strong> работают на порядок лучше благодаря информации о типах. Рефакторинг становится безопаснее и быстрее.</p><h4>Документация кода:</h4><p>Типы служат <strong>встроенной документацией</strong> — не нужно гадать, какие параметры принимает функция и что она возвращает.</p><h4>Масштабируемость:</h4><p>TypeScript делает код <strong>более предсказуемым</strong> в больших командах и проектах. Легче понимать код, написанный другими разработчиками.</p><h4>Современный JavaScript:</h4><p>Возможность использовать <strong>новейшие возможности JS</strong> с компиляцией в старые версии для совместимости.</p><p><em>Результат:</em> Меньше багов, быстрая разработка, лучшая поддержка кода.</p>",
    difficulty: 'junior',
    tags: ['преимущества', 'TypeScript', 'основы']
  },
  {
    id: 2,
    question: "Какие недостатки или сложности использования TypeScript вы можете выделить?",
    answer: "<p>При всех преимуществах, TypeScript имеет ряд <strong>недостатков и сложностей</strong>:</p><h4>Порог входа:</h4><p><strong>Кривая обучения</strong> — разработчикам нужно изучить систему типов, дженерики, advanced типы. Это требует времени.</p><h4>Время компиляции:</h4><p><strong>Дополнительный шаг сборки</strong> — код нужно компилировать перед запуском, что замедляет разработку больших проектов.</p><h4>Overhead для небольших проектов:</h4><p>Для <strong>маленьких скриптов или прототипов</strong> TypeScript может быть избыточным — больше времени на настройку, чем на реальную разработку.</p><h4>Ложное чувство безопасности:</h4><p>TypeScript проверяет типы только <strong>на этапе компиляции</strong> — runtime ошибки все еще возможны, особенно при работе с внешними API.</p><h4>Сложность типизации:</h4><p><strong>Типизация сложных библиотек</strong> может быть трудной. Иногда проще написать <code>any</code>, что сводит на нет преимущества TypeScript.</p><h4>Размер экосистемы:</h4><p>Не все библиотеки имеют <strong>качественные типы</strong> — приходится писать свои или использовать @types пакеты.</p>",
    difficulty: 'junior',
    tags: ['недостатки', 'TypeScript', 'сложности']
  },
  {
    id: 3,
    question: "Как TypeScript влияет на производительность разработки?",
    answer: "<p>Влияние TypeScript на производительность разработки <strong>неоднозначно</strong> и зависит от контекста:</p><h4>Замедление на старте:</h4><p><strong>Начальная настройка</strong> требует времени — конфигурация tsconfig, настройка путей, установка типов для библиотек.</p><p><strong>Написание типов</strong> замедляет первоначальную разработку — нужно явно описывать интерфейсы, типы параметров.</p><h4>Ускорение в долгосрочной перспективе:</h4><p><strong>Меньше времени на отладку</strong> — большинство ошибок ловятся до запуска приложения.</p><p><strong>Безопасный рефакторинг</strong> — изменения в коде сразу показывают, что сломалось. Не нужно искать все места использования вручную.</p><p><strong>Быстрая навигация</strong> — IDE мгновенно показывает определения, использования, сигнатуры функций.</p><h4>Факторы влияния:</h4><p><strong>Размер команды:</strong> В больших командах TypeScript ускоряет разработку значительно.</p><p><strong>Размер проекта:</strong> Для pet-проектов может быть overhead, для enterprise — необходимость.</p><p><em>Вывод:</em> Краткосрочно замедляет, долгосрочно ускоряет разработку.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'разработка', 'эффективность']
  },
  {
    id: 4,
    question: "В каких случаях использование TypeScript оправдано, а в каких — нет?",
    answer: "<p>Выбор TypeScript должен основываться на <strong>контексте проекта</strong>:</p><h4>TypeScript оправдан:</h4><p><strong>Крупные проекты:</strong> Где работает несколько разработчиков и кодовая база большая — типизация критична.</p><p><strong>Long-term проекты:</strong> Которые будут поддерживаться годами — типы служат документацией.</p><p><strong>Библиотеки и SDK:</strong> Публичные API выигрывают от типизации — пользователи получают автодополнение.</p><p><strong>Backend на Node.js:</strong> Где нет браузерной проверки и ошибки дороже.</p><p><strong>Работа с данными:</strong> Сложные data structures, API интеграции — типы предотвращают ошибки.</p><h4>TypeScript избыточен:</h4><p><strong>Прототипы и MVP:</strong> Когда важна скорость валидации идеи.</p><p><strong>Маленькие скрипты:</strong> Утилиты, однократные задачи — overhead не окупается.</p><p><strong>Простые landing pages:</strong> Минимум логики, много верстки.</p><p><strong>Команда не готова:</strong> Если разработчики не знают TypeScript — внедрение замедлит работу.</p><p><em>Золотое правило:</em> Если проект проживет дольше месяца и в нем больше 1000 строк — TypeScript оправдан.</p>",
    difficulty: 'middle',
    tags: ['применение', 'выбор технологии', 'контекст']
  },
  {
    id: 5,
    question: "Как TypeScript помогает в рефакторинге кода?",
    answer: "<p>TypeScript делает рефакторинг <strong>значительно безопаснее и быстрее</strong>:</p><h4>Автоматическое обнаружение проблем:</h4><p>При изменении сигнатуры функции или интерфейса TypeScript <strong>сразу показывает все места</strong>, где код сломался. Не нужно гадать или искать вручную.</p><h4>Уверенный rename:</h4><p><strong>Переименование переменных и функций</strong> работает безопасно — IDE находит все использования благодаря типам.</p><h4>Изменение структур данных:</h4><p>Если изменить интерфейс, компилятор <strong>укажет все места</strong>, где нужно обновить код для соответствия новой структуре.</p><h4>Удаление мертвого кода:</h4><p>TypeScript помогает найти <strong>неиспользуемый код</strong> — если функция нигде не вызывается, это видно по отсутствию ссылок.</p><h4>Безопасные эксперименты:</h4><p>Можно смело экспериментировать с архитектурой — <strong>типы сразу покажут</strong>, что сломалось и где нужны изменения.</p><p><em>Реальный пример:</em> Изменение API endpoint с 5 параметрами на объект с опциями — TypeScript покажет все 50+ вызовов, которые нужно обновить.</p>",
    difficulty: 'middle',
    tags: ['рефакторинг', 'поддержка кода', 'безопасность']
  },
  {
    id: 6,
    question: "Какие проблемы могут возникнуть при миграции JavaScript проекта на TypeScript?",
    answer: "<p>Миграция на TypeScript может встретить <strong>ряд серьезных вызовов</strong>:</p><h4>Технические сложности:</h4><p><strong>Legacy код:</strong> Старый JavaScript код может использовать паттерны, которые сложно типизировать — динамические свойства, monkey patching.</p><p><strong>Отсутствие типов для библиотек:</strong> Старые или малоизвестные библиотеки могут не иметь @types пакетов.</p><p><strong>Build процесс:</strong> Нужно настроить компиляцию, sourcemaps, интеграцию с существующими инструментами сборки.</p><h4>Временные затраты:</h4><p><strong>Постепенная миграция:</strong> Нельзя мигрировать все сразу — нужна стратегия постепенного перехода файл за файлом.</p><p><strong>Обучение команды:</strong> Разработчики должны изучить TypeScript, что отнимает время от основной работы.</p><h4>Организационные проблемы:</h4><p><strong>Сопротивление команды:</strong> Не все хотят менять привычный workflow.</p><p><strong>Снижение velocity:</strong> Первое время команда будет работать медленнее.</p><p><em>Решение:</em> Начинать с новых файлов, постепенно мигрировать критичные части, использовать <code>allowJs</code> для плавного перехода.</p>",
    difficulty: 'middle',
    tags: ['миграция', 'TypeScript', 'проблемы', 'переход']
  },
  {
    id: 7,
    question: "Как TypeScript влияет на размер финального бандла?",
    answer: "<p>Влияние TypeScript на размер бандла <strong>минимально или отсутствует</strong>:</p><h4>TypeScript компилируется в JavaScript:</h4><p>Типы существуют только <strong>на этапе разработки</strong> и полностью удаляются при компиляции. В production попадает чистый JavaScript.</p><h4>Потенциальное увеличение:</h4><p><strong>Polyfills и helper функции:</strong> TypeScript может добавлять вспомогательный код для эмуляции новых возможностей в старых браузерах — decorators, async/await.</p><p><strong>Импорт типов:</strong> Если случайно импортировать не только типы, но и runtime код из type-only модулей.</p><h4>Оптимизация:</h4><p><strong>importHelpers:</strong> Использование tslib для переиспользования helper функций вместо дублирования в каждом файле.</p><p><strong>Type-only imports:</strong> Явное указание <code>import type</code> гарантирует, что импорт не попадет в бандл.</p><p><strong>Tree shaking:</strong> Работает одинаково хорошо с TypeScript и JavaScript при правильной настройке.</p><p><em>Вывод:</em> TypeScript сам по себе не увеличивает размер бандла — важнее настройки компиляции и bundler'а.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'бандл', 'оптимизация']
  },
  {
    id: 8,
    question: "Какие альтернативы TypeScript существуют и в чем их отличия?",
    answer: "<p>Существует несколько <strong>альтернативных подходов</strong> к типизации JavaScript:</p><h4>Flow:</h4><p><strong>Разработан Facebook</strong> — похож на TypeScript, но менее популярен. Основное отличие — более строгая система типов, но меньше community поддержки.</p><h4>JSDoc:</h4><p><strong>Типизация через комментарии</strong> — позволяет добавлять типы в обычный JavaScript без компиляции. Поддерживается в VS Code, но менее мощная, чем TypeScript.</p><h4>ReScript (ex ReasonML):</h4><p><strong>Функциональный язык</strong>, компилирующийся в JavaScript — более строгая система типов, но радикально отличается синтаксисом.</p><h4>Dart:</h4><p><strong>Альтернативный язык</strong> от Google — собственная экосистема, используется в Flutter, но не популярен для веб-разработки.</p><h4>Vanilla JavaScript + ESLint:</h4><p><strong>Без явной типизации</strong> — полагается на линтинг и тесты. Подходит для небольших проектов.</p><p><em>Позиция TypeScript:</em> Наиболее популярная и поддерживаемая альтернатива с огромной экосистемой, постепенным adoption и отличной интеграцией с существующим JS.</p>",
    difficulty: 'senior',
    tags: ['альтернативы', 'сравнение', 'Flow', 'JSDoc']
  },
  {
    id: 9,
    question: "Как TypeScript справляется с динамической природой JavaScript?",
    answer: "<p>TypeScript предлагает <strong>компромисс между безопасностью и гибкостью</strong>:</p><h4>Escape hatches:</h4><p><strong>Type any:</strong> Позволяет отключить проверку типов когда это необходимо — работа с legacy кодом, сложные динамические структуры.</p><p><strong>Type unknown:</strong> Более безопасная альтернатива any — требует явной проверки перед использованием.</p><p><strong>Type assertions:</strong> Возможность явно указать тип, когда разработчик знает больше компилятора.</p><h4>Advanced типы:</h4><p><strong>Union types:</strong> Тип может быть одним из нескольких вариантов — моделирует динамическое поведение безопасно.</p><p><strong>Type guards:</strong> Сужение типов через runtime проверки — <code>typeof</code>, <code>instanceof</code>.</p><p><strong>Conditional types:</strong> Типы, которые меняются в зависимости от условий — мощный инструмент для сложной логики.</p><h4>Проблемные области:</h4><p><strong>Prototype manipulation:</strong> Динамическое добавление свойств сложно типизировать.</p><p><strong>eval и dynamic code:</strong> Невозможно статически проверить.</p><p><em>Философия:</em> TypeScript не борется с динамичностью JS, а предоставляет инструменты для безопасной работы с ней.</p>",
    difficulty: 'senior',
    tags: ['типизация', 'динамичность', 'гибкость', 'advanced types']
  },
  {
    id: 10,
    question: "Какие проблемы с типизацией третьесторонних библиотек вы встречали?",
    answer: "<p>Работа с типами сторонних библиотек часто вызывает <strong>специфические проблемы</strong>:</p><h4>Отсутствие типов:</h4><p><strong>Старые библиотеки</strong> могут не иметь TypeScript поддержки вообще — приходится писать свои <code>.d.ts</code> файлы или использовать <code>any</code>.</p><h4>Неточные типы:</h4><p><strong>@types пакеты</strong> могут отставать от реальной библиотеки или содержать ошибки. Типы пишут энтузиасты, не авторы библиотеки.</p><h4>Конфликты версий:</h4><p><strong>Несоответствие версий</strong> между библиотекой и @types пакетом может приводить к неправильным типам.</p><h4>Слишком строгие типы:</h4><p>Некоторые библиотеки типизированы <strong>слишком строго</strong>, не позволяя делать валидные, но не предусмотренные автором вещи.</p><h4>Generic hell:</h4><p><strong>Сложная generic типизация</strong> в библиотеках типа RxJS или Redux может быть трудна для понимания и использования.</p><h4>Решения:</h4><p>Использование <strong>module augmentation</strong> для расширения типов, создание своих type wrappers, contributing в DefinitelyTyped.</p><p><em>Практика:</em> Важно проверять качество типов библиотеки перед использованием в проекте.</p>",
    difficulty: 'senior',
    tags: ['библиотеки', 'типизация', 'проблемы', '@types']
  },
  {
    id: 11,
    question: "Как TypeScript влияет на время сборки проекта?",
    answer: "<p>TypeScript может <strong>заметно влиять на время сборки</strong>, особенно в больших проектах:</p><h4>Факторы замедления:</h4><p><strong>Type checking:</strong> Проверка типов требует времени — чем сложнее типы и больше файлов, тем дольше компиляция.</p><p><strong>Incremental compilation:</strong> Первая сборка может быть очень долгой, последующие быстрее благодаря кэшированию.</p><p><strong>Сложные типы:</strong> Advanced types, глубокие generic типы, сложные conditional types замедляют компиляцию значительно.</p><h4>Оптимизация:</h4><p><strong>Project references:</strong> Разделение проекта на подпроекты ускоряет сборку через параллелизацию.</p><p><strong>skipLibCheck:</strong> Пропуск проверки типов в node_modules ускоряет компиляцию, но может скрыть ошибки.</p><p><strong>Isolatedmodules:</strong> Упрощает компиляцию, позволяя обрабатывать файлы независимо.</p><p><strong>Использование esbuild/swc:</strong> Альтернативные компиляторы быстрее tsc, но не проверяют типы.</p><h4>Практический подход:</h4><p>Использовать <strong>type checking отдельно от сборки</strong> в development — сборщик компилирует без проверки типов, а tsc проверяет в фоне.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'сборка', 'оптимизация', 'компиляция']
  },
  {
    id: 12,
    question: "Какие проблемы может создать чрезмерное использование типа any?",
    answer: "<p>Злоупотребление <code>any</code> <strong>нивелирует преимущества TypeScript</strong>:</p><h4>Потеря безопасности типов:</h4><p><strong>Ошибки не ловятся:</strong> Компилятор не может предупредить о проблемах — any отключает всю проверку типов для этого значения.</p><p><strong>Цепная реакция:</strong> Any <em>распространяется</em> — если функция принимает any, её возвращаемое значение тоже становится any.</p><h4>Ухудшение developer experience:</h4><p><strong>Нет автодополнения:</strong> IDE не может подсказать доступные свойства и методы.</p><p><strong>Сложный рефакторинг:</strong> При изменении кода с any невозможно найти все затронутые места.</p><h4>Ложная безопасность:</h4><p><strong>Иллюзия типизации:</strong> Проект формально на TypeScript, но фактически работает как JavaScript без проверок.</p><h4>Технический долг:</h4><p><strong>Откладывание проблем:</strong> Any — это часто временное решение, которое становится постоянным.</p><h4>Альтернативы:</h4><p>Использовать <strong>unknown</strong> вместо any, писать конкретные типы, использовать union types для динамических значений.</p><p><em>Правило:</em> Каждый any в коде должен иметь обоснование и план по замене на конкретный тип.</p>",
    difficulty: 'middle',
    tags: ['any', 'типы', 'безопасность', 'best practices']
  },
  {
    id: 13,
    question: "Как TypeScript помогает в работе с большими командами разработчиков?",
    answer: "<p>TypeScript особенно ценен в <strong>командной разработке</strong>:</p><h4>Единое понимание кода:</h4><p><strong>Типы как контракты:</strong> Интерфейсы и типы служат соглашением между разработчиками — явно определяют, что ожидается и что возвращается.</p><p><strong>Самодокументирующийся код:</strong> Типы объясняют намерения без необходимости читать реализацию.</p><h4>Снижение code review нагрузки:</h4><p><strong>Меньше trivial ошибок:</strong> Компилятор ловит опечатки, неправильные типы, missing properties — ревьюеры могут фокусироваться на логике.</p><p><strong>Безопасные изменения API:</strong> Изменения в публичных интерфейсах сразу видны всей команде через ошибки компиляции.</p><h4>Onboarding новых разработчиков:</h4><p><strong>Быстрое понимание:</strong> Новички быстрее разбираются в кодовой базе благодаря типам и автодополнению.</p><p><strong>Меньше вопросов:</strong> IDE отвечает на многие вопросы о структурах данных и API.</p><h4>Предотвращение конфликтов:</h4><p><strong>Breaking changes видны сразу:</strong> Если один разработчик меняет интерфейс, другие сразу видят ошибки в своих ветках.</p><p><em>Эффект:</em> Команда работает быстрее и увереннее, коммуникация улучшается.</p>",
    difficulty: 'senior',
    tags: ['командная работа', 'масштабирование', 'collaboration']
  },
  {
    id: 14,
    question: "Какие проблемы возникают при использовании TypeScript в монорепозиториях?",
    answer: "<p>Монорепозитории с TypeScript имеют <strong>специфические вызовы</strong>:</p><h4>Сложность настройки:</h4><p><strong>Project references:</strong> Настройка зависимостей между пакетами требует внимательности — каждый подпроект нуждается в своем tsconfig.</p><p><strong>Path mapping:</strong> Сложная конфигурация путей для импортов между пакетами.</p><h4>Проблемы сборки:</h4><p><strong>Порядок компиляции:</strong> Пакеты должны компилироваться в правильном порядке зависимостей.</p><p><strong>Долгое время сборки:</strong> Проверка типов во всех пакетах может занимать значительное время.</p><p><strong>Incremental builds:</strong> Не всегда работают корректно, приходится делать полную пересборку.</p><h4>Version management:</h4><p><strong>Синхронизация версий TypeScript:</strong> Разные пакеты могут требовать разные версии, что создает конфликты.</p><p><strong>@types пакеты:</strong> Нужно следить за совместимостью типов между пакетами.</p><h4>Решения:</h4><p>Использование инструментов типа <strong>Turborepo, Nx</strong> для управления сборкой, правильная настройка project references, shared tsconfig для общих правил.</p><p><em>Рекомендация:</em> Инвестировать время в правильную настройку на старте проекта.</p>",
    difficulty: 'senior',
    tags: ['монорепозиторий', 'масштабирование', 'сложности', 'настройка']
  },
  {
    id: 15,
    question: "Как вы оцениваете будущее TypeScript в веб-разработке?",
    answer: "<p>TypeScript имеет <strong>перспективное будущее</strong> в веб-разработке:</p><h4>Текущие тренды:</h4><p><strong>Повсеместное принятие:</strong> Большинство популярных фреймворков и библиотек написаны на TypeScript или имеют first-class поддержку.</p><p><strong>Стандарт индустрии:</strong> В вакансиях TypeScript часто является требованием, а не плюсом.</p><h4>Развитие языка:</h4><p><strong>Type annotations proposal:</strong> Обсуждается возможность добавления синтаксиса типов напрямую в JavaScript — TypeScript может стать частью стандарта.</p><p><strong>Улучшение производительности:</strong> Работа над ускорением компиляции продолжается.</p><h4>Потенциальные вызовы:</h4><p><strong>Альтернативные подходы:</strong> JSDoc с TypeScript, новые инструменты типа Hegel могут составить конкуренцию.</p><p><strong>Усложнение языка:</strong> Каждая новая возможность делает систему типов сложнее.</p><h4>Вероятный сценарий:</h4><p>TypeScript останется <strong>доминирующим решением</strong> для типизации JavaScript на ближайшие 5-10 лет. Возможна более тесная интеграция с JavaScript стандартами.</p><p><em>Вывод:</em> Инвестиции в изучение TypeScript оправданы — он никуда не исчезнет.</p>",
    difficulty: 'senior',
    tags: ['будущее', 'тренды', 'индустрия', 'перспективы']
  }
];
