export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const reactInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое React и в чем его основные преимущества?",
    answer: "<p><strong>React</strong> — это JavaScript библиотека для создания пользовательских интерфейсов, разработанная Facebook в 2013 году.</p><p><strong>Основные преимущества:</strong></p><ul><li><strong>Компонентный подход</strong> — приложение разбивается на независимые переиспользуемые компоненты</li><li><strong>Virtual DOM</strong> — эффективное обновление реального DOM через виртуальное представление</li><li><strong>Однонаправленный поток данных</strong> — предсказуемость и простота отладки</li><li><strong>Декларативность</strong> — описываем что хотим получить, а не как это сделать</li><li><strong>Большая экосистема</strong> — множество готовых решений и библиотек</li></ul><p>React фокусируется только на слое представления (View), что делает его гибким и легко интегрируемым с другими технологиями.</p>",
    difficulty: 'junior',
    tags: ['основы', 'преимущества', 'концепции']
  },
  {
    id: 2,
    question: "Объясните разницу между библиотекой и фреймворком. Почему React — это библиотека?",
    answer: "<p><strong>Фреймворк</strong> предоставляет полную структуру приложения и диктует архитектуру — вы работаете по его правилам. Примеры: Angular, Vue (частично).</p><p><strong>Библиотека</strong> предоставляет набор инструментов для решения конкретных задач — вы сами решаете, как их использовать.</p><p><strong>React — библиотека, потому что:</strong></p><ul><li>Отвечает только за UI слой</li><li>Не навязывает структуру проекта</li><li>Не включает роутинг, управление состоянием из коробки</li><li>Можно использовать только нужные части</li><li>Легко интегрируется в существующие проекты</li></ul><p>Для полноценного приложения React комбинируют с другими библиотеками: React Router, Redux/MobX, и так далее.</p>",
    difficulty: 'junior',
    tags: ['основы', 'терминология', 'архитектура']
  },
  {
    id: 3,
    question: "Что такое JSX и почему он используется в React?",
    answer: "<p><strong>JSX (JavaScript XML)</strong> — это синтаксическое расширение JavaScript, позволяющее писать HTML-подобный код внутри JavaScript.</p><p><strong>Преимущества JSX:</strong></p><ul><li><strong>Наглядность</strong> — структура компонента видна сразу</li><li><strong>Мощь JavaScript</strong> — можно использовать любые JS выражения</li><li><strong>Безопасность</strong> — автоматическое экранирование предотвращает XSS</li><li><strong>Оптимизация</strong> — Babel проверяет JSX на этапе компиляции</li></ul><p><strong>Как это работает:</strong></p><p>JSX компилируется в вызовы React.createElement(). Код выглядит как HTML, но это JavaScript объекты, описывающие структуру UI.</p><p>JSX необязателен, но делает код понятнее и позволяет использовать всю мощь JavaScript при описании UI.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'синтаксис', 'основы']
  },
  {
    id: 4,
    question: "Объясните концепцию Virtual DOM. Как и зачем React его использует?",
    answer: "<p><strong>Virtual DOM</strong> — это легковесная копия реального DOM в памяти, представленная как JavaScript объект.</p><p><strong>Как работает:</strong></p><ul><li>При изменении состояния React создает новое виртуальное дерево</li><li>Сравнивает его с предыдущей версией (reconciliation)</li><li>Вычисляет минимальный набор изменений</li><li>Применяет только эти изменения к реальному DOM</li></ul><p><strong>Зачем это нужно:</strong></p><ul><li><strong>Производительность</strong> — работа с реальным DOM медленная, с Virtual DOM — быстрая</li><li><strong>Батчинг</strong> — React группирует обновления, избегая лишних перерисовок</li><li><strong>Кросс-платформенность</strong> — один код для web, mobile (React Native)</li></ul><p>Virtual DOM — это компромисс между производительностью ручной оптимизации DOM и удобством декларативного подхода.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'производительность', 'reconciliation']
  },
  {
    id: 5,
    question: "В чем разница между управляемыми (controlled) и неуправляемыми (uncontrolled) компонентами?",
    answer: "<p><strong>Управляемые компоненты (Controlled):</strong></p><ul><li>Значение хранится в state React</li><li>Обновляется через обработчики событий</li><li>React — единственный источник истины</li><li>Полный контроль над данными формы</li></ul><p><strong>Неуправляемые компоненты (Uncontrolled):</strong></p><ul><li>Значение хранится в самом DOM элементе</li><li>Доступ через ref</li><li>DOM — источник истины</li><li>Проще для простых форм</li></ul><p><strong>Когда использовать:</strong></p><p><em>Controlled</em> — когда нужна валидация на лету, условная логика, синхронизация нескольких полей.</p><p><em>Uncontrolled</em> — для простых форм, интеграции с non-React кодом, файловых input (которые всегда uncontrolled).</p><p>В большинстве случаев рекомендуется использовать управляемые компоненты для предсказуемости.</p>",
    difficulty: 'middle',
    tags: ['формы', 'controlled', 'uncontrolled', 'state']
  },
  {
    id: 6,
    question: "Что такое props и как они работают в React?",
    answer: "<p><strong>Props (properties)</strong> — это механизм передачи данных от родительского компонента к дочернему.</p><p><strong>Ключевые особенности:</strong></p><ul><li><strong>Только для чтения</strong> — компонент не может изменять свои props</li><li><strong>Однонаправленный поток</strong> — данные идут сверху вниз</li><li><strong>Любые типы данных</strong> — строки, числа, объекты, функции, компоненты</li></ul><p><strong>Зачем нужны props:</strong></p><ul><li>Передача данных в компоненты</li><li>Переиспользование компонентов с разными данными</li><li>Передача callback функций для коммуникации снизу вверх</li><li>Композиция компонентов через children</li></ul><p><strong>Props vs State:</strong></p><p>Props приходят извне и неизменяемы, State управляется внутри компонента и изменяем. Изменение props вызывает ререндер компонента.</p>",
    difficulty: 'junior',
    tags: ['props', 'передача данных', 'основы']
  },
  {
    id: 7,
    question: "Объясните концепцию однонаправленного потока данных в React",
    answer: "<p><strong>Однонаправленный поток данных (Unidirectional data flow)</strong> — фундаментальная концепция React, где данные текут только в одном направлении: от родителей к детям.</p><p><strong>Как это работает:</strong></p><ul><li>Родитель передает данные детям через props</li><li>Дети могут отправлять события родителю через callback</li><li>Состояние живет на верхнем уровне и передается вниз</li><li>Изменения состояния вызывают ререндер дерева компонентов</li></ul><p><strong>Преимущества:</strong></p><ul><li><strong>Предсказуемость</strong> — легко понять, откуда приходят данные</li><li><strong>Отладка</strong> — проще отследить источник проблем</li><li><strong>Тестируемость</strong> — чистые функции легко тестировать</li></ul><p>Это противоположность двунаправленному связыванию (two-way binding) в Angular, где изменения могут идти в обе стороны.</p>",
    difficulty: 'middle',
    tags: ['поток данных', 'архитектура', 'концепции']
  },
  {
    id: 8,
    question: "Что такое компонентный подход и какие преимущества он дает?",
    answer: "<p><strong>Компонентный подход</strong> — это разделение UI на независимые, переиспользуемые части, каждая из которых управляет своим состоянием и логикой.</p><p><strong>Принципы компонентного подхода:</strong></p><ul><li><strong>Инкапсуляция</strong> — логика и UI вместе в одном месте</li><li><strong>Переиспользование</strong> — один раз написали, используем везде</li><li><strong>Композиция</strong> — собираем сложные UI из простых частей</li><li><strong>Изоляция</strong> — изменения в одном компоненте не ломают другие</li></ul><p><strong>Преимущества:</strong></p><ul><li>Код легче понимать и поддерживать</li><li>Проще тестировать изолированно</li><li>Команда может работать параллельно над разными компонентами</li><li>Легко масштабировать приложение</li><li>Возможность создавать библиотеки компонентов</li></ul><p>Компонентность — не уникальная особенность React, но он популяризировал этот подход.</p>",
    difficulty: 'junior',
    tags: ['компоненты', 'архитектура', 'переиспользование']
  },
  {
    id: 9,
    question: "Чем React отличается от других популярных фреймворков (Angular, Vue)?",
    answer: "<p><strong>React vs Angular:</strong></p><ul><li>React — библиотека (только UI), Angular — полноценный фреймворк</li><li>React использует JSX, Angular — TypeScript с шаблонами</li><li>React — функциональный подход с хуками, Angular — ООП с классами</li><li>React проще начать, Angular — больше из коробки</li></ul><p><strong>React vs Vue:</strong></p><ul><li>Схожи по концепции Virtual DOM и компонентности</li><li>Vue использует SFC (Single File Components) с template, React — JSX</li><li>Vue проще для новичков, более «батарейный»</li><li>React имеет большее комьюнити и экосистему</li></ul><p><strong>Когда выбрать React:</strong></p><ul><li>Нужна гибкость в выборе инструментов</li><li>Важна мобильная разработка (React Native)</li><li>Большая команда с опытом в JavaScript</li><li>Требуется богатая экосистема библиотек</li></ul>",
    difficulty: 'middle',
    tags: ['сравнение', 'Angular', 'Vue', 'выбор технологий']
  },
  {
    id: 10,
    question: "Объясните концепцию декларативного программирования в контексте React",
    answer: "<p><strong>Декларативное программирование</strong> — это подход, где мы описываем ЧТО хотим получить, а не КАК это сделать (императивный подход).</p><p><strong>В React:</strong></p><p>Мы описываем желаемое состояние UI, а React сам разбирается, как обновить DOM для достижения этого состояния.</p><p><strong>Декларативный подход:</strong></p><p>Описываем UI как функцию от state: UI = f(state). При изменении state React пересчитывает UI.</p><p><strong>Императивный подход (классический DOM):</strong></p><p>Вручную манипулируем DOM: находим элемент, изменяем его атрибуты, добавляем/удаляем классы.</p><p><strong>Преимущества декларативности:</strong></p><ul><li>Код проще читать и понимать</li><li>Меньше багов — не нужно думать о промежуточных состояниях</li><li>Легче тестировать — проверяем результат, а не шаги</li><li>React оптимизирует обновления автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['декларативность', 'концепции', 'парадигмы']
  },
  {
    id: 11,
    question: "Какие проблемы решает React в веб-разработке?",
    answer: "<p>React решает несколько фундаментальных проблем современной веб-разработки:</p><p><strong>1. Сложность управления DOM:</strong></p><ul><li>Ручные манипуляции с DOM сложны и подвержены ошибкам</li><li>Virtual DOM автоматизирует и оптимизирует обновления</li></ul><p><strong>2. Переиспользование кода:</strong></p><ul><li>Компоненты можно использовать многократно</li><li>Создание библиотек компонентов для всей команды</li></ul><p><strong>3. Управление состоянием:</strong></p><ul><li>Четкая связь между данными и UI</li><li>Предсказуемое обновление интерфейса</li></ul><p><strong>4. Масштабирование приложений:</strong></p><ul><li>Компонентная архитектура облегчает работу больших команд</li><li>Модульность упрощает рефакторинг</li></ul><p><strong>5. Производительность:</strong></p><ul><li>Эффективные алгоритмы обновления</li><li>Батчинг и оптимизация ререндеров</li></ul>",
    difficulty: 'middle',
    tags: ['проблемы', 'решения', 'преимущества']
  },
  {
    id: 12,
    question: "Как React подходит для создания SPA (Single Page Applications)?",
    answer: "<p>React отлично подходит для создания SPA благодаря своей архитектуре:</p><p><strong>Ключевые возможности для SPA:</strong></p><ul><li><strong>Клиентский рендеринг</strong> — весь UI управляется на клиенте</li><li><strong>React Router</strong> — навигация без перезагрузки страницы</li><li><strong>Управление состоянием</strong> — Context API, Redux для глобального state</li><li><strong>Code splitting</strong> — загрузка кода по требованию</li><li><strong>Lazy loading</strong> — отложенная загрузка компонентов</li></ul><p><strong>Преимущества React для SPA:</strong></p><ul><li>Быстрые переходы между страницами</li><li>Нет полной перезагрузки страницы</li><li>Богатая интерактивность</li><li>Оптимистичные обновления UI</li></ul><p><strong>Дополнительные инструменты:</strong></p><p>Для полноценного SPA обычно добавляют: роутинг (React Router), состояние (Redux/MobX), API запросы (axios/fetch).</p>",
    difficulty: 'middle',
    tags: ['SPA', 'архитектура', 'роутинг']
  },
  {
    id: 13,
    question: "Можно ли использовать React для создания мобильных приложений?",
    answer: "<p>Да, через <strong>React Native</strong> — фреймворк для создания нативных мобильных приложений на React.</p><p><strong>Как это работает:</strong></p><ul><li>Пишем код на JavaScript/React</li><li>React Native компилирует в нативные компоненты iOS/Android</li><li>Используем знакомые концепции: компоненты, state, props, хуки</li></ul><p><strong>Отличия от React для web:</strong></p><ul><li>Вместо HTML используем компоненты React Native (View, Text, Image)</li><li>Стилизация через StyleSheet API (похоже на CSS)</li><li>Доступ к нативным API через мосты</li><li>Одна кодовая база для iOS и Android</li></ul><p><strong>Преимущества:</strong></p><ul><li>Переиспользование навыков React</li><li>Быстрая разработка для обеих платформ</li><li>Hot reload для быстрой итерации</li><li>Большое комьюнити и экосистема</li></ul><p>React Native — это отдельный проект, но концепции и подходы те же, что в React.</p>",
    difficulty: 'junior',
    tags: ['React Native', 'мобильная разработка', 'кросс-платформа']
  },
  {
    id: 14,
    question: "В чем суть философии 'Learn Once, Write Anywhere' в React?",
    answer: "<p><strong>'Learn Once, Write Anywhere'</strong> — философия React, означающая: выучив React один раз, можно писать приложения для разных платформ.</p><p><strong>Где можно использовать React:</strong></p><ul><li><strong>Web</strong> — React DOM для браузера</li><li><strong>Mobile</strong> — React Native для iOS/Android</li><li><strong>Desktop</strong> — Electron с React</li><li><strong>VR</strong> — React 360 для виртуальной реальности</li><li><strong>Terminal</strong> — React Ink для CLI приложений</li></ul><p><strong>Общие концепции:</strong></p><ul><li>Компонентная модель</li><li>State и props</li><li>Хуки и жизненный цикл</li><li>Однонаправленный поток данных</li></ul><p><strong>Различия:</strong></p><p>Меняются только примитивы рендеринга (div → View, p → Text), но подход остается тем же.</p><p>Это не 'Write Once, Run Anywhere' — код нужно адаптировать под платформу, но знания переносятся полностью.</p>",
    difficulty: 'senior',
    tags: ['философия', 'кросс-платформа', 'экосистема']
  },
  {
    id: 15,
    question: "Какие недостатки есть у React и когда его лучше не использовать?",
    answer: "<p>React — отличный инструмент, но у него есть недостатки:</p><p><strong>Основные недостатки:</strong></p><ul><li><strong>Не полноценный фреймворк</strong> — нужно выбирать роутер, state management, и т.д.</li><li><strong>Быстрые изменения</strong> — API меняется, нужно постоянно учиться</li><li><strong>JSX</strong> — может быть непривычен новичкам</li><li><strong>SEO сложности</strong> — требуется SSR для хорошей индексации</li><li><strong>Большой размер</strong> — базовый бандл React довольно большой</li></ul><p><strong>Когда React избыточен:</strong></p><ul><li>Простые статические сайты (лучше использовать HTML/CSS)</li><li>Лендинги без интерактивности</li><li>Проекты с жесткими требованиями к размеру бандла</li><li>Когда команда не знакома с JavaScript экосистемой</li></ul><p><strong>Когда выбрать альтернативу:</strong></p><ul><li>Angular — если нужен опinionated фреймворк</li><li>Vue — если нужна меньшая кривая обучения</li><li>Svelte — если критичен размер бандла</li></ul>",
    difficulty: 'senior',
    tags: ['недостатки', 'ограничения', 'выбор технологий']
  }
]
