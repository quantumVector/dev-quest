export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const reactInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое React и в чем его основные преимущества?",
    answer: "<p><strong>React</strong> — это JavaScript библиотека для создания пользовательских интерфейсов, разработанная Facebook в 2013 году.</p><p><strong>Основные преимущества:</strong></p><ul><li><strong>Компонентный подход</strong> — приложение разбивается на независимые переиспользуемые компоненты</li><li><strong>Virtual DOM</strong> — эффективное обновление реального DOM через виртуальное представление</li><li><strong>Однонаправленный поток данных</strong> — предсказуемость и простота отладки</li><li><strong>Декларативность</strong> — описываем что хотим получить, а не как это сделать</li><li><strong>Большая экосистема</strong> — множество готовых решений и библиотек</li></ul><p>React фокусируется только на слое представления (View), что делает его гибким и легко интегрируемым с другими технологиями.</p>",
    difficulty: 'junior',
    tags: ['основы', 'преимущества', 'концепции']
  },
  {
    id: 2,
    question: "Объясните разницу между библиотекой и фреймворком. Почему React — это библиотека?",
    answer: "<p><strong>Фреймворк</strong> предоставляет полную структуру приложения и диктует архитектуру — вы работаете по его правилам. Примеры: Angular, Vue (частично).</p><p><strong>Библиотека</strong> предоставляет набор инструментов для решения конкретных задач — вы сами решаете, как их использовать.</p><p><strong>React — библиотека, потому что:</strong></p><ul><li>Отвечает только за UI слой</li><li>Не навязывает структуру проекта</li><li>Не включает роутинг, управление состоянием из коробки</li><li>Можно использовать только нужные части</li><li>Легко интегрируется в существующие проекты</li></ul><p>Для полноценного приложения React комбинируют с другими библиотеками: React Router, Redux/MobX, и так далее.</p>",
    difficulty: 'junior',
    tags: ['основы', 'терминология', 'архитектура']
  },
  {
    id: 3,
    question: "Что такое JSX и почему он используется в React?",
    answer: "<p><strong>JSX (JavaScript XML)</strong> — это синтаксическое расширение JavaScript, позволяющее писать HTML-подобный код внутри JavaScript.</p><p><strong>Преимущества JSX:</strong></p><ul><li><strong>Наглядность</strong> — структура компонента видна сразу</li><li><strong>Мощь JavaScript</strong> — можно использовать любые JS выражения</li><li><strong>Безопасность</strong> — автоматическое экранирование предотвращает XSS</li><li><strong>Оптимизация</strong> — Babel проверяет JSX на этапе компиляции</li></ul><p><strong>Как это работает:</strong></p><p>JSX компилируется в вызовы React.createElement(). Код выглядит как HTML, но это JavaScript объекты, описывающие структуру UI.</p><p>JSX необязателен, но делает код понятнее и позволяет использовать всю мощь JavaScript при описании UI.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'синтаксис', 'основы']
  },
  {
    id: 4,
    question: "Объясните концепцию Virtual DOM. Как и зачем React его использует?",
    answer: "<p><strong>Virtual DOM</strong> — это легковесная копия реального DOM в памяти, представленная как JavaScript объект.</p><p><strong>Как работает:</strong></p><ul><li>При изменении состояния React создает новое виртуальное дерево</li><li>Сравнивает его с предыдущей версией (reconciliation)</li><li>Вычисляет минимальный набор изменений</li><li>Применяет только эти изменения к реальному DOM</li></ul><p><strong>Зачем это нужно:</strong></p><ul><li><strong>Производительность</strong> — работа с реальным DOM медленная, с Virtual DOM — быстрая</li><li><strong>Батчинг</strong> — React группирует обновления, избегая лишних перерисовок</li><li><strong>Кросс-платформенность</strong> — один код для web, mobile (React Native)</li></ul><p>Virtual DOM — это компромисс между производительностью ручной оптимизации DOM и удобством декларативного подхода.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'производительность', 'reconciliation']
  },
  {
    id: 5,
    question: "В чем разница между управляемыми (controlled) и неуправляемыми (uncontrolled) компонентами?",
    answer: "<p><strong>Управляемые компоненты (Controlled):</strong></p><ul><li>Значение хранится в state React</li><li>Обновляется через обработчики событий</li><li>React — единственный источник истины</li><li>Полный контроль над данными формы</li></ul><p><strong>Неуправляемые компоненты (Uncontrolled):</strong></p><ul><li>Значение хранится в самом DOM элементе</li><li>Доступ через ref</li><li>DOM — источник истины</li><li>Проще для простых форм</li></ul><p><strong>Когда использовать:</strong></p><p><em>Controlled</em> — когда нужна валидация на лету, условная логика, синхронизация нескольких полей.</p><p><em>Uncontrolled</em> — для простых форм, интеграции с non-React кодом, файловых input (которые всегда uncontrolled).</p><p>В большинстве случаев рекомендуется использовать управляемые компоненты для предсказуемости.</p>",
    difficulty: 'middle',
    tags: ['формы', 'controlled', 'uncontrolled', 'state']
  },
  {
    id: 6,
    question: "Что такое props и как они работают в React?",
    answer: "<p><strong>Props (properties)</strong> — это механизм передачи данных от родительского компонента к дочернему.</p><p><strong>Ключевые особенности:</strong></p><ul><li><strong>Только для чтения</strong> — компонент не может изменять свои props</li><li><strong>Однонаправленный поток</strong> — данные идут сверху вниз</li><li><strong>Любые типы данных</strong> — строки, числа, объекты, функции, компоненты</li></ul><p><strong>Зачем нужны props:</strong></p><ul><li>Передача данных в компоненты</li><li>Переиспользование компонентов с разными данными</li><li>Передача callback функций для коммуникации снизу вверх</li><li>Композиция компонентов через children</li></ul><p><strong>Props vs State:</strong></p><p>Props приходят извне и неизменяемы, State управляется внутри компонента и изменяем. Изменение props вызывает ререндер компонента.</p>",
    difficulty: 'junior',
    tags: ['props', 'передача данных', 'основы']
  },
  {
    id: 7,
    question: "Объясните концепцию однонаправленного потока данных в React",
    answer: "<p><strong>Однонаправленный поток данных (Unidirectional data flow)</strong> — фундаментальная концепция React, где данные текут только в одном направлении: от родителей к детям.</p><p><strong>Как это работает:</strong></p><ul><li>Родитель передает данные детям через props</li><li>Дети могут отправлять события родителю через callback</li><li>Состояние живет на верхнем уровне и передается вниз</li><li>Изменения состояния вызывают ререндер дерева компонентов</li></ul><p><strong>Преимущества:</strong></p><ul><li><strong>Предсказуемость</strong> — легко понять, откуда приходят данные</li><li><strong>Отладка</strong> — проще отследить источник проблем</li><li><strong>Тестируемость</strong> — чистые функции легко тестировать</li></ul><p>Это противоположность двунаправленному связыванию (two-way binding) в Angular, где изменения могут идти в обе стороны.</p>",
    difficulty: 'middle',
    tags: ['поток данных', 'архитектура', 'концепции']
  },
  {
    id: 8,
    question: "Что такое компонентный подход и какие преимущества он дает?",
    answer: "<p><strong>Компонентный подход</strong> — это разделение UI на независимые, переиспользуемые части, каждая из которых управляет своим состоянием и логикой.</p><p><strong>Принципы компонентного подхода:</strong></p><ul><li><strong>Инкапсуляция</strong> — логика и UI вместе в одном месте</li><li><strong>Переиспользование</strong> — один раз написали, используем везде</li><li><strong>Композиция</strong> — собираем сложные UI из простых частей</li><li><strong>Изоляция</strong> — изменения в одном компоненте не ломают другие</li></ul><p><strong>Преимущества:</strong></p><ul><li>Код легче понимать и поддерживать</li><li>Проще тестировать изолированно</li><li>Команда может работать параллельно над разными компонентами</li><li>Легко масштабировать приложение</li><li>Возможность создавать библиотеки компонентов</li></ul><p>Компонентность — не уникальная особенность React, но он популяризировал этот подход.</p>",
    difficulty: 'junior',
    tags: ['компоненты', 'архитектура', 'переиспользование']
  },
  {
    id: 9,
    question: "Чем React отличается от других популярных фреймворков (Angular, Vue)?",
    answer: "<p><strong>React vs Angular:</strong></p><ul><li>React — библиотека (только UI), Angular — полноценный фреймворк</li><li>React использует JSX, Angular — TypeScript с шаблонами</li><li>React — функциональный подход с хуками, Angular — ООП с классами</li><li>React проще начать, Angular — больше из коробки</li></ul><p><strong>React vs Vue:</strong></p><ul><li>Схожи по концепции Virtual DOM и компонентности</li><li>Vue использует SFC (Single File Components) с template, React — JSX</li><li>Vue проще для новичков, более «батарейный»</li><li>React имеет большее комьюнити и экосистему</li></ul><p><strong>Когда выбрать React:</strong></p><ul><li>Нужна гибкость в выборе инструментов</li><li>Важна мобильная разработка (React Native)</li><li>Большая команда с опытом в JavaScript</li><li>Требуется богатая экосистема библиотек</li></ul>",
    difficulty: 'middle',
    tags: ['сравнение', 'Angular', 'Vue', 'выбор технологий']
  },
  {
    id: 10,
    question: "Объясните концепцию декларативного программирования в контексте React",
    answer: "<p><strong>Декларативное программирование</strong> — это подход, где мы описываем ЧТО хотим получить, а не КАК это сделать (императивный подход).</p><p><strong>В React:</strong></p><p>Мы описываем желаемое состояние UI, а React сам разбирается, как обновить DOM для достижения этого состояния.</p><p><strong>Декларативный подход:</strong></p><p>Описываем UI как функцию от state: UI = f(state). При изменении state React пересчитывает UI.</p><p><strong>Императивный подход (классический DOM):</strong></p><p>Вручную манипулируем DOM: находим элемент, изменяем его атрибуты, добавляем/удаляем классы.</p><p><strong>Преимущества декларативности:</strong></p><ul><li>Код проще читать и понимать</li><li>Меньше багов — не нужно думать о промежуточных состояниях</li><li>Легче тестировать — проверяем результат, а не шаги</li><li>React оптимизирует обновления автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['декларативность', 'концепции', 'парадигмы']
  },
  {
    id: 11,
    question: "Какие проблемы решает React в веб-разработке?",
    answer: "<p>React решает несколько фундаментальных проблем современной веб-разработки:</p><p><strong>1. Сложность управления DOM:</strong></p><ul><li>Ручные манипуляции с DOM сложны и подвержены ошибкам</li><li>Virtual DOM автоматизирует и оптимизирует обновления</li></ul><p><strong>2. Переиспользование кода:</strong></p><ul><li>Компоненты можно использовать многократно</li><li>Создание библиотек компонентов для всей команды</li></ul><p><strong>3. Управление состоянием:</strong></p><ul><li>Четкая связь между данными и UI</li><li>Предсказуемое обновление интерфейса</li></ul><p><strong>4. Масштабирование приложений:</strong></p><ul><li>Компонентная архитектура облегчает работу больших команд</li><li>Модульность упрощает рефакторинг</li></ul><p><strong>5. Производительность:</strong></p><ul><li>Эффективные алгоритмы обновления</li><li>Батчинг и оптимизация ререндеров</li></ul>",
    difficulty: 'middle',
    tags: ['проблемы', 'решения', 'преимущества']
  },
  {
    id: 12,
    question: "Как React подходит для создания SPA (Single Page Applications)?",
    answer: "<p>React отлично подходит для создания SPA благодаря своей архитектуре:</p><p><strong>Ключевые возможности для SPA:</strong></p><ul><li><strong>Клиентский рендеринг</strong> — весь UI управляется на клиенте</li><li><strong>React Router</strong> — навигация без перезагрузки страницы</li><li><strong>Управление состоянием</strong> — Context API, Redux для глобального state</li><li><strong>Code splitting</strong> — загрузка кода по требованию</li><li><strong>Lazy loading</strong> — отложенная загрузка компонентов</li></ul><p><strong>Преимущества React для SPA:</strong></p><ul><li>Быстрые переходы между страницами</li><li>Нет полной перезагрузки страницы</li><li>Богатая интерактивность</li><li>Оптимистичные обновления UI</li></ul><p><strong>Дополнительные инструменты:</strong></p><p>Для полноценного SPA обычно добавляют: роутинг (React Router), состояние (Redux/MobX), API запросы (axios/fetch).</p>",
    difficulty: 'middle',
    tags: ['SPA', 'архитектура', 'роутинг']
  },
  {
    id: 13,
    question: "Можно ли использовать React для создания мобильных приложений?",
    answer: "<p>Да, через <strong>React Native</strong> — фреймворк для создания нативных мобильных приложений на React.</p><p><strong>Как это работает:</strong></p><ul><li>Пишем код на JavaScript/React</li><li>React Native компилирует в нативные компоненты iOS/Android</li><li>Используем знакомые концепции: компоненты, state, props, хуки</li></ul><p><strong>Отличия от React для web:</strong></p><ul><li>Вместо HTML используем компоненты React Native (View, Text, Image)</li><li>Стилизация через StyleSheet API (похоже на CSS)</li><li>Доступ к нативным API через мосты</li><li>Одна кодовая база для iOS и Android</li></ul><p><strong>Преимущества:</strong></p><ul><li>Переиспользование навыков React</li><li>Быстрая разработка для обеих платформ</li><li>Hot reload для быстрой итерации</li><li>Большое комьюнити и экосистема</li></ul><p>React Native — это отдельный проект, но концепции и подходы те же, что в React.</p>",
    difficulty: 'junior',
    tags: ['React Native', 'мобильная разработка', 'кросс-платформа']
  },
  {
    id: 14,
    question: "В чем суть философии 'Learn Once, Write Anywhere' в React?",
    answer: "<p><strong>'Learn Once, Write Anywhere'</strong> — философия React, означающая: выучив React один раз, можно писать приложения для разных платформ.</p><p><strong>Где можно использовать React:</strong></p><ul><li><strong>Web</strong> — React DOM для браузера</li><li><strong>Mobile</strong> — React Native для iOS/Android</li><li><strong>Desktop</strong> — Electron с React</li><li><strong>VR</strong> — React 360 для виртуальной реальности</li><li><strong>Terminal</strong> — React Ink для CLI приложений</li></ul><p><strong>Общие концепции:</strong></p><ul><li>Компонентная модель</li><li>State и props</li><li>Хуки и жизненный цикл</li><li>Однонаправленный поток данных</li></ul><p><strong>Различия:</strong></p><p>Меняются только примитивы рендеринга (div → View, p → Text), но подход остается тем же.</p><p>Это не 'Write Once, Run Anywhere' — код нужно адаптировать под платформу, но знания переносятся полностью.</p>",
    difficulty: 'senior',
    tags: ['философия', 'кросс-платформа', 'экосистема']
  },
  {
    id: 15,
    question: "Какие недостатки есть у React и когда его лучше не использовать?",
    answer: "<p>React — отличный инструмент, но у него есть недостатки:</p><p><strong>Основные недостатки:</strong></p><ul><li><strong>Не полноценный фреймворк</strong> — нужно выбирать роутер, state management, и т.д.</li><li><strong>Быстрые изменения</strong> — API меняется, нужно постоянно учиться</li><li><strong>JSX</strong> — может быть непривычен новичкам</li><li><strong>SEO сложности</strong> — требуется SSR для хорошей индексации</li><li><strong>Большой размер</strong> — базовый бандл React довольно большой</li></ul><p><strong>Когда React избыточен:</strong></p><ul><li>Простые статические сайты (лучше использовать HTML/CSS)</li><li>Лендинги без интерактивности</li><li>Проекты с жесткими требованиями к размеру бандла</li><li>Когда команда не знакома с JavaScript экосистемой</li></ul><p><strong>Когда выбрать альтернативу:</strong></p><ul><li>Angular — если нужен опinionated фреймворк</li><li>Vue — если нужна меньшая кривая обучения</li><li>Svelte — если критичен размер бандла</li></ul>",
    difficulty: 'senior',
    tags: ['недостатки', 'ограничения', 'выбор технологий']
  },
  {
    id: 16,
    question: "Что такое Virtual DOM и как он работает в React?",
    answer: "<p><strong>Virtual DOM</strong> — это легковесное JavaScript представление реального DOM дерева.</p><p><strong>Как работает:</strong></p><ul><li>React хранит копию DOM в памяти как JS объект</li><li>При изменении state/props создается новое виртуальное дерево</li><li>React сравнивает новое дерево со старым (diffing)</li><li>Вычисляет минимальный набор изменений</li><li>Применяет только необходимые изменения к реальному DOM</li></ul><p><strong>Почему это быстрее:</strong></p><p>Работа с JS объектами в памяти в сотни раз быстрее, чем манипуляции с реальным DOM. React минимизирует дорогостоящие операции с DOM, группируя изменения.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'производительность', 'основы']
  },
  {
    id: 17,
    question: "В чем разница между Virtual DOM и реальным DOM?",
    answer: "<p><strong>Реальный DOM:</strong></p><ul><li>Представление HTML в браузере</li><li>Тяжеловесная структура с методами браузера</li><li>Каждое изменение вызывает reflow/repaint</li><li>Медленные операции чтения и записи</li><li>Прямые манипуляции могут быть неэффективными</li></ul><p><strong>Virtual DOM:</strong></p><ul><li>JavaScript объект в памяти</li><li>Легковесная копия реального DOM</li><li>Быстрое сравнение и вычисление изменений</li><li>Батчинг множественных обновлений</li><li>Не вызывает перерисовку до применения к реальному DOM</li></ul><p>Virtual DOM — это прослойка оптимизации между вашим кодом и реальным DOM.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'DOM', 'отличия']
  },
  {
    id: 18,
    question: "Опишите процесс reconciliation в React. Как React понимает, что нужно обновить?",
    answer: "<p><strong>Reconciliation</strong> — это процесс сравнения (diffing) двух виртуальных деревьев для определения изменений.</p><p><strong>Как работает:</strong></p><ul><li>React создает новое Virtual DOM дерево</li><li>Сравнивает его с предыдущим снимком</li><li>Использует эвристический алгоритм O(n)</li><li>Сравнивает элементы по типу и ключу</li><li>Формирует список минимальных изменений (patches)</li></ul><p><strong>Оптимизации:</strong></p><ul><li>Элементы разных типов — полная замена поддерева</li><li>Элементы одного типа — обновление атрибутов</li><li>Списки — использование key для идентификации</li></ul><p>Этот процесс происходит автоматически при каждом изменении state или props.</p>",
    difficulty: 'senior',
    tags: ['reconciliation', 'diffing', 'алгоритмы']
  },
  {
    id: 19,
    question: "Почему React использует алгоритм diffing O(n) вместо O(n³)?",
    answer: "<p>Классический алгоритм сравнения деревьев имеет сложность O(n³), что неприемлемо для UI с тысячами элементов.</p><p><strong>Эвристики React для O(n):</strong></p><ul><li><strong>Разные типы → разные деревья</strong> — React не пытается сравнивать &lt;div&gt; с &lt;span&gt;</li><li><strong>Ключи для стабильной идентификации</strong> — key помогает отслеживать элементы между рендерами</li><li><strong>Побратимство по уровням</strong> — сравнение только на одном уровне, без глубокого анализа</li></ul><p><strong>Компромисс:</strong></p><p>Алгоритм не всегда оптимален теоретически, но на практике эти эвристики работают в 99% случаев и дают приемлемую производительность для реальных приложений.</p>",
    difficulty: 'senior',
    tags: ['алгоритмы', 'оптимизация', 'сложность']
  },
  {
    id: 20,
    question: "Зачем нужны ключи (keys) в списках и как они помогают Virtual DOM?",
    answer: "<p><strong>Keys</strong> — это специальный атрибут, помогающий React идентифицировать элементы между рендерами.</p><p><strong>Зачем нужны:</strong></p><ul><li>Стабильная идентичность элементов при пересортировке</li><li>Переиспользование DOM узлов вместо пересоздания</li><li>Сохранение state компонентов в списке</li><li>Корректная работа анимаций и фокуса</li></ul><p><strong>Как работают:</strong></p><p>При diffing React сопоставляет элементы по key. Если key не изменился, React обновляет существующий элемент вместо удаления и создания нового.</p><p><strong>Антипаттерн:</strong></p><p>Использование индекса массива как key проблематично при изменении порядка — элементы будут пересозданы, потеряв state.</p>",
    difficulty: 'middle',
    tags: ['keys', 'списки', 'оптимизация']
  },
  {
    id: 21,
    question: "Что произойдет, если не использовать key в списках?",
    answer: "<p>Без key React использует индекс элемента как идентификатор по умолчанию.</p><p><strong>Проблемы:</strong></p><ul><li><strong>Некорректные обновления</strong> — при изменении порядка React обновит не те элементы</li><li><strong>Потеря state</strong> — внутреннее состояние компонентов может перепутаться</li><li><strong>Проблемы с фокусом</strong> — input элементы теряют фокус</li><li><strong>Лишние рендеры</strong> — React может пересоздать элементы вместо переиспользования</li><li><strong>Баги в анимациях</strong> — анимации могут применяться к неправильным элементам</li></ul><p><strong>Когда индекс допустим:</strong></p><p>Только если список статичен и никогда не меняет порядок, не фильтруется и не добавляет элементы в середину.</p>",
    difficulty: 'middle',
    tags: ['keys', 'проблемы', 'best practices']
  },
  {
    id: 22,
    question: "Как Virtual DOM помогает с производительностью по сравнению с прямыми манипуляциями DOM?",
    answer: "<p><strong>Проблемы прямых манипуляций DOM:</strong></p><ul><li>Каждое изменение может вызывать reflow/repaint</li><li>Множественные обновления = множественные перерисовки</li><li>Разработчик должен вручную оптимизировать</li><li>Трудно отследить все зависимости изменений</li></ul><p><strong>Преимущества Virtual DOM:</strong></p><ul><li><strong>Батчинг</strong> — группировка изменений в один update</li><li><strong>Минимизация операций</strong> — только необходимые изменения</li><li><strong>Автоматическая оптимизация</strong> — React сам вычисляет оптимальный path</li><li><strong>Предсказуемость</strong> — декларативный подход убирает ручное управление</li></ul><p>Virtual DOM — это разумный баланс между производительностью и удобством разработки.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'оптимизация', 'преимущества']
  },
  {
    id: 23,
    question: "Всегда ли Virtual DOM быстрее прямых манипуляций с DOM?",
    answer: "<p><strong>Нет, не всегда.</strong> Virtual DOM — это компромисс, а не серебряная пуля.</p><p><strong>Когда Virtual DOM медленнее:</strong></p><ul><li>Очень простые, точечные обновления одного элемента</li><li>Высокочастотные изменения (например, canvas анимации)</li><li>Когда overhead diffing превышает выгоду от оптимизации</li></ul><p><strong>Когда Virtual DOM быстрее:</strong></p><ul><li>Сложные UI с множественными зависимостями</li><li>Много одновременных обновлений</li><li>Когда сложно вручную оптимизировать</li></ul><p><strong>Реальная ценность:</strong></p><p>Virtual DOM дает не только скорость, но и удобство разработки, предсказуемость и масштабируемость. Для 99% задач этого достаточно.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'ограничения', 'компромиссы']
  },
  {
    id: 24,
    question: "Объясните, что такое Fiber архитектура и как она улучшила работу Virtual DOM?",
    answer: "<p><strong>React Fiber</strong> — это полная переработка reconciliation алгоритма, представленная в React 16.</p><p><strong>Проблема старого подхода:</strong></p><p>Reconciliation был синхронным и блокирующим — при больших обновлениях UI мог \"зависать\".</p><p><strong>Что изменил Fiber:</strong></p><ul><li><strong>Incremental rendering</strong> — работа разбивается на части</li><li><strong>Приоритизация</strong> — важные обновления (ввод) приоритетнее фоновых</li><li><strong>Pause/resume</strong> — React может прервать работу и продолжить позже</li><li><strong>Прерывание</strong> — отмена устаревшей работы</li></ul><p><strong>Результат:</strong></p><p>Более плавный UI, отзывчивые анимации, отсутствие \"зависаний\" даже при тяжелых вычислениях.</p>",
    difficulty: 'senior',
    tags: ['Fiber', 'архитектура', 'React 16+']
  },
  {
    id: 25,
    question: "Как React батчит (группирует) обновления состояния?",
    answer: "<p><strong>Батчинг</strong> — это группировка нескольких вызовов setState в один ререндер.</p><p><strong>До React 18:</strong></p><ul><li>Батчинг работал только в event handlers</li><li>В промисах, setTimeout, нативных событиях — каждый setState вызывал ререндер</li></ul><p><strong>React 18 (Automatic Batching):</strong></p><ul><li>Батчинг везде по умолчанию</li><li>В промисах, setTimeout, нативных событиях тоже батчится</li><li>Можно отключить через flushSync() если нужно</li></ul><p><strong>Почему это важно:</strong></p><p>Множественные setState не вызывают множественных рендеров. React собирает все изменения и применяет одним батчем, минимизируя работу с DOM.</p>",
    difficulty: 'senior',
    tags: ['батчинг', 'setState', 'React 18']
  },
  {
    id: 26,
    question: "Что такое reconciliation в контексте React Fiber?",
    answer: "<p>В Fiber reconciliation стал асинхронным и прерываемым процессом.</p><p><strong>Две фазы работы:</strong></p><p><strong>1. Render фаза (прерываемая):</strong></p><ul><li>Построение нового Fiber дерева</li><li>Вычисление изменений (diffing)</li><li>Может быть прервана и перезапущена</li><li>Без side-effects</li></ul><p><strong>2. Commit фаза (синхронная):</strong></p><ul><li>Применение изменений к реальному DOM</li><li>Вызов lifecycle методов</li><li>Не может быть прервана</li><li>Выполняется за один проход</li></ul><p><strong>Преимущество:</strong></p><p>React может прервать дорогостоящую render фазу для обработки более важных обновлений, затем вернуться к ней.</p>",
    difficulty: 'senior',
    tags: ['reconciliation', 'Fiber', 'фазы рендера']
  },
  {
    id: 27,
    question: "Как Virtual DOM работает с событиями в React?",
    answer: "<p>React использует <strong>синтетические события (SyntheticEvent)</strong> — обертку над нативными событиями браузера.</p><p><strong>Почему не напрямую:</strong></p><ul><li><strong>Кросс-браузерность</strong> — единый API для всех браузеров</li><li><strong>Производительность</strong> — event delegation на корневом уровне</li><li><strong>Объединение с Virtual DOM</strong> — события привязаны к виртуальным узлам</li></ul><p><strong>Как работает:</strong></p><ul><li>React регистрирует один обработчик на root элементе</li><li>При событии React определяет целевой компонент через Fiber дерево</li><li>Вызывает соответствующий обработчик с SyntheticEvent</li></ul><p><strong>Изменение в React 17:</strong></p><p>Event delegation теперь на корне приложения, а не document — улучшает работу с микрофронтендами.</p>",
    difficulty: 'senior',
    tags: ['события', 'SyntheticEvent', 'delegation']
  },
  {
    id: 28,
    question: "Можно ли обойтись без Virtual DOM? Какие есть альтернативы?",
    answer: "<p>Да, Virtual DOM — не единственный подход к реактивному UI.</p><p><strong>Альтернативы:</strong></p><ul><li><strong>Svelte</strong> — компиляция в императивный код без runtime diffing</li><li><strong>Solid.js</strong> — fine-grained reactivity с прямыми обновлениями DOM</li><li><strong>Vue 3 Composition API</strong> — комбинация Virtual DOM с реактивностью</li><li><strong>Angular Signals</strong> — реактивные примитивы без Virtual DOM</li></ul><p><strong>Преимущества без Virtual DOM:</strong></p><ul><li>Меньше overhead на diffing</li><li>Более предсказуемая производительность</li><li>Меньший размер бандла</li></ul><p><strong>Компромиссы:</strong></p><p>Virtual DOM дает гибкость и простоту разработки. Альтернативы часто быстрее, но требуют более аккуратного подхода к оптимизации.</p>",
    difficulty: 'senior',
    tags: ['альтернативы', 'сравнение', 'Svelte', 'Solid']
  },
  {
    id: 29,
    question: "Как React определяет, что компонент нужно перерендерить?",
    answer: "<p>React запускает ререндер компонента в нескольких случаях:</p><p><strong>Триггеры ререндера:</strong></p><ul><li><strong>Изменение state</strong> — вызов setState/useState updater</li><li><strong>Изменение props</strong> — родитель передал новые props</li><li><strong>Изменение context</strong> — значение useContext изменилось</li><li><strong>Ререндер родителя</strong> — по умолчанию дети тоже рендерятся</li><li><strong>forceUpdate()</strong> — принудительный рендер (устарело)</li></ul><p><strong>Важно:</strong></p><p>Ререндер не означает изменение DOM. React сравнит Virtual DOM и применит изменения только если они есть.</p><p><strong>Оптимизация:</strong></p><p>React.memo, useMemo, useCallback помогают избежать ненужных ререндеров при неизменных данных.</p>",
    difficulty: 'middle',
    tags: ['ререндер', 'триггеры', 'оптимизация']
  },
  {
    id: 30,
    question: "В чем разница между createElement и JSX в контексте Virtual DOM?",
    answer: "<p>JSX — это синтаксический сахар, который компилируется в вызовы createElement (в React 17+: jsx() runtime).</p><p><strong>JSX код:</strong></p><p>Выглядит как HTML, но это JavaScript, который Babel транспилирует.</p><p><strong>React.createElement():</strong></p><p>Создает JavaScript объект (React элемент) — узел Virtual DOM дерева. Принимает тип, props, children.</p><p><strong>Virtual DOM узел:</strong></p><p>Это просто объект с полями: type (компонент/тег), props (атрибуты), key, ref, children.</p><p><strong>Процесс:</strong></p><p>JSX → createElement → Virtual DOM объект → reconciliation → реальный DOM</p><p>Вся магия React построена на манипуляции этими легковесными объектами вместо тяжелого DOM.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'createElement', 'компиляция']
  },
  {
    id: 31,
    question: "Что такое JSX и чем он отличается от обычного JavaScript?",
    answer: "<p><strong>JSX (JavaScript XML)</strong> — это синтаксическое расширение JavaScript, которое позволяет писать разметку, похожую на HTML, прямо в JavaScript коде.</p><p><strong>Ключевые отличия от JavaScript:</strong></p><ul><li>JSX не является валидным JavaScript — требует транспиляции</li><li>Использует XML-подобный синтаксис для описания UI</li><li>Позволяет встраивать JavaScript выражения через фигурные скобки {}</li><li>Имеет свои правила именования (className вместо class, htmlFor вместо for)</li></ul><p><strong>Важно понимать:</strong></p><p>JSX — это не шаблонный язык и не HTML. Это JavaScript код, который выглядит как разметка для удобства восприятия. После компиляции JSX превращается в обычные функции JavaScript.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'основы', 'синтаксис']
  },
  {
    id: 32,
    question: "Какие инструменты используются для поддержки JSX-синтаксиса?",
    answer: "<p>JSX требует транспиляции в обычный JavaScript. Основные инструменты:</p><p><strong>Babel:</strong></p><ul><li>Самый популярный транспилятор для JSX</li><li>Плагин @babel/preset-react для JSX трансформации</li><li>Используется в Create React App, Next.js и большинстве проектов</li></ul><p><strong>TypeScript:</strong></p><ul><li>Нативная поддержка JSX через расширение .tsx</li><li>Встроенная проверка типов для JSX элементов</li><li>Опция jsx в tsconfig.json определяет способ компиляции</li></ul><p><strong>Другие инструменты:</strong></p><ul><li>SWC — современная быстрая альтернатива Babel на Rust</li><li>esbuild — сверхбыстрый бандлер с поддержкой JSX</li></ul><p>В современных проектах настройка часто скрыта в инструментах типа Vite или Next.js.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'инструменты', 'Babel', 'TypeScript']
  },
  {
    id: 33,
    question: "Во что преобразуются JSX-теги при компиляции?",
    answer: "<p>JSX теги компилируются в вызовы функций создания React элементов.</p><p><strong>До React 17:</strong></p><p>JSX компилировался в React.createElement() вызовы. Поэтому React нужно было импортировать в каждом файле.</p><p><strong>React 17+ (новый JSX Transform):</strong></p><p>JSX компилируется в специальные функции jsx() и jsxs() из 'react/jsx-runtime'. Import React больше не требуется.</p><p><strong>Что создается:</strong></p><p>В результате получается обычный JavaScript объект — React элемент, который описывает структуру Virtual DOM узла. Объект содержит: type (тип элемента), props (свойства и children), key, ref.</p><p>Эти объекты — основа Virtual DOM, с которыми React работает при reconciliation.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'компиляция', 'createElement', 'transform']
  },
  {
    id: 34,
    question: "Почему в JSX используется className вместо class?",
    answer: "<p>В JSX используется className вместо class по историческим и техническим причинам:</p><p><strong>Техническая причина:</strong></p><ul><li>class — зарезервированное ключевое слово в JavaScript</li><li>JSX компилируется в JavaScript объекты с полем props</li><li>Использование class как имени свойства может вызвать проблемы</li></ul><p><strong>Исторический контекст:</strong></p><p>Когда создавался React, использование зарезервированных слов в объектах было более проблематичным. Хотя современный JavaScript позволяет 'class' как ключ объекта, React сохранил className для обратной совместимости.</p><p><strong>Аналогично:</strong></p><ul><li>htmlFor вместо for</li><li>onChange вместо onchange</li><li>dangerouslySetInnerHTML вместо innerHTML</li></ul>",
    difficulty: 'junior',
    tags: ['JSX', 'атрибуты', 'отличия от HTML']
  },
  {
    id: 35,
    question: "Можно ли использовать if-else внутри JSX?",
    answer: "<p><strong>Напрямую нельзя</strong> — внутри фигурных скобок JSX можно использовать только выражения, а if-else это statement (инструкция).</p><p><strong>Альтернативы:</strong></p><p><strong>1. Тернарный оператор:</strong></p><p>Самый частый способ для простых условий.</p><p><strong>2. Логический оператор &&:</strong></p><p>Для рендера при выполнении условия.</p><p><strong>3. Переменная перед return:</strong></p><p>Можно использовать полноценный if-else до JSX, сохранив результат в переменную.</p><p><strong>4. IIFE (Immediately Invoked Function Expression):</strong></p><p>Можно вызвать функцию с if-else внутри фигурных скобок, но это редкий паттерн.</p><p>В большинстве случаев достаточно тернарного оператора или &&.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'условия', 'выражения']
  },
  {
    id: 36,
    question: "Что можно и что нельзя рендерить в JSX?",
    answer: "<p><strong>Можно рендерить:</strong></p><ul><li>Строки и числа — отображаются как текст</li><li>React элементы — результат JSX или createElement</li><li>Массивы элементов — React отрендерит каждый</li><li>null, undefined, false, true — не рендерятся (пустота)</li><li>Фрагменты (<></> или <Fragment>)</li></ul><p><strong>Нельзя рендерить напрямую:</strong></p><ul><li>Объекты — вызовут ошибку \"Objects are not valid as a React child\"</li><li>Функции — нужно их вызвать</li><li>Promises — нужно обработать через then или async/await</li><li>Символы и другие не-примитивные типы</li></ul><p><strong>Важно:</strong></p><p>0 (ноль) рендерится как текст, что иногда неожиданно при условном рендере. Пустые строки тоже рендерятся.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'рендеринг', 'типы данных']
  },
  {
    id: 37,
    question: "Как работают комментарии в JSX?",
    answer: "<p>В JSX комментарии отличаются от обычного JavaScript и HTML.</p><p><strong>Внутри JSX разметки:</strong></p><p>Используются JavaScript комментарии внутри фигурных скобок: {/* комментарий */}. Обычные // или /* */ вне скобок не работают.</p><p><strong>Вне JSX (в коде JavaScript):</strong></p><p>Работают стандартные JavaScript комментарии: // или /* */.</p><p><strong>Почему так:</strong></p><p>JSX это JavaScript, поэтому внутри разметки нужно явно указать, что это комментарий через {}. Компилятор видит это как JavaScript выражение.</p><p><strong>HTML комментарии:</strong></p><p>HTML комментарии <!-- --> не работают в JSX и вызовут ошибку.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'комментарии', 'синтаксис']
  },
  {
    id: 38,
    question: "Почему JSX элементы должны иметь один корневой элемент?",
    answer: "<p>JSX выражение должно иметь один корневой элемент, потому что оно компилируется в один вызов функции.</p><p><strong>Техническое объяснение:</strong></p><p>Функция может вернуть только одно значение. JSX компилируется в вызов createElement/jsx(), который возвращает один объект. Несколько соседних элементов — это несколько объектов, что невозможно вернуть напрямую.</p><p><strong>Решения:</strong></p><ul><li><strong>Fragment</strong> (<React.Fragment> или <>...</>) — группирует без лишнего DOM</li><li><strong>Обертка div</strong> — добавляет реальный DOM элемент</li><li><strong>Массив</strong> — можно вернуть массив элементов с ключами</li></ul><p><strong>Современный подход:</strong></p><p>Фрагменты (<></>) — стандартное решение, не добавляющее лишних узлов в DOM.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'фрагменты', 'ограничения']
  },
  {
    id: 39,
    question: "В чем разница между React.createElement и JSX?",
    answer: "<p>JSX — это синтаксический сахар над React.createElement (или современным jsx() runtime).</p><p><strong>JSX:</strong></p><ul><li>Декларативный, читаемый синтаксис</li><li>Похож на HTML</li><li>Требует транспиляции</li><li>Удобен для написания UI</li></ul><p><strong>createElement:</strong></p><ul><li>Императивный вызов функции</li><li>Работает без транспиляции</li><li>Менее читаем при сложной вложенности</li><li>Это то, во что компилируется JSX</li></ul><p><strong>Функционально идентичны:</strong></p><p>Оба создают одинаковые React элементы (объекты Virtual DOM). JSX просто удобнее читать и писать.</p><p><strong>Когда использовать createElement:</strong></p><p>При динамическом создании элементов, в библиотеках, или когда нужно избежать транспиляции.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'createElement', 'API', 'отличия']
  },
  {
    id: 40,
    question: "Как JSX предотвращает XSS атаки?",
    answer: "<p>JSX автоматически экранирует значения перед рендерингом, что защищает от XSS (Cross-Site Scripting).</p><p><strong>Как это работает:</strong></p><ul><li>Все значения в {} преобразуются в строки и экранируются</li><li>Специальные символы (<, >, &, кавычки) заменяются на HTML entities</li><li>Вредоносный код не может быть выполнен</li></ul><p><strong>Пример защиты:</strong></p><p>Если пользователь введет <script>alert('XSS')</script>, React отобразит это как текст, а не выполнит скрипт.</p><p><strong>Исключение:</strong></p><p>dangerouslySetInnerHTML — специальный prop для вставки сырого HTML. Название предупреждает об опасности. Использовать только с проверенными данными.</p><p>Это встроенная защита делает React безопасным по умолчанию.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'безопасность', 'XSS']
  },
  {
    id: 41,
    question: "Что такое JSX spread attributes и когда их использовать?",
    answer: "<p><strong>Spread attributes</strong> — это способ передать все свойства объекта как props компоненту через оператор расширения (...).</p><p><strong>Применение:</strong></p><p>Полезно при проксировании props, создании wrapper компонентов, или передаче множества пропсов от родителя к ребенку.</p><p><strong>Преимущества:</strong></p><ul><li>Меньше кода при множестве пропсов</li><li>Удобно для компонентов-оберток</li><li>Гибкость при неизвестном наборе props</li></ul><p><strong>Недостатки:</strong></p><ul><li>Неявность — непонятно какие props передаются</li><li>Можно случайно передать лишние props</li><li>Хуже для производительности при частом использовании</li></ul><p><strong>Best practice:</strong></p><p>Использовать умеренно, деструктурировать нужные props явно, остальное в spread.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'spread', 'props', 'паттерны']
  },
  {
    id: 42,
    question: "Как в JSX работают булевы атрибуты?",
    answer: "<p>Булевы атрибуты в JSX ведут себя иначе, чем в HTML.</p><p><strong>В HTML:</strong></p><p>Наличие атрибута = true, отсутствие = false. Значение не важно.</p><p><strong>В JSX:</strong></p><p>Нужно явно передавать true или false. Можно использовать краткую запись: disabled эквивалентно disabled={true}.</p><p><strong>Особенности:</strong></p><ul><li>false делает атрибут отсутствующим в DOM</li><li>true добавляет атрибут в DOM</li><li>undefined/null также убирают атрибут</li></ul><p><strong>Распространенные булевы атрибуты:</strong></p><p>disabled, checked, required, readOnly, autoFocus, multiple.</p><p><strong>Важно:</strong></p><p>Строки \"false\" или \"true\" — это не boolean, а строки, что может вызвать баги.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'атрибуты', 'boolean', 'HTML']
  },
  {
    id: 43,
    question: "В чем разница между {} и {{}} в JSX?",
    answer: "<p>Это частый источник путаницы для новичков.</p><p><strong>Одинарные фигурные скобки {}:</strong></p><ul><li>Обозначают JavaScript выражение внутри JSX</li><li>Используются для вставки переменных, вызова функций, условий</li></ul><p><strong>Двойные фигурные скобки {{}}:</strong></p><ul><li>Это не специальный синтаксис JSX</li><li>Внешние {} — синтаксис JSX</li><li>Внутренние {} — литерал JavaScript объекта</li><li>Используются для передачи объектов как props</li></ul><p><strong>Типичное применение {{}}:</strong></p><p>Inline стили в JSX — style={{color: 'red'}}. Первые {} говорят \"это JS\", вторые {} создают объект стилей.</p><p><strong>Важно понимать:</strong></p><p>Это просто объект внутри JavaScript выражения, никакой магии.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'синтаксис', 'фигурные скобки', 'объекты']
  },
  {
    id: 44,
    question: "Почему нельзя использовать for и while циклы прямо в JSX?",
    answer: "<p>for и while — это statements (инструкции), а в JSX можно использовать только expressions (выражения).</p><p><strong>В чем разница:</strong></p><ul><li><strong>Expression</strong> — возвращает значение (тернарный оператор, вызов функции)</li><li><strong>Statement</strong> — выполняет действие, не возвращает значение (for, while, if)</li></ul><p><strong>Альтернативы в JSX:</strong></p><ul><li><strong>map()</strong> — самый частый способ для списков</li><li><strong>filter()</strong> — для условной фильтрации элементов</li><li><strong>reduce()</strong> — для сложных трансформаций</li><li><strong>IIFE</strong> — можно обернуть цикл в функцию и сразу вызвать</li></ul><p><strong>Best practice:</strong></p><p>Использовать функциональные методы массивов (map, filter) — это декларативнее и читаемее.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'циклы', 'выражения', 'ограничения']
  },
  {
    id: 45,
    question: "Как JSX обрабатывает пробелы и переносы строк?",
    answer: "<p>JSX обрабатывает whitespace (пробелы, табы, переносы) не так, как HTML.</p><p><strong>Правила JSX:</strong></p><ul><li>Пробелы в начале и конце строки удаляются</li><li>Пустые строки удаляются</li><li>Переносы строк рядом с тегами сворачиваются</li><li>Множественные пробелы между словами сохраняются</li></ul><p><strong>Отличие от HTML:</strong></p><p>HTML сворачивает любые последовательности whitespace в один пробел. JSX более предсказуем.</p><p><strong>Как контролировать:</strong></p><ul><li>Явные пробелы через {' '}</li><li>&nbsp; для неразрывного пробела</li><li>CSS white-space для управления отображением</li></ul><p><strong>На практике:</strong></p><p>Обычно достаточно знать, что пробелы между тегами схлопываются, и использовать {' '} когда нужен гарантированный пробел.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'whitespace', 'форматирование', 'особенности']
  },
  {
    id: 46,
    question: "Что такое SyntheticEvent в React и зачем он нужен?",
    answer: "<p><strong>SyntheticEvent</strong> — это кросс-браузерная обертка React над нативными событиями браузера.</p><p><strong>Зачем нужен:</strong></p><ul><li><strong>Единый API</strong> — одинаковое поведение во всех браузерах</li><li><strong>Производительность</strong> — переиспользование объектов событий (event pooling до React 17)</li><li><strong>Удобство</strong> — нормализация различий между браузерами</li><li><strong>Совместимость с Virtual DOM</strong> — интеграция в систему React</li></ul><p><strong>Ключевые особенности:</strong></p><p>SyntheticEvent имеет тот же интерфейс, что и нативное событие: stopPropagation(), preventDefault(), target, currentTarget. Но это отдельный объект, который React создает и управляет его жизненным циклом.</p>",
    difficulty: 'middle',
    tags: ['события', 'SyntheticEvent', 'основы']
  },
  {
    id: 47,
    question: "В чем разница между SyntheticEvent и нативным браузерным событием?",
    answer: "<p><strong>SyntheticEvent (React):</strong></p><ul><li>Кросс-браузерная обертка</li><li>Единый интерфейс для всех браузеров</li><li>Переиспользуется React (pooling до версии 17)</li><li>Имеет дополнительное поле nativeEvent</li><li>Null-ится после обработки (в старых версиях)</li></ul><p><strong>Native Event (браузер):</strong></p><ul><li>Нативный объект браузера</li><li>Может отличаться между браузерами</li><li>Не переиспользуется</li><li>Доступен через event.nativeEvent в React</li><li>Живет до сборки мусора</li></ul><p><strong>Важно:</strong></p><p>В большинстве случаев можно работать с SyntheticEvent как с обычным событием. Доступ к нативному событию нужен редко.</p>",
    difficulty: 'middle',
    tags: ['события', 'SyntheticEvent', 'отличия', 'Native Events']
  },
  {
    id: 48,
    question: "Как в React обрабатываются события? Опишите механизм event delegation.",
    answer: "<p>React использует паттерн <strong>event delegation</strong> для оптимизации обработки событий.</p><p><strong>Как работает:</strong></p><ul><li>React не регистрирует обработчики на каждом элементе</li><li>Все события регистрируются на корневом узле приложения</li><li>При всплытии события React определяет целевой компонент</li><li>Создает SyntheticEvent и вызывает нужный обработчик</li></ul><p><strong>Преимущества:</strong></p><ul><li><strong>Память</strong> — один обработчик вместо тысяч</li><li><strong>Производительность</strong> — меньше регистраций/удалений</li><li><strong>Динамичность</strong> — работает для динамически добавленных элементов</li></ul><p><strong>Изменение в React 17:</strong></p><p>События теперь регистрируются на корне React приложения, а не на document — это улучшает работу с несколькими React приложениями на странице.</p>",
    difficulty: 'senior',
    tags: ['события', 'event delegation', 'производительность', 'архитектура']
  },
  {
    id: 49,
    question: "Почему нельзя использовать асинхронный доступ к SyntheticEvent?",
    answer: "<p>До React 17 SyntheticEvent объекты переиспользовались (event pooling).</p><p><strong>Проблема:</strong></p><ul><li>После выполнения обработчика все свойства события обнулялись</li><li>Асинхронный доступ (setTimeout, Promise) получал null значения</li><li>React очищал объект для переиспользования</li></ul><p><strong>Решение в старых версиях:</strong></p><p>Использовать event.persist() — убирало событие из пула и сохраняло значения. Или копировать нужные значения в переменные.</p><p><strong>React 17+:</strong></p><p>Event pooling убрали! Теперь можно безопасно использовать события асинхронно без persist(). Это упростило работу, но немного снизило производительность.</p><p><strong>Best practice:</strong></p><p>Все равно лучше извлекать нужные значения сразу для читаемости кода.</p>",
    difficulty: 'senior',
    tags: ['события', 'SyntheticEvent', 'pooling', 'React 17']
  },
  {
    id: 50,
    question: "В чем разница между onClick и onclick в React?",
    answer: "<p><strong>onClick (React/JSX):</strong></p><ul><li>CamelCase нотация</li><li>Принимает функцию как значение</li><li>SyntheticEvent обертка</li><li>Работает через event delegation</li><li>Рекомендуемый способ в React</li></ul><p><strong>onclick (нативный HTML):</strong></p><ul><li>Lowercase</li><li>Принимает строку с JavaScript кодом</li><li>Нативное событие браузера</li><li>Прямая регистрация на элементе</li><li>Антипаттерн в React</li></ul><p><strong>Почему camelCase:</strong></p><p>JSX следует JavaScript конвенциям именования, не HTML. Все DOM свойства и атрибуты в React используют camelCase: onClick, onChange, onSubmit.</p><p><strong>Важно:</strong></p><p>В React всегда используем onClick={handler}, никогда onclick=\"handler()\".</p>",
    difficulty: 'junior',
    tags: ['события', 'именование', 'onClick', 'основы']
  },
  {
    id: 51,
    question: "Как правильно передавать аргументы в обработчики событий?",
    answer: "<p>Есть несколько способов передать аргументы в event handler:</p><p><strong>1. Стрелочная функция inline:</strong></p><p>Создаем новую функцию при каждом рендере. Просто, но может влиять на производительность при частых ререндерах.</p><p><strong>2. Метод bind:</strong></p><p>Привязываем аргументы через bind(). Тоже создает новую функцию при каждом рендере.</p><p><strong>3. Data-атрибуты:</strong></p><p>Храним данные в data-* атрибутах, читаем через event.currentTarget.dataset.</p><p><strong>4. Каррирование:</strong></p><p>Функция возвращает функцию. Внешняя создается один раз, внутренняя — при событии.</p><p><strong>Best practice:</strong></p><p>Для списков и оптимизации — каррирование или useCallback. Для простых случаев — стрелочная функция inline.</p>",
    difficulty: 'middle',
    tags: ['события', 'аргументы', 'обработчики', 'паттерны']
  },
  {
    id: 52,
    question: "Что такое event.preventDefault() и event.stopPropagation()? Когда их использовать?",
    answer: "<p><strong>event.preventDefault():</strong></p><ul><li>Отменяет действие браузера по умолчанию</li><li>Не влияет на всплытие события</li><li>Используется для: отмены отправки формы, предотвращения перехода по ссылке, отмены контекстного меню</li></ul><p><strong>event.stopPropagation():</strong></p><ul><li>Останавливает всплытие события вверх по дереву</li><li>Не отменяет действие по умолчанию</li><li>Родительские обработчики не будут вызваны</li><li>Используется когда событие должно обработаться только на текущем элементе</li></ul><p><strong>Важное отличие:</strong></p><p>preventDefault() отменяет браузерное поведение, stopPropagation() — распространение события в React/DOM дереве.</p><p><strong>Можно использовать вместе:</strong></p><p>Если нужно и отменить действие, и остановить всплытие.</p>",
    difficulty: 'middle',
    tags: ['события', 'preventDefault', 'stopPropagation', 'методы']
  },
  {
    id: 53,
    question: "В чем разница между event.target и event.currentTarget?",
    answer: "<p><strong>event.target:</strong></p><ul><li>Элемент, который инициировал событие</li><li>Элемент, на котором произошел клик/действие</li><li>Может быть дочерним элементом</li><li>Не меняется при всплытии</li></ul><p><strong>event.currentTarget:</strong></p><ul><li>Элемент, на котором зарегистрирован обработчик</li><li>Элемент, к которому привязан onClick</li><li>Всегда совпадает с this в классовых компонентах</li><li>Меняется при всплытии</li></ul><p><strong>Практический пример:</strong></p><p>Если кликнуть на span внутри div с обработчиком: target будет span (где кликнули), currentTarget — div (где обработчик).</p><p><strong>Когда важно:</strong></p><p>При работе с делегированием событий или когда нужно получить данные из элемента с обработчиком, а не из вложенного.</p>",
    difficulty: 'middle',
    tags: ['события', 'target', 'currentTarget', 'отличия']
  },
  {
    id: 54,
    question: "Как в React обрабатывать события в фазе capture?",
    answer: "<p>По умолчанию React обрабатывает события в фазе <strong>bubbling</strong> (всплытие), но можно использовать фазу <strong>capture</strong> (погружение).</p><p><strong>Синтаксис:</strong></p><p>Добавить суффикс Capture к имени события: onClickCapture, onChangeCapture, onFocusCapture.</p><p><strong>Фазы события:</strong></p><ul><li><strong>Capture</strong> — событие идет от корня к цели (сверху вниз)</li><li><strong>Target</strong> — событие достигло целевого элемента</li><li><strong>Bubble</strong> — событие всплывает обратно к корню (снизу вверх)</li></ul><p><strong>Порядок выполнения:</strong></p><p>Сначала все onClickCapture от корня к цели, потом onClick от цели к корню.</p><p><strong>Когда использовать:</strong></p><p>Для перехвата событий до дочерних элементов, блокировки действий, глобальных обработчиков.</p>",
    difficulty: 'senior',
    tags: ['события', 'capture', 'bubbling', 'фазы']
  },
  {
    id: 55,
    question: "Почему важно не использовать стрелочные функции и bind в render?",
    answer: "<p>Создание новых функций в render может вызывать проблемы с производительностью.</p><p><strong>Проблемы:</strong></p><ul><li>Новая функция создается при каждом рендере</li><li>Нарушается сравнение пропсов в React.memo</li><li>Дочерние компоненты ре-рендерятся без необходимости</li><li>Невозможна оптимизация через shouldComponentUpdate</li></ul><p><strong>Решения:</strong></p><ul><li><strong>useCallback</strong> — мемоизация функций в функциональных компонентах</li><li><strong>Метод класса</strong> — определение обработчика как метода класса</li><li><strong>Bind в constructor</strong> — однократная привязка контекста</li><li><strong>Class field syntax</strong> — стрелочные функции как поля класса</li></ul><p><strong>Когда можно игнорировать:</strong></p><p>Для простых компонентов без оптимизации или когда дочерние компоненты легковесные.</p>",
    difficulty: 'senior',
    tags: ['события', 'производительность', 'оптимизация', 'best practices']
  },
  {
    id: 56,
    question: "Как работает onChange в React и чем отличается от нативного?",
    answer: "<p>React нормализовал поведение onChange для лучшего developer experience.</p><p><strong>В React onChange:</strong></p><ul><li>Срабатывает при каждом изменении значения</li><li>Работает как onInput в нативном DOM</li><li>Срабатывает на каждый ввод символа</li><li>Единообразно для всех input элементов</li></ul><p><strong>Нативный onchange:</strong></p><ul><li>Срабатывает при потере фокуса (для текстовых input)</li><li>Для radio/checkbox — сразу при изменении</li><li>Непредсказуемое поведение между элементами</li></ul><p><strong>Почему React изменил поведение:</strong></p><p>Для создания controlled компонентов нужна мгновенная реакция на изменения. Нативный onchange срабатывал слишком поздно.</p><p><strong>Нативный аналог:</strong></p><p>Если нужно нативное поведение, можно использовать onBlur.</p>",
    difficulty: 'middle',
    tags: ['события', 'onChange', 'формы', 'отличия']
  },
  {
    id: 57,
    question: "Что такое пассивные события (passive events) и как они влияют на производительность?",
    answer: "<p><strong>Passive events</strong> — это события с опцией {passive: true}, которые обещают не вызывать preventDefault().</p><p><strong>Зачем нужны:</strong></p><ul><li>Браузер не ждет выполнения обработчика для scroll/touch</li><li>Улучшается плавность прокрутки и касаний</li><li>Особенно важно на мобильных устройствах</li></ul><p><strong>В React:</strong></p><p>React автоматически делает некоторые события пассивными (wheel, touchstart, touchmove). Нельзя вызвать preventDefault() для пассивных событий.</p><p><strong>Как использовать непассивное:</strong></p><p>Нужно регистрировать напрямую через addEventListener с {passive: false} в useEffect, если требуется preventDefault().</p><p><strong>Важно:</strong></p><p>Это оптимизация браузера, React просто следует спецификации.</p>",
    difficulty: 'senior',
    tags: ['события', 'производительность', 'passive events', 'оптимизация']
  },
  {
    id: 58,
    question: "Как обрабатывать события клавиатуры в React?",
    answer: "<p>React предоставляет несколько событий для работы с клавиатурой:</p><p><strong>Основные события:</strong></p><ul><li><strong>onKeyDown</strong> — клавиша нажата</li><li><strong>onKeyPress</strong> — клавиша нажата (deprecated, не использовать)</li><li><strong>onKeyUp</strong> — клавиша отпущена</li></ul><p><strong>Свойства события:</strong></p><ul><li><strong>key</strong> — название клавиши ('Enter', 'a', 'ArrowUp')</li><li><strong>code</strong> — физический код клавиши ('KeyA', 'Enter')</li><li><strong>keyCode</strong> — числовой код (deprecated)</li><li><strong>altKey, ctrlKey, shiftKey, metaKey</strong> — модификаторы</li></ul><p><strong>Best practices:</strong></p><p>Использовать event.key вместо keyCode. Для горячих клавиш проверять комбинации модификаторов. onKeyDown для большинства случаев, onKeyUp для специфичных сценариев.</p>",
    difficulty: 'middle',
    tags: ['события', 'клавиатура', 'onKeyDown', 'обработка']
  },
  {
    id: 59,
    question: "Как правильно работать с событиями в useEffect?",
    answer: "<p>При работе с нативными событиями в useEffect нужно соблюдать правила:</p><p><strong>Паттерн подписки:</strong></p><ul><li>Регистрировать обработчик в useEffect</li><li>Обязательно удалять в cleanup функции</li><li>Использовать один и тот же reference функции</li></ul><p><strong>Частые ошибки:</strong></p><ul><li>Забыть cleanup — утечка памяти и множественные обработчики</li><li>Создать новую функцию в cleanup — удаление не сработает</li><li>Не указать зависимости — stale closure на старые значения</li></ul><p><strong>Когда использовать:</strong></p><p>Для событий window, document, нативных элементов через ref, сторонних библиотек. Для обычных React событий использовать onClick и др.</p><p><strong>Best practice:</strong></p><p>Выносить обработчик в отдельную функцию, мемоизировать через useCallback с правильными зависимостями.</p>",
    difficulty: 'senior',
    tags: ['события', 'useEffect', 'cleanup', 'хуки']
  },
  {
    id: 60,
    question: "В чем особенности событий форм в React (onSubmit, onChange, onInput)?",
    answer: "<p><strong>onSubmit:</strong></p><ul><li>Срабатывает при отправке формы (Enter или кнопка submit)</li><li>Всегда вызывать event.preventDefault() чтобы избежать перезагрузки страницы</li><li>Регистрируется на <form>, не на кнопке</li></ul><p><strong>onChange:</strong></p><ul><li>В React работает как нативный onInput — при каждом изменении</li><li>Основа для controlled компонентов</li><li>Работает для input, textarea, select</li></ul><p><strong>onInput:</strong></p><ul><li>Нативное событие, работает аналогично React onChange</li><li>В React лучше использовать onChange для единообразия</li></ul><p><strong>Best practices:</strong></p><p>Использовать onSubmit на форме, onChange для полей, всегда preventDefault для onSubmit, валидировать данные до отправки.</p>",
    difficulty: 'middle',
    tags: ['события', 'формы', 'onSubmit', 'onChange']
  },
  {
    id: 61,
    question: "Что такое ref в React и для чего он используется?",
    answer: "<p><strong>Ref (reference)</strong> — это способ получить прямой доступ к DOM элементу или экземпляру компонента.</p><p><strong>Основное назначение:</strong></p><ul><li>Доступ к DOM узлам для императивных операций</li><li>Хранение мутабельных значений между рендерами</li><li>Интеграция со сторонними библиотеками</li><li>Управление фокусом, выделением текста, анимациями</li></ul><p><strong>Ключевая особенность:</strong></p><p>Изменение ref.current НЕ вызывает ререндер — это делает ref идеальным для хранения данных, которые не влияют на UI.</p><p><strong>Когда использовать:</strong></p><p>Когда нужно «вырваться» из декларативного подхода React и выполнить императивные действия с DOM или сохранить значение без триггера рендера.</p>",
    difficulty: 'junior',
    tags: ['ref', 'основы', 'DOM']
  },
  {
    id: 62,
    question: "В чем разница между useRef и createRef?",
    answer: "<p><strong>useRef (хук):</strong></p><ul><li>Для функциональных компонентов</li><li>Создается один раз при монтировании</li><li>Сохраняет значение между рендерами</li><li>Возвращает один и тот же объект всегда</li></ul><p><strong>createRef (классический API):</strong></p><ul><li>Для классовых компонентов</li><li>Создает новый ref объект при каждом вызове</li><li>В функциональных компонентах создавал бы новый ref каждый рендер</li><li>Сохраняется в поле класса (this.myRef)</li></ul><p><strong>Важное отличие:</strong></p><p>useRef персистентен между рендерами, createRef — нет. В функциональных компонентах всегда используем useRef.</p><p><strong>Современная практика:</strong></p><p>useRef — стандарт для функциональных компонентов, createRef остался для legacy классовых компонентов.</p>",
    difficulty: 'middle',
    tags: ['useRef', 'createRef', 'отличия', 'хуки']
  },
  {
    id: 63,
    question: "Какой основной сценарий использования useRef кроме доступа к DOM?",
    answer: "<p><strong>Хранение мутабельных значений</strong> — главный неочевидный use case для useRef.</p><p><strong>Типичные сценарии:</strong></p><ul><li><strong>Хранение предыдущих значений</strong> — сохранить предыдущий state для сравнения</li><li><strong>Таймеры и интервалы</strong> — хранить ID для clearTimeout/clearInterval</li><li><strong>Счетчики без ререндера</strong> — отслеживание количества рендеров</li><li><strong>Флаги состояния</strong> — isMounted, isFirstRender</li><li><strong>Кеширование вычислений</strong> — сохранить результат без useMemo</li></ul><p><strong>Почему ref, а не state:</strong></p><p>ref не вызывает ререндер при изменении — идеально для вспомогательных данных, которые не должны влиять на UI.</p><p><strong>Принцип:</strong></p><p>Если данные не отображаются в UI — используй ref, если отображаются — state.</p>",
    difficulty: 'middle',
    tags: ['useRef', 'мутабельность', 'сценарии использования']
  },
  {
    id: 64,
    question: "Что такое forwardRef и зачем он нужен?",
    answer: "<p><strong>forwardRef</strong> — это функция высшего порядка, позволяющая компоненту передать ref дальше к дочернему элементу.</p><p><strong>Проблема без forwardRef:</strong></p><p>Обычные функциональные компоненты не могут принимать ref как prop — React его игнорирует. ref это специальный prop, как key.</p><p><strong>Как работает:</strong></p><p>forwardRef оборачивает компонент и предоставляет ref вторым параметром после props. Внутри можно прокинуть ref дальше к нужному элементу.</p><p><strong>Когда использовать:</strong></p><ul><li>Библиотеки UI компонентов — Input, Button с доступом к DOM</li><li>HOC компоненты — сохранение возможности получить ref</li><li>Wrapper компоненты — прокидывание ref через обертку</li></ul>",
    difficulty: 'middle',
    tags: ['forwardRef', 'ref', 'компоненты']
  },
  {
    id: 65,
    question: "Какие преимущества дает forwardRef при работе с компонентами?",
    answer: "<p><strong>Основные преимущества forwardRef:</strong></p><ul><li><strong>Прозрачность API</strong> — компонент работает как нативный элемент</li><li><strong>Композиция</strong> — можно оборачивать компоненты без потери функциональности</li><li><strong>Доступ к DOM</strong> — родитель может управлять фокусом, прокруткой</li><li><strong>Интеграция</strong> — компоненты легко использовать со сторонними библиотеками</li><li><strong>Совместимость</strong> — работа с императивными API без костылей</li></ul><p><strong>Практическая ценность:</strong></p><p>Позволяет создавать переиспользуемые компоненты, которые не скрывают возможности нативных элементов.</p><p><strong>Пример:</strong></p><p>Input компонент с forwardRef позволяет родителю вызвать focus() без дополнительных пропсов или callback'ов.</p>",
    difficulty: 'middle',
    tags: ['forwardRef', 'преимущества', 'архитектура']
  },
  {
    id: 66,
    question: "Как работать с несколькими ref в одном компоненте?",
    answer: "<p>Есть несколько подходов для работы с множественными ref:</p><p><strong>1. Несколько useRef:</strong></p><p>Создать отдельный ref для каждого элемента — самый простой способ.</p><p><strong>2. Ref как объект/массив:</strong></p><p>Хранить все ref'ы в одном объекте или массиве — удобно для динамических списков.</p><p><strong>3. Callback ref:</strong></p><p>Использовать функцию вместо объекта ref — даст больше контроля при присвоении.</p><p><strong>4. useImperativeHandle:</strong></p><p>Собрать методы из разных элементов в один API для родителя.</p><p><strong>Best practice для списков:</strong></p><p>Создать Map или объект для хранения ref'ов по ключу элемента, использовать callback ref для добавления в коллекцию.</p>",
    difficulty: 'senior',
    tags: ['ref', 'множественные ref', 'паттерны']
  },
  {
    id: 67,
    question: "Что такое useImperativeHandle и когда его использовать?",
    answer: "<p><strong>useImperativeHandle</strong> — хук для кастомизации значения ref, передаваемого родителю через forwardRef.</p><p><strong>Зачем нужен:</strong></p><ul><li>Ограничить API — не давать полный доступ к DOM</li><li>Создать кастомные методы для родителя</li><li>Скрыть внутреннюю реализацию</li><li>Объединить несколько элементов в один интерфейс</li></ul><p><strong>Как работает:</strong></p><p>Вместо прокидывания ref напрямую к DOM, создаем объект с нужными методами. Родитель получает не DOM элемент, а наш кастомный API.</p><p><strong>Когда использовать:</strong></p><p>В библиотеках компонентов, когда нужен контроль над публичным API, для инкапсуляции логики.</p><p><strong>Важно:</strong></p><p>Это escape hatch — использовать умеренно, предпочитать декларативный подход через props.</p>",
    difficulty: 'senior',
    tags: ['useImperativeHandle', 'forwardRef', 'API', 'хуки']
  },
  {
    id: 68,
    question: "В чем разница между callback ref и object ref?",
    answer: "<p><strong>Object ref (useRef):</strong></p><ul><li>Объект с полем current</li><li>Присваивается автоматически React'ом</li><li>Статичный — один и тот же объект</li><li>Не уведомляет об изменениях</li></ul><p><strong>Callback ref:</strong></p><ul><li>Функция, вызываемая с DOM элементом</li><li>Вызывается при монтировании (с элементом) и размонтировании (с null)</li><li>Можно выполнить side effects</li><li>Уведомляет об изменениях ref</li></ul><p><strong>Когда использовать callback:</strong></p><ul><li>Нужно выполнить действие при получении ref</li><li>Динамические списки с ref</li><li>Интеграция со сторонними библиотеками</li><li>Измерение размеров элемента</li></ul><p><strong>Особенность:</strong></p><p>Callback ref вызывается дважды при каждом изменении — сначала с null (unmount), потом с элементом (mount).</p>",
    difficulty: 'senior',
    tags: ['ref', 'callback ref', 'отличия', 'продвинутое']
  },
  {
    id: 69,
    question: "Почему изменение ref.current не вызывает ререндер?",
    answer: "<p>ref.current — это обычное JavaScript свойство объекта, не связанное с системой реактивности React.</p><p><strong>Техническое объяснение:</strong></p><ul><li>ref это просто объект {current: значение}</li><li>React не отслеживает изменения в ref.current</li><li>Нет геттеров/сеттеров для перехвата мутаций</li><li>ref живет вне системы state/props</li></ul><p><strong>Почему так спроектировано:</strong></p><p>ref нужен именно для хранения мутабельных значений БЕЗ ререндера — это его основная фича, не баг.</p><p><strong>Когда это полезно:</strong></p><p>Хранение DOM элементов, таймеров, счетчиков, флагов — данных, которые нужны для логики, но не для отображения.</p><p><strong>Если нужен ререндер:</strong></p><p>Используй state вместо ref — это фундаментальное различие между ними.</p>",
    difficulty: 'middle',
    tags: ['ref', 'ререндер', 'реактивность', 'принципы']
  },
  {
    id: 70,
    question: "Как правильно очищать ref в useEffect cleanup?",
    answer: "<p>При работе с ref в useEffect важно правильно управлять ресурсами.</p><p><strong>Паттерн очистки:</strong></p><p>Сохранить ref.current в переменную в начале effect, использовать эту переменную в cleanup. Это защищает от ситуации, когда ref.current изменился к моменту cleanup.</p><p><strong>Почему важно:</strong></p><ul><li>ref.current может быть null в cleanup</li><li>Элемент мог размонтироваться</li><li>ref мог быть переназначен</li></ul><p><strong>Частые ошибки:</strong></p><ul><li>Использовать ref.current напрямую в cleanup — может быть null</li><li>Не проверять на существование перед удалением обработчиков</li><li>Забыть сохранить локальную копию для cleanup</li></ul><p><strong>Best practice:</strong></p><p>Всегда захватывать ref.current в переменную в теле effect, использовать в cleanup, проверять на null.</p>",
    difficulty: 'senior',
    tags: ['ref', 'useEffect', 'cleanup', 'best practices']
  },
  {
    id: 71,
    question: "Можно ли передать ref как обычный prop?",
    answer: "<p><strong>Напрямую нельзя</strong> — ref это зарезервированный prop, как key.</p><p><strong>Что происходит:</strong></p><p>Если передать ref={myRef} в компонент, React не передаст его в props — он обработается специальным образом.</p><p><strong>Решения:</strong></p><ul><li><strong>forwardRef</strong> — стандартный способ для передачи ref</li><li><strong>Другое имя</strong> — innerRef, inputRef, customRef как обычный prop</li><li><strong>Callback prop</strong> — передать функцию, которая получит элемент</li></ul><p><strong>Почему ref особенный:</strong></p><p>React обрабатывает ref и key на особом уровне — они не попадают в props компонента, чтобы избежать конфликтов и упростить внутреннюю работу.</p><p><strong>Best practice:</strong></p><p>Для библиотечных компонентов — forwardRef. Для внутренних — можно innerRef как prop.</p>",
    difficulty: 'middle',
    tags: ['ref', 'props', 'ограничения', 'forwardRef']
  },
  {
    id: 72,
    question: "Что такое управляемый и неуправляемый ref в React?",
    answer: "<p>Это концепция аналогичная controlled/uncontrolled компонентам, но для ref.</p><p><strong>Управляемый ref (controlled):</strong></p><ul><li>Родитель создает ref и передает в дочерний компонент</li><li>Родитель контролирует и использует ref</li><li>Компонент получает ref через forwardRef</li><li>Источник истины — родитель</li></ul><p><strong>Неуправляемый ref (uncontrolled):</strong></p><ul><li>Компонент создает свой внутренний ref</li><li>Родитель не имеет доступа</li><li>Источник истины — сам компонент</li><li>Используется для внутренней логики</li></ul><p><strong>Когда что использовать:</strong></p><p>Controlled ref — когда родителю нужен доступ к DOM. Uncontrolled — для внутренней реализации компонента.</p><p><strong>Можно комбинировать:</strong></p><p>Компонент может иметь внутренний ref и принимать внешний через forwardRef.</p>",
    difficulty: 'senior',
    tags: ['ref', 'controlled', 'uncontrolled', 'паттерны']
  },
  {
    id: 73,
    question: "Как объединить внешний forwardedRef с внутренним ref?",
    answer: "<p>Часто компоненту нужен собственный ref для логики И нужно пробросить ref родителю.</p><p><strong>Проблема:</strong></p><p>У элемента может быть только один ref. Как использовать и внутренний, и внешний одновременно?</p><p><strong>Решение 1 — Callback ref:</strong></p><p>Создать функцию, которая присваивает элемент обоим ref'ам — и внутреннему, и forwardedRef.</p><p><strong>Решение 2 — useImperativeHandle:</strong></p><p>Использовать внутренний ref для логики, через useImperativeHandle дать родителю кастомный API.</p><p><strong>Решение 3 — Библиотека:</strong></p><p>Использовать хелпер типа useForkRef из библиотек (MUI использует этот паттерн).</p><p><strong>Best practice:</strong></p><p>Для простых случаев — callback ref. Для сложных — useImperativeHandle с ограниченным API.</p>",
    difficulty: 'senior',
    tags: ['ref', 'forwardRef', 'объединение', 'продвинутое']
  },
  {
    id: 74,
    question: "Когда следует избегать использования ref?",
    answer: "<p>ref — это escape hatch, который нужно использовать осторожно.</p><p><strong>Не использовать ref для:</strong></p><ul><li><strong>Данных для рендера</strong> — используй state</li><li><strong>Коммуникации компонентов</strong> — используй props/context</li><li><strong>Замены state</strong> — теряется реактивность</li><li><strong>Обхода однонаправленного потока</strong> — нарушается архитектура</li></ul><p><strong>Антипаттерны:</strong></p><ul><li>Вызывать методы дочерних компонентов через ref</li><li>Хранить в ref данные, которые влияют на UI</li><li>Использовать ref для избежания ререндеров (есть лучшие способы)</li></ul><p><strong>Когда ref оправдан:</strong></p><p>DOM манипуляции (фокус, скролл), интеграция со сторонними библиотеками, измерения, анимации, хранение мутабельных значений.</p><p><strong>Принцип:</strong></p><p>Сначала попробуй решить декларативно через props/state. ref — последнее средство.</p>",
    difficulty: 'middle',
    tags: ['ref', 'антипаттерны', 'best practices', 'архитектура']
  },
  {
    id: 75,
    question: "Как ref работает с React StrictMode и почему компонент с ref может рендериться дважды?",
    answer: "<p><strong>StrictMode в разработке</strong> намеренно делает двойной рендер для выявления проблем.</p><p><strong>Влияние на ref:</strong></p><ul><li>Callback ref вызывается 4 раза вместо 2 (mount-unmount-mount-unmount)</li><li>useEffect cleanup/setup запускается дважды</li><li>ref.current может временно быть null даже после монтирования</li></ul><p><strong>Почему это происходит:</strong></p><p>StrictMode симулирует размонтирование/монтирование для проверки корректности cleanup логики.</p><p><strong>Как это учитывать:</strong></p><ul><li>Код должен быть идемпотентным</li><li>Cleanup должен корректно отменять side effects</li><li>Не полагаться на количество вызовов</li></ul><p><strong>В продакшене:</strong></p><p>Двойного рендера нет — это только dev режим для помощи в отладке.</p>",
    difficulty: 'senior',
    tags: ['ref', 'StrictMode', 'debugging', 'особенности']
  },
  {
    id: 76,
    question: "Что такое useMemo и для чего он используется?",
    answer: "<p><strong>useMemo</strong> — это хук для мемоизации вычисленных значений, позволяющий кэшировать результат дорогостоящих вычислений.</p><p><strong>Основное назначение:</strong></p><ul><li>Оптимизация производительности через кэширование</li><li>Избежание лишних вычислений при каждом рендере</li><li>Сохранение референса объекта/массива между рендерами</li></ul><p><strong>Как работает:</strong></p><p>useMemo принимает функцию-вычисление и массив зависимостей. Пересчет происходит только когда изменяются зависимости. В остальных случаях возвращается кэшированное значение.</p><p><strong>Важно понимать:</strong></p><p>useMemo — это оптимизация, не гарантия. React может \"забыть\" мемоизированное значение для освобождения памяти. Код должен работать корректно и без useMemo.</p>",
    difficulty: 'middle',
    tags: ['useMemo', 'мемоизация', 'оптимизация', 'хуки']
  },
  {
    id: 77,
    question: "Какие преимущества дает useMemo для оптимизации производительности?",
    answer: "<p><strong>Ключевые преимущества useMemo:</strong></p><ul><li><strong>Избежание тяжелых вычислений</strong> — сортировка, фильтрация, математические операции выполняются только при изменении данных</li><li><strong>Стабильность референсов</strong> — объекты и массивы не пересоздаются при каждом рендере</li><li><strong>Предотвращение лишних ререндеров</strong> — компоненты с React.memo не ре-рендерятся при неизменных мемоизированных пропсах</li><li><strong>Оптимизация зависимостей</strong> — useEffect не перезапускается при стабильных объектах в deps</li></ul><p><strong>Измеримый эффект:</strong></p><p>При правильном использовании может значительно улучшить отзывчивость UI, особенно при работе с большими списками или сложными вычислениями.</p>",
    difficulty: 'middle',
    tags: ['useMemo', 'производительность', 'преимущества']
  },
  {
    id: 78,
    question: "В каких ситуациях следует использовать useMemo?",
    answer: "<p><strong>Используй useMemo когда:</strong></p><ul><li><strong>Дорогие вычисления</strong> — фильтрация/сортировка больших массивов, сложные математические расчеты</li><li><strong>Передача объектов в зависимости</strong> — объект/массив в deps useEffect, чтобы избежать бесконечных циклов</li><li><strong>Props для React.memo</strong> — передача объектов в оптимизированные компоненты</li><li><strong>Тяжелые трансформации данных</strong> — форматирование, группировка, агрегация данных</li></ul><p><strong>НЕ используй для:</strong></p><ul><li>Простых вычислений — сложение чисел, конкатенация строк</li><li>Примитивных значений — числа, строки, boolean уже стабильны</li><li>Преждевременной оптимизации — сначала измерь, есть ли проблема</li></ul><p><strong>Правило:</strong></p><p>useMemo — это оптимизация с накладными расходами. Используй только когда профилирование показывает реальную проблему.</p>",
    difficulty: 'middle',
    tags: ['useMemo', 'сценарии использования', 'best practices']
  },
  {
    id: 79,
    question: "Что такое useCallback и как он связан с обработчиками событий?",
    answer: "<p><strong>useCallback</strong> — это хук для мемоизации функций, возвращающий стабильную ссылку на функцию между рендерами.</p><p><strong>Связь с обработчиками:</strong></p><p>При каждом рендере все функции пересоздаются с новой ссылкой. useCallback предотвращает это, сохраняя одну и ту же функцию пока не изменятся зависимости.</p><p><strong>Основное применение:</strong></p><ul><li>Обработчики событий для оптимизированных компонентов</li><li>Callback'и, передаваемые в дочерние компоненты с React.memo</li><li>Функции в зависимостях useEffect</li><li>Функции, используемые в контексте или других хуках</li></ul><p><strong>Ключевое отличие от useMemo:</strong></p><p>useCallback мемоизирует саму функцию, useMemo — результат её вызова.</p>",
    difficulty: 'middle',
    tags: ['useCallback', 'мемоизация', 'обработчики', 'хуки']
  },
  {
    id: 80,
    question: "В каких ситуациях следует использовать useCallback?",
    answer: "<p><strong>Используй useCallback когда:</strong></p><ul><li><strong>Передача в React.memo компоненты</strong> — чтобы дочерний компонент не ре-рендерился</li><li><strong>В deps других хуков</strong> — функция в зависимостях useEffect, useMemo</li><li><strong>Оптимизация списков</strong> — callback для каждого элемента списка</li><li><strong>Контекст</strong> — функции в значении контекста</li><li><strong>Сторонние библиотеки</strong> — когда библиотека сравнивает функции по ссылке</li></ul><p><strong>НЕ используй для:</strong></p><ul><li>Обычных inline обработчиков без оптимизации</li><li>Функций, которые не передаются как props</li><li>Когда дочерний компонент не оптимизирован</li></ul><p><strong>Принцип:</strong></p><p>useCallback имеет смысл только в связке с другими оптимизациями (React.memo, deps). Сам по себе он добавляет overhead.</p>",
    difficulty: 'middle',
    tags: ['useCallback', 'сценарии использования', 'best practices']
  },
  {
    id: 81,
    question: "В чем разница между useMemo и useCallback?",
    answer: "<p><strong>Функциональное различие:</strong></p><ul><li><strong>useMemo(() => value, deps)</strong> — мемоизирует РЕЗУЛЬТАТ вызова функции</li><li><strong>useCallback(fn, deps)</strong> — мемоизирует САМУ функцию</li></ul><p><strong>На практике:</strong></p><p>useCallback(fn, deps) полностью эквивалентен useMemo(() => fn, deps). useCallback — это просто синтаксический сахар для частого случая.</p><p><strong>Когда что использовать:</strong></p><ul><li>useMemo — для вычисляемых значений (числа, строки, объекты, массивы)</li><li>useCallback — для функций-обработчиков</li></ul><p><strong>Важно:</strong></p><p>Оба возвращают мемоизированное значение, но семантически useCallback явно показывает, что мемоизируется функция.</p>",
    difficulty: 'middle',
    tags: ['useMemo', 'useCallback', 'отличия', 'сравнение']
  },
  {
    id: 82,
    question: "Как работает массив зависимостей в useMemo и useCallback?",
    answer: "<p><strong>Массив зависимостей</strong> определяет, когда нужно пересчитать мемоизированное значение.</p><p><strong>Как работает:</strong></p><ul><li>React сравнивает каждую зависимость с предыдущим значением через Object.is</li><li>Если хотя бы одна изменилась — вычисление/функция пересоздаются</li><li>Если все зависимости те же — возвращается кэшированное значение</li></ul><p><strong>Важные правила:</strong></p><ul><li>Включать ВСЕ используемые внешние значения из области видимости</li><li>Не опускать зависимости — это приводит к stale closure</li><li>Объекты и массивы сравниваются по ссылке, не по содержимому</li></ul><p><strong>Пустой массив []:</strong></p><p>Мемоизация навсегда — вычисление происходит один раз при монтировании.</p><p><strong>ESLint правило:</strong></p><p>exhaustive-deps помогает избежать забытых зависимостей.</p>",
    difficulty: 'middle',
    tags: ['useMemo', 'useCallback', 'зависимости', 'deps']
  },
  {
    id: 83,
    question: "Что такое stale closure и как useMemo/useCallback могут к этому привести?",
    answer: "<p><strong>Stale closure</strong> — это замыкание, которое захватило устаревшие значения из-за неправильных зависимостей.</p><p><strong>Как возникает:</strong></p><p>Если не указать значение в deps, функция/вычисление \"заморозятся\" со старыми значениями. При изменении этих значений мемоизированная функция продолжит использовать первоначальные.</p><p><strong>Типичный пример:</strong></p><p>useCallback с обработчиком, который использует state, но state не в deps — обработчик всегда видит начальное значение state.</p><p><strong>Симптомы:</strong></p><ul><li>Функция использует устаревшие данные</li><li>Неожиданное поведение после обновлений state</li><li>Работает при первом рендере, потом ломается</li></ul><p><strong>Решение:</strong></p><p>Всегда включать в deps все используемые значения. Использовать ESLint exhaustive-deps правило.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'useCallback', 'stale closure', 'проблемы']
  },
  {
    id: 84,
    question: "Почему нельзя полагаться на useMemo как на гарантию кэширования?",
    answer: "<p>React не гарантирует, что мемоизированное значение сохранится навсегда.</p><p><strong>Причины:</strong></p><ul><li><strong>Управление памятью</strong> — React может очистить кэш для освобождения памяти</li><li><strong>Concurrent режим</strong> — React может отменить незавершенную работу</li><li><strong>Future optimizations</strong> — будущие версии могут менять стратегию кэширования</li></ul><p><strong>Из документации:</strong></p><p>useMemo — это подсказка для оптимизации, а не семантическая гарантия. Код должен корректно работать и без мемоизации.</p><p><strong>Практический смысл:</strong></p><ul><li>Используй useMemo только для производительности</li><li>НЕ полагайся на него для корректности логики</li><li>Побочные эффекты должны быть в useEffect, не в useMemo</li></ul><p><strong>Правило:</strong></p><p>Приложение должно работать правильно, даже если убрать все useMemo — просто медленнее.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'гарантии', 'ограничения', 'принципы']
  },
  {
    id: 85,
    question: "Как useMemo и useCallback взаимодействуют с React.memo?",
    answer: "<p>React.memo, useMemo и useCallback — это триада оптимизации, работающая вместе.</p><p><strong>React.memo:</strong></p><p>Мемоизирует компонент — пропускает ререндер если props не изменились (shallow comparison).</p><p><strong>Проблема без useMemo/useCallback:</strong></p><p>Объекты, массивы и функции пересоздаются при каждом рендере родителя — React.memo видит \"новые\" props и ре-рендерит компонент.</p><p><strong>Решение:</strong></p><ul><li>useMemo — для объектов/массивов в props</li><li>useCallback — для функций-обработчиков в props</li></ul><p><strong>Цепочка оптимизации:</strong></p><p>Родитель использует useMemo/useCallback → стабильные props → React.memo пропускает ререндер ребенка.</p><p><strong>Важно:</strong></p><p>Без React.memo на дочернем компоненте useMemo/useCallback в родителе бессмысленны для этой цели.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'useCallback', 'React.memo', 'оптимизация']
  },
  {
    id: 86,
    question: "Всегда ли нужно оборачивать объекты и массивы в useMemo?",
    answer: "<p><strong>Нет, не всегда.</strong> Это частая ошибка преждевременной оптимизации.</p><p><strong>Когда НЕ нужно:</strong></p><ul><li>Объект/массив не передается как prop</li><li>Дочерний компонент не оптимизирован React.memo</li><li>Объект не в deps других хуков</li><li>Вычисление объекта простое и быстрое</li></ul><p><strong>Когда нужно:</strong></p><ul><li>Объект передается в React.memo компонент</li><li>Объект в зависимостях useEffect/useMemo/useCallback</li><li>Создание объекта дорогостоящее</li><li>Объект используется как identity (map keys, Set/Map)</li></ul><p><strong>Overhead useMemo:</strong></p><p>useMemo сам имеет стоимость — сравнение deps, хранение в памяти. Для простых объектов это может быть дороже их создания.</p><p><strong>Правило:</strong></p><p>Оптимизируй после измерения. React Profiler покажет реальные проблемы.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'объекты', 'best practices', 'оптимизация']
  },
  {
    id: 87,
    question: "Как правильно использовать useMemo для вычислений с тяжелыми зависимостями?",
    answer: "<p>При тяжелых вычислениях важно правильно структурировать зависимости.</p><p><strong>Проблема:</strong></p><p>Если вся тяжелая зависимость (большой объект/массив) в deps, малейшее изменение вызовет пересчет.</p><p><strong>Стратегии оптимизации:</strong></p><ul><li><strong>Примитивные зависимости</strong> — извлечь конкретные значения вместо всего объекта</li><li><strong>Разбить на части</strong> — несколько useMemo с разными частями данных</li><li><strong>Селекторы</strong> — вычислять только нужные поля из объекта</li><li><strong>Нормализация</strong> — хранить данные в удобной для сравнения форме</li></ul><p><strong>Пример паттерна:</strong></p><p>Вместо зависимости от всего массива, зависеть от его длины и hash/timestamp изменений.</p><p><strong>Важно:</strong></p><p>Баланс между точностью deps и частотой пересчетов — слишком грубые deps дают stale data, слишком точные — частые ненужные вычисления.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'оптимизация', 'зависимости', 'продвинутое']
  },
  {
    id: 88,
    question: "В чем разница между мемоизацией и кэшированием в контексте React?",
    answer: "<p><strong>Мемоизация (useMemo/useCallback):</strong></p><ul><li>Кэширование результата функции на основе входных параметров</li><li>Автоматическая инвалидация при изменении зависимостей</li><li>Управляется React'ом</li><li>Живет в рамках компонента и его рендеров</li></ul><p><strong>Кэширование (общее понятие):</strong></p><ul><li>Сохранение данных для переиспользования</li><li>Может быть глобальным (localStorage, server cache)</li><li>Требует явного управления инвалидацией</li><li>Живет дольше компонента</li></ul><p><strong>useMemo — это специфичная мемоизация:</strong></p><p>Работает только внутри компонента между его рендерами. При размонтировании компонента кэш теряется.</p><p><strong>Для глобального кэша:</strong></p><p>Используй state management, React Query, SWR или собственное решение.</p>",
    difficulty: 'middle',
    tags: ['мемоизация', 'кэширование', 'концепции', 'отличия']
  },
  {
    id: 89,
    question: "Можно ли использовать useMemo для побочных эффектов?",
    answer: "<p><strong>Нет, категорически нельзя!</strong> Это антипаттерн и нарушение правил React.</p><p><strong>Почему нельзя:</strong></p><ul><li>useMemo может вызваться или не вызваться — нет гарантий</li><li>React может отменить вычисление в concurrent режиме</li><li>Вычисление должно быть чистой функцией</li><li>Побочные эффекты нарушают идемпотентность</li></ul><p><strong>Что такое побочный эффект:</strong></p><p>Запросы к API, изменение DOM, подписки, таймеры, логирование, изменение внешних переменных.</p><p><strong>Правильное место для эффектов:</strong></p><ul><li><strong>useEffect</strong> — для синхронизации с внешними системами</li><li><strong>event handlers</strong> — для реакции на действия пользователя</li></ul><p><strong>Правило:</strong></p><p>useMemo только для вычислений. Функция в useMemo должна быть чистой — одинаковый вход дает одинаковый выход без side effects.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'побочные эффекты', 'антипаттерны', 'правила']
  },
  {
    id: 90,
    question: "Какие распространенные ошибки делают при использовании useMemo и useCallback?",
    answer: "<p><strong>Топ ошибок:</strong></p><ul><li><strong>Преждевременная оптимизация</strong> — обернуть всё подряд без измерения проблемы</li><li><strong>Неполные зависимости</strong> — пропустить значения в deps → stale closure</li><li><strong>Объекты в deps</strong> — передать нестабильный объект → бесконечные пересчеты</li><li><strong>Побочные эффекты</strong> — делать API запросы или мутации в useMemo</li><li><strong>Игнорирование overhead</strong> — мемоизировать простые вычисления</li><li><strong>Мемоизация без React.memo</strong> — useCallback для props немемоизированного компонента</li><li><strong>Забыть зависимости</strong> — пустой массив [] где нужны реальные deps</li></ul><p><strong>Best practice:</strong></p><p>Начинай без оптимизаций. Профилируй. Оптимизируй узкие места. Проверяй exhaustive-deps. Тестируй после изменений.</p>",
    difficulty: 'senior',
    tags: ['useMemo', 'useCallback', 'ошибки', 'best practices']
  },
  {
    id: 91,
    question: "Что такое useEffect и для чего он используется?",
    answer: "<p><strong>useEffect</strong> — это хук для выполнения побочных эффектов в функциональных компонентах.</p><p><strong>Основное назначение:</strong></p><ul><li>Синхронизация компонента с внешними системами</li><li>Выполнение кода после рендеринга</li><li>Замена методов жизненного цикла классовых компонентов</li><li>Управление подписками и таймерами</li></ul><p><strong>Что такое побочный эффект:</strong></p><p>Любое взаимодействие с миром за пределами React: API запросы, DOM манипуляции, подписки, таймеры, логирование.</p><p><strong>Ключевая идея:</strong></p><p>useEffect запускается ПОСЛЕ того, как React отрисовал изменения в DOM — это гарантирует, что UI обновлен до выполнения эффекта.</p>",
    difficulty: 'junior',
    tags: ['useEffect', 'хуки', 'побочные эффекты', 'основы']
  },
  {
    id: 92,
    question: "В чем разница между useEffect и методами жизненного цикла классовых компонентов?",
    answer: "<p><strong>Концептуальное различие:</strong></p><p>Методы жизненного цикла думают о моменте времени (монтирование, обновление, размонтирование). useEffect думает о синхронизации — что нужно синхронизировать и когда.</p><p><strong>componentDidMount + componentDidUpdate:</strong></p><p>useEffect с зависимостями покрывает оба случая одной функцией — код не дублируется.</p><p><strong>componentWillUnmount:</strong></p><p>Cleanup функция из useEffect — но она вызывается не только при размонтировании, но и перед каждым новым эффектом.</p><p><strong>Принципиальная разница:</strong></p><p>Lifecycle методы — императивные (делай это в этот момент). useEffect — декларативный (синхронизируй это с тем).</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'lifecycle', 'отличия', 'концепции']
  },
  {
    id: 93,
    question: "В какой момент вызывается useEffect? До или после отрисовки в DOM?",
    answer: "<p><strong>useEffect вызывается ПОСЛЕ отрисовки в DOM.</strong></p><p><strong>Порядок выполнения:</strong></p><ul><li>React рендерит компонент (вычисляет JSX)</li><li>React применяет изменения к DOM</li><li>Браузер отрисовывает (paint)</li><li>Только потом запускается useEffect</li></ul><p><strong>Почему так:</strong></p><p>Это гарантирует, что пользователь видит обновленный UI как можно быстрее. Эффекты не блокируют визуальное обновление.</p><p><strong>Исключение — useLayoutEffect:</strong></p><p>Выполняется синхронно ПОСЛЕ мутаций DOM, но ДО отрисовки браузером. Блокирует paint.</p><p><strong>Практический смысл:</strong></p><p>В useEffect уже можно безопасно читать размеры элементов, фокусировать input — DOM уже обновлен.</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'timing', 'рендеринг', 'порядок выполнения']
  },
  {
    id: 94,
    question: "Что такое cleanup функция в useEffect и когда она вызывается?",
    answer: "<p><strong>Cleanup функция</strong> — это функция, которую возвращает эффект для очистки ресурсов.</p><p><strong>Когда вызывается:</strong></p><ul><li><strong>Перед повторным запуском эффекта</strong> — если зависимости изменились</li><li><strong>При размонтировании компонента</strong> — финальная очистка</li></ul><p><strong>Важно понимать:</strong></p><p>Cleanup вызывается НЕ только при unmount, но и перед каждым новым эффектом. Это ключевое отличие от componentWillUnmount.</p><p><strong>Зачем нужна:</strong></p><ul><li>Отменить подписки</li><li>Очистить таймеры</li><li>Отменить запросы</li><li>Удалить обработчики событий</li></ul><p><strong>Порядок:</strong></p><p>Cleanup предыдущего эффекта → новый эффект. Это гарантирует отсутствие дублирования подписок.</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'cleanup', 'жизненный цикл']
  },
  {
    id: 95,
    question: "Объясните порядок выполнения useEffect при монтировании, обновлении и размонтировании компонента",
    answer: "<p><strong>При монтировании:</strong></p><ul><li>Render компонента</li><li>React обновляет DOM</li><li>Браузер рисует экран</li><li>useEffect выполняется</li></ul><p><strong>При обновлении (изменились deps):</strong></p><ul><li>Render компонента</li><li>React обновляет DOM</li><li>Браузер рисует экран</li><li>Cleanup функция предыдущего эффекта</li><li>Новый useEffect выполняется</li></ul><p><strong>При размонтировании:</strong></p><ul><li>Cleanup функция последнего эффекта</li><li>Компонент удаляется из DOM</li></ul><p><strong>Ключевой момент:</strong></p><p>Cleanup ВСЕГДА выполняется с замыканием на старые значения props/state — это защищает от race conditions.</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'порядок выполнения', 'lifecycle', 'flow']
  },
  {
    id: 96,
    question: "Что происходит, если не указать массив зависимостей в useEffect?",
    answer: "<p><strong>Без массива зависимостей</strong> эффект запускается после КАЖДОГО рендера.</p><p><strong>Поведение:</strong></p><ul><li>Эффект выполняется при монтировании</li><li>Эффект выполняется после каждого обновления</li><li>Cleanup вызывается перед каждым новым эффектом</li><li>Финальный cleanup при размонтировании</li></ul><p><strong>Когда это уместно:</strong></p><p>Очень редко. Обычно это ошибка — бесконечные циклы, лишние запросы, проблемы с производительностью.</p><p><strong>Легитимные случаи:</strong></p><p>Логирование каждого рендера, синхронизация с быстро меняющимися внешними данными.</p><p><strong>Best practice:</strong></p><p>Всегда явно указывать deps, даже если это пустой массив [].</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'зависимости', 'поведение']
  },
  {
    id: 97,
    question: "В чем разница между useEffect с пустым массивом [] и без массива зависимостей?",
    answer: "<p><strong>Пустой массив []:</strong></p><ul><li>Эффект выполняется ОДИН раз при монтировании</li><li>Cleanup один раз при размонтировании</li><li>Аналог componentDidMount + componentWillUnmount</li><li>Замыкание на начальные значения props/state</li></ul><p><strong>Без массива:</strong></p><ul><li>Эффект после КАЖДОГО рендера</li><li>Cleanup перед каждым следующим эффектом + при unmount</li><li>Аналог componentDidMount + componentDidUpdate + componentWillUnmount</li><li>Всегда актуальные значения</li></ul><p><strong>Распространенная ошибка:</strong></p><p>Использовать [] когда нужны зависимости — получаем stale closure на устаревшие значения.</p><p><strong>Правило:</strong></p><p>[] только для эффектов, которые действительно нужны один раз. Для всего остального — явные deps.</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'зависимости', 'отличия', 'поведение']
  },
  {
    id: 98,
    question: "Что такое stale closure в контексте useEffect и как его избежать?",
    answer: "<p><strong>Stale closure</strong> — это когда эффект захватил устаревшие значения из-за неправильных зависимостей.</p><p><strong>Как возникает:</strong></p><p>useEffect с пустым массивом [] или неполными deps захватывает значения при первом рендере. При изменении этих значений эффект продолжает видеть старые.</p><p><strong>Типичный пример:</strong></p><p>Интервал с [] в deps, который использует state — setInterval всегда видит начальное значение счетчика.</p><p><strong>Как избежать:</strong></p><ul><li><strong>Правильные deps</strong> — включить все используемые значения</li><li><strong>Функциональный setState</strong> — setState(prev => prev + 1) не требует state в deps</li><li><strong>useRef</strong> — для мутабельных значений без deps</li><li><strong>ESLint</strong> — правило exhaustive-deps предупредит</li></ul>",
    difficulty: 'senior',
    tags: ['useEffect', 'stale closure', 'проблемы', 'зависимости']
  },
  {
    id: 99,
    question: "Почему useEffect может вызываться дважды в development режиме?",
    answer: "<p><strong>React 18 Strict Mode</strong> в development намеренно вызывает эффекты дважды.</p><p><strong>Порядок в dev:</strong></p><ul><li>Mount → Effect → Cleanup → Effect снова</li><li>Это симулирует unmount/remount цикл</li></ul><p><strong>Зачем это нужно:</strong></p><ul><li>Проверка корректности cleanup логики</li><li>Выявление проблем с ресурсами (утечки памяти)</li><li>Подготовка к будущим фичам (сохранение состояния при unmount)</li></ul><p><strong>В production:</strong></p><p>Двойного вызова нет — эффект выполняется один раз при монтировании.</p><p><strong>Как должен быть написан код:</strong></p><p>Эффект должен быть идемпотентным — повторный вызов не должен ломать логику. Cleanup должен корректно отменять все side effects.</p>",
    difficulty: 'senior',
    tags: ['useEffect', 'StrictMode', 'development', 'особенности']
  },
  {
    id: 100,
    question: "В чем разница между useEffect и useLayoutEffect?",
    answer: "<p><strong>Timing выполнения:</strong></p><p><strong>useEffect:</strong></p><ul><li>Асинхронный — после paint браузера</li><li>Не блокирует визуальное обновление</li><li>Используется в 99% случаев</li></ul><p><strong>useLayoutEffect:</strong></p><ul><li>Синхронный — после DOM мутаций, ДО paint</li><li>Блокирует отрисовку браузера</li><li>Используется для измерений DOM и синхронных мутаций</li></ul><p><strong>Когда использовать useLayoutEffect:</strong></p><ul><li>Измерение размеров элементов</li><li>Синхронные DOM мутации перед отрисовкой</li><li>Предотвращение визуального мерцания</li><li>Синхронизация с анимациями</li></ul><p><strong>Проблемы useLayoutEffect:</strong></p><p>Может вызвать задержки UI, так как блокирует paint. В SSR вызывает предупреждения.</p>",
    difficulty: 'senior',
    tags: ['useEffect', 'useLayoutEffect', 'отличия', 'timing']
  },
  {
    id: 101,
    question: "Как правильно отменять async операции в useEffect cleanup?",
    answer: "<p><strong>Проблема:</strong></p><p>async/await нельзя использовать напрямую в useEffect — эффект не может быть async функцией.</p><p><strong>Паттерны отмены:</strong></p><p><strong>1. AbortController для fetch:</strong></p><p>Создать AbortController, передать signal в fetch, вызвать abort() в cleanup.</p><p><strong>2. Флаг isActive/isMounted:</strong></p><p>Переменная let isMounted = true, проверять перед setState, в cleanup установить false.</p><p><strong>3. Отмена через ref:</strong></p><p>Хранить promise в ref, отменять через кастомную логику отмены.</p><p><strong>4. Библиотеки:</strong></p><p>use-async-effect, react-use — готовые решения.</p><p><strong>Best practice:</strong></p><p>AbortController для fetch запросов — стандартный и надежный способ.</p>",
    difficulty: 'senior',
    tags: ['useEffect', 'async', 'cleanup', 'отмена запросов']
  },
  {
    id: 102,
    question: "Можно ли вызвать несколько useEffect в одном компоненте? Как определяется порядок их выполнения?",
    answer: "<p><strong>Да, можно и нужно!</strong> Множественные useEffect — это best practice для разделения логики.</p><p><strong>Порядок выполнения:</strong></p><p>Эффекты выполняются в порядке их объявления в коде — сверху вниз.</p><p><strong>Зачем несколько эффектов:</strong></p><ul><li><strong>Separation of concerns</strong> — каждый эффект отвечает за одну вещь</li><li><strong>Разные зависимости</strong> — не пересекающиеся deps для разной логики</li><li><strong>Читаемость</strong> — проще понять назначение каждого эффекта</li><li><strong>Независимая cleanup</strong> — каждая подписка очищается отдельно</li></ul><p><strong>Пример:</strong></p><p>Один useEffect для WebSocket подписки, другой для document.title, третий для аналитики — все с разными deps.</p><p><strong>Не стоит:</strong></p><p>Объединять несвязанную логику в один огромный useEffect.</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'множественные эффекты', 'best practices', 'порядок']
  },
  {
    id: 103,
    question: "Что произойдет, если изменить state внутри useEffect без зависимостей?",
    answer: "<p><strong>Зависит от массива зависимостей:</strong></p><p><strong>С пустым массивом []:</strong></p><p>State изменится один раз при монтировании, вызовет ререндер компонента, но эффект не запустится снова — безопасно.</p><p><strong>Без массива зависимостей:</strong></p><p>Бесконечный цикл! Effect → setState → render → effect → setState → ...</p><p><strong>С неполными deps:</strong></p><p>Stale closure — эффект видит старые значения, setState может работать некорректно.</p><p><strong>Правильный подход:</strong></p><ul><li>Указать state в deps если он используется</li><li>Использовать функциональный setState если нужно предыдущее значение</li><li>Проверить логику — возможно state нужно вычислять при рендере, не в эффекте</li></ul><p><strong>Принцип:</strong></p><p>Эффекты для синхронизации с внешним миром, не для вычисления state.</p>",
    difficulty: 'middle',
    tags: ['useEffect', 'state', 'бесконечный цикл', 'проблемы']
  },
  {
    id: 104,
    question: "Как правильно работать с event listeners в useEffect?",
    answer: "<p><strong>Стандартный паттерн подписки:</strong></p><p><strong>1. Setup в эффекте:</strong></p><p>addEventListener на window/document/element в теле эффекта.</p><p><strong>2. Cleanup:</strong></p><p>removeEventListener в cleanup функции с той же самой функцией-обработчиком.</p><p><strong>Важные детали:</strong></p><ul><li><strong>Одна и та же функция</strong> — нельзя создавать новую в cleanup</li><li><strong>Сохранить ссылку</strong> — определить обработчик до addEventListener</li><li><strong>Зависимости</strong> — если обработчик использует props/state, включить в deps или использовать ref</li></ul><p><strong>Частые ошибки:</strong></p><ul><li>Забыть cleanup — утечка памяти, множественные подписки</li><li>Стрелочная функция в addEventListener — не получится удалить</li><li>Неправильные deps — stale closure в обработчике</li></ul>",
    difficulty: 'middle',
    tags: ['useEffect', 'events', 'cleanup', 'подписки']
  },
  {
    id: 105,
    question: "Какие распространенные ошибки делают при работе с useEffect?",
    answer: "<p><strong>Топ ошибок:</strong></p><ul><li><strong>Бесконечные циклы</strong> — setState без deps или с объектом в deps</li><li><strong>Забытый cleanup</strong> — утечки памяти, дублирование подписок</li><li><strong>Stale closure</strong> — пустой [] когда нужны реальные deps</li><li><strong>Логика вместо синхронизации</strong> — вычисления в эффекте вместо рендера</li><li><strong>async useEffect</strong> — нельзя делать эффект async функцией</li><li><strong>Игнорирование exhaustive-deps</strong> — отключение ESLint правила</li><li><strong>Мутации в эффекте</strong> — изменение props/state напрямую</li><li><strong>Эффект для однократных действий</strong> — onClick логика в useEffect</li></ul><p><strong>Best practice:</strong></p><p>Понимать назначение useEffect — синхронизация с внешними системами. Для логики есть другие места.</p>",
    difficulty: 'senior',
    tags: ['useEffect', 'ошибки', 'антипаттерны', 'best practices']
  },
  {
    id: 106,
    question: "Какие существуют причины для ререндера компонента в React?",
    answer: "<p>Компонент ре-рендерится в следующих случаях:</p><p><strong>Основные триггеры:</strong></p><ul><li><strong>Изменение собственного state</strong> — вызов setState или set функции из useState</li><li><strong>Изменение props</strong> — родитель передал новые props</li><li><strong>Ререндер родителя</strong> — по умолчанию все дочерние компоненты тоже рендерятся</li><li><strong>Изменение context</strong> — значение useContext изменилось</li><li><strong>forceUpdate</strong> — принудительный ререндер (legacy API, не использовать)</li></ul><p><strong>Важно понимать:</strong></p><p>Ререндер родителя вызывает ререндер всех детей, даже если их props не изменились — это поведение по умолчанию. React.memo позволяет это оптимизировать.</p><p><strong>Ререндер ≠ обновление DOM:</strong></p><p>Ререндер — это пересчет Virtual DOM. Реальный DOM обновляется только если есть изменения.</p>",
    difficulty: 'junior',
    tags: ['ререндер', 'производительность', 'триггеры', 'основы']
  },
  {
    id: 107,
    question: "Почему ререндер родителя вызывает ререндер всех дочерних компонентов?",
    answer: "<p>Это поведение по умолчанию в React по соображениям корректности и предсказуемости.</p><p><strong>Логика React:</strong></p><p>Если родитель изменился, потенциально могли измениться и дети — React перестраховывается и рендерит всё дерево.</p><p><strong>Почему не сравнивать props автоматически:</strong></p><ul><li>Shallow comparison пропсов имеет свою стоимость</li><li>Для большинства компонентов ререндер быстрый</li><li>Оптимизация должна быть явной и осознанной</li><li>Неправильная оптимизация хуже отсутствия оптимизации</li></ul><p><strong>Философия:</strong></p><p>React оптимизирует обновление DOM, но не рендеринг компонентов. Разработчик сам решает, где нужна оптимизация через React.memo.</p><p><strong>На практике:</strong></p><p>Для большинства приложений это не проблема — рендеринг быстрый, узкие места в другом месте.</p>",
    difficulty: 'middle',
    tags: ['ререндер', 'родитель-потомок', 'поведение', 'философия']
  },
  {
    id: 108,
    question: "Как отследить и измерить лишние рендеры в приложении?",
    answer: "<p>Есть несколько инструментов для выявления проблем с производительностью:</p><p><strong>1. React DevTools Profiler:</strong></p><ul><li>Визуализация времени рендера каждого компонента</li><li>Flame graph — какие компоненты тормозят</li><li>Ranked chart — самые медленные компоненты</li><li>Причины ререндера для каждого компонента</li></ul><p><strong>2. why-did-you-render библиотека:</strong></p><ul><li>Показывает в консоли почему компонент ре-рендерился</li><li>Сравнивает старые и новые props</li><li>Выявляет ненужные ререндеры</li></ul><p><strong>3. Кастомные хуки для логирования:</strong></p><p>useWhyDidYouUpdate хук для отслеживания изменений props в конкретном компоненте.</p><p><strong>4. Performance API браузера:</strong></p><p>performance.mark/measure для точных замеров критичных участков.</p>",
    difficulty: 'middle',
    tags: ['ререндер', 'отладка', 'инструменты', 'профилирование']
  },
  {
    id: 109,
    question: "Что показывает React DevTools Profiler и как им пользоваться?",
    answer: "<p><strong>React DevTools Profiler</strong> — встроенный инструмент для анализа производительности.</p><p><strong>Основные возможности:</strong></p><ul><li><strong>Flame Graph</strong> — визуализация иерархии компонентов и времени рендера</li><li><strong>Ranked Chart</strong> — список компонентов от самых медленных к быстрым</li><li><strong>Причины ререндера</strong> — почему компонент обновился (state, props, parent, hooks)</li><li><strong>Commits timeline</strong> — история всех рендеров</li></ul><p><strong>Как использовать:</strong></p><p>Включить запись, совершить действия в приложении, остановить запись. Изучить Flame Graph — ширина = время рендера, желтые компоненты = медленные.</p><p><strong>На что смотреть:</strong></p><p>Широкие желтые блоки, компоненты с частыми ререндерами без изменения UI, глубокие деревья компонентов.</p>",
    difficulty: 'middle',
    tags: ['DevTools', 'Profiler', 'производительность', 'инструменты']
  },
  {
    id: 110,
    question: "Как определить, что ререндер компонента является лишним?",
    answer: "<p><strong>Лишний ререндер</strong> — это когда компонент ре-рендерится, но его вывод в DOM не меняется.</p><p><strong>Признаки лишнего ререндера:</strong></p><ul><li>Props компонента не изменились (или изменились только по референсу)</li><li>Визуально ничего не обновилось</li><li>Virtual DOM показал, что изменений нет</li><li>Компонент в списке React.memo candidates</li></ul><p><strong>Как проверить:</strong></p><ul><li>React DevTools Profiler — смотреть на \"Why did this render\"</li><li>Логировать props в render: console.log(props) и сравнивать</li><li>why-did-you-render библиотека</li></ul><p><strong>Когда оптимизировать:</strong></p><p>Не все лишние рендеры — проблема. Оптимизировать, если компонент тяжелый или рендерится очень часто.</p><p><strong>Правило:</strong></p><p>Сначала измерь — есть ли реальная проблема с производительностью, потом оптимизируй.</p>",
    difficulty: 'middle',
    tags: ['ререндер', 'оптимизация', 'диагностика', 'лишние рендеры']
  },
  {
    id: 111,
    question: "Какие паттерны вызывают самые частые лишние рендеры?",
    answer: "<p><strong>Топ антипаттернов:</strong></p><p><strong>1. Inline объекты/массивы в props:</strong></p><p>style={{margin: 10}} или data={[1,2,3]} — новый объект каждый рендер.</p><p><strong>2. Inline функции в props:</strong></p><p>onClick={() => handle(id)} — новая функция каждый рендер.</p><p><strong>3. Некорректный children паттерн:</strong></p><p>Передача children через props вместо JSX children.</p><p><strong>4. Context с нестабильным value:</strong></p><p>value={{user, settings}} — новый объект при каждом рендере провайдера.</p><p><strong>5. Вычисления в render:</strong></p><p>Тяжелые вычисления без useMemo — пересчет при каждом рендере.</p><p><strong>6. Неправильный Component в Component:</strong></p><p>Определение компонента внутри другого компонента — пересоздание при каждом рендере.</p>",
    difficulty: 'senior',
    tags: ['ререндер', 'антипаттерны', 'оптимизация', 'частые ошибки']
  },
  {
    id: 112,
    question: "Почему создание компонента внутри другого компонента вызывает проблемы?",
    answer: "<p>Это один из худших антипаттернов по производительности в React.</p><p><strong>Что происходит:</strong></p><p>При каждом рендере родителя создается новый тип компонента. React видит это как совершенно другой компонент и полностью пересоздает его — unmount старого + mount нового.</p><p><strong>Последствия:</strong></p><ul><li><strong>Потеря state</strong> — весь внутренний state сбрасывается</li><li><strong>Потеря focus</strong> — input теряет фокус</li><li><strong>Перезапуск анимаций</strong> — анимации начинаются заново</li><li><strong>Лишние useEffect</strong> — cleanup и setup при каждом рендере родителя</li><li><strong>Производительность</strong> — unmount/mount гораздо дороже простого ререндера</li></ul><p><strong>Решение:</strong></p><p>Определять компоненты вне render функции, на уровне модуля.</p>",
    difficulty: 'senior',
    tags: ['ререндер', 'антипаттерны', 'компоненты', 'производительность']
  },
  {
    id: 113,
    question: "Как Context API влияет на ререндеры и как минимизировать их количество?",
    answer: "<p><strong>Проблема с Context:</strong></p><p>Все компоненты, использующие useContext, ре-рендерятся при изменении value провайдера — даже если используют только часть данных.</p><p><strong>Стратегии оптимизации:</strong></p><p><strong>1. Разделение контекстов:</strong></p><p>Не один большой context, а несколько маленьких по назначению — data context, actions context.</p><p><strong>2. Мемоизация value:</strong></p><p>Обернуть value в useMemo чтобы объект не пересоздавался при каждом рендере провайдера.</p><p><strong>3. Context Selectors:</strong></p><p>Использовать библиотеки типа use-context-selector для подписки на части данных.</p><p><strong>4. React.memo у потребителей:</strong></p><p>Обернуть компоненты в React.memo если они не зависят от context.</p><p><strong>5. Composition:</strong></p><p>Использовать children prop вместо context где возможно.</p>",
    difficulty: 'senior',
    tags: ['Context', 'ререндер', 'оптимизация', 'производительность']
  },
  {
    id: 114,
    question: "Что такое 'render bailout' и когда React пропускает ререндер?",
    answer: "<p><strong>Render bailout</strong> — это оптимизация, когда React пропускает ререндер компонента.</p><p><strong>Когда происходит bailout:</strong></p><ul><li><strong>React.memo</strong> — props не изменились (shallow equal)</li><li><strong>useState bailout</strong> — setState с тем же значением (Object.is сравнение)</li><li><strong>useReducer bailout</strong> — новый state === старый state</li><li><strong>Тот же элемент</strong> — компонент вернул точно тот же JSX элемент (по ссылке)</li></ul><p><strong>Важно понимать:</strong></p><p>Bailout останавливает ререндер текущего компонента и его детей. Но для bailout сначала нужно запустить render родителя — это не бесплатно.</p><p><strong>useState bailout особенность:</strong></p><p>Если setState вызвать с тем же значением дважды подряд, второй раз будет bailout даже без React.memo.</p>",
    difficulty: 'senior',
    tags: ['bailout', 'оптимизация', 'ререндер', 'внутреннее устройство']
  },
  {
    id: 115,
    question: "Как props drilling влияет на производительность и ререндеры?",
    answer: "<p><strong>Props drilling</strong> — это передача props через множество промежуточных компонентов.</p><p><strong>Влияние на производительность:</strong></p><ul><li><strong>Сам по себе не замедляет</strong> — передача props быстрая операция</li><li><strong>Проблема в ререндерах</strong> — промежуточные компоненты ре-рендерятся даже если не используют props</li><li><strong>Каскад обновлений</strong> — изменение пропса вызывает волну ререндеров вниз</li></ul><p><strong>Решения:</strong></p><p><strong>1. Context API:</strong></p><p>Для данных, используемых глубоко в дереве — избежать промежуточных компонентов.</p><p><strong>2. Composition (children):</strong></p><p>Передать компонент через children — промежуточные слои не знают о содержимом.</p><p><strong>3. React.memo на промежуточных:</strong></p><p>Обернуть компоненты, которые только проксируют props.</p><p><strong>Когда drilling OK:</strong></p><p>2-3 уровня вложенности — нормально, не усложнять раньше времени.</p>",
    difficulty: 'middle',
    tags: ['props drilling', 'ререндер', 'производительность', 'архитектура']
  },
  {
    id: 116,
    question: "Почему изменение key у компонента вызывает полный remount?",
    answer: "<p><strong>key — это identity компонента</strong> для React. Изменение key означает \"это другой компонент\".</p><p><strong>Что происходит:</strong></p><ul><li>React видит новый key</li><li>Вызывает unmount старого компонента (cleanup, componentWillUnmount)</li><li>Создает новый экземпляр компонента</li><li>Вызывает mount (useEffect, componentDidMount)</li><li>Весь state сбрасывается</li></ul><p><strong>Это не баг, а фича:</strong></p><p>Иногда нужно принудительно сбросить компонент — изменение key самый чистый способ.</p><p><strong>Применение:</strong></p><ul><li>Сброс формы при смене пользователя</li><li>Пересоздание плеера при смене видео</li><li>Сброс состояния при переходе между табами</li></ul><p><strong>Производительность:</strong></p><p>Unmount/mount дорого — использовать осознанно, не менять key без необходимости.</p>",
    difficulty: 'middle',
    tags: ['key', 'remount', 'ререндер', 'жизненный цикл']
  },
  {
    id: 117,
    question: "Как подъем состояния наверх (lifting state up) влияет на ререндеры?",
    answer: "<p><strong>Lifting state up</strong> — перемещение state на общего родителя для шаринга между компонентами.</p><p><strong>Влияние на ререндеры:</strong></p><ul><li><strong>Увеличение ререндеров</strong> — изменение state ре-рендерит родителя и всех его детей</li><li><strong>Затрагивает незаинтересованных</strong> — компоненты, не использующие state, тоже ре-рендерятся</li><li><strong>Размер дерева</strong> — чем выше state, тем больше компонентов в зоне ререндера</li></ul><p><strong>Баланс:</strong></p><p>Поднимать state только настолько высоко, насколько нужно для шаринга. Не поднимать весь state в корень приложения.</p><p><strong>Альтернативы:</strong></p><ul><li><strong>Context</strong> — для данных нужных глубоко в дереве</li><li><strong>State management</strong> — Redux, Zustand для глобального состояния</li><li><strong>Composition</strong> — передача готовых компонентов вместо данных</li></ul>",
    difficulty: 'middle',
    tags: ['state', 'lifting state up', 'ререндер', 'архитектура']
  },
  {
    id: 118,
    question: "Что такое паттерн 'colocation' для состояния и как он помогает с производительностью?",
    answer: "<p><strong>Colocation (совместное размещение)</strong> — хранение state максимально близко к месту использования.</p><p><strong>Принцип:</strong></p><p>Не поднимать state выше, чем необходимо. Если state нужен только одному компоненту — держать его там.</p><p><strong>Преимущества для производительности:</strong></p><ul><li><strong>Изолированные ререндеры</strong> — изменение state влияет только на локальное поддерево</li><li><strong>Меньше затронутых компонентов</strong> — узкая зона обновления</li><li><strong>Проще оптимизировать</strong> — очевидно какие компоненты зависят от state</li></ul><p><strong>Пример:</strong></p><p>State для toggle аккордеона держать в самом аккордеоне, не в родителе всех аккордеонов.</p><p><strong>Правило Kent C. Dodds:</strong></p><p>\"State должен жить как можно ближе к тому, где используется, но не ближе\".</p>",
    difficulty: 'senior',
    tags: ['state', 'colocation', 'производительность', 'архитектура']
  },
  {
    id: 119,
    question: "Как composition паттерн помогает избежать лишних ререндеров?",
    answer: "<p><strong>Composition через children</strong> — мощный паттерн оптимизации, часто недооцененный.</p><p><strong>Как работает:</strong></p><p>Компонент получает готовые children как prop. При изменении state компонента, children НЕ ре-рендерятся — они созданы родителем, который не изменился.</p><p><strong>Магия:</strong></p><p>children — это уже готовые React элементы. Они создаются при рендере родителя. Внутренний state оборачивающего компонента не влияет на них.</p><p><strong>Применение:</strong></p><ul><li>Layout компоненты с sidebar/modal</li><li>Tabs с произвольным контентом</li><li>Провайдеры с частыми изменениями</li></ul><p><strong>Преимущество перед Context:</strong></p><p>Не нужно мемоизировать props или оборачивать в React.memo — children автоматически стабильны.</p><p><strong>Это declarative оптимизация:</strong></p><p>Архитектура сама предотвращает ререндеры.</p>",
    difficulty: 'senior',
    tags: ['composition', 'children', 'оптимизация', 'ререндер']
  },
  {
    id: 120,
    question: "Какие метрики использовать для определения критичности проблемы с ререндерами?",
    answer: "<p>Не все лишние ререндеры требуют оптимизации. Важно измерить реальное влияние.</p><p><strong>Ключевые метрики:</strong></p><p><strong>1. Время рендера (Profiler):</strong></p><ul><li>Компонент > 16ms (60fps) — красная зона</li><li>Компонент > 50ms — критично</li><li>Суммарное время всех ререндеров</li></ul><p><strong>2. Частота ререндеров:</strong></p><ul><li>Сколько раз компонент рендерится за взаимодействие</li><li>Ререндеры при каждом keypress — может быть проблемой</li></ul><p><strong>3. User experience метрики:</strong></p><ul><li>FPS падает ниже 30 — заметно пользователю</li><li>Input lag > 100ms — ощущается задержка ввода</li><li>Time to Interactive (TTI)</li></ul><p><strong>4. Размер дерева:</strong></p><ul><li>Сколько компонентов в cascading ререндере</li><li>Глубина дерева обновлений</li></ul><p><strong>Правило:</strong></p><p>Если пользователь не чувствует проблемы — не оптимизируй.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'метрики', 'оптимизация', 'измерения']
  },
  {
    id: 121,
    question: "Что такое React.memo и как он работает?",
    answer: "<p><strong>React.memo</strong> — это Higher-Order Component (HOC) для мемоизации функциональных компонентов.</p><p><strong>Как работает:</strong></p><ul><li>Оборачивает компонент и кэширует результат рендера</li><li>При новом рендере сравнивает props (shallow comparison)</li><li>Если props не изменились — возвращает кэшированный результат</li><li>Если props изменились — рендерит компонент заново</li></ul><p><strong>Синтаксис:</strong></p><p>const MemoizedComponent = React.memo(MyComponent). Можно передать вторую функцию для кастомного сравнения props.</p><p><strong>Когда использовать:</strong></p><ul><li>Компонент часто рендерится с одинаковыми props</li><li>Компонент тяжелый в рендере</li><li>Компонент в списке с множеством элементов</li></ul><p><strong>Важно:</strong></p><p>React.memo сравнивает только props, не state или context. Это оптимизация, добавляющая overhead — использовать осознанно.</p>",
    difficulty: 'middle',
    tags: ['React.memo', 'мемоизация', 'оптимизация', 'компоненты']
  },
  {
    id: 122,
    question: "В чем разница между React.memo и useMemo?",
    answer: "<p>Это два разных инструмента с разным назначением:</p><p><strong>React.memo:</strong></p><ul><li>Мемоизирует ВЕСЬ компонент</li><li>Сравнивает props компонента</li><li>Решает когда компонент НЕ нужно рендерить</li><li>HOC — оборачивает компонент снаружи</li><li>Возвращает мемоизированный компонент</li></ul><p><strong>useMemo:</strong></p><ul><li>Мемоизирует ЗНАЧЕНИЕ внутри компонента</li><li>Сравнивает зависимости</li><li>Кэширует результат вычислений</li><li>Хук — используется внутри компонента</li><li>Возвращает мемоизированное значение</li></ul><p><strong>Можно использовать вместе:</strong></p><p>Родитель использует useMemo для props, дочерний обернут в React.memo — максимальная оптимизация.</p><p><strong>Аналогия:</strong></p><p>React.memo — это сигнализация на входе в дом, useMemo — сейф внутри дома.</p>",
    difficulty: 'middle',
    tags: ['React.memo', 'useMemo', 'отличия', 'оптимизация']
  },
  {
    id: 123,
    question: "Как работает кастомная функция сравнения в React.memo?",
    answer: "<p>React.memo принимает вторым аргументом функцию для кастомного сравнения props.</p><p><strong>Сигнатура:</strong></p><p>React.memo(Component, (prevProps, nextProps) => boolean). Возвращает true если props равны (НЕ рендерить), false если разные (рендерить).</p><p><strong>Важное отличие от shouldComponentUpdate:</strong></p><p>Логика инвертирована! true = пропустить рендер, false = рендерить. В shouldComponentUpdate наоборот.</p><p><strong>Когда использовать:</strong></p><ul><li>Глубокое сравнение объектов</li><li>Сравнение только части props</li><li>Кастомная логика равенства</li><li>Игнорирование определенных props</li></ul><p><strong>Осторожно:</strong></p><p>Глубокое сравнение может быть дороже ререндера. Функция вызывается при каждом потенциальном рендере — должна быть быстрой.</p>",
    difficulty: 'senior',
    tags: ['React.memo', 'сравнение', 'оптимизация', 'продвинутое']
  },
  {
    id: 124,
    question: "Почему React.memo не помогает, если передавать объекты или функции в props?",
    answer: "<p>React.memo делает shallow comparison — сравнивает props по ссылке через Object.is.</p><p><strong>Проблема:</strong></p><ul><li>Объекты и массивы создаются заново при каждом рендере родителя</li><li>Новая ссылка !== старая ссылка</li><li>React.memo видит \"изменение\" props</li><li>Компонент ре-рендерится несмотря на memo</li></ul><p><strong>Аналогично с функциями:</strong></p><p>Каждый рендер создает новые функции-обработчики с новой ссылкой.</p><p><strong>Решение:</strong></p><ul><li>useMemo для объектов/массивов</li><li>useCallback для функций</li><li>Хранить стабильные значения вне компонента</li><li>Использовать примитивы где возможно</li></ul><p><strong>Цепочка оптимизации:</strong></p><p>Родитель мемоизирует props (useMemo/useCallback) → ребенок обернут в React.memo → стабильные props → пропуск ререндера.</p>",
    difficulty: 'middle',
    tags: ['React.memo', 'props', 'ссылки', 'проблемы']
  },
  {
    id: 125,
    question: "Когда НЕ стоит использовать React.memo?",
    answer: "<p>React.memo — не серебряная пуля, у него есть стоимость и ограничения.</p><p><strong>Не использовать когда:</strong></p><ul><li><strong>Props часто меняются</strong> — overhead сравнения без выгоды</li><li><strong>Компонент легковесный</strong> — рендер быстрее, чем сравнение props</li><li><strong>Props нестабильны</strong> — объекты/функции без мемоизации родителя</li><li><strong>Мало рендеров</strong> — компонент редко обновляется</li><li><strong>Использует context</strong> — memo не защитит от ререндеров через context</li></ul><p><strong>Overhead React.memo:</strong></p><ul><li>Сравнение props при каждом потенциальном рендере</li><li>Дополнительная память для хранения предыдущих props</li><li>Усложнение отладки</li></ul><p><strong>Золотое правило:</strong></p><p>Не оборачивать все компоненты в memo \"на всякий случай\". Измерить проблему → применить memo → проверить улучшение.</p>",
    difficulty: 'middle',
    tags: ['React.memo', 'ограничения', 'best practices', 'когда не использовать']
  },
  {
    id: 126,
    question: "Как React.memo взаимодействует с хуками (useState, useEffect)?",
    answer: "<p>React.memo влияет только на принятие решения о рендере, но не изменяет работу хуков.</p><p><strong>useState/useReducer:</strong></p><ul><li>Изменение собственного state всегда вызывает рендер</li><li>React.memo не блокирует рендеры от внутреннего state</li><li>Memo защищает только от ререндеров через props родителя</li></ul><p><strong>useEffect:</strong></p><ul><li>Если memo пропустил рендер — useEffect не запустится</li><li>Зависимости useEffect должны учитывать это</li><li>Stale closure может возникнуть при агрессивной мемоизации</li></ul><p><strong>useContext:</strong></p><ul><li>React.memo НЕ защищает от ререндеров через context</li><li>Изменение context обходит memo и рендерит компонент</li><li>Нужны дополнительные техники оптимизации context</li></ul><p><strong>Важно:</strong></p><p>Memo — это оптимизация входящих props, внутренняя логика компонента работает стандартно.</p>",
    difficulty: 'senior',
    tags: ['React.memo', 'хуки', 'взаимодействие', 'особенности']
  },
  {
    id: 127,
    question: "Что такое PureComponent и чем он отличается от React.memo?",
    answer: "<p><strong>PureComponent</strong> — базовый класс для классовых компонентов с встроенным shallow comparison.</p><p><strong>PureComponent (классы):</strong></p><ul><li>Расширяет React.Component</li><li>Автоматическая реализация shouldComponentUpdate</li><li>Сравнивает props И state (shallow)</li><li>Только для классовых компонентов</li></ul><p><strong>React.memo (функции):</strong></p><ul><li>HOC для функциональных компонентов</li><li>Сравнивает только props</li><li>Можно передать кастомную функцию сравнения</li><li>Современный подход</li></ul><p><strong>Общее:</strong></p><p>Оба делают shallow comparison для оптимизации, но для разных типов компонентов.</p><p><strong>Современная практика:</strong></p><p>Использовать функциональные компоненты с React.memo вместо классов с PureComponent.</p>",
    difficulty: 'middle',
    tags: ['PureComponent', 'React.memo', 'отличия', 'классы vs функции']
  },
  {
    id: 128,
    question: "Как оптимизировать рендеринг больших списков?",
    answer: "<p>Списки — частый источник проблем с производительностью. Есть несколько стратегий.</p><p><strong>1. Правильные keys:</strong></p><ul><li>Стабильные уникальные ID, не индексы</li><li>Помогают React переиспользовать DOM узлы</li></ul><p><strong>2. Виртуализация (windowing):</strong></p><ul><li>Рендерить только видимые элементы</li><li>react-window, react-virtual — готовые библиотеки</li><li>Для списков > 100 элементов критично</li></ul><p><strong>3. React.memo на элементах списка:</strong></p><ul><li>Элемент не ре-рендерится если его props не изменились</li><li>Важно мемоизировать callbacks (useCallback)</li></ul><p><strong>4. Pagination/Infinite scroll:</strong></p><ul><li>Загружать порциями вместо всего списка</li><li>Улучшает первую загрузку</li></ul><p><strong>5. useMemo для тяжелых трансформаций:</strong></p><p>Фильтрация, сортировка — мемоизировать результат.</p>",
    difficulty: 'middle',
    tags: ['списки', 'оптимизация', 'виртуализация', 'производительность']
  },
  {
    id: 129,
    question: "Что такое windowing/virtualization и как это работает?",
    answer: "<p><strong>Virtualization (виртуализация списков)</strong> — техника рендеринга только видимой части списка.</p><p><strong>Как работает:</strong></p><ul><li>Вычисляется область просмотра (viewport)</li><li>Рендерятся только элементы в viewport + небольшой буфер</li><li>При скролле элементы динамически добавляются/удаляются</li><li>Создается иллюзия полного списка через padding</li></ul><p><strong>Преимущества:</strong></p><ul><li>DOM содержит ~10-20 элементов вместо тысяч</li><li>Константная производительность независимо от размера списка</li><li>Быстрая прокрутка без лагов</li><li>Меньше потребление памяти</li></ul><p><strong>Популярные библиотеки:</strong></p><ul><li>react-window — легковесная, от автора react-virtualized</li><li>react-virtual — от TanStack</li><li>react-virtuoso — много фич из коробки</li></ul><p><strong>Когда использовать:</strong></p><p>Списки > 100 элементов, таблицы с тысячами строк.</p>",
    difficulty: 'senior',
    tags: ['виртуализация', 'списки', 'оптимизация', 'библиотеки']
  },
  {
    id: 130,
    question: "Как правильно оптимизировать компоненты форм с множеством полей?",
    answer: "<p>Формы — источник частых ререндеров при вводе. Нужна правильная архитектура.</p><p><strong>Проблема:</strong></p><p>При изменении одного поля весь компонент формы ре-рендерится, перерисовывая все остальные поля.</p><p><strong>Стратегии оптимизации:</strong></p><p><strong>1. Controlled компоненты с изоляцией state:</strong></p><ul><li>Каждое поле — отдельный компонент со своим state</li><li>React.memo на полях</li><li>Изменение одного поля не влияет на другие</li></ul><p><strong>2. Uncontrolled формы с ref:</strong></p><ul><li>Использовать ref вместо state для значений</li><li>Нет ререндеров при вводе</li><li>Читать значения при submit</li></ul><p><strong>3. Библиотеки форм:</strong></p><ul><li>React Hook Form — uncontrolled подход, минимум ререндеров</li><li>Formik — controlled, но с оптимизациями</li></ul><p><strong>4. Debounce валидации:</strong></p><p>Не валидировать при каждом keystroke.</p>",
    difficulty: 'senior',
    tags: ['формы', 'оптимизация', 'ререндер', 'архитектура']
  },
  {
    id: 131,
    question: "Что такое code splitting и lazy loading в контексте оптимизации?",
    answer: "<p><strong>Code Splitting</strong> — разделение бандла на части, загружаемые по требованию.</p><p><strong>React.lazy():</strong></p><ul><li>Динамический import() для компонентов</li><li>Компонент загружается только когда нужен</li><li>Автоматическое разделение на чанки</li></ul><p><strong>Suspense:</strong></p><ul><li>Обертка для lazy компонентов</li><li>Показывает fallback во время загрузки</li><li>Управляет состоянием загрузки</li></ul><p><strong>Где применять:</strong></p><ul><li><strong>Роуты</strong> — каждая страница отдельный чанк</li><li><strong>Модалы/диалоги</strong> — загружать при открытии</li><li><strong>Тяжелые компоненты</strong> — графики, редакторы, карты</li><li><strong>Условный код</strong> — админ панель для админов</li></ul><p><strong>Выгода:</strong></p><p>Меньший initial bundle → быстрее Time to Interactive → лучше UX.</p><p><strong>Важно:</strong></p><p>Не разделять слишком мелко — overhead HTTP запросов может превысить выгоду.</p>",
    difficulty: 'middle',
    tags: ['code splitting', 'lazy loading', 'оптимизация', 'бандл']
  },
  {
    id: 132,
    question: "Как оптимизировать рендеринг при работе с большими данными в state?",
    answer: "<p>Большие объемы данных в state требуют особого подхода к оптимизации.</p><p><strong>Стратегии:</strong></p><p><strong>1. Нормализация данных:</strong></p><ul><li>Хранить данные как словарь по ID вместо массива</li><li>Обновление O(1) вместо O(n)</li><li>Избегать поиска при каждом обновлении</li></ul><p><strong>2. Иммутабельные обновления:</strong></p><ul><li>Использовать Immer для упрощения обновлений</li><li>Избегать мутаций — React не заметит изменения</li></ul><p><strong>3. Разделение state:</strong></p><ul><li>Не держать все в одном огромном объекте</li><li>Разбить на логические части</li><li>Изменение части не триггерит всё</li></ul><p><strong>4. Selectors с мемоизацией:</strong></p><ul><li>useMemo для производных данных</li><li>Reselect для сложных вычислений</li></ul><p><strong>5. Pagination state:</strong></p><p>Не хранить все данные в памяти, только текущую страницу.</p>",
    difficulty: 'senior',
    tags: ['state', 'большие данные', 'оптимизация', 'нормализация']
  },
  {
    id: 133,
    question: "Что такое debouncing и throttling, и как их применять для оптимизации?",
    answer: "<p>Это техники ограничения частоты вызова функций.</p><p><strong>Debouncing (антидребезг):</strong></p><ul><li>Вызов функции откладывается после последнего события</li><li>Если события продолжаются — таймер сбрасывается</li><li>Функция вызовется только когда события прекратятся</li><li>Применение: поиск при вводе, автосохранение, валидация</li></ul><p><strong>Throttling (троттлинг):</strong></p><ul><li>Функция вызывается максимум раз в N миллисекунд</li><li>Даже если события происходят чаще</li><li>Гарантирует регулярные вызовы</li><li>Применение: scroll обработчики, resize, mousemove</li></ul><p><strong>В React:</strong></p><ul><li>lodash.debounce/throttle</li><li>use-debounce хук</li><li>Собственная реализация через useRef + setTimeout</li></ul><p><strong>Важно:</strong></p><p>Функция должна быть стабильной (useCallback), иначе debounce/throttle не сработает.</p>",
    difficulty: 'middle',
    tags: ['debouncing', 'throttling', 'оптимизация', 'события']
  },
  {
    id: 134,
    question: "Как оптимизировать Context чтобы избежать лишних ререндеров потребителей?",
    answer: "<p>Context — мощный инструмент, но легко вызвать проблемы с производительностью.</p><p><strong>Техники оптимизации:</strong></p><p><strong>1. Split contexts (разделение):</strong></p><ul><li>Один контекст для данных, другой для actions</li><li>Компоненты подписываются только на нужное</li><li>Изменение actions не ре-рендерит data consumers</li></ul><p><strong>2. Мемоизация value:</strong></p><ul><li>Обернуть value в useMemo</li><li>Без этого новый объект при каждом рендере провайдера</li><li>Все потребители ре-рендерятся</li></ul><p><strong>3. Провайдер ниже в дереве:</strong></p><ul><li>Размещать Provider как можно ближе к потребителям</li><li>Меньше компонентов между провайдером и потребителями</li></ul><p><strong>4. Селекторы через useMemo:</strong></p><ul><li>Извлекать только нужную часть контекста</li><li>Остальные изменения не вызовут ререндер</li></ul><p><strong>5. Context + React.memo:</strong></p><p>Компоненты между провайдером и потребителем в React.memo.</p>",
    difficulty: 'senior',
    tags: ['Context', 'оптимизация', 'ререндер', 'продвинутое']
  },
  {
    id: 135,
    question: "Какие инструменты и техники помогают избежать преждевременной оптимизации?",
    answer: "<p><strong>Преждевременная оптимизация — корень всех зол.</strong> Важно сначала измерить, потом оптимизировать.</p><p><strong>Процесс правильной оптимизации:</strong></p><p><strong>1. Измерение (Profiling):</strong></p><ul><li>React DevTools Profiler — найти медленные компоненты</li><li>Chrome Performance tab — общая картина</li><li>User Timing API — кастомные метки</li><li>Web Vitals — реальные метрики UX</li></ul><p><strong>2. Приоритизация:</strong></p><ul><li>Оптимизировать самое медленное место</li><li>Правило 80/20 — 20% кода дает 80% проблем</li><li>Фокус на критичных user flows</li></ul><p><strong>3. Итеративный подход:</strong></p><ul><li>Одна оптимизация → измерение → следующая</li><li>Не оптимизировать всё сразу</li></ul><p><strong>Правила здравого смысла:</strong></p><ul><li>Код работает → не трогай</li><li>Пользователь не жалуется → не оптимизируй</li><li>Профайлер не показывает проблему → не изменяй</li></ul><p><strong>Помнить:</strong></p><p>Простой читаемый код ценнее преждевременно оптимизированного.</p>",
    difficulty: 'senior',
    tags: ['оптимизация', 'best practices', 'измерения', 'профилирование']
  }
]
