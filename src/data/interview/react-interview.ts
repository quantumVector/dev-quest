export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const reactInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое React и в чем его основные преимущества?",
    answer: "<p><strong>React</strong> — это JavaScript библиотека для создания пользовательских интерфейсов, разработанная Facebook в 2013 году.</p><p><strong>Основные преимущества:</strong></p><ul><li><strong>Компонентный подход</strong> — приложение разбивается на независимые переиспользуемые компоненты</li><li><strong>Virtual DOM</strong> — эффективное обновление реального DOM через виртуальное представление</li><li><strong>Однонаправленный поток данных</strong> — предсказуемость и простота отладки</li><li><strong>Декларативность</strong> — описываем что хотим получить, а не как это сделать</li><li><strong>Большая экосистема</strong> — множество готовых решений и библиотек</li></ul><p>React фокусируется только на слое представления (View), что делает его гибким и легко интегрируемым с другими технологиями.</p>",
    difficulty: 'junior',
    tags: ['основы', 'преимущества', 'концепции']
  },
  {
    id: 2,
    question: "Объясните разницу между библиотекой и фреймворком. Почему React — это библиотека?",
    answer: "<p><strong>Фреймворк</strong> предоставляет полную структуру приложения и диктует архитектуру — вы работаете по его правилам. Примеры: Angular, Vue (частично).</p><p><strong>Библиотека</strong> предоставляет набор инструментов для решения конкретных задач — вы сами решаете, как их использовать.</p><p><strong>React — библиотека, потому что:</strong></p><ul><li>Отвечает только за UI слой</li><li>Не навязывает структуру проекта</li><li>Не включает роутинг, управление состоянием из коробки</li><li>Можно использовать только нужные части</li><li>Легко интегрируется в существующие проекты</li></ul><p>Для полноценного приложения React комбинируют с другими библиотеками: React Router, Redux/MobX, и так далее.</p>",
    difficulty: 'junior',
    tags: ['основы', 'терминология', 'архитектура']
  },
  {
    id: 3,
    question: "Что такое JSX и почему он используется в React?",
    answer: "<p><strong>JSX (JavaScript XML)</strong> — это синтаксическое расширение JavaScript, позволяющее писать HTML-подобный код внутри JavaScript.</p><p><strong>Преимущества JSX:</strong></p><ul><li><strong>Наглядность</strong> — структура компонента видна сразу</li><li><strong>Мощь JavaScript</strong> — можно использовать любые JS выражения</li><li><strong>Безопасность</strong> — автоматическое экранирование предотвращает XSS</li><li><strong>Оптимизация</strong> — Babel проверяет JSX на этапе компиляции</li></ul><p><strong>Как это работает:</strong></p><p>JSX компилируется в вызовы React.createElement(). Код выглядит как HTML, но это JavaScript объекты, описывающие структуру UI.</p><p>JSX необязателен, но делает код понятнее и позволяет использовать всю мощь JavaScript при описании UI.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'синтаксис', 'основы']
  },
  {
    id: 4,
    question: "Объясните концепцию Virtual DOM. Как и зачем React его использует?",
    answer: "<p><strong>Virtual DOM</strong> — это легковесная копия реального DOM в памяти, представленная как JavaScript объект.</p><p><strong>Как работает:</strong></p><ul><li>При изменении состояния React создает новое виртуальное дерево</li><li>Сравнивает его с предыдущей версией (reconciliation)</li><li>Вычисляет минимальный набор изменений</li><li>Применяет только эти изменения к реальному DOM</li></ul><p><strong>Зачем это нужно:</strong></p><ul><li><strong>Производительность</strong> — работа с реальным DOM медленная, с Virtual DOM — быстрая</li><li><strong>Батчинг</strong> — React группирует обновления, избегая лишних перерисовок</li><li><strong>Кросс-платформенность</strong> — один код для web, mobile (React Native)</li></ul><p>Virtual DOM — это компромисс между производительностью ручной оптимизации DOM и удобством декларативного подхода.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'производительность', 'reconciliation']
  },
  {
    id: 5,
    question: "В чем разница между управляемыми (controlled) и неуправляемыми (uncontrolled) компонентами?",
    answer: "<p><strong>Управляемые компоненты (Controlled):</strong></p><ul><li>Значение хранится в state React</li><li>Обновляется через обработчики событий</li><li>React — единственный источник истины</li><li>Полный контроль над данными формы</li></ul><p><strong>Неуправляемые компоненты (Uncontrolled):</strong></p><ul><li>Значение хранится в самом DOM элементе</li><li>Доступ через ref</li><li>DOM — источник истины</li><li>Проще для простых форм</li></ul><p><strong>Когда использовать:</strong></p><p><em>Controlled</em> — когда нужна валидация на лету, условная логика, синхронизация нескольких полей.</p><p><em>Uncontrolled</em> — для простых форм, интеграции с non-React кодом, файловых input (которые всегда uncontrolled).</p><p>В большинстве случаев рекомендуется использовать управляемые компоненты для предсказуемости.</p>",
    difficulty: 'middle',
    tags: ['формы', 'controlled', 'uncontrolled', 'state']
  },
  {
    id: 6,
    question: "Что такое props и как они работают в React?",
    answer: "<p><strong>Props (properties)</strong> — это механизм передачи данных от родительского компонента к дочернему.</p><p><strong>Ключевые особенности:</strong></p><ul><li><strong>Только для чтения</strong> — компонент не может изменять свои props</li><li><strong>Однонаправленный поток</strong> — данные идут сверху вниз</li><li><strong>Любые типы данных</strong> — строки, числа, объекты, функции, компоненты</li></ul><p><strong>Зачем нужны props:</strong></p><ul><li>Передача данных в компоненты</li><li>Переиспользование компонентов с разными данными</li><li>Передача callback функций для коммуникации снизу вверх</li><li>Композиция компонентов через children</li></ul><p><strong>Props vs State:</strong></p><p>Props приходят извне и неизменяемы, State управляется внутри компонента и изменяем. Изменение props вызывает ререндер компонента.</p>",
    difficulty: 'junior',
    tags: ['props', 'передача данных', 'основы']
  },
  {
    id: 7,
    question: "Объясните концепцию однонаправленного потока данных в React",
    answer: "<p><strong>Однонаправленный поток данных (Unidirectional data flow)</strong> — фундаментальная концепция React, где данные текут только в одном направлении: от родителей к детям.</p><p><strong>Как это работает:</strong></p><ul><li>Родитель передает данные детям через props</li><li>Дети могут отправлять события родителю через callback</li><li>Состояние живет на верхнем уровне и передается вниз</li><li>Изменения состояния вызывают ререндер дерева компонентов</li></ul><p><strong>Преимущества:</strong></p><ul><li><strong>Предсказуемость</strong> — легко понять, откуда приходят данные</li><li><strong>Отладка</strong> — проще отследить источник проблем</li><li><strong>Тестируемость</strong> — чистые функции легко тестировать</li></ul><p>Это противоположность двунаправленному связыванию (two-way binding) в Angular, где изменения могут идти в обе стороны.</p>",
    difficulty: 'middle',
    tags: ['поток данных', 'архитектура', 'концепции']
  },
  {
    id: 8,
    question: "Что такое компонентный подход и какие преимущества он дает?",
    answer: "<p><strong>Компонентный подход</strong> — это разделение UI на независимые, переиспользуемые части, каждая из которых управляет своим состоянием и логикой.</p><p><strong>Принципы компонентного подхода:</strong></p><ul><li><strong>Инкапсуляция</strong> — логика и UI вместе в одном месте</li><li><strong>Переиспользование</strong> — один раз написали, используем везде</li><li><strong>Композиция</strong> — собираем сложные UI из простых частей</li><li><strong>Изоляция</strong> — изменения в одном компоненте не ломают другие</li></ul><p><strong>Преимущества:</strong></p><ul><li>Код легче понимать и поддерживать</li><li>Проще тестировать изолированно</li><li>Команда может работать параллельно над разными компонентами</li><li>Легко масштабировать приложение</li><li>Возможность создавать библиотеки компонентов</li></ul><p>Компонентность — не уникальная особенность React, но он популяризировал этот подход.</p>",
    difficulty: 'junior',
    tags: ['компоненты', 'архитектура', 'переиспользование']
  },
  {
    id: 9,
    question: "Чем React отличается от других популярных фреймворков (Angular, Vue)?",
    answer: "<p><strong>React vs Angular:</strong></p><ul><li>React — библиотека (только UI), Angular — полноценный фреймворк</li><li>React использует JSX, Angular — TypeScript с шаблонами</li><li>React — функциональный подход с хуками, Angular — ООП с классами</li><li>React проще начать, Angular — больше из коробки</li></ul><p><strong>React vs Vue:</strong></p><ul><li>Схожи по концепции Virtual DOM и компонентности</li><li>Vue использует SFC (Single File Components) с template, React — JSX</li><li>Vue проще для новичков, более «батарейный»</li><li>React имеет большее комьюнити и экосистему</li></ul><p><strong>Когда выбрать React:</strong></p><ul><li>Нужна гибкость в выборе инструментов</li><li>Важна мобильная разработка (React Native)</li><li>Большая команда с опытом в JavaScript</li><li>Требуется богатая экосистема библиотек</li></ul>",
    difficulty: 'middle',
    tags: ['сравнение', 'Angular', 'Vue', 'выбор технологий']
  },
  {
    id: 10,
    question: "Объясните концепцию декларативного программирования в контексте React",
    answer: "<p><strong>Декларативное программирование</strong> — это подход, где мы описываем ЧТО хотим получить, а не КАК это сделать (императивный подход).</p><p><strong>В React:</strong></p><p>Мы описываем желаемое состояние UI, а React сам разбирается, как обновить DOM для достижения этого состояния.</p><p><strong>Декларативный подход:</strong></p><p>Описываем UI как функцию от state: UI = f(state). При изменении state React пересчитывает UI.</p><p><strong>Императивный подход (классический DOM):</strong></p><p>Вручную манипулируем DOM: находим элемент, изменяем его атрибуты, добавляем/удаляем классы.</p><p><strong>Преимущества декларативности:</strong></p><ul><li>Код проще читать и понимать</li><li>Меньше багов — не нужно думать о промежуточных состояниях</li><li>Легче тестировать — проверяем результат, а не шаги</li><li>React оптимизирует обновления автоматически</li></ul>",
    difficulty: 'middle',
    tags: ['декларативность', 'концепции', 'парадигмы']
  },
  {
    id: 11,
    question: "Какие проблемы решает React в веб-разработке?",
    answer: "<p>React решает несколько фундаментальных проблем современной веб-разработки:</p><p><strong>1. Сложность управления DOM:</strong></p><ul><li>Ручные манипуляции с DOM сложны и подвержены ошибкам</li><li>Virtual DOM автоматизирует и оптимизирует обновления</li></ul><p><strong>2. Переиспользование кода:</strong></p><ul><li>Компоненты можно использовать многократно</li><li>Создание библиотек компонентов для всей команды</li></ul><p><strong>3. Управление состоянием:</strong></p><ul><li>Четкая связь между данными и UI</li><li>Предсказуемое обновление интерфейса</li></ul><p><strong>4. Масштабирование приложений:</strong></p><ul><li>Компонентная архитектура облегчает работу больших команд</li><li>Модульность упрощает рефакторинг</li></ul><p><strong>5. Производительность:</strong></p><ul><li>Эффективные алгоритмы обновления</li><li>Батчинг и оптимизация ререндеров</li></ul>",
    difficulty: 'middle',
    tags: ['проблемы', 'решения', 'преимущества']
  },
  {
    id: 12,
    question: "Как React подходит для создания SPA (Single Page Applications)?",
    answer: "<p>React отлично подходит для создания SPA благодаря своей архитектуре:</p><p><strong>Ключевые возможности для SPA:</strong></p><ul><li><strong>Клиентский рендеринг</strong> — весь UI управляется на клиенте</li><li><strong>React Router</strong> — навигация без перезагрузки страницы</li><li><strong>Управление состоянием</strong> — Context API, Redux для глобального state</li><li><strong>Code splitting</strong> — загрузка кода по требованию</li><li><strong>Lazy loading</strong> — отложенная загрузка компонентов</li></ul><p><strong>Преимущества React для SPA:</strong></p><ul><li>Быстрые переходы между страницами</li><li>Нет полной перезагрузки страницы</li><li>Богатая интерактивность</li><li>Оптимистичные обновления UI</li></ul><p><strong>Дополнительные инструменты:</strong></p><p>Для полноценного SPA обычно добавляют: роутинг (React Router), состояние (Redux/MobX), API запросы (axios/fetch).</p>",
    difficulty: 'middle',
    tags: ['SPA', 'архитектура', 'роутинг']
  },
  {
    id: 13,
    question: "Можно ли использовать React для создания мобильных приложений?",
    answer: "<p>Да, через <strong>React Native</strong> — фреймворк для создания нативных мобильных приложений на React.</p><p><strong>Как это работает:</strong></p><ul><li>Пишем код на JavaScript/React</li><li>React Native компилирует в нативные компоненты iOS/Android</li><li>Используем знакомые концепции: компоненты, state, props, хуки</li></ul><p><strong>Отличия от React для web:</strong></p><ul><li>Вместо HTML используем компоненты React Native (View, Text, Image)</li><li>Стилизация через StyleSheet API (похоже на CSS)</li><li>Доступ к нативным API через мосты</li><li>Одна кодовая база для iOS и Android</li></ul><p><strong>Преимущества:</strong></p><ul><li>Переиспользование навыков React</li><li>Быстрая разработка для обеих платформ</li><li>Hot reload для быстрой итерации</li><li>Большое комьюнити и экосистема</li></ul><p>React Native — это отдельный проект, но концепции и подходы те же, что в React.</p>",
    difficulty: 'junior',
    tags: ['React Native', 'мобильная разработка', 'кросс-платформа']
  },
  {
    id: 14,
    question: "В чем суть философии 'Learn Once, Write Anywhere' в React?",
    answer: "<p><strong>'Learn Once, Write Anywhere'</strong> — философия React, означающая: выучив React один раз, можно писать приложения для разных платформ.</p><p><strong>Где можно использовать React:</strong></p><ul><li><strong>Web</strong> — React DOM для браузера</li><li><strong>Mobile</strong> — React Native для iOS/Android</li><li><strong>Desktop</strong> — Electron с React</li><li><strong>VR</strong> — React 360 для виртуальной реальности</li><li><strong>Terminal</strong> — React Ink для CLI приложений</li></ul><p><strong>Общие концепции:</strong></p><ul><li>Компонентная модель</li><li>State и props</li><li>Хуки и жизненный цикл</li><li>Однонаправленный поток данных</li></ul><p><strong>Различия:</strong></p><p>Меняются только примитивы рендеринга (div → View, p → Text), но подход остается тем же.</p><p>Это не 'Write Once, Run Anywhere' — код нужно адаптировать под платформу, но знания переносятся полностью.</p>",
    difficulty: 'senior',
    tags: ['философия', 'кросс-платформа', 'экосистема']
  },
  {
    id: 15,
    question: "Какие недостатки есть у React и когда его лучше не использовать?",
    answer: "<p>React — отличный инструмент, но у него есть недостатки:</p><p><strong>Основные недостатки:</strong></p><ul><li><strong>Не полноценный фреймворк</strong> — нужно выбирать роутер, state management, и т.д.</li><li><strong>Быстрые изменения</strong> — API меняется, нужно постоянно учиться</li><li><strong>JSX</strong> — может быть непривычен новичкам</li><li><strong>SEO сложности</strong> — требуется SSR для хорошей индексации</li><li><strong>Большой размер</strong> — базовый бандл React довольно большой</li></ul><p><strong>Когда React избыточен:</strong></p><ul><li>Простые статические сайты (лучше использовать HTML/CSS)</li><li>Лендинги без интерактивности</li><li>Проекты с жесткими требованиями к размеру бандла</li><li>Когда команда не знакома с JavaScript экосистемой</li></ul><p><strong>Когда выбрать альтернативу:</strong></p><ul><li>Angular — если нужен опinionated фреймворк</li><li>Vue — если нужна меньшая кривая обучения</li><li>Svelte — если критичен размер бандла</li></ul>",
    difficulty: 'senior',
    tags: ['недостатки', 'ограничения', 'выбор технологий']
  },
  {
    id: 16,
    question: "Что такое Virtual DOM и как он работает в React?",
    answer: "<p><strong>Virtual DOM</strong> — это легковесное JavaScript представление реального DOM дерева.</p><p><strong>Как работает:</strong></p><ul><li>React хранит копию DOM в памяти как JS объект</li><li>При изменении state/props создается новое виртуальное дерево</li><li>React сравнивает новое дерево со старым (diffing)</li><li>Вычисляет минимальный набор изменений</li><li>Применяет только необходимые изменения к реальному DOM</li></ul><p><strong>Почему это быстрее:</strong></p><p>Работа с JS объектами в памяти в сотни раз быстрее, чем манипуляции с реальным DOM. React минимизирует дорогостоящие операции с DOM, группируя изменения.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'производительность', 'основы']
  },
  {
    id: 17,
    question: "В чем разница между Virtual DOM и реальным DOM?",
    answer: "<p><strong>Реальный DOM:</strong></p><ul><li>Представление HTML в браузере</li><li>Тяжеловесная структура с методами браузера</li><li>Каждое изменение вызывает reflow/repaint</li><li>Медленные операции чтения и записи</li><li>Прямые манипуляции могут быть неэффективными</li></ul><p><strong>Virtual DOM:</strong></p><ul><li>JavaScript объект в памяти</li><li>Легковесная копия реального DOM</li><li>Быстрое сравнение и вычисление изменений</li><li>Батчинг множественных обновлений</li><li>Не вызывает перерисовку до применения к реальному DOM</li></ul><p>Virtual DOM — это прослойка оптимизации между вашим кодом и реальным DOM.</p>",
    difficulty: 'middle',
    tags: ['Virtual DOM', 'DOM', 'отличия']
  },
  {
    id: 18,
    question: "Опишите процесс reconciliation в React. Как React понимает, что нужно обновить?",
    answer: "<p><strong>Reconciliation</strong> — это процесс сравнения (diffing) двух виртуальных деревьев для определения изменений.</p><p><strong>Как работает:</strong></p><ul><li>React создает новое Virtual DOM дерево</li><li>Сравнивает его с предыдущим снимком</li><li>Использует эвристический алгоритм O(n)</li><li>Сравнивает элементы по типу и ключу</li><li>Формирует список минимальных изменений (patches)</li></ul><p><strong>Оптимизации:</strong></p><ul><li>Элементы разных типов — полная замена поддерева</li><li>Элементы одного типа — обновление атрибутов</li><li>Списки — использование key для идентификации</li></ul><p>Этот процесс происходит автоматически при каждом изменении state или props.</p>",
    difficulty: 'senior',
    tags: ['reconciliation', 'diffing', 'алгоритмы']
  },
  {
    id: 19,
    question: "Почему React использует алгоритм diffing O(n) вместо O(n³)?",
    answer: "<p>Классический алгоритм сравнения деревьев имеет сложность O(n³), что неприемлемо для UI с тысячами элементов.</p><p><strong>Эвристики React для O(n):</strong></p><ul><li><strong>Разные типы → разные деревья</strong> — React не пытается сравнивать &lt;div&gt; с &lt;span&gt;</li><li><strong>Ключи для стабильной идентификации</strong> — key помогает отслеживать элементы между рендерами</li><li><strong>Побратимство по уровням</strong> — сравнение только на одном уровне, без глубокого анализа</li></ul><p><strong>Компромисс:</strong></p><p>Алгоритм не всегда оптимален теоретически, но на практике эти эвристики работают в 99% случаев и дают приемлемую производительность для реальных приложений.</p>",
    difficulty: 'senior',
    tags: ['алгоритмы', 'оптимизация', 'сложность']
  },
  {
    id: 20,
    question: "Зачем нужны ключи (keys) в списках и как они помогают Virtual DOM?",
    answer: "<p><strong>Keys</strong> — это специальный атрибут, помогающий React идентифицировать элементы между рендерами.</p><p><strong>Зачем нужны:</strong></p><ul><li>Стабильная идентичность элементов при пересортировке</li><li>Переиспользование DOM узлов вместо пересоздания</li><li>Сохранение state компонентов в списке</li><li>Корректная работа анимаций и фокуса</li></ul><p><strong>Как работают:</strong></p><p>При diffing React сопоставляет элементы по key. Если key не изменился, React обновляет существующий элемент вместо удаления и создания нового.</p><p><strong>Антипаттерн:</strong></p><p>Использование индекса массива как key проблематично при изменении порядка — элементы будут пересозданы, потеряв state.</p>",
    difficulty: 'middle',
    tags: ['keys', 'списки', 'оптимизация']
  },
  {
    id: 21,
    question: "Что произойдет, если не использовать key в списках?",
    answer: "<p>Без key React использует индекс элемента как идентификатор по умолчанию.</p><p><strong>Проблемы:</strong></p><ul><li><strong>Некорректные обновления</strong> — при изменении порядка React обновит не те элементы</li><li><strong>Потеря state</strong> — внутреннее состояние компонентов может перепутаться</li><li><strong>Проблемы с фокусом</strong> — input элементы теряют фокус</li><li><strong>Лишние рендеры</strong> — React может пересоздать элементы вместо переиспользования</li><li><strong>Баги в анимациях</strong> — анимации могут применяться к неправильным элементам</li></ul><p><strong>Когда индекс допустим:</strong></p><p>Только если список статичен и никогда не меняет порядок, не фильтруется и не добавляет элементы в середину.</p>",
    difficulty: 'middle',
    tags: ['keys', 'проблемы', 'best practices']
  },
  {
    id: 22,
    question: "Как Virtual DOM помогает с производительностью по сравнению с прямыми манипуляциями DOM?",
    answer: "<p><strong>Проблемы прямых манипуляций DOM:</strong></p><ul><li>Каждое изменение может вызывать reflow/repaint</li><li>Множественные обновления = множественные перерисовки</li><li>Разработчик должен вручную оптимизировать</li><li>Трудно отследить все зависимости изменений</li></ul><p><strong>Преимущества Virtual DOM:</strong></p><ul><li><strong>Батчинг</strong> — группировка изменений в один update</li><li><strong>Минимизация операций</strong> — только необходимые изменения</li><li><strong>Автоматическая оптимизация</strong> — React сам вычисляет оптимальный path</li><li><strong>Предсказуемость</strong> — декларативный подход убирает ручное управление</li></ul><p>Virtual DOM — это разумный баланс между производительностью и удобством разработки.</p>",
    difficulty: 'middle',
    tags: ['производительность', 'оптимизация', 'преимущества']
  },
  {
    id: 23,
    question: "Всегда ли Virtual DOM быстрее прямых манипуляций с DOM?",
    answer: "<p><strong>Нет, не всегда.</strong> Virtual DOM — это компромисс, а не серебряная пуля.</p><p><strong>Когда Virtual DOM медленнее:</strong></p><ul><li>Очень простые, точечные обновления одного элемента</li><li>Высокочастотные изменения (например, canvas анимации)</li><li>Когда overhead diffing превышает выгоду от оптимизации</li></ul><p><strong>Когда Virtual DOM быстрее:</strong></p><ul><li>Сложные UI с множественными зависимостями</li><li>Много одновременных обновлений</li><li>Когда сложно вручную оптимизировать</li></ul><p><strong>Реальная ценность:</strong></p><p>Virtual DOM дает не только скорость, но и удобство разработки, предсказуемость и масштабируемость. Для 99% задач этого достаточно.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'ограничения', 'компромиссы']
  },
  {
    id: 24,
    question: "Объясните, что такое Fiber архитектура и как она улучшила работу Virtual DOM?",
    answer: "<p><strong>React Fiber</strong> — это полная переработка reconciliation алгоритма, представленная в React 16.</p><p><strong>Проблема старого подхода:</strong></p><p>Reconciliation был синхронным и блокирующим — при больших обновлениях UI мог \"зависать\".</p><p><strong>Что изменил Fiber:</strong></p><ul><li><strong>Incremental rendering</strong> — работа разбивается на части</li><li><strong>Приоритизация</strong> — важные обновления (ввод) приоритетнее фоновых</li><li><strong>Pause/resume</strong> — React может прервать работу и продолжить позже</li><li><strong>Прерывание</strong> — отмена устаревшей работы</li></ul><p><strong>Результат:</strong></p><p>Более плавный UI, отзывчивые анимации, отсутствие \"зависаний\" даже при тяжелых вычислениях.</p>",
    difficulty: 'senior',
    tags: ['Fiber', 'архитектура', 'React 16+']
  },
  {
    id: 25,
    question: "Как React батчит (группирует) обновления состояния?",
    answer: "<p><strong>Батчинг</strong> — это группировка нескольких вызовов setState в один ререндер.</p><p><strong>До React 18:</strong></p><ul><li>Батчинг работал только в event handlers</li><li>В промисах, setTimeout, нативных событиях — каждый setState вызывал ререндер</li></ul><p><strong>React 18 (Automatic Batching):</strong></p><ul><li>Батчинг везде по умолчанию</li><li>В промисах, setTimeout, нативных событиях тоже батчится</li><li>Можно отключить через flushSync() если нужно</li></ul><p><strong>Почему это важно:</strong></p><p>Множественные setState не вызывают множественных рендеров. React собирает все изменения и применяет одним батчем, минимизируя работу с DOM.</p>",
    difficulty: 'senior',
    tags: ['батчинг', 'setState', 'React 18']
  },
  {
    id: 26,
    question: "Что такое reconciliation в контексте React Fiber?",
    answer: "<p>В Fiber reconciliation стал асинхронным и прерываемым процессом.</p><p><strong>Две фазы работы:</strong></p><p><strong>1. Render фаза (прерываемая):</strong></p><ul><li>Построение нового Fiber дерева</li><li>Вычисление изменений (diffing)</li><li>Может быть прервана и перезапущена</li><li>Без side-effects</li></ul><p><strong>2. Commit фаза (синхронная):</strong></p><ul><li>Применение изменений к реальному DOM</li><li>Вызов lifecycle методов</li><li>Не может быть прервана</li><li>Выполняется за один проход</li></ul><p><strong>Преимущество:</strong></p><p>React может прервать дорогостоящую render фазу для обработки более важных обновлений, затем вернуться к ней.</p>",
    difficulty: 'senior',
    tags: ['reconciliation', 'Fiber', 'фазы рендера']
  },
  {
    id: 27,
    question: "Как Virtual DOM работает с событиями в React?",
    answer: "<p>React использует <strong>синтетические события (SyntheticEvent)</strong> — обертку над нативными событиями браузера.</p><p><strong>Почему не напрямую:</strong></p><ul><li><strong>Кросс-браузерность</strong> — единый API для всех браузеров</li><li><strong>Производительность</strong> — event delegation на корневом уровне</li><li><strong>Объединение с Virtual DOM</strong> — события привязаны к виртуальным узлам</li></ul><p><strong>Как работает:</strong></p><ul><li>React регистрирует один обработчик на root элементе</li><li>При событии React определяет целевой компонент через Fiber дерево</li><li>Вызывает соответствующий обработчик с SyntheticEvent</li></ul><p><strong>Изменение в React 17:</strong></p><p>Event delegation теперь на корне приложения, а не document — улучшает работу с микрофронтендами.</p>",
    difficulty: 'senior',
    tags: ['события', 'SyntheticEvent', 'delegation']
  },
  {
    id: 28,
    question: "Можно ли обойтись без Virtual DOM? Какие есть альтернативы?",
    answer: "<p>Да, Virtual DOM — не единственный подход к реактивному UI.</p><p><strong>Альтернативы:</strong></p><ul><li><strong>Svelte</strong> — компиляция в императивный код без runtime diffing</li><li><strong>Solid.js</strong> — fine-grained reactivity с прямыми обновлениями DOM</li><li><strong>Vue 3 Composition API</strong> — комбинация Virtual DOM с реактивностью</li><li><strong>Angular Signals</strong> — реактивные примитивы без Virtual DOM</li></ul><p><strong>Преимущества без Virtual DOM:</strong></p><ul><li>Меньше overhead на diffing</li><li>Более предсказуемая производительность</li><li>Меньший размер бандла</li></ul><p><strong>Компромиссы:</strong></p><p>Virtual DOM дает гибкость и простоту разработки. Альтернативы часто быстрее, но требуют более аккуратного подхода к оптимизации.</p>",
    difficulty: 'senior',
    tags: ['альтернативы', 'сравнение', 'Svelte', 'Solid']
  },
  {
    id: 29,
    question: "Как React определяет, что компонент нужно перерендерить?",
    answer: "<p>React запускает ререндер компонента в нескольких случаях:</p><p><strong>Триггеры ререндера:</strong></p><ul><li><strong>Изменение state</strong> — вызов setState/useState updater</li><li><strong>Изменение props</strong> — родитель передал новые props</li><li><strong>Изменение context</strong> — значение useContext изменилось</li><li><strong>Ререндер родителя</strong> — по умолчанию дети тоже рендерятся</li><li><strong>forceUpdate()</strong> — принудительный рендер (устарело)</li></ul><p><strong>Важно:</strong></p><p>Ререндер не означает изменение DOM. React сравнит Virtual DOM и применит изменения только если они есть.</p><p><strong>Оптимизация:</strong></p><p>React.memo, useMemo, useCallback помогают избежать ненужных ререндеров при неизменных данных.</p>",
    difficulty: 'middle',
    tags: ['ререндер', 'триггеры', 'оптимизация']
  },
  {
    id: 30,
    question: "В чем разница между createElement и JSX в контексте Virtual DOM?",
    answer: "<p>JSX — это синтаксический сахар, который компилируется в вызовы createElement (в React 17+: jsx() runtime).</p><p><strong>JSX код:</strong></p><p>Выглядит как HTML, но это JavaScript, который Babel транспилирует.</p><p><strong>React.createElement():</strong></p><p>Создает JavaScript объект (React элемент) — узел Virtual DOM дерева. Принимает тип, props, children.</p><p><strong>Virtual DOM узел:</strong></p><p>Это просто объект с полями: type (компонент/тег), props (атрибуты), key, ref, children.</p><p><strong>Процесс:</strong></p><p>JSX → createElement → Virtual DOM объект → reconciliation → реальный DOM</p><p>Вся магия React построена на манипуляции этими легковесными объектами вместо тяжелого DOM.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'createElement', 'компиляция']
  },
  {
    id: 31,
    question: "Что такое JSX и чем он отличается от обычного JavaScript?",
    answer: "<p><strong>JSX (JavaScript XML)</strong> — это синтаксическое расширение JavaScript, которое позволяет писать разметку, похожую на HTML, прямо в JavaScript коде.</p><p><strong>Ключевые отличия от JavaScript:</strong></p><ul><li>JSX не является валидным JavaScript — требует транспиляции</li><li>Использует XML-подобный синтаксис для описания UI</li><li>Позволяет встраивать JavaScript выражения через фигурные скобки {}</li><li>Имеет свои правила именования (className вместо class, htmlFor вместо for)</li></ul><p><strong>Важно понимать:</strong></p><p>JSX — это не шаблонный язык и не HTML. Это JavaScript код, который выглядит как разметка для удобства восприятия. После компиляции JSX превращается в обычные функции JavaScript.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'основы', 'синтаксис']
  },
  {
    id: 32,
    question: "Какие инструменты используются для поддержки JSX-синтаксиса?",
    answer: "<p>JSX требует транспиляции в обычный JavaScript. Основные инструменты:</p><p><strong>Babel:</strong></p><ul><li>Самый популярный транспилятор для JSX</li><li>Плагин @babel/preset-react для JSX трансформации</li><li>Используется в Create React App, Next.js и большинстве проектов</li></ul><p><strong>TypeScript:</strong></p><ul><li>Нативная поддержка JSX через расширение .tsx</li><li>Встроенная проверка типов для JSX элементов</li><li>Опция jsx в tsconfig.json определяет способ компиляции</li></ul><p><strong>Другие инструменты:</strong></p><ul><li>SWC — современная быстрая альтернатива Babel на Rust</li><li>esbuild — сверхбыстрый бандлер с поддержкой JSX</li></ul><p>В современных проектах настройка часто скрыта в инструментах типа Vite или Next.js.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'инструменты', 'Babel', 'TypeScript']
  },
  {
    id: 33,
    question: "Во что преобразуются JSX-теги при компиляции?",
    answer: "<p>JSX теги компилируются в вызовы функций создания React элементов.</p><p><strong>До React 17:</strong></p><p>JSX компилировался в React.createElement() вызовы. Поэтому React нужно было импортировать в каждом файле.</p><p><strong>React 17+ (новый JSX Transform):</strong></p><p>JSX компилируется в специальные функции jsx() и jsxs() из 'react/jsx-runtime'. Import React больше не требуется.</p><p><strong>Что создается:</strong></p><p>В результате получается обычный JavaScript объект — React элемент, который описывает структуру Virtual DOM узла. Объект содержит: type (тип элемента), props (свойства и children), key, ref.</p><p>Эти объекты — основа Virtual DOM, с которыми React работает при reconciliation.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'компиляция', 'createElement', 'transform']
  },
  {
    id: 34,
    question: "Почему в JSX используется className вместо class?",
    answer: "<p>В JSX используется className вместо class по историческим и техническим причинам:</p><p><strong>Техническая причина:</strong></p><ul><li>class — зарезервированное ключевое слово в JavaScript</li><li>JSX компилируется в JavaScript объекты с полем props</li><li>Использование class как имени свойства может вызвать проблемы</li></ul><p><strong>Исторический контекст:</strong></p><p>Когда создавался React, использование зарезервированных слов в объектах было более проблематичным. Хотя современный JavaScript позволяет 'class' как ключ объекта, React сохранил className для обратной совместимости.</p><p><strong>Аналогично:</strong></p><ul><li>htmlFor вместо for</li><li>onChange вместо onchange</li><li>dangerouslySetInnerHTML вместо innerHTML</li></ul>",
    difficulty: 'junior',
    tags: ['JSX', 'атрибуты', 'отличия от HTML']
  },
  {
    id: 35,
    question: "Можно ли использовать if-else внутри JSX?",
    answer: "<p><strong>Напрямую нельзя</strong> — внутри фигурных скобок JSX можно использовать только выражения, а if-else это statement (инструкция).</p><p><strong>Альтернативы:</strong></p><p><strong>1. Тернарный оператор:</strong></p><p>Самый частый способ для простых условий.</p><p><strong>2. Логический оператор &&:</strong></p><p>Для рендера при выполнении условия.</p><p><strong>3. Переменная перед return:</strong></p><p>Можно использовать полноценный if-else до JSX, сохранив результат в переменную.</p><p><strong>4. IIFE (Immediately Invoked Function Expression):</strong></p><p>Можно вызвать функцию с if-else внутри фигурных скобок, но это редкий паттерн.</p><p>В большинстве случаев достаточно тернарного оператора или &&.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'условия', 'выражения']
  },
  {
    id: 36,
    question: "Что можно и что нельзя рендерить в JSX?",
    answer: "<p><strong>Можно рендерить:</strong></p><ul><li>Строки и числа — отображаются как текст</li><li>React элементы — результат JSX или createElement</li><li>Массивы элементов — React отрендерит каждый</li><li>null, undefined, false, true — не рендерятся (пустота)</li><li>Фрагменты (<></> или <Fragment>)</li></ul><p><strong>Нельзя рендерить напрямую:</strong></p><ul><li>Объекты — вызовут ошибку \"Objects are not valid as a React child\"</li><li>Функции — нужно их вызвать</li><li>Promises — нужно обработать через then или async/await</li><li>Символы и другие не-примитивные типы</li></ul><p><strong>Важно:</strong></p><p>0 (ноль) рендерится как текст, что иногда неожиданно при условном рендере. Пустые строки тоже рендерятся.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'рендеринг', 'типы данных']
  },
  {
    id: 37,
    question: "Как работают комментарии в JSX?",
    answer: "<p>В JSX комментарии отличаются от обычного JavaScript и HTML.</p><p><strong>Внутри JSX разметки:</strong></p><p>Используются JavaScript комментарии внутри фигурных скобок: {/* комментарий */}. Обычные // или /* */ вне скобок не работают.</p><p><strong>Вне JSX (в коде JavaScript):</strong></p><p>Работают стандартные JavaScript комментарии: // или /* */.</p><p><strong>Почему так:</strong></p><p>JSX это JavaScript, поэтому внутри разметки нужно явно указать, что это комментарий через {}. Компилятор видит это как JavaScript выражение.</p><p><strong>HTML комментарии:</strong></p><p>HTML комментарии <!-- --> не работают в JSX и вызовут ошибку.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'комментарии', 'синтаксис']
  },
  {
    id: 38,
    question: "Почему JSX элементы должны иметь один корневой элемент?",
    answer: "<p>JSX выражение должно иметь один корневой элемент, потому что оно компилируется в один вызов функции.</p><p><strong>Техническое объяснение:</strong></p><p>Функция может вернуть только одно значение. JSX компилируется в вызов createElement/jsx(), который возвращает один объект. Несколько соседних элементов — это несколько объектов, что невозможно вернуть напрямую.</p><p><strong>Решения:</strong></p><ul><li><strong>Fragment</strong> (<React.Fragment> или <>...</>) — группирует без лишнего DOM</li><li><strong>Обертка div</strong> — добавляет реальный DOM элемент</li><li><strong>Массив</strong> — можно вернуть массив элементов с ключами</li></ul><p><strong>Современный подход:</strong></p><p>Фрагменты (<></>) — стандартное решение, не добавляющее лишних узлов в DOM.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'фрагменты', 'ограничения']
  },
  {
    id: 39,
    question: "В чем разница между React.createElement и JSX?",
    answer: "<p>JSX — это синтаксический сахар над React.createElement (или современным jsx() runtime).</p><p><strong>JSX:</strong></p><ul><li>Декларативный, читаемый синтаксис</li><li>Похож на HTML</li><li>Требует транспиляции</li><li>Удобен для написания UI</li></ul><p><strong>createElement:</strong></p><ul><li>Императивный вызов функции</li><li>Работает без транспиляции</li><li>Менее читаем при сложной вложенности</li><li>Это то, во что компилируется JSX</li></ul><p><strong>Функционально идентичны:</strong></p><p>Оба создают одинаковые React элементы (объекты Virtual DOM). JSX просто удобнее читать и писать.</p><p><strong>Когда использовать createElement:</strong></p><p>При динамическом создании элементов, в библиотеках, или когда нужно избежать транспиляции.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'createElement', 'API', 'отличия']
  },
  {
    id: 40,
    question: "Как JSX предотвращает XSS атаки?",
    answer: "<p>JSX автоматически экранирует значения перед рендерингом, что защищает от XSS (Cross-Site Scripting).</p><p><strong>Как это работает:</strong></p><ul><li>Все значения в {} преобразуются в строки и экранируются</li><li>Специальные символы (<, >, &, кавычки) заменяются на HTML entities</li><li>Вредоносный код не может быть выполнен</li></ul><p><strong>Пример защиты:</strong></p><p>Если пользователь введет <script>alert('XSS')</script>, React отобразит это как текст, а не выполнит скрипт.</p><p><strong>Исключение:</strong></p><p>dangerouslySetInnerHTML — специальный prop для вставки сырого HTML. Название предупреждает об опасности. Использовать только с проверенными данными.</p><p>Это встроенная защита делает React безопасным по умолчанию.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'безопасность', 'XSS']
  },
  {
    id: 41,
    question: "Что такое JSX spread attributes и когда их использовать?",
    answer: "<p><strong>Spread attributes</strong> — это способ передать все свойства объекта как props компоненту через оператор расширения (...).</p><p><strong>Применение:</strong></p><p>Полезно при проксировании props, создании wrapper компонентов, или передаче множества пропсов от родителя к ребенку.</p><p><strong>Преимущества:</strong></p><ul><li>Меньше кода при множестве пропсов</li><li>Удобно для компонентов-оберток</li><li>Гибкость при неизвестном наборе props</li></ul><p><strong>Недостатки:</strong></p><ul><li>Неявность — непонятно какие props передаются</li><li>Можно случайно передать лишние props</li><li>Хуже для производительности при частом использовании</li></ul><p><strong>Best practice:</strong></p><p>Использовать умеренно, деструктурировать нужные props явно, остальное в spread.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'spread', 'props', 'паттерны']
  },
  {
    id: 42,
    question: "Как в JSX работают булевы атрибуты?",
    answer: "<p>Булевы атрибуты в JSX ведут себя иначе, чем в HTML.</p><p><strong>В HTML:</strong></p><p>Наличие атрибута = true, отсутствие = false. Значение не важно.</p><p><strong>В JSX:</strong></p><p>Нужно явно передавать true или false. Можно использовать краткую запись: disabled эквивалентно disabled={true}.</p><p><strong>Особенности:</strong></p><ul><li>false делает атрибут отсутствующим в DOM</li><li>true добавляет атрибут в DOM</li><li>undefined/null также убирают атрибут</li></ul><p><strong>Распространенные булевы атрибуты:</strong></p><p>disabled, checked, required, readOnly, autoFocus, multiple.</p><p><strong>Важно:</strong></p><p>Строки \"false\" или \"true\" — это не boolean, а строки, что может вызвать баги.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'атрибуты', 'boolean', 'HTML']
  },
  {
    id: 43,
    question: "В чем разница между {} и {{}} в JSX?",
    answer: "<p>Это частый источник путаницы для новичков.</p><p><strong>Одинарные фигурные скобки {}:</strong></p><ul><li>Обозначают JavaScript выражение внутри JSX</li><li>Используются для вставки переменных, вызова функций, условий</li></ul><p><strong>Двойные фигурные скобки {{}}:</strong></p><ul><li>Это не специальный синтаксис JSX</li><li>Внешние {} — синтаксис JSX</li><li>Внутренние {} — литерал JavaScript объекта</li><li>Используются для передачи объектов как props</li></ul><p><strong>Типичное применение {{}}:</strong></p><p>Inline стили в JSX — style={{color: 'red'}}. Первые {} говорят \"это JS\", вторые {} создают объект стилей.</p><p><strong>Важно понимать:</strong></p><p>Это просто объект внутри JavaScript выражения, никакой магии.</p>",
    difficulty: 'junior',
    tags: ['JSX', 'синтаксис', 'фигурные скобки', 'объекты']
  },
  {
    id: 44,
    question: "Почему нельзя использовать for и while циклы прямо в JSX?",
    answer: "<p>for и while — это statements (инструкции), а в JSX можно использовать только expressions (выражения).</p><p><strong>В чем разница:</strong></p><ul><li><strong>Expression</strong> — возвращает значение (тернарный оператор, вызов функции)</li><li><strong>Statement</strong> — выполняет действие, не возвращает значение (for, while, if)</li></ul><p><strong>Альтернативы в JSX:</strong></p><ul><li><strong>map()</strong> — самый частый способ для списков</li><li><strong>filter()</strong> — для условной фильтрации элементов</li><li><strong>reduce()</strong> — для сложных трансформаций</li><li><strong>IIFE</strong> — можно обернуть цикл в функцию и сразу вызвать</li></ul><p><strong>Best practice:</strong></p><p>Использовать функциональные методы массивов (map, filter) — это декларативнее и читаемее.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'циклы', 'выражения', 'ограничения']
  },
  {
    id: 45,
    question: "Как JSX обрабатывает пробелы и переносы строк?",
    answer: "<p>JSX обрабатывает whitespace (пробелы, табы, переносы) не так, как HTML.</p><p><strong>Правила JSX:</strong></p><ul><li>Пробелы в начале и конце строки удаляются</li><li>Пустые строки удаляются</li><li>Переносы строк рядом с тегами сворачиваются</li><li>Множественные пробелы между словами сохраняются</li></ul><p><strong>Отличие от HTML:</strong></p><p>HTML сворачивает любые последовательности whitespace в один пробел. JSX более предсказуем.</p><p><strong>Как контролировать:</strong></p><ul><li>Явные пробелы через {' '}</li><li>&nbsp; для неразрывного пробела</li><li>CSS white-space для управления отображением</li></ul><p><strong>На практике:</strong></p><p>Обычно достаточно знать, что пробелы между тегами схлопываются, и использовать {' '} когда нужен гарантированный пробел.</p>",
    difficulty: 'middle',
    tags: ['JSX', 'whitespace', 'форматирование', 'особенности']
  },
  {
    id: 46,
    question: "Что такое SyntheticEvent в React и зачем он нужен?",
    answer: "<p><strong>SyntheticEvent</strong> — это кросс-браузерная обертка React над нативными событиями браузера.</p><p><strong>Зачем нужен:</strong></p><ul><li><strong>Единый API</strong> — одинаковое поведение во всех браузерах</li><li><strong>Производительность</strong> — переиспользование объектов событий (event pooling до React 17)</li><li><strong>Удобство</strong> — нормализация различий между браузерами</li><li><strong>Совместимость с Virtual DOM</strong> — интеграция в систему React</li></ul><p><strong>Ключевые особенности:</strong></p><p>SyntheticEvent имеет тот же интерфейс, что и нативное событие: stopPropagation(), preventDefault(), target, currentTarget. Но это отдельный объект, который React создает и управляет его жизненным циклом.</p>",
    difficulty: 'middle',
    tags: ['события', 'SyntheticEvent', 'основы']
  },
  {
    id: 47,
    question: "В чем разница между SyntheticEvent и нативным браузерным событием?",
    answer: "<p><strong>SyntheticEvent (React):</strong></p><ul><li>Кросс-браузерная обертка</li><li>Единый интерфейс для всех браузеров</li><li>Переиспользуется React (pooling до версии 17)</li><li>Имеет дополнительное поле nativeEvent</li><li>Null-ится после обработки (в старых версиях)</li></ul><p><strong>Native Event (браузер):</strong></p><ul><li>Нативный объект браузера</li><li>Может отличаться между браузерами</li><li>Не переиспользуется</li><li>Доступен через event.nativeEvent в React</li><li>Живет до сборки мусора</li></ul><p><strong>Важно:</strong></p><p>В большинстве случаев можно работать с SyntheticEvent как с обычным событием. Доступ к нативному событию нужен редко.</p>",
    difficulty: 'middle',
    tags: ['события', 'SyntheticEvent', 'отличия', 'Native Events']
  },
  {
    id: 48,
    question: "Как в React обрабатываются события? Опишите механизм event delegation.",
    answer: "<p>React использует паттерн <strong>event delegation</strong> для оптимизации обработки событий.</p><p><strong>Как работает:</strong></p><ul><li>React не регистрирует обработчики на каждом элементе</li><li>Все события регистрируются на корневом узле приложения</li><li>При всплытии события React определяет целевой компонент</li><li>Создает SyntheticEvent и вызывает нужный обработчик</li></ul><p><strong>Преимущества:</strong></p><ul><li><strong>Память</strong> — один обработчик вместо тысяч</li><li><strong>Производительность</strong> — меньше регистраций/удалений</li><li><strong>Динамичность</strong> — работает для динамически добавленных элементов</li></ul><p><strong>Изменение в React 17:</strong></p><p>События теперь регистрируются на корне React приложения, а не на document — это улучшает работу с несколькими React приложениями на странице.</p>",
    difficulty: 'senior',
    tags: ['события', 'event delegation', 'производительность', 'архитектура']
  },
  {
    id: 49,
    question: "Почему нельзя использовать асинхронный доступ к SyntheticEvent?",
    answer: "<p>До React 17 SyntheticEvent объекты переиспользовались (event pooling).</p><p><strong>Проблема:</strong></p><ul><li>После выполнения обработчика все свойства события обнулялись</li><li>Асинхронный доступ (setTimeout, Promise) получал null значения</li><li>React очищал объект для переиспользования</li></ul><p><strong>Решение в старых версиях:</strong></p><p>Использовать event.persist() — убирало событие из пула и сохраняло значения. Или копировать нужные значения в переменные.</p><p><strong>React 17+:</strong></p><p>Event pooling убрали! Теперь можно безопасно использовать события асинхронно без persist(). Это упростило работу, но немного снизило производительность.</p><p><strong>Best practice:</strong></p><p>Все равно лучше извлекать нужные значения сразу для читаемости кода.</p>",
    difficulty: 'senior',
    tags: ['события', 'SyntheticEvent', 'pooling', 'React 17']
  },
  {
    id: 50,
    question: "В чем разница между onClick и onclick в React?",
    answer: "<p><strong>onClick (React/JSX):</strong></p><ul><li>CamelCase нотация</li><li>Принимает функцию как значение</li><li>SyntheticEvent обертка</li><li>Работает через event delegation</li><li>Рекомендуемый способ в React</li></ul><p><strong>onclick (нативный HTML):</strong></p><ul><li>Lowercase</li><li>Принимает строку с JavaScript кодом</li><li>Нативное событие браузера</li><li>Прямая регистрация на элементе</li><li>Антипаттерн в React</li></ul><p><strong>Почему camelCase:</strong></p><p>JSX следует JavaScript конвенциям именования, не HTML. Все DOM свойства и атрибуты в React используют camelCase: onClick, onChange, onSubmit.</p><p><strong>Важно:</strong></p><p>В React всегда используем onClick={handler}, никогда onclick=\"handler()\".</p>",
    difficulty: 'junior',
    tags: ['события', 'именование', 'onClick', 'основы']
  },
  {
    id: 51,
    question: "Как правильно передавать аргументы в обработчики событий?",
    answer: "<p>Есть несколько способов передать аргументы в event handler:</p><p><strong>1. Стрелочная функция inline:</strong></p><p>Создаем новую функцию при каждом рендере. Просто, но может влиять на производительность при частых ререндерах.</p><p><strong>2. Метод bind:</strong></p><p>Привязываем аргументы через bind(). Тоже создает новую функцию при каждом рендере.</p><p><strong>3. Data-атрибуты:</strong></p><p>Храним данные в data-* атрибутах, читаем через event.currentTarget.dataset.</p><p><strong>4. Каррирование:</strong></p><p>Функция возвращает функцию. Внешняя создается один раз, внутренняя — при событии.</p><p><strong>Best practice:</strong></p><p>Для списков и оптимизации — каррирование или useCallback. Для простых случаев — стрелочная функция inline.</p>",
    difficulty: 'middle',
    tags: ['события', 'аргументы', 'обработчики', 'паттерны']
  },
  {
    id: 52,
    question: "Что такое event.preventDefault() и event.stopPropagation()? Когда их использовать?",
    answer: "<p><strong>event.preventDefault():</strong></p><ul><li>Отменяет действие браузера по умолчанию</li><li>Не влияет на всплытие события</li><li>Используется для: отмены отправки формы, предотвращения перехода по ссылке, отмены контекстного меню</li></ul><p><strong>event.stopPropagation():</strong></p><ul><li>Останавливает всплытие события вверх по дереву</li><li>Не отменяет действие по умолчанию</li><li>Родительские обработчики не будут вызваны</li><li>Используется когда событие должно обработаться только на текущем элементе</li></ul><p><strong>Важное отличие:</strong></p><p>preventDefault() отменяет браузерное поведение, stopPropagation() — распространение события в React/DOM дереве.</p><p><strong>Можно использовать вместе:</strong></p><p>Если нужно и отменить действие, и остановить всплытие.</p>",
    difficulty: 'middle',
    tags: ['события', 'preventDefault', 'stopPropagation', 'методы']
  },
  {
    id: 53,
    question: "В чем разница между event.target и event.currentTarget?",
    answer: "<p><strong>event.target:</strong></p><ul><li>Элемент, который инициировал событие</li><li>Элемент, на котором произошел клик/действие</li><li>Может быть дочерним элементом</li><li>Не меняется при всплытии</li></ul><p><strong>event.currentTarget:</strong></p><ul><li>Элемент, на котором зарегистрирован обработчик</li><li>Элемент, к которому привязан onClick</li><li>Всегда совпадает с this в классовых компонентах</li><li>Меняется при всплытии</li></ul><p><strong>Практический пример:</strong></p><p>Если кликнуть на span внутри div с обработчиком: target будет span (где кликнули), currentTarget — div (где обработчик).</p><p><strong>Когда важно:</strong></p><p>При работе с делегированием событий или когда нужно получить данные из элемента с обработчиком, а не из вложенного.</p>",
    difficulty: 'middle',
    tags: ['события', 'target', 'currentTarget', 'отличия']
  },
  {
    id: 54,
    question: "Как в React обрабатывать события в фазе capture?",
    answer: "<p>По умолчанию React обрабатывает события в фазе <strong>bubbling</strong> (всплытие), но можно использовать фазу <strong>capture</strong> (погружение).</p><p><strong>Синтаксис:</strong></p><p>Добавить суффикс Capture к имени события: onClickCapture, onChangeCapture, onFocusCapture.</p><p><strong>Фазы события:</strong></p><ul><li><strong>Capture</strong> — событие идет от корня к цели (сверху вниз)</li><li><strong>Target</strong> — событие достигло целевого элемента</li><li><strong>Bubble</strong> — событие всплывает обратно к корню (снизу вверх)</li></ul><p><strong>Порядок выполнения:</strong></p><p>Сначала все onClickCapture от корня к цели, потом onClick от цели к корню.</p><p><strong>Когда использовать:</strong></p><p>Для перехвата событий до дочерних элементов, блокировки действий, глобальных обработчиков.</p>",
    difficulty: 'senior',
    tags: ['события', 'capture', 'bubbling', 'фазы']
  },
  {
    id: 55,
    question: "Почему важно не использовать стрелочные функции и bind в render?",
    answer: "<p>Создание новых функций в render может вызывать проблемы с производительностью.</p><p><strong>Проблемы:</strong></p><ul><li>Новая функция создается при каждом рендере</li><li>Нарушается сравнение пропсов в React.memo</li><li>Дочерние компоненты ре-рендерятся без необходимости</li><li>Невозможна оптимизация через shouldComponentUpdate</li></ul><p><strong>Решения:</strong></p><ul><li><strong>useCallback</strong> — мемоизация функций в функциональных компонентах</li><li><strong>Метод класса</strong> — определение обработчика как метода класса</li><li><strong>Bind в constructor</strong> — однократная привязка контекста</li><li><strong>Class field syntax</strong> — стрелочные функции как поля класса</li></ul><p><strong>Когда можно игнорировать:</strong></p><p>Для простых компонентов без оптимизации или когда дочерние компоненты легковесные.</p>",
    difficulty: 'senior',
    tags: ['события', 'производительность', 'оптимизация', 'best practices']
  },
  {
    id: 56,
    question: "Как работает onChange в React и чем отличается от нативного?",
    answer: "<p>React нормализовал поведение onChange для лучшего developer experience.</p><p><strong>В React onChange:</strong></p><ul><li>Срабатывает при каждом изменении значения</li><li>Работает как onInput в нативном DOM</li><li>Срабатывает на каждый ввод символа</li><li>Единообразно для всех input элементов</li></ul><p><strong>Нативный onchange:</strong></p><ul><li>Срабатывает при потере фокуса (для текстовых input)</li><li>Для radio/checkbox — сразу при изменении</li><li>Непредсказуемое поведение между элементами</li></ul><p><strong>Почему React изменил поведение:</strong></p><p>Для создания controlled компонентов нужна мгновенная реакция на изменения. Нативный onchange срабатывал слишком поздно.</p><p><strong>Нативный аналог:</strong></p><p>Если нужно нативное поведение, можно использовать onBlur.</p>",
    difficulty: 'middle',
    tags: ['события', 'onChange', 'формы', 'отличия']
  },
  {
    id: 57,
    question: "Что такое пассивные события (passive events) и как они влияют на производительность?",
    answer: "<p><strong>Passive events</strong> — это события с опцией {passive: true}, которые обещают не вызывать preventDefault().</p><p><strong>Зачем нужны:</strong></p><ul><li>Браузер не ждет выполнения обработчика для scroll/touch</li><li>Улучшается плавность прокрутки и касаний</li><li>Особенно важно на мобильных устройствах</li></ul><p><strong>В React:</strong></p><p>React автоматически делает некоторые события пассивными (wheel, touchstart, touchmove). Нельзя вызвать preventDefault() для пассивных событий.</p><p><strong>Как использовать непассивное:</strong></p><p>Нужно регистрировать напрямую через addEventListener с {passive: false} в useEffect, если требуется preventDefault().</p><p><strong>Важно:</strong></p><p>Это оптимизация браузера, React просто следует спецификации.</p>",
    difficulty: 'senior',
    tags: ['события', 'производительность', 'passive events', 'оптимизация']
  },
  {
    id: 58,
    question: "Как обрабатывать события клавиатуры в React?",
    answer: "<p>React предоставляет несколько событий для работы с клавиатурой:</p><p><strong>Основные события:</strong></p><ul><li><strong>onKeyDown</strong> — клавиша нажата</li><li><strong>onKeyPress</strong> — клавиша нажата (deprecated, не использовать)</li><li><strong>onKeyUp</strong> — клавиша отпущена</li></ul><p><strong>Свойства события:</strong></p><ul><li><strong>key</strong> — название клавиши ('Enter', 'a', 'ArrowUp')</li><li><strong>code</strong> — физический код клавиши ('KeyA', 'Enter')</li><li><strong>keyCode</strong> — числовой код (deprecated)</li><li><strong>altKey, ctrlKey, shiftKey, metaKey</strong> — модификаторы</li></ul><p><strong>Best practices:</strong></p><p>Использовать event.key вместо keyCode. Для горячих клавиш проверять комбинации модификаторов. onKeyDown для большинства случаев, onKeyUp для специфичных сценариев.</p>",
    difficulty: 'middle',
    tags: ['события', 'клавиатура', 'onKeyDown', 'обработка']
  },
  {
    id: 59,
    question: "Как правильно работать с событиями в useEffect?",
    answer: "<p>При работе с нативными событиями в useEffect нужно соблюдать правила:</p><p><strong>Паттерн подписки:</strong></p><ul><li>Регистрировать обработчик в useEffect</li><li>Обязательно удалять в cleanup функции</li><li>Использовать один и тот же reference функции</li></ul><p><strong>Частые ошибки:</strong></p><ul><li>Забыть cleanup — утечка памяти и множественные обработчики</li><li>Создать новую функцию в cleanup — удаление не сработает</li><li>Не указать зависимости — stale closure на старые значения</li></ul><p><strong>Когда использовать:</strong></p><p>Для событий window, document, нативных элементов через ref, сторонних библиотек. Для обычных React событий использовать onClick и др.</p><p><strong>Best practice:</strong></p><p>Выносить обработчик в отдельную функцию, мемоизировать через useCallback с правильными зависимостями.</p>",
    difficulty: 'senior',
    tags: ['события', 'useEffect', 'cleanup', 'хуки']
  },
  {
    id: 60,
    question: "В чем особенности событий форм в React (onSubmit, onChange, onInput)?",
    answer: "<p><strong>onSubmit:</strong></p><ul><li>Срабатывает при отправке формы (Enter или кнопка submit)</li><li>Всегда вызывать event.preventDefault() чтобы избежать перезагрузки страницы</li><li>Регистрируется на <form>, не на кнопке</li></ul><p><strong>onChange:</strong></p><ul><li>В React работает как нативный onInput — при каждом изменении</li><li>Основа для controlled компонентов</li><li>Работает для input, textarea, select</li></ul><p><strong>onInput:</strong></p><ul><li>Нативное событие, работает аналогично React onChange</li><li>В React лучше использовать onChange для единообразия</li></ul><p><strong>Best practices:</strong></p><p>Использовать onSubmit на форме, onChange для полей, всегда preventDefault для onSubmit, валидировать данные до отправки.</p>",
    difficulty: 'middle',
    tags: ['события', 'формы', 'onSubmit', 'onChange']
  },
  {
    id: 61,
    question: "Что такое ref в React и для чего он используется?",
    answer: "<p><strong>Ref (reference)</strong> — это способ получить прямой доступ к DOM элементу или экземпляру компонента.</p><p><strong>Основное назначение:</strong></p><ul><li>Доступ к DOM узлам для императивных операций</li><li>Хранение мутабельных значений между рендерами</li><li>Интеграция со сторонними библиотеками</li><li>Управление фокусом, выделением текста, анимациями</li></ul><p><strong>Ключевая особенность:</strong></p><p>Изменение ref.current НЕ вызывает ререндер — это делает ref идеальным для хранения данных, которые не влияют на UI.</p><p><strong>Когда использовать:</strong></p><p>Когда нужно «вырваться» из декларативного подхода React и выполнить императивные действия с DOM или сохранить значение без триггера рендера.</p>",
    difficulty: 'junior',
    tags: ['ref', 'основы', 'DOM']
  },
  {
    id: 62,
    question: "В чем разница между useRef и createRef?",
    answer: "<p><strong>useRef (хук):</strong></p><ul><li>Для функциональных компонентов</li><li>Создается один раз при монтировании</li><li>Сохраняет значение между рендерами</li><li>Возвращает один и тот же объект всегда</li></ul><p><strong>createRef (классический API):</strong></p><ul><li>Для классовых компонентов</li><li>Создает новый ref объект при каждом вызове</li><li>В функциональных компонентах создавал бы новый ref каждый рендер</li><li>Сохраняется в поле класса (this.myRef)</li></ul><p><strong>Важное отличие:</strong></p><p>useRef персистентен между рендерами, createRef — нет. В функциональных компонентах всегда используем useRef.</p><p><strong>Современная практика:</strong></p><p>useRef — стандарт для функциональных компонентов, createRef остался для legacy классовых компонентов.</p>",
    difficulty: 'middle',
    tags: ['useRef', 'createRef', 'отличия', 'хуки']
  },
  {
    id: 63,
    question: "Какой основной сценарий использования useRef кроме доступа к DOM?",
    answer: "<p><strong>Хранение мутабельных значений</strong> — главный неочевидный use case для useRef.</p><p><strong>Типичные сценарии:</strong></p><ul><li><strong>Хранение предыдущих значений</strong> — сохранить предыдущий state для сравнения</li><li><strong>Таймеры и интервалы</strong> — хранить ID для clearTimeout/clearInterval</li><li><strong>Счетчики без ререндера</strong> — отслеживание количества рендеров</li><li><strong>Флаги состояния</strong> — isMounted, isFirstRender</li><li><strong>Кеширование вычислений</strong> — сохранить результат без useMemo</li></ul><p><strong>Почему ref, а не state:</strong></p><p>ref не вызывает ререндер при изменении — идеально для вспомогательных данных, которые не должны влиять на UI.</p><p><strong>Принцип:</strong></p><p>Если данные не отображаются в UI — используй ref, если отображаются — state.</p>",
    difficulty: 'middle',
    tags: ['useRef', 'мутабельность', 'сценарии использования']
  },
  {
    id: 64,
    question: "Что такое forwardRef и зачем он нужен?",
    answer: "<p><strong>forwardRef</strong> — это функция высшего порядка, позволяющая компоненту передать ref дальше к дочернему элементу.</p><p><strong>Проблема без forwardRef:</strong></p><p>Обычные функциональные компоненты не могут принимать ref как prop — React его игнорирует. ref это специальный prop, как key.</p><p><strong>Как работает:</strong></p><p>forwardRef оборачивает компонент и предоставляет ref вторым параметром после props. Внутри можно прокинуть ref дальше к нужному элементу.</p><p><strong>Когда использовать:</strong></p><ul><li>Библиотеки UI компонентов — Input, Button с доступом к DOM</li><li>HOC компоненты — сохранение возможности получить ref</li><li>Wrapper компоненты — прокидывание ref через обертку</li></ul>",
    difficulty: 'middle',
    tags: ['forwardRef', 'ref', 'компоненты']
  },
  {
    id: 65,
    question: "Какие преимущества дает forwardRef при работе с компонентами?",
    answer: "<p><strong>Основные преимущества forwardRef:</strong></p><ul><li><strong>Прозрачность API</strong> — компонент работает как нативный элемент</li><li><strong>Композиция</strong> — можно оборачивать компоненты без потери функциональности</li><li><strong>Доступ к DOM</strong> — родитель может управлять фокусом, прокруткой</li><li><strong>Интеграция</strong> — компоненты легко использовать со сторонними библиотеками</li><li><strong>Совместимость</strong> — работа с императивными API без костылей</li></ul><p><strong>Практическая ценность:</strong></p><p>Позволяет создавать переиспользуемые компоненты, которые не скрывают возможности нативных элементов.</p><p><strong>Пример:</strong></p><p>Input компонент с forwardRef позволяет родителю вызвать focus() без дополнительных пропсов или callback'ов.</p>",
    difficulty: 'middle',
    tags: ['forwardRef', 'преимущества', 'архитектура']
  },
  {
    id: 66,
    question: "Как работать с несколькими ref в одном компоненте?",
    answer: "<p>Есть несколько подходов для работы с множественными ref:</p><p><strong>1. Несколько useRef:</strong></p><p>Создать отдельный ref для каждого элемента — самый простой способ.</p><p><strong>2. Ref как объект/массив:</strong></p><p>Хранить все ref'ы в одном объекте или массиве — удобно для динамических списков.</p><p><strong>3. Callback ref:</strong></p><p>Использовать функцию вместо объекта ref — даст больше контроля при присвоении.</p><p><strong>4. useImperativeHandle:</strong></p><p>Собрать методы из разных элементов в один API для родителя.</p><p><strong>Best practice для списков:</strong></p><p>Создать Map или объект для хранения ref'ов по ключу элемента, использовать callback ref для добавления в коллекцию.</p>",
    difficulty: 'senior',
    tags: ['ref', 'множественные ref', 'паттерны']
  },
  {
    id: 67,
    question: "Что такое useImperativeHandle и когда его использовать?",
    answer: "<p><strong>useImperativeHandle</strong> — хук для кастомизации значения ref, передаваемого родителю через forwardRef.</p><p><strong>Зачем нужен:</strong></p><ul><li>Ограничить API — не давать полный доступ к DOM</li><li>Создать кастомные методы для родителя</li><li>Скрыть внутреннюю реализацию</li><li>Объединить несколько элементов в один интерфейс</li></ul><p><strong>Как работает:</strong></p><p>Вместо прокидывания ref напрямую к DOM, создаем объект с нужными методами. Родитель получает не DOM элемент, а наш кастомный API.</p><p><strong>Когда использовать:</strong></p><p>В библиотеках компонентов, когда нужен контроль над публичным API, для инкапсуляции логики.</p><p><strong>Важно:</strong></p><p>Это escape hatch — использовать умеренно, предпочитать декларативный подход через props.</p>",
    difficulty: 'senior',
    tags: ['useImperativeHandle', 'forwardRef', 'API', 'хуки']
  },
  {
    id: 68,
    question: "В чем разница между callback ref и object ref?",
    answer: "<p><strong>Object ref (useRef):</strong></p><ul><li>Объект с полем current</li><li>Присваивается автоматически React'ом</li><li>Статичный — один и тот же объект</li><li>Не уведомляет об изменениях</li></ul><p><strong>Callback ref:</strong></p><ul><li>Функция, вызываемая с DOM элементом</li><li>Вызывается при монтировании (с элементом) и размонтировании (с null)</li><li>Можно выполнить side effects</li><li>Уведомляет об изменениях ref</li></ul><p><strong>Когда использовать callback:</strong></p><ul><li>Нужно выполнить действие при получении ref</li><li>Динамические списки с ref</li><li>Интеграция со сторонними библиотеками</li><li>Измерение размеров элемента</li></ul><p><strong>Особенность:</strong></p><p>Callback ref вызывается дважды при каждом изменении — сначала с null (unmount), потом с элементом (mount).</p>",
    difficulty: 'senior',
    tags: ['ref', 'callback ref', 'отличия', 'продвинутое']
  },
  {
    id: 69,
    question: "Почему изменение ref.current не вызывает ререндер?",
    answer: "<p>ref.current — это обычное JavaScript свойство объекта, не связанное с системой реактивности React.</p><p><strong>Техническое объяснение:</strong></p><ul><li>ref это просто объект {current: значение}</li><li>React не отслеживает изменения в ref.current</li><li>Нет геттеров/сеттеров для перехвата мутаций</li><li>ref живет вне системы state/props</li></ul><p><strong>Почему так спроектировано:</strong></p><p>ref нужен именно для хранения мутабельных значений БЕЗ ререндера — это его основная фича, не баг.</p><p><strong>Когда это полезно:</strong></p><p>Хранение DOM элементов, таймеров, счетчиков, флагов — данных, которые нужны для логики, но не для отображения.</p><p><strong>Если нужен ререндер:</strong></p><p>Используй state вместо ref — это фундаментальное различие между ними.</p>",
    difficulty: 'middle',
    tags: ['ref', 'ререндер', 'реактивность', 'принципы']
  },
  {
    id: 70,
    question: "Как правильно очищать ref в useEffect cleanup?",
    answer: "<p>При работе с ref в useEffect важно правильно управлять ресурсами.</p><p><strong>Паттерн очистки:</strong></p><p>Сохранить ref.current в переменную в начале effect, использовать эту переменную в cleanup. Это защищает от ситуации, когда ref.current изменился к моменту cleanup.</p><p><strong>Почему важно:</strong></p><ul><li>ref.current может быть null в cleanup</li><li>Элемент мог размонтироваться</li><li>ref мог быть переназначен</li></ul><p><strong>Частые ошибки:</strong></p><ul><li>Использовать ref.current напрямую в cleanup — может быть null</li><li>Не проверять на существование перед удалением обработчиков</li><li>Забыть сохранить локальную копию для cleanup</li></ul><p><strong>Best practice:</strong></p><p>Всегда захватывать ref.current в переменную в теле effect, использовать в cleanup, проверять на null.</p>",
    difficulty: 'senior',
    tags: ['ref', 'useEffect', 'cleanup', 'best practices']
  },
  {
    id: 71,
    question: "Можно ли передать ref как обычный prop?",
    answer: "<p><strong>Напрямую нельзя</strong> — ref это зарезервированный prop, как key.</p><p><strong>Что происходит:</strong></p><p>Если передать ref={myRef} в компонент, React не передаст его в props — он обработается специальным образом.</p><p><strong>Решения:</strong></p><ul><li><strong>forwardRef</strong> — стандартный способ для передачи ref</li><li><strong>Другое имя</strong> — innerRef, inputRef, customRef как обычный prop</li><li><strong>Callback prop</strong> — передать функцию, которая получит элемент</li></ul><p><strong>Почему ref особенный:</strong></p><p>React обрабатывает ref и key на особом уровне — они не попадают в props компонента, чтобы избежать конфликтов и упростить внутреннюю работу.</p><p><strong>Best practice:</strong></p><p>Для библиотечных компонентов — forwardRef. Для внутренних — можно innerRef как prop.</p>",
    difficulty: 'middle',
    tags: ['ref', 'props', 'ограничения', 'forwardRef']
  },
  {
    id: 72,
    question: "Что такое управляемый и неуправляемый ref в React?",
    answer: "<p>Это концепция аналогичная controlled/uncontrolled компонентам, но для ref.</p><p><strong>Управляемый ref (controlled):</strong></p><ul><li>Родитель создает ref и передает в дочерний компонент</li><li>Родитель контролирует и использует ref</li><li>Компонент получает ref через forwardRef</li><li>Источник истины — родитель</li></ul><p><strong>Неуправляемый ref (uncontrolled):</strong></p><ul><li>Компонент создает свой внутренний ref</li><li>Родитель не имеет доступа</li><li>Источник истины — сам компонент</li><li>Используется для внутренней логики</li></ul><p><strong>Когда что использовать:</strong></p><p>Controlled ref — когда родителю нужен доступ к DOM. Uncontrolled — для внутренней реализации компонента.</p><p><strong>Можно комбинировать:</strong></p><p>Компонент может иметь внутренний ref и принимать внешний через forwardRef.</p>",
    difficulty: 'senior',
    tags: ['ref', 'controlled', 'uncontrolled', 'паттерны']
  },
  {
    id: 73,
    question: "Как объединить внешний forwardedRef с внутренним ref?",
    answer: "<p>Часто компоненту нужен собственный ref для логики И нужно пробросить ref родителю.</p><p><strong>Проблема:</strong></p><p>У элемента может быть только один ref. Как использовать и внутренний, и внешний одновременно?</p><p><strong>Решение 1 — Callback ref:</strong></p><p>Создать функцию, которая присваивает элемент обоим ref'ам — и внутреннему, и forwardedRef.</p><p><strong>Решение 2 — useImperativeHandle:</strong></p><p>Использовать внутренний ref для логики, через useImperativeHandle дать родителю кастомный API.</p><p><strong>Решение 3 — Библиотека:</strong></p><p>Использовать хелпер типа useForkRef из библиотек (MUI использует этот паттерн).</p><p><strong>Best practice:</strong></p><p>Для простых случаев — callback ref. Для сложных — useImperativeHandle с ограниченным API.</p>",
    difficulty: 'senior',
    tags: ['ref', 'forwardRef', 'объединение', 'продвинутое']
  },
  {
    id: 74,
    question: "Когда следует избегать использования ref?",
    answer: "<p>ref — это escape hatch, который нужно использовать осторожно.</p><p><strong>Не использовать ref для:</strong></p><ul><li><strong>Данных для рендера</strong> — используй state</li><li><strong>Коммуникации компонентов</strong> — используй props/context</li><li><strong>Замены state</strong> — теряется реактивность</li><li><strong>Обхода однонаправленного потока</strong> — нарушается архитектура</li></ul><p><strong>Антипаттерны:</strong></p><ul><li>Вызывать методы дочерних компонентов через ref</li><li>Хранить в ref данные, которые влияют на UI</li><li>Использовать ref для избежания ререндеров (есть лучшие способы)</li></ul><p><strong>Когда ref оправдан:</strong></p><p>DOM манипуляции (фокус, скролл), интеграция со сторонними библиотеками, измерения, анимации, хранение мутабельных значений.</p><p><strong>Принцип:</strong></p><p>Сначала попробуй решить декларативно через props/state. ref — последнее средство.</p>",
    difficulty: 'middle',
    tags: ['ref', 'антипаттерны', 'best practices', 'архитектура']
  },
  {
    id: 75,
    question: "Как ref работает с React StrictMode и почему компонент с ref может рендериться дважды?",
    answer: "<p><strong>StrictMode в разработке</strong> намеренно делает двойной рендер для выявления проблем.</p><p><strong>Влияние на ref:</strong></p><ul><li>Callback ref вызывается 4 раза вместо 2 (mount-unmount-mount-unmount)</li><li>useEffect cleanup/setup запускается дважды</li><li>ref.current может временно быть null даже после монтирования</li></ul><p><strong>Почему это происходит:</strong></p><p>StrictMode симулирует размонтирование/монтирование для проверки корректности cleanup логики.</p><p><strong>Как это учитывать:</strong></p><ul><li>Код должен быть идемпотентным</li><li>Cleanup должен корректно отменять side effects</li><li>Не полагаться на количество вызовов</li></ul><p><strong>В продакшене:</strong></p><p>Двойного рендера нет — это только dev режим для помощи в отладке.</p>",
    difficulty: 'senior',
    tags: ['ref', 'StrictMode', 'debugging', 'особенности']
  }
]
