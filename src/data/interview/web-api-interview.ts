export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webAPIInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое Blob и для чего он используется?",
    answer: "<p><strong>Blob</strong> (Binary Large Object) — это объект, представляющий неизменяемые необработанные данные произвольного размера в двоичном формате.</p><p>Blob используется для работы с файлоподобными данными в браузере, когда нужно хранить, обрабатывать или передавать бинарные данные.</p><h4>Основные применения:</h4><ul><li><strong>Работа с файлами:</strong> Загрузка, скачивание, обработка файлов</li><li><strong>Медиа-контент:</strong> Создание URL для изображений, видео, аудио</li><li><strong>Генерация файлов:</strong> Создание текстовых файлов, CSV, JSON для скачивания</li><li><strong>Работа с Canvas:</strong> Экспорт изображений из canvas</li><li><strong>Передача данных:</strong> Отправка бинарных данных через Fetch API или XMLHttpRequest</li></ul><p>Blob имеет два основных свойства: <code>size</code> (размер в байтах) и <code>type</code> (MIME-тип данных). Данные внутри Blob неизменяемы, но можно создавать новые Blob на основе существующих.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'основы', 'бинарные данные']
  },
  {
    id: 2,
    question: "В чем разница между Blob и File?",
    answer: "<p><strong>File</strong> — это специализированный тип Blob, который содержит дополнительную информацию о файле.</p><h4>Ключевые различия:</h4><p><strong>File наследуется от Blob</strong> и добавляет дополнительные свойства:</p><ul><li><code>name</code> — имя файла</li><li><code>lastModified</code> — временная метка последнего изменения</li><li><code>lastModifiedDate</code> (устаревшее) — дата последнего изменения</li></ul><p><strong>Blob</strong> — это более общий объект для произвольных бинарных данных, который не связан с файловой системой.</p><h4>Создание:</h4><p>Blob создается программно через конструктор, а File обычно получается из <code>input[type='file']</code>, drag-and-drop или создается через конструктор File с указанием имени.</p><h4>Использование:</h4><p>File используется когда важна информация о файле (имя, дата), Blob — для работы с чистыми данными без метаинформации.</p><p><em>На практике:</em> File можно использовать везде, где ожидается Blob, так как File является его расширением.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'File', 'различия', 'наследование']
  },
  {
    id: 3,
    question: "Как создать Blob из различных типов данных?",
    answer: "<p>Blob можно создать из разных типов данных используя конструктор <code>new Blob()</code>:</p><h4>Из строки:</h4><p>Самый простой случай — передать массив со строкой. Второй параметр определяет MIME-тип.</p><p>Например: <code>new Blob(['Привет, мир!'], { type: 'text/plain' })</code></p><h4>Из ArrayBuffer:</h4><p>Для работы с бинарными данными можно использовать типизированные массивы:</p><p><code>const buffer = new Uint8Array([72, 101, 108, 108, 111]);</code><br><code>const blob = new Blob([buffer], { type: 'application/octet-stream' });</code></p><h4>Из другого Blob:</h4><p>Можно комбинировать несколько Blob в один новый Blob:</p><p><code>new Blob([blob1, blob2, 'текст'], { type: 'text/plain' })</code></p><h4>Из JSON:</h4><p>Полезно для создания файлов JSON:</p><p><code>const data = { name: 'John', age: 30 };</code><br><code>const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });</code></p><p><em>Важно:</em> Первый параметр конструктора всегда должен быть массивом, даже если передается один элемент.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'создание', 'конструктор', 'типы данных']
  },
  {
    id: 4,
    question: "Что такое Blob URL и как его создать?",
    answer: "<p><strong>Blob URL</strong> — это специальный URL-адрес, указывающий на Blob-объект в памяти браузера. Он позволяет работать с Blob как с обычным файлом по URL.</p><h4>Создание Blob URL:</h4><p>Используется метод <code>URL.createObjectURL(blob)</code>, который создает уникальную строку вида <code>blob:https://example.com/550e8400-e29b-41d4-a716-446655440000</code></p><h4>Применение:</h4><ul><li><strong>Отображение изображений:</strong> Установка blob URL как src для img элемента</li><li><strong>Скачивание файлов:</strong> Создание ссылки для загрузки сгенерированного контента</li><li><strong>Воспроизведение медиа:</strong> Использование в video или audio элементах</li><li><strong>Открытие в новой вкладке:</strong> window.open с blob URL</li></ul><h4>Освобождение памяти:</h4><p>Blob URL занимает память, пока существует. Важно освобождать его через <code>URL.revokeObjectURL(blobUrl)</code> когда он больше не нужен.</p><p><em>Best practice:</em> Всегда вызывайте revokeObjectURL после использования, особенно в long-running приложениях, чтобы избежать утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['Blob URL', 'память', 'createObjectURL', 'revokeObjectURL']
  },
  {
    id: 5,
    question: "Как прочитать содержимое Blob или File?",
    answer: "<p>Для чтения содержимого Blob/File используется <strong>FileReader API</strong>:</p><h4>Основные методы FileReader:</h4><p><strong>readAsText():</strong> Читает содержимое как текст. Можно указать кодировку вторым параметром.</p><p><strong>readAsDataURL():</strong> Преобразует в Data URL (base64). Удобно для отображения изображений.</p><p><strong>readAsArrayBuffer():</strong> Читает как ArrayBuffer для работы с бинарными данными.</p><p><strong>readAsBinaryString():</strong> Читает как бинарную строку (устаревший метод).</p><h4>События FileReader:</h4><ul><li><code>onload</code> — успешное чтение</li><li><code>onerror</code> — ошибка чтения</li><li><code>onprogress</code> — процесс чтения (для больших файлов)</li><li><code>onloadend</code> — завершение чтения (успешное или с ошибкой)</li></ul><h4>Современный подход:</h4><p>Можно использовать методы самого Blob: <code>text()</code>, <code>arrayBuffer()</code>, которые возвращают Promise:</p><p><code>const text = await blob.text();</code><br><code>const buffer = await blob.arrayBuffer();</code></p><p><em>Преимущество:</em> Promise-based API проще для работы с async/await.</p>",
    difficulty: 'middle',
    tags: ['FileReader', 'чтение', 'асинхронность', 'методы']
  },
  {
    id: 6,
    question: "Как реализовать скачивание файла, созданного в браузере?",
    answer: "<p>Скачивание файла из браузера реализуется через создание временной ссылки с Blob URL:</p><h4>Базовая реализация:</h4><p>1. Создаем Blob с нужным содержимым<br>2. Создаем Blob URL через <code>URL.createObjectURL()</code><br>3. Создаем ссылку (a элемент)<br>4. Устанавливаем href на Blob URL<br>5. Устанавливаем атрибут download с именем файла<br>6. Программно кликаем по ссылке<br>7. Удаляем ссылку и освобождаем URL</p><h4>Пример функции:</h4><p><code>function downloadFile(content, filename, type) {</code><br><code>&nbsp;&nbsp;const blob = new Blob([content], { type });</code><br><code>&nbsp;&nbsp;const url = URL.createObjectURL(blob);</code><br><code>&nbsp;&nbsp;const a = document.createElement('a');</code><br><code>&nbsp;&nbsp;a.href = url;</code><br><code>&nbsp;&nbsp;a.download = filename;</code><br><code>&nbsp;&nbsp;a.click();</code><br><code>&nbsp;&nbsp;URL.revokeObjectURL(url);</code><br><code>}</code></p><h4>Применение:</h4><p>Скачивание сгенерированных CSV, JSON, текстовых файлов, экспорт данных из canvas, сохранение пользовательского контента.</p><p><em>Важно:</em> Атрибут download работает только для same-origin URL и blob URL.</p>",
    difficulty: 'middle',
    tags: ['скачивание', 'download', 'практика', 'пользовательский опыт']
  },
  {
    id: 7,
    question: "Как работать с частями Blob через метод slice()?",
    answer: "<p>Метод <code>slice()</code> позволяет <strong>извлекать части Blob</strong> без копирования данных в память:</p><h4>Синтаксис:</h4><p><code>blob.slice(start, end, contentType)</code></p><ul><li><code>start</code> — начальная позиция (байт), по умолчанию 0</li><li><code>end</code> — конечная позиция (не включительно), по умолчанию blob.size</li><li><code>contentType</code> — MIME-тип нового Blob, по умолчанию пустая строка</li></ul><h4>Особенности:</h4><p>Slice не копирует данные в памяти — создается <strong>ссылка на часть оригинального Blob</strong>. Это делает операцию очень быстрой даже для больших файлов.</p><h4>Применение:</h4><p><strong>Chunked upload:</strong> Разделение большого файла на части для загрузки по частям.</p><p><strong>Чтение больших файлов:</strong> Обработка файла по частям, чтобы не загружать весь в память.</p><p><strong>Извлечение заголовков:</strong> Чтение первых байтов файла для определения типа.</p><p><strong>Манипуляция данными:</strong> Удаление или замена частей файла.</p><p><em>Производительность:</em> Slice работает за O(1), так как не копирует данные, только создает новый Blob-дескриптор.</p>",
    difficulty: 'middle',
    tags: ['slice', 'chunking', 'производительность', 'память']
  },
  {
    id: 8,
    question: "Как реализовать загрузку большого файла по частям (chunked upload)?",
    answer: "<p><strong>Chunked upload</strong> — это техника загрузки больших файлов по частям, что улучшает надежность и позволяет показывать прогресс:</p><h4>Алгоритм реализации:</h4><p><strong>1. Разбиение файла:</strong> Используем метод <code>slice()</code> для деления файла на части (chunks) фиксированного размера, например 1MB.</p><p><strong>2. Последовательная загрузка:</strong> Отправляем каждую часть отдельным запросом с информацией о позиции.</p><p><strong>3. Отслеживание прогресса:</strong> После каждой успешной загрузки обновляем прогресс-бар.</p><p><strong>4. Обработка ошибок:</strong> При неудаче повторяем загрузку конкретного chunk, а не всего файла.</p><p><strong>5. Финализация:</strong> После загрузки всех частей сервер собирает их в единый файл.</p><h4>Преимущества:</h4><ul><li>Возможность паузы и возобновления загрузки</li><li>Точный прогресс загрузки</li><li>Автоматическое восстановление после сетевых ошибок</li><li>Меньше нагрузка на память — загружаем по частям</li></ul><h4>На сервере:</h4><p>Сервер должен поддерживать прием частей, сохранять их с метаданными и собирать в финальный файл после получения всех chunk.</p>",
    difficulty: 'senior',
    tags: ['chunked upload', 'большие файлы', 'производительность', 'надежность']
  },
  {
    id: 9,
    question: "Как конвертировать изображение из canvas в Blob?",
    answer: "<p>Конвертация canvas в Blob используется для сохранения или загрузки изображений, созданных или отредактированных в браузере:</p><h4>Метод toBlob():</h4><p>Canvas предоставляет асинхронный метод <code>toBlob(callback, type, quality)</code>:</p><ul><li><code>callback</code> — функция, получающая созданный Blob</li><li><code>type</code> — MIME-тип (по умолчанию 'image/png')</li><li><code>quality</code> — качество для JPEG/WebP от 0 до 1</li></ul><h4>Промисификация:</h4><p>Для удобства можно обернуть в Promise:</p><p><code>function canvasToBlob(canvas, type, quality) {</code><br><code>&nbsp;&nbsp;return new Promise(resolve => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.toBlob(resolve, type, quality);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Применение:</h4><ul><li>Экспорт отредактированных изображений</li><li>Создание превью перед загрузкой</li><li>Применение фильтров и эффектов</li><li>Водяные знаки и аннотации</li><li>Оптимизация размера изображения</li></ul><h4>Форматы:</h4><p>Поддерживаются 'image/png', 'image/jpeg', 'image/webp'. PNG поддерживает прозрачность, JPEG — регулируемое качество для меньшего размера.</p>",
    difficulty: 'middle',
    tags: ['canvas', 'изображения', 'конвертация', 'toBlob']
  },
  {
    id: 10,
    question: "В чем разница между Data URL и Blob URL?",
    answer: "<p>Data URL и Blob URL — два способа представления бинарных данных в виде URL, но с разными характеристиками:</p><h4>Data URL:</h4><p><strong>Формат:</strong> <code>data:[MIME-type];base64,[закодированные данные]</code></p><p><strong>Характеристики:</strong></p><ul><li>Данные встроены прямо в URL</li><li>Очень длинная строка для больших файлов</li><li>Увеличивает размер на ~33% из-за base64</li><li>Можно копировать, сохранять, передавать</li><li>Работает везде, где принимается URL</li><li>Не требует освобождения памяти</li></ul><h4>Blob URL:</h4><p><strong>Формат:</strong> <code>blob:https://example.com/uuid</code></p><p><strong>Характеристики:</strong></p><ul><li>Короткая строка-ссылка на данные в памяти</li><li>Не увеличивает размер — ссылка фиксированной длины</li><li>Работает только в текущей сессии браузера</li><li>Требует явного освобождения памяти</li><li>Быстрее для больших файлов</li><li>Нельзя передать между страницами/вкладками</li></ul><h4>Когда использовать:</h4><p><strong>Data URL:</strong> Маленькие изображения, иконки, inline-вставки, когда нужна переносимость.</p><p><strong>Blob URL:</strong> Большие файлы, временный контент, когда важна производительность.</p>",
    difficulty: 'middle',
    tags: ['Data URL', 'Blob URL', 'различия', 'производительность']
  },
  {
    id: 11,
    question: "Как обработать drag-and-drop файлов?",
    answer: "<p>Drag-and-drop файлов реализуется через <strong>HTML5 Drag and Drop API</strong> в сочетании с File API:</p><h4>Основные события:</h4><p><strong>dragover:</strong> Срабатывает когда элемент перетаскивается над зоной. Нужно вызвать <code>preventDefault()</code> для разрешения drop.</p><p><strong>drop:</strong> Срабатывает когда элемент отпускают в зоне. Здесь получаем файлы.</p><p><strong>dragleave:</strong> Срабатывает когда элемент покидает зону (для визуального feedback).</p><h4>Получение файлов:</h4><p>Файлы доступны через <code>event.dataTransfer.files</code> — это FileList, похожий на массив File объектов.</p><h4>Реализация:</h4><p><code>dropZone.addEventListener('dragover', (e) => {</code><br><code>&nbsp;&nbsp;e.preventDefault();</code><br><code>&nbsp;&nbsp;dropZone.classList.add('drag-over');</code><br><code>});</code></p><p><code>dropZone.addEventListener('drop', async (e) => {</code><br><code>&nbsp;&nbsp;e.preventDefault();</code><br><code>&nbsp;&nbsp;const files = Array.from(e.dataTransfer.files);</code><br><code>&nbsp;&nbsp;// обработка файлов</code><br><code>});</code></p><h4>Улучшения UX:</h4><ul><li>Визуальный feedback при наведении</li><li>Валидация типов файлов</li><li>Превью изображений</li><li>Прогресс загрузки</li></ul>",
    difficulty: 'middle',
    tags: ['drag-and-drop', 'File API', 'UX', 'события']
  },
  {
    id: 12,
    question: "Как проверить MIME-тип файла на клиенте?",
    answer: "<p>Проверка MIME-типа файла важна для валидации загружаемых файлов:</p><h4>Свойство file.type:</h4><p>File объект имеет свойство <code>type</code>, содержащее MIME-тип, например 'image/jpeg', 'application/pdf'.</p><p><strong>Ограничение:</strong> Это значение определяется по расширению файла и может быть легко подделано. Нельзя полагаться только на него для безопасности.</p><h4>Проверка сигнатуры (magic numbers):</h4><p>Для надежной проверки читаем первые байты файла и сравниваем с известными сигнатурами:</p><ul><li>JPEG: FF D8 FF</li><li>PNG: 89 50 4E 47</li><li>PDF: 25 50 44 46</li><li>ZIP: 50 4B 03 04</li></ul><p>Читаем начало файла через <code>slice()</code> и <code>arrayBuffer()</code>, затем сравниваем байты.</p><h4>Комплексный подход:</h4><p><strong>1. Базовая проверка:</strong> file.type для быстрой фильтрации</p><p><strong>2. Сигнатура:</strong> Проверка magic numbers для важных файлов</p><p><strong>3. Серверная валидация:</strong> Окончательная проверка на сервере</p><p><em>Безопасность:</em> Клиентская проверка — только для UX. Всегда валидируйте на сервере.</p>",
    difficulty: 'senior',
    tags: ['MIME-тип', 'валидация', 'безопасность', 'magic numbers']
  },
  {
    id: 13,
    question: "Как работать с Blob в Service Worker?",
    answer: "<p>Service Worker может работать с Blob для <strong>кэширования, оффлайн-доступа и обработки файлов</strong>:</p><h4>Кэширование Blob:</h4><p>В Service Worker можно перехватывать запросы и создавать Response с Blob:</p><p><code>const blob = new Blob(['cached content'], { type: 'text/html' });</code><br><code>return new Response(blob, { status: 200 });</code></p><h4>Обработка файлов:</h4><p>Service Worker может получать файлы через <code>fetch()</code>, обрабатывать их и возвращать модифицированный Blob.</p><h4>Offline-first стратегия:</h4><p>При отсутствии сети Service Worker может отдавать закэшированные Blob-ресурсы из Cache API.</p><h4>Особенности:</h4><ul><li>Blob можно сохранять в Cache API</li><li>Можно создавать синтетические Response с Blob</li><li>Полезно для обработки изображений, оптимизации</li><li>Можно проксировать и трансформировать контент</li></ul><h4>Применение:</h4><p>Оффлайн-режим для медиа-контента, динамическая генерация ресурсов, оптимизация изображений на лету, прокси для внешних ресурсов.</p><p><em>Важно:</em> Blob в Service Worker работает асинхронно, используйте Promise API.</p>",
    difficulty: 'senior',
    tags: ['Service Worker', 'кэширование', 'offline', 'производительность']
  },
  {
    id: 14,
    question: "Какие есть ограничения и best practices при работе с Blob?",
    answer: "<p>При работе с Blob важно понимать ограничения и следовать лучшим практикам:</p><h4>Ограничения памяти:</h4><p><strong>Размер:</strong> Blob хранится в памяти браузера. Для очень больших файлов (гигабайты) может не хватить памяти.</p><p><strong>Blob URL:</strong> Каждый созданный Blob URL занимает память до вызова <code>revokeObjectURL()</code>.</p><h4>Best Practices:</h4><p><strong>Освобождение ресурсов:</strong> Всегда вызывайте <code>URL.revokeObjectURL()</code> после использования Blob URL.</p><p><strong>Обработка по частям:</strong> Для больших файлов используйте <code>slice()</code> и обрабатывайте chunk за chunk.</p><p><strong>Проверка размера:</strong> Проверяйте <code>blob.size</code> перед обработкой и устанавливайте лимиты.</p><p><strong>Типизация:</strong> Всегда указывайте правильный MIME-тип при создании Blob.</p><p><strong>Обработка ошибок:</strong> FileReader может выбросить ошибку при чтении, всегда обрабатывайте <code>onerror</code>.</p><h4>Производительность:</h4><ul><li>Используйте Workers для обработки больших файлов</li><li>Избегайте создания множества Blob URL одновременно</li><li>Кэшируйте обработанные Blob где возможно</li></ul>",
    difficulty: 'senior',
    tags: ['ограничения', 'best practices', 'производительность', 'память']
  },
  {
    id: 15,
    question: "Как использовать Blob с Web Workers?",
    answer: "<p>Web Workers позволяют обрабатывать Blob в <strong>отдельном потоке</strong>, не блокируя основной поток:</p><h4>Передача Blob в Worker:</h4><p>Blob можно передать в Worker через <code>postMessage()</code>. Браузер автоматически клонирует Blob, используя structured clone algorithm.</p><p><code>worker.postMessage({ blob: myBlob });</code></p><h4>Transferable Objects:</h4><p>Для больших данных можно использовать <strong>transferable objects</strong> с ArrayBuffer, чтобы передать владение без копирования:</p><p><code>const buffer = await blob.arrayBuffer();</code><br><code>worker.postMessage({ buffer }, [buffer]);</code></p><h4>Применение:</h4><p><strong>Обработка изображений:</strong> Ресайз, фильтры, компрессия в фоне.</p><p><strong>Парсинг файлов:</strong> CSV, JSON, XML больших размеров.</p><p><strong>Шифрование/дешифрование:</strong> Криптографические операции.</p><p><strong>Генерация контента:</strong> Создание PDF, ZIP файлов.</p><h4>Паттерн использования:</h4><p>1. Передаем Blob/ArrayBuffer в Worker<br>2. Worker обрабатывает данные<br>3. Worker возвращает результат (Blob или данные)<br>4. Основной поток использует результат</p><p><em>Преимущество:</em> Интерфейс остается отзывчивым во время тяжелых операций с файлами.</p>",
    difficulty: 'senior',
    tags: ['Web Workers', 'многопоточность', 'производительность', 'асинхронность']
  },
  {
    id: 16,
    question: "В чем главное различие между Fetch API и XMLHttpRequest?",
    answer: "<p>Основные различия между Fetch API и XMLHttpRequest:</p><h4>Fetch API:</h4><ul><li><strong>Promise-based:</strong> Возвращает Promise, отлично работает с async/await</li><li><strong>Современный синтаксис:</strong> Более чистый и читаемый код</li><li><strong>Streaming:</strong> Поддержка ReadableStream для прогресса скачивания</li><li><strong>Только асинхронный:</strong> Нет синхронных запросов</li></ul><h4>XMLHttpRequest:</h4><ul><li><strong>Callback-based:</strong> Использует события (onload, onerror)</li><li><strong>Upload progress:</strong> Единственный способ отследить прогресс ОТПРАВКИ через xhr.upload.onprogress</li><li><strong>Синхронные запросы:</strong> Поддерживает (хотя deprecated)</li><li><strong>Встроенный timeout:</strong> Свойство xhr.timeout</li></ul><p><em>Ключевое отличие:</em> XMLHttpRequest — единственный способ получить прогресс загрузки файла на сервер, что критично для upload с progress bar.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'XMLHttpRequest', 'различия', 'HTTP']
  },
  {
    id: 17,
    question: "Как отследить прогресс загрузки файла на сервер?",
    answer: "<p>Прогресс загрузки файла на сервер можно отследить <strong>только через XMLHttpRequest</strong> с использованием события <code>xhr.upload.onprogress</code>:</p><h4>Реализация:</h4><p><code>const xhr = new XMLHttpRequest();</code><br><code>const formData = new FormData();</code><br><code>formData.append('file', file);</code></p><p><code>xhr.upload.onprogress = (event) => {</code><br><code>&nbsp;&nbsp;if (event.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const percent = (event.loaded / event.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Загружено: ' + percent + '%');</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><p><code>xhr.open('POST', '/upload');</code><br><code>xhr.send(formData);</code></p><h4>Важные события xhr.upload:</h4><ul><li><code>onloadstart</code> — начало отправки</li><li><code>onprogress</code> — процесс отправки (ключевое!)</li><li><code>onload</code> — файл отправлен на сервер</li><li><code>onerror</code> — ошибка при отправке</li><li><code>onabort</code> — отправка отменена</li></ul><p><strong>Критично:</strong> Fetch API НЕ предоставляет возможности отслеживать прогресс отправки! Fetch может отслеживать только прогресс скачивания через ReadableStream.</p>",
    difficulty: 'middle',
    tags: ['XMLHttpRequest', 'upload progress', 'файлы', 'события']
  },
  {
    id: 18,
    question: "Почему Fetch API не подходит для событий beforeunload/unload?",
    answer: "<p>Fetch API может не успеть выполниться при закрытии страницы, так как браузер может прервать асинхронные операции:</p><h4>Проблема с Fetch:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;fetch('/analytics', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({ event: 'page_close' })</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;// ⚠️ Запрос может быть прерван!</code><br><code>});</code></p><h4>Правильные решения:</h4><p><strong>1. navigator.sendBeacon (ЛУЧШИЙ):</strong></p><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;navigator.sendBeacon('/analytics', JSON.stringify(data));</code><br><code>});</code></p><p><strong>2. Fetch с keepalive:</strong></p><p><code>fetch('/analytics', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: JSON.stringify(data),</code><br><code>&nbsp;&nbsp;keepalive: true  // Гарантирует завершение</code><br><code>});</code></p><p><strong>3. XMLHttpRequest синхронный (fallback):</strong></p><p><code>const xhr = new XMLHttpRequest();</code><br><code>xhr.open('POST', '/analytics', false);  // синхронный</code><br><code>xhr.send(JSON.stringify(data));</code></p><p><em>Вывод:</em> Для beforeunload используйте sendBeacon или keepalive, обычный Fetch ненадежен.</p>",
    difficulty: 'senior',
    tags: ['Fetch', 'beforeunload', 'sendBeacon', 'XMLHttpRequest']
  },
  {
    id: 19,
    question: "Что такое navigator.sendBeacon и когда его использовать?",
    answer: "<p><strong>navigator.sendBeacon</strong> — метод для надежной отправки небольших данных на сервер, который гарантирует доставку даже при закрытии страницы:</p><h4>Синтаксис:</h4><p><code>navigator.sendBeacon(url, data)</code></p><p>Возвращает <code>true</code> если данные успешно поставлены в очередь, иначе <code>false</code>.</p><h4>Особенности:</h4><ul><li><strong>Асинхронный:</strong> Не блокирует закрытие страницы</li><li><strong>Гарантированная отправка:</strong> Браузер отправит данные даже после закрытия</li><li><strong>Ограничение размера:</strong> Обычно до 64KB</li><li><strong>POST запрос:</strong> Всегда отправляется как POST</li><li><strong>Нет ответа:</strong> Невозможно получить response</li></ul><h4>Типичное использование:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;const data = JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;event: 'page_close',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;url: window.location.href</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;navigator.sendBeacon('/analytics', data);</code><br><code>});</code></p><h4>Когда использовать:</h4><ul><li>Отправка аналитики при закрытии страницы</li><li>Сбор метрик времени на странице</li><li>Логирование пользовательских действий</li><li>Отправка статистики сессии</li></ul>",
    difficulty: 'middle',
    tags: ['sendBeacon', 'аналитика', 'beforeunload', 'Web API']
  },
  {
    id: 20,
    question: "Как отменить Fetch запрос?",
    answer: "<p>Для отмены Fetch запроса используется <strong>AbortController</strong>:</p><h4>Базовая отмена:</h4><p><code>const controller = new AbortController();</code></p><p><code>fetch('/api/data', {</code><br><code>&nbsp;&nbsp;signal: controller.signal</code><br><code>})</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить запрос</code><br><code>controller.abort();</code></p><h4>Timeout через AbortController:</h4><p><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Request timeout');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отмена предыдущих запросов:</h4><p><code>let controller;</code><br><code>searchInput.addEventListener('input', async (e) => {</code><br><code>&nbsp;&nbsp;if (controller) controller.abort();</code><br><code>&nbsp;&nbsp;controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const results = await fetch('/search?q=' + e.target.value, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p>",
    difficulty: 'middle',
    tags: ['Fetch', 'AbortController', 'отмена запроса', 'timeout']
  },
  {
    id: 21,
    question: "Почему Fetch не выбрасывает ошибку для HTTP 404 или 500?",
    answer: "<p>Fetch считает любой полученный HTTP-ответ успешным выполнением Promise, даже если это код ошибки (4xx, 5xx):</p><h4>Поведение Fetch:</h4><p><code>fetch('/api/users/999')</code><br><code>&nbsp;&nbsp;.then(response => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(response.status);  // 404</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(response.ok);      // false</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Promise НЕ rejected!</code><br><code>&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сюда попадем только при СЕТЕВОЙ ошибке</code><br><code>&nbsp;&nbsp;});</code></p><h4>Правильная обработка:</h4><p><code>async function fetchUser(id) {</code><br><code>&nbsp;&nbsp;const response = await fetch(\`/api/users/\${id}\`);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP error! status: \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.json();</code><br><code>}</code></p><h4>Универсальная обертка:</h4><p><code>async function safeFetch(url, options) {</code><br><code>&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const error = new Error('HTTP Error');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.status = response.status;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.response = response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response;</code><br><code>}</code></p><p><strong>Причина:</strong> Promise отклоняется только при сетевых ошибках (нет интернета, DNS ошибка), но НЕ при HTTP ошибках. Всегда проверяйте <code>response.ok</code> или <code>response.status</code>.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'обработка ошибок', 'HTTP статусы', 'Promise']
  },
  {
    id: 22,
    question: "В чем разница между прогрессом загрузки (download) и прогрессом отправки (upload)?",
    answer: "<p>Это два разных процесса передачи данных, требующие разных подходов для отслеживания:</p><h4>Download Progress (скачивание с сервера):</h4><p><strong>Fetch API — ReadableStream:</strong></p><p><code>const response = await fetch('/large-file');</code><br><code>const reader = response.body.getReader();</code><br><code>const contentLength = +response.headers.get('Content-Length');</code><br><code>let receivedLength = 0;</code><br><code></code><br><code>while (true) {</code><br><code>&nbsp;&nbsp;const { done, value } = await reader.read();</code><br><code>&nbsp;&nbsp;if (done) break;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;receivedLength += value.length;</code><br><code>&nbsp;&nbsp;const percent = (receivedLength / contentLength) * 100;</code><br><code>}</code></p><p><strong>XMLHttpRequest — onprogress:</strong></p><p><code>xhr.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>};</code></p><h4>Upload Progress (отправка на сервер):</h4><p><strong>Только XMLHttpRequest — upload.onprogress:</strong></p><p><code>xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;console.log('Отправлено на сервер: ' + percent + '%');</code><br><code>};</code></p><p><strong>❌ Fetch НЕ поддерживает:</strong> Нет способа отследить прогресс отправки данных на сервер через Fetch API!</p><h4>Ключевое различие:</h4><ul><li><strong>Download:</strong> Fetch ✅ (через ReadableStream), XHR ✅ (через onprogress)</li><li><strong>Upload:</strong> Fetch ❌ (нет API), XHR ✅ (через upload.onprogress)</li></ul>",
    difficulty: 'senior',
    tags: ['progress', 'upload', 'download', 'ReadableStream']
  },
  {
    id: 23,
    question: "Как реализовать retry механизм для Fetch?",
    answer: "<p>Retry механизм позволяет автоматически повторять неудачные запросы с exponential backoff:</p><h4>Базовая реализация:</h4><p><code>async function fetchWithRetry(url, options = {}, maxRetries = 3) {</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === maxRetries) throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exponential backoff: 1s, 2s, 4s...</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.pow(2, attempt) * 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${maxRetries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await new Promise(resolve => setTimeout(resolve, delay));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>С селективным retry:</h4><p><code>async function smartRetry(url, options = {}, config = {}) {</code><br><code>&nbsp;&nbsp;const {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;maxRetries = 3,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;retryOn = [500, 502, 503, 504],  // Только серверные ошибки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;retryDelay = 1000</code><br><code>&nbsp;&nbsp;} = config;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response.ok) return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Не retry для 4xx ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!retryOn.includes(response.status)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt < maxRetries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await new Promise(r => setTimeout(r, retryDelay * (attempt + 1)));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === maxRetries) throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'senior',
    tags: ['Fetch', 'retry', 'надежность', 'error handling']
  },
  {
    id: 24,
    question: "Как обрабатывать различные типы ответов в Fetch?",
    answer: "<p>Fetch предоставляет разные методы для обработки различных типов контента:</p><h4>Основные методы Response:</h4><p><code>response.json()</code> — парсит JSON<br><code>response.text()</code> — возвращает текст<br><code>response.blob()</code> — возвращает Blob (файлы, изображения)<br><code>response.arrayBuffer()</code> — возвращает ArrayBuffer (бинарные данные)<br><code>response.formData()</code> — парсит FormData</p><h4>Автоматическое определение типа:</h4><p><code>async function handleResponse(response) {</code><br><code>&nbsp;&nbsp;const contentType = response.headers.get('content-type');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('application/json')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('text/')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.text();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('image/')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.blob();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.arrayBuffer();</code><br><code>}</code></p><h4>Работа с изображениями:</h4><p><code>const response = await fetch('/image.jpg');</code><br><code>const blob = await response.blob();</code><br><code>const imageUrl = URL.createObjectURL(blob);</code><br><code>img.src = imageUrl;</code></p><h4>Работа с файлами:</h4><p><code>const response = await fetch('/document.pdf');</code><br><code>const blob = await response.blob();</code><br><code>const url = URL.createObjectURL(blob);</code><br><code>const a = document.createElement('a');</code><br><code>a.href = url;</code><br><code>a.download = 'document.pdf';</code><br><code>a.click();</code></p><p><strong>Важно:</strong> Методы response.json(), text(), blob() можно вызвать только ОДИН раз!</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'Response', 'типы данных', 'content-type']
  },
  {
    id: 25,
    question: "Как работает chunked upload большого файла?",
    answer: "<p><strong>Chunked upload</strong> — техника загрузки больших файлов по частям для повышения надежности и отображения прогресса:</p><h4>Алгоритм:</h4><p><strong>1. Разбиение файла:</strong> Используем <code>file.slice()</code> для деления на chunks</p><p><code>const chunkSize = 1024 * 1024;  // 1MB</code><br><code>const totalChunks = Math.ceil(file.size / chunkSize);</code></p><p><strong>2. Отправка chunk:</strong></p><p><code>for (let i = 0; i < totalChunks; i++) {</code><br><code>&nbsp;&nbsp;const start = i * chunkSize;</code><br><code>&nbsp;&nbsp;const end = Math.min(start + chunkSize, file.size);</code><br><code>&nbsp;&nbsp;const chunk = file.slice(start, end);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const formData = new FormData();</code><br><code>&nbsp;&nbsp;formData.append('chunk', chunk);</code><br><code>&nbsp;&nbsp;formData.append('chunkIndex', i);</code><br><code>&nbsp;&nbsp;formData.append('totalChunks', totalChunks);</code><br><code>&nbsp;&nbsp;formData.append('filename', file.name);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;await uploadChunk(formData, i);</code><br><code>}</code></p><p><strong>3. Отслеживание прогресса:</strong> Используем XMLHttpRequest для каждого chunk:</p><p><code>function uploadChunk(formData, index) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const chunkProgress = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const totalProgress = ((index + chunkProgress/100) / totalChunks) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateProgressBar(totalProgress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => reject();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('POST', '/upload-chunk');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(formData);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Преимущества:</h4><ul><li>Возможность паузы и возобновления</li><li>Автоматический retry при ошибке chunk</li><li>Точный прогресс загрузки</li><li>Меньше нагрузка на память</li></ul>",
    difficulty: 'senior',
    tags: ['chunked upload', 'большие файлы', 'XMLHttpRequest', 'производительность']
  },
  {
    id: 26,
    question: "Какие заголовки важны при работе с Fetch и как их устанавливать?",
    answer: "<p>Заголовки (headers) критичны для правильной работы HTTP-запросов:</p><h4>Установка заголовков:</h4><p><code>fetch('/api/users', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;headers: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Content-Type': 'application/json',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Authorization': 'Bearer token123',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Accept': 'application/json'</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;body: JSON.stringify({ name: 'John' })</code><br><code>});</code></p><h4>Важные заголовки запроса:</h4><ul><li><code>Content-Type</code> — тип отправляемых данных (application/json, multipart/form-data)</li><li><code>Authorization</code> — токен аутентификации (Bearer, Basic)</li><li><code>Accept</code> — ожидаемый тип ответа</li><li><code>Accept-Language</code> — предпочитаемый язык</li></ul><h4>Работа с Headers API:</h4><p><code>const headers = new Headers();</code><br><code>headers.append('Content-Type', 'application/json');</code><br><code>headers.append('Authorization', 'Bearer token');</code><br><code></code><br><code>fetch('/api/data', { headers });</code></p><h4>Чтение заголовков ответа:</h4><p><code>const response = await fetch('/api/data');</code><br><code></code><br><code>const contentType = response.headers.get('content-type');</code><br><code>const date = response.headers.get('date');</code><br><code></code><br><code>// Итерация по всем заголовкам</code><br><code>for (let [key, value] of response.headers) {</code><br><code>&nbsp;&nbsp;console.log(\`\${key}: \${value}\`);</code><br><code>}</code></p><h4>Важно для FormData:</h4><p><code>const formData = new FormData();</code><br><code>formData.append('file', file);</code><br><code></code><br><code>fetch('/upload', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: formData</code><br><code>&nbsp;&nbsp;// НЕ устанавливайте Content-Type!</code><br><code>&nbsp;&nbsp;// Браузер установит правильный multipart/form-data с boundary</code><br><code>});</code></p>",
    difficulty: 'middle',
    tags: ['Fetch', 'headers', 'HTTP', 'Content-Type']
  },
  {
    id: 27,
    question: "Как реализовать универсальную функцию для HTTP-запросов, которая использует Fetch или XHR в зависимости от задачи?",
    answer: "<p>Универсальная функция должна автоматически выбирать между Fetch и XMLHttpRequest в зависимости от требований:</p><h4>Реализация:</h4><p><code>async function universalRequest(url, options = {}) {</code><br><code>&nbsp;&nbsp;const {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method = 'GET',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers = {},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;uploadProgress,    // Если нужен — используем XHR</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;downloadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = 0</code><br><code>&nbsp;&nbsp;} = options;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Если нужен upload progress — ТОЛЬКО XHR</code><br><code>&nbsp;&nbsp;if (uploadProgress) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return xhrRequest(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uploadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;downloadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Иначе используем Fetch</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (timeout) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.json();</code><br><code>}</code></p><h4>XHR часть:</h4><p><code>function xhrRequest(url, options) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (options.uploadProgress) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options.uploadProgress((e.loaded / e.total) * 100);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (xhr.status >= 200 && xhr.status < 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(JSON.parse(xhr.responseText));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error(\`HTTP \${xhr.status}\`));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open(options.method, url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(options.body);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p>",
    difficulty: 'senior',
    tags: ['Fetch', 'XMLHttpRequest', 'универсальность', 'API wrapper']
  },
  {
    id: 28,
    question: "Что такое keepalive в Fetch и когда его использовать?",
    answer: "<p>Опция <code>keepalive: true</code> в Fetch гарантирует, что запрос будет завершен даже если страница закрывается:</p><h4>Синтаксис:</h4><p><code>fetch('/analytics', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: JSON.stringify(data),</code><br><code>&nbsp;&nbsp;keepalive: true  // Ключевая опция!</code><br><code>});</code></p><h4>Назначение:</h4><ul><li>Запрос продолжит выполняться после закрытия страницы</li><li>Браузер гарантирует завершение запроса</li><li>Не блокирует UI как синхронный XHR</li></ul><h4>Использование в beforeunload:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;fetch('/analytics', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event: 'page_close',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;keepalive: true</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Ограничения:</h4><ul><li>Размер тела запроса ограничен (обычно ~64KB)</li><li>Невозможно получить response (запрос асинхронный)</li><li>Подходит только для POST запросов с небольшими данными</li></ul><h4>Сравнение с альтернативами:</h4><table><tr><th>Метод</th><th>Гарантия</th><th>Размер</th><th>Блокировка UI</th></tr><tr><td>sendBeacon</td><td>✅</td><td>~64KB</td><td>❌</td></tr><tr><td>Fetch keepalive</td><td>✅</td><td>~64KB</td><td>❌</td></tr><tr><td>XHR sync</td><td>✅</td><td>Без ограничений</td><td>✅ (плохо!)</td></tr><tr><td>Обычный Fetch</td><td>❌</td><td>Без ограничений</td><td>❌</td></tr></table><p><em>Вывод:</em> Для аналитики при закрытии страницы используйте sendBeacon или Fetch с keepalive.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'keepalive', 'beforeunload', 'аналитика']
  },
  {
    id: 29,
    question: "Как обрабатывать CORS ошибки в Fetch?",
    answer: "<p>CORS (Cross-Origin Resource Sharing) ошибки возникают при запросах к другому домену:</p><h4>Типичная CORS ошибка:</h4><p><code>fetch('https://api.example.com/data')</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// TypeError: Failed to fetch</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// (может быть CORS или сетевая ошибка)</code><br><code>&nbsp;&nbsp;});</code></p><h4>Режимы CORS:</h4><p><code>fetch(url, {</code><br><code>&nbsp;&nbsp;mode: 'cors',        // По умолчанию, требует CORS заголовков</code><br><code>&nbsp;&nbsp;mode: 'no-cors',     // Непрозрачный ответ, нельзя прочитать</code><br><code>&nbsp;&nbsp;mode: 'same-origin'  // Только same-origin запросы</code><br><code>});</code></p><h4>Отправка credentials:</h4><p><code>fetch('https://api.example.com/data', {</code><br><code>&nbsp;&nbsp;credentials: 'include'  // Отправляет cookies cross-origin</code><br><code>});</code></p><p>Опции: <code>'omit'</code> (не отправлять), <code>'same-origin'</code> (только same-origin), <code>'include'</code> (всегда)</p><h4>Обработка CORS ошибок:</h4><p><code>async function fetchWithCORSHandling(url) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode: 'cors',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;credentials: 'include'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error instanceof TypeError) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Вероятно CORS или сетевая ошибка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('CORS or network error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Не удалось подключиться к серверу');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Важно помнить:</h4><ul><li>CORS настраивается на СЕРВЕРЕ, не на клиенте</li><li>Fetch не может обойти CORS</li><li>mode: 'no-cors' не решает проблему (нельзя прочитать ответ)</li><li>Для development используйте прокси или CORS плагин</li></ul>",
    difficulty: 'middle',
    tags: ['Fetch', 'CORS', 'безопасность', 'cross-origin']
  },
  {
    id: 30,
    question: "Как отследить прогресс скачивания файла через Fetch?",
    answer: "<p>Для отслеживания прогресса скачивания Fetch использует <strong>ReadableStream API</strong>:</p><h4>Базовая реализация:</h4><p><code>async function downloadWithProgress(url, onProgress) {</code><br><code>&nbsp;&nbsp;const response = await fetch(url);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Получаем общий размер</code><br><code>&nbsp;&nbsp;const contentLength = +response.headers.get('Content-Length');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Создаем reader для чтения потока</code><br><code>&nbsp;&nbsp;const reader = response.body.getReader();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;let receivedLength = 0;</code><br><code>&nbsp;&nbsp;const chunks = [];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;while (true) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const { done, value } = await reader.read();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (done) break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;chunks.push(value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;receivedLength += value.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызываем callback прогресса</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const percent = (receivedLength / contentLength) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;onProgress(percent, receivedLength, contentLength);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Собираем все chunk в один Blob</code><br><code>&nbsp;&nbsp;return new Blob(chunks);</code><br><code>}</code></p><h4>Использование:</h4><p><code>const blob = await downloadWithProgress(</code><br><code>&nbsp;&nbsp;'/large-file.zip',</code><br><code>&nbsp;&nbsp;(percent, loaded, total) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Скачано: \${percent.toFixed(2)}%\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${loaded} из \${total} байт\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обновление UI</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;progressBar.style.width = percent + '%';</code><br><code>&nbsp;&nbsp;}</code><br><code>);</code><br><code></code><br><code>// Сохранение файла</code><br><code>const url = URL.createObjectURL(blob);</code><br><code>const a = document.createElement('a');</code><br><code>a.href = url;</code><br><code>a.download = 'file.zip';</code><br><code>a.click();</code></p><h4>Важное отличие:</h4><ul><li><strong>Fetch ReadableStream:</strong> Прогресс СКАЧИВАНИЯ (download) ✅</li><li><strong>XHR upload.onprogress:</strong> Прогресс ОТПРАВКИ (upload) ✅</li></ul>",
    difficulty: 'senior',
    tags: ['Fetch', 'ReadableStream', 'download progress', 'скачивание']
  },
  {
    id: 31,
    question: "Какие методы поддержания постоянного соединения с сервером существуют в JavaScript?",
    answer: "<p>В JavaScript существует несколько методов поддержания постоянного соединения с сервером:</p><h4>1. WebSocket</h4><p>Двусторонняя связь через протокол ws:// или wss://. Позволяет клиенту и серверу отправлять данные в любое время.</p><h4>2. Server-Sent Events (EventSource)</h4><p>Односторонняя связь от сервера к клиенту через HTTP. Автоматическое переподключение встроено.</p><h4>3. Long Polling</h4><p>Клиент отправляет запрос, сервер держит соединение открытым до появления данных, затем клиент сразу делает новый запрос.</p><h4>4. Short Polling (Regular Polling)</h4><p>Клиент периодически опрашивает сервер через обычные HTTP запросы с фиксированным интервалом.</p><h4>Сравнение методов:</h4><ul><li><strong>WebSocket:</strong> Лучшая производительность, минимальный overhead, требует специальный сервер</li><li><strong>EventSource:</strong> Проще в использовании, работает через HTTP, только от сервера к клиенту</li><li><strong>Long Polling:</strong> Универсальный fallback, больше нагрузка на сервер</li><li><strong>Short Polling:</strong> Самый простой, но неэффективный метод</li></ul><p><em>Выбор метода:</em> Зависит от требований к latency, направлению передачи данных, поддержки браузеров и инфраструктурных ограничений.</p>",
    difficulty: 'junior',
    tags: ['WebSocket', 'EventSource', 'Long Polling', 'методы соединения']
  },
  {
    id: 32,
    question: "Что такое WebSocket и как установить WebSocket соединение?",
    answer: "<p><strong>WebSocket</strong> — это протокол для двусторонней связи между клиентом и сервером через единое TCP соединение.</p><h4>Установка соединения:</h4><p><code>const ws = new WebSocket('ws://localhost:3000');</code></p><p>Для защищенного соединения используется wss:// протокол.</p><h4>Процесс установки соединения:</h4><p><strong>1. HTTP Upgrade:</strong> Клиент отправляет HTTP запрос с заголовками:<br><code>Upgrade: websocket</code><br><code>Connection: Upgrade</code></p><p><strong>2. Handshake:</strong> Сервер соглашается и отправляет статус 101 Switching Protocols</p><p><strong>3. Переключение:</strong> Соединение переключается с HTTP на WebSocket протокол</p><h4>События WebSocket:</h4><p><code>ws.onopen = () => console.log('Подключено');</code><br><code>ws.onmessage = (event) => console.log(event.data);</code><br><code>ws.onerror = (error) => console.error(error);</code><br><code>ws.onclose = () => console.log('Закрыто');</code></p><h4>Отправка данных:</h4><p><code>ws.send('Hello Server!');</code><br><code>ws.send(JSON.stringify({ type: 'message' }));</code><br><code>ws.send(new Uint8Array([1, 2, 3]));</code></p><p><em>Важно:</em> Перед отправкой проверяйте <code>ws.readyState === WebSocket.OPEN</code></p>",
    difficulty: 'junior',
    tags: ['WebSocket', 'соединение', 'протокол', 'handshake']
  },
  {
    id: 33,
    question: "Какие состояния (readyState) имеет WebSocket соединение?",
    answer: "<p>WebSocket имеет 4 состояния, доступных через свойство <code>readyState</code>:</p><h4>WebSocket.CONNECTING (0)</h4><p>Соединение устанавливается. WebSocket создан, но handshake еще не завершен. Отправка данных невозможна.</p><h4>WebSocket.OPEN (1)</h4><p>Соединение установлено и готово к обмену данными. Можно отправлять и получать сообщения.</p><p><code>if (ws.readyState === WebSocket.OPEN) {</code><br><code>&nbsp;&nbsp;ws.send('message');</code><br><code>}</code></p><h4>WebSocket.CLOSING (2)</h4><p>Соединение закрывается. Метод <code>close()</code> был вызван, но соединение еще не закрыто полностью.</p><h4>WebSocket.CLOSED (3)</h4><p>Соединение закрыто или не удалось установить. Больше нельзя отправлять или получать данные.</p><h4>Проверка состояния:</h4><p><code>console.log(ws.readyState);</code><br><code>// 0 - CONNECTING</code><br><code>// 1 - OPEN</code><br><code>// 2 - CLOSING</code><br><code>// 3 - CLOSED</code></p><h4>Практическое применение:</h4><p><code>function sendMessage(message) {</code><br><code>&nbsp;&nbsp;if (ws.readyState === WebSocket.OPEN) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.send(message);</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('WebSocket не готов');</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'middle',
    tags: ['WebSocket', 'readyState', 'состояния', 'lifecycle']
  },
  {
    id: 34,
    question: "Как реализовать автоматическое переподключение WebSocket при разрыве соединения?",
    answer: "<p>Автоматическое переподключение критично для надежности WebSocket соединений:</p><h4>Базовая реализация:</h4><p><code>class ReconnectingWebSocket {</code><br><code>&nbsp;&nbsp;constructor(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.url = url;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectInterval = options.reconnectInterval || 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxReconnectInterval = options.maxReconnectInterval || 30000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectDecay = options.reconnectDecay || 1.5;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectAttempts = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.forcedClose = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.messageQueue = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.connect();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;connect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = new WebSocket(this.url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onopen = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectAttempts = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.flushQueue();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onclose = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.forcedClose) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;reconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.min(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.maxReconnectInterval</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectAttempts++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => this.connect(), delay);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Ключевые моменты:</h4><ul><li><strong>Экспоненциальная задержка:</strong> Увеличивает интервал между попытками</li><li><strong>Очередь сообщений:</strong> Сохраняет неотправленные сообщения</li><li><strong>Принудительное закрытие:</strong> Флаг для отличия намеренного закрытия от ошибки</li><li><strong>Ограничение задержки:</strong> Максимальный интервал переподключения</li></ul>",
    difficulty: 'senior',
    tags: ['WebSocket', 'переподключение', 'reconnection', 'надежность']
  },
  {
    id: 35,
    question: "Что такое heartbeat (ping-pong) в WebSocket и зачем он нужен?",
    answer: "<p><strong>Heartbeat (ping-pong)</strong> — механизм проверки жизнеспособности WebSocket соединения через периодическую отправку ping сообщений.</p><h4>Зачем нужен heartbeat:</h4><ul><li><strong>Обнаружение разрыва:</strong> Определяет неактивное соединение быстрее чем TCP timeout</li><li><strong>Keep-alive:</strong> Предотвращает закрытие соединения прокси/firewall</li><li><strong>Проверка доступности:</strong> Убеждается что сервер отвечает</li></ul><h4>Реализация:</h4><p><code>class WebSocketWithHeartbeat {</code><br><code>&nbsp;&nbsp;constructor(url, heartbeatInterval = 30000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = new WebSocket(url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.heartbeatInterval = heartbeatInterval;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.heartbeatTimer = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pongTimeout = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onopen = () => this.startHeartbeat();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onclose = () => this.stopHeartbeat();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = JSON.parse(event.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data.type === 'pong') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.pongTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;startHeartbeat() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.heartbeatTimer = setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({ type: 'ping' }));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pongTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Нет ответа на ping, переподключение...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.close();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 5000);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.heartbeatInterval);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>На сервере:</h4><p>Сервер должен отвечать на ping сообщения pong ответом для подтверждения активности.</p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'heartbeat', 'ping-pong', 'keep-alive']
  },
  {
    id: 36,
    question: "Что такое Server-Sent Events (EventSource) и как он работает?",
    answer: "<p><strong>Server-Sent Events (SSE)</strong> — технология для односторонней передачи данных от сервера к клиенту через HTTP.</p><h4>Создание EventSource:</h4><p><code>const eventSource = new EventSource('/api/events');</code></p><h4>Как работает:</h4><p><strong>1. Клиент:</strong> Отправляет обычный HTTP GET запрос на сервер</p><p><strong>2. Сервер:</strong> Отвечает с заголовками:<br><code>Content-Type: text/event-stream</code><br><code>Cache-Control: no-cache</code><br><code>Connection: keep-alive</code></p><p><strong>3. Поток данных:</strong> Сервер держит соединение открытым и отправляет данные в формате:<br><code>data: сообщение\\n\\n</code></p><h4>Обработка событий:</h4><p><code>eventSource.onopen = () => {</code><br><code>&nbsp;&nbsp;console.log('Соединение установлено');</code><br><code>};</code></p><p><code>eventSource.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;console.log('Данные:', event.data);</code><br><code>&nbsp;&nbsp;console.log('ID:', event.lastEventId);</code><br><code>};</code></p><p><code>eventSource.onerror = (error) => {</code><br><code>&nbsp;&nbsp;console.error('Ошибка:', error);</code><br><code>};</code></p><h4>Именованные события:</h4><p><code>eventSource.addEventListener('notification', (event) => {</code><br><code>&nbsp;&nbsp;const data = JSON.parse(event.data);</code><br><code>&nbsp;&nbsp;showNotification(data);</code><br><code>});</code></p><h4>Ключевые особенности:</h4><ul><li><strong>Автоматическое переподключение:</strong> Браузер сам переподключается при разрыве</li><li><strong>lastEventId:</strong> Восстановление с последнего события</li><li><strong>Только текст:</strong> Нельзя отправлять бинарные данные</li><li><strong>Только GET:</strong> Нельзя установить кастомные заголовки</li></ul>",
    difficulty: 'middle',
    tags: ['EventSource', 'Server-Sent Events', 'SSE', 'односторонняя связь']
  },
  {
    id: 37,
    question: "В чем главные отличия EventSource от WebSocket?",
    answer: "<p>EventSource и WebSocket решают разные задачи и имеют существенные различия:</p><h4>Направление передачи данных:</h4><p><strong>EventSource:</strong> Только от сервера к клиенту (односторонняя). Клиент не может отправлять данные через EventSource.</p><p><strong>WebSocket:</strong> Двусторонняя связь (full-duplex). Клиент и сервер могут отправлять данные в любое время.</p><h4>Протокол:</h4><p><strong>EventSource:</strong> Работает через обычный HTTP/HTTPS. Использует стандартные HTTP запросы.</p><p><strong>WebSocket:</strong> Отдельный протокол ws:// или wss://. Требует HTTP Upgrade для установки соединения.</p><h4>Автопереподключение:</h4><p><strong>EventSource:</strong> Автоматическое переподключение встроено в браузер. Не требует дополнительного кода.</p><p><strong>WebSocket:</strong> Нет автоматического переподключения. Нужно реализовывать вручную.</p><h4>Типы данных:</h4><p><strong>EventSource:</strong> Только текстовые данные (строки). Нельзя отправлять бинарные данные.</p><p><strong>WebSocket:</strong> Текст и бинарные данные (ArrayBuffer, Blob, TypedArray).</p><h4>Overhead:</h4><p><strong>EventSource:</strong> HTTP заголовки в каждом сообщении (больше overhead).</p><p><strong>WebSocket:</strong> Минимальный overhead (2-14 байт на кадр).</p><h4>Когда использовать:</h4><p><strong>EventSource:</strong> Уведомления, новостные ленты, мониторинг, прогресс операций — когда данные только от сервера.</p><p><strong>WebSocket:</strong> Чаты, игры, collaborative editing, трейдинг — когда нужна двусторонняя связь в реальном времени.</p>",
    difficulty: 'middle',
    tags: ['EventSource', 'WebSocket', 'сравнение', 'различия']
  },
  {
    id: 38,
    question: "Что такое Long Polling и когда его следует использовать?",
    answer: "<p><strong>Long Polling</strong> — техника, при которой клиент отправляет HTTP запрос, а сервер держит соединение открытым до появления новых данных или таймаута.</p><h4>Как работает:</h4><p><strong>1. Запрос:</strong> Клиент отправляет HTTP запрос на сервер</p><p><strong>2. Ожидание:</strong> Сервер НЕ отвечает сразу, держит соединение открытым</p><p><strong>3. Ответ:</strong> Когда появляются данные или истекает таймаут, сервер отправляет ответ</p><p><strong>4. Повтор:</strong> Клиент сразу отправляет новый запрос</p><h4>Реализация:</h4><p><code>async function longPoll() {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/long-poll', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: AbortSignal.timeout(30000)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;handleData(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сразу делаем следующий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;longPoll();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Повтор с задержкой при ошибке</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(longPoll, 5000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Когда использовать:</h4><ul><li><strong>Fallback:</strong> Когда WebSocket/EventSource недоступны</li><li><strong>Старые браузеры:</strong> Где нет поддержки современных технологий</li><li><strong>Строгие firewall:</strong> Корпоративные сети, блокирующие WebSocket</li><li><strong>Нечастые обновления:</strong> Данные появляются раз в несколько секунд</li><li><strong>Простота:</strong> Когда нужна максимальная совместимость</li></ul><h4>Недостатки:</h4><ul><li>Больше overhead чем WebSocket (HTTP заголовки)</li><li>Выше latency</li><li>Больше нагрузка на сервер</li><li>Сложнее масштабировать</li></ul>",
    difficulty: 'middle',
    tags: ['Long Polling', 'HTTP', 'fallback', 'совместимость']
  },
  {
    id: 39,
    question: "Какие коды закрытия (close codes) существуют в WebSocket и что они означают?",
    answer: "<p>WebSocket использует коды закрытия для указания причины разрыва соединения:</p><h4>Стандартные коды (1000-1015):</h4><p><strong>1000 - Normal Closure:</strong> Нормальное закрытие соединения. Задача выполнена успешно.</p><p><strong>1001 - Going Away:</strong> Endpoint уходит (например, сервер выключается или пользователь покидает страницу).</p><p><strong>1002 - Protocol Error:</strong> Ошибка протокола. Получены некорректные данные.</p><p><strong>1003 - Unsupported Data:</strong> Получен неподдерживаемый тип данных (например, только текст, а пришли бинарные).</p><p><strong>1006 - Abnormal Closure:</strong> Соединение закрыто ненормально (без close frame). Используется браузером, нельзя отправить явно.</p><p><strong>1007 - Invalid Payload:</strong> Некорректная кодировка данных (например, не UTF-8 в текстовом фрейме).</p><p><strong>1008 - Policy Violation:</strong> Нарушение политики (например, аутентификация не прошла).</p><p><strong>1009 - Message Too Big:</strong> Сообщение слишком большое для обработки.</p><p><strong>1010 - Mandatory Extension:</strong> Клиент ожидал расширение, которое сервер не согласовал.</p><p><strong>1011 - Internal Server Error:</strong> Внутренняя ошибка сервера.</p><h4>Использование:</h4><p><code>ws.close(1000, 'Normal close');</code><br><code>ws.close(1008, 'Authentication failed');</code></p><p><code>ws.onclose = (event) => {</code><br><code>&nbsp;&nbsp;console.log('Code:', event.code);</code><br><code>&nbsp;&nbsp;console.log('Reason:', event.reason);</code><br><code>&nbsp;&nbsp;console.log('Clean:', event.wasClean);</code><br><code>};</code></p><h4>Кастомные коды (3000-4999):</h4><p>Можно использовать для специфичных нужд приложения:<br><code>ws.close(4000, 'Custom error');</code></p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'close codes', 'коды закрытия', 'протокол']
  },
  {
    id: 40,
    question: "Как отправлять и получать бинарные данные через WebSocket?",
    answer: "<p>WebSocket поддерживает отправку и получение бинарных данных через ArrayBuffer и Blob:</p><h4>Настройка типа бинарных данных:</h4><p><code>ws.binaryType = 'arraybuffer';  // по умолчанию</code><br><code>// или</code><br><code>ws.binaryType = 'blob';</code></p><h4>Отправка бинарных данных:</h4><p><strong>1. ArrayBuffer:</strong></p><p><code>const buffer = new ArrayBuffer(8);</code><br><code>const view = new Uint8Array(buffer);</code><br><code>view[0] = 1;</code><br><code>view[1] = 2;</code><br><code>ws.send(buffer);</code></p><p><strong>2. TypedArray:</strong></p><p><code>const bytes = new Uint8Array([1, 2, 3, 4, 5]);</code><br><code>ws.send(bytes);</code></p><p><strong>3. Blob:</strong></p><p><code>const blob = new Blob(['Binary data'], {</code><br><code>&nbsp;&nbsp;type: 'application/octet-stream'</code><br><code>});</code><br><code>ws.send(blob);</code></p><h4>Получение бинарных данных:</h4><p><code>ws.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;if (event.data instanceof ArrayBuffer) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const view = new Uint8Array(event.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('ArrayBuffer:', view);</code><br><code>&nbsp;&nbsp;} else if (event.data instanceof Blob) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;event.data.arrayBuffer().then(buffer => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Blob as ArrayBuffer:', buffer);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Text:', event.data);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Практический пример - отправка файла:</h4><p><code>async function sendFile(file) {</code><br><code>&nbsp;&nbsp;const buffer = await file.arrayBuffer();</code><br><code>&nbsp;&nbsp;ws.send(buffer);</code><br><code>}</code></p><p><em>Преимущество:</em> Бинарные данные передаются эффективнее текстовых (нет base64 кодирования).</p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'бинарные данные', 'ArrayBuffer', 'Blob']
  },
  {
    id: 41,
    question: "Как реализовать систему комнат (rooms) с WebSocket?",
    answer: "<p>Система комнат позволяет группировать пользователей и отправлять сообщения только участникам конкретной комнаты:</p><h4>Клиентская часть:</h4><p><code>class ChatClient {</code><br><code>&nbsp;&nbsp;constructor(url) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = new WebSocket(url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentRoom = null;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;joinRoom(roomId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentRoom = roomId;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'join',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomId: roomId</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;leaveRoom(roomId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'leave',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomId: roomId</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentRoom = null;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;sendToRoom(message) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'message',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomId: this.currentRoom,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: message</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Серверная часть (Node.js + ws):</h4><p><code>const rooms = new Map(); // roomId -> Set of clients</code></p><p><code>wss.on('connection', (ws) => {</code><br><code>&nbsp;&nbsp;ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (message.type === 'join') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!rooms.has(message.roomId)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rooms.set(message.roomId, new Set());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rooms.get(message.roomId).add(ws);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ws.currentRoom = message.roomId;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (message.type === 'message') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const roomClients = rooms.get(message.roomId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomClients?.forEach(client => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (client.readyState === WebSocket.OPEN) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client.send(JSON.stringify(message));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'rooms', 'комнаты', 'групповые сообщения']
  },
  {
    id: 42,
    question: "Какие существуют fallback стратегии если WebSocket недоступен?",
    answer: "<p>Fallback стратегии обеспечивают работу приложения когда WebSocket не поддерживается или заблокирован:</p><h4>1. EventSource (Server-Sent Events)</h4><p>Первый fallback - пробуем EventSource для односторонней связи от сервера:</p><p><code>if ('EventSource' in window) {</code><br><code>&nbsp;&nbsp;const es = new EventSource('/api/events');</code><br><code>}</code></p><h4>2. Long Polling</h4><p>Если EventSource недоступен, используем Long Polling:</p><p><code>async function longPoll() {</code><br><code>&nbsp;&nbsp;const response = await fetch('/api/long-poll');</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;handleData(data);</code><br><code>&nbsp;&nbsp;longPoll(); // Сразу следующий запрос</code><br><code>}</code></p><h4>3. Short Polling</h4><p>Последняя опция - регулярный опрос сервера:</p><p><code>setInterval(() => {</code><br><code>&nbsp;&nbsp;fetch('/api/messages')</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.then(handleData);</code><br><code>}, 5000);</code></p><h4>Универсальный клиент с auto-fallback:</h4><p><code>class UniversalClient {</code><br><code>&nbsp;&nbsp;async connect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const methods = [</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tryWebSocket(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tryEventSource(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tryLongPolling()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (const method of methods) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await method();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; // Успех</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Trying next method...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Библиотеки с auto-fallback:</h4><ul><li><strong>Socket.IO:</strong> Автоматический fallback WebSocket → Polling</li><li><strong>SockJS:</strong> WebSocket эмуляция для старых браузеров</li><li><strong>SignalR:</strong> Microsoft's решение с auto-fallback</li></ul>",
    difficulty: 'senior',
    tags: ['fallback', 'совместимость', 'graceful degradation', 'стратегии']
  },
  {
    id: 43,
    question: "Как обеспечить безопасность WebSocket соединений?",
    answer: "<p>Безопасность WebSocket критична для защиты данных и предотвращения атак:</p><h4>1. Использовать WSS (WebSocket Secure)</h4><p>Всегда используйте wss:// вместо ws:// для шифрования соединения:</p><p><code>const ws = new WebSocket('wss://example.com');</code></p><h4>2. Валидация Origin</h4><p>На сервере проверяйте заголовок Origin для предотвращения CSRF:</p><p><code>wss.on('connection', (ws, request) => {</code><br><code>&nbsp;&nbsp;const origin = request.headers.origin;</code><br><code>&nbsp;&nbsp;if (origin !== 'https://trusted-domain.com') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1008, 'Unauthorized origin');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>3. Аутентификация и авторизация</h4><p>Проверяйте токены при установке соединения:</p><p><code>ws.onopen = () => {</code><br><code>&nbsp;&nbsp;ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;type: 'auth',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;token: localStorage.getItem('authToken')</code><br><code>&nbsp;&nbsp;}));</code><br><code>};</code></p><p>На сервере:</p><p><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;const message = JSON.parse(data);</code><br><code>&nbsp;&nbsp;if (message.type === 'auth') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!verifyToken(message.token)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1008, 'Invalid token');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>4. Rate Limiting</h4><p>Ограничивайте частоту сообщений от клиента:</p><p><code>const messageLimit = new Map();</code><br><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;const count = messageLimit.get(ws) || 0;</code><br><code>&nbsp;&nbsp;if (count > 100) { // 100 сообщений в минуту</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1008, 'Rate limit exceeded');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>5. Валидация данных</h4><p>Всегда валидируйте входящие данные:</p><p><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!validateMessage(message)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1003, 'Invalid data');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1002, 'Parse error');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>6. Ограничение размера сообщений</h4><p><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;if (data.length > 1024 * 1024) { // 1MB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1009, 'Message too big');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'безопасность', 'аутентификация', 'валидация']
  },
  {
    id: 44,
    question: "Как отслеживать и отображать статус соединения для пользователя?",
    answer: "<p>Отображение статуса соединения улучшает UX и помогает пользователю понять состояние приложения:</p><h4>Реализация индикатора статуса:</h4><p><code>class ConnectionStatus {</code><br><code>&nbsp;&nbsp;constructor(ws) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = ws;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator = document.getElementById('status');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupListeners();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupListeners() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onopen = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setStatus('connected', 'Подключено');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onclose = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setStatus('disconnected', 'Отключено');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setStatus('error', 'Ошибка соединения');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setStatus(state, message) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = \`status-\${state}\`;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = message;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Уведомление</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (state === 'disconnected') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showNotification('Соединение потеряно');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>HTML индикатор:</h4><p><code>&lt;div id=\"status\" class=\"status-connecting\"&gt;</code><br><code>&nbsp;&nbsp;&lt;span class=\"dot\"&gt;&lt;/span&gt;</code><br><code>&nbsp;&nbsp;&lt;span class=\"text\"&gt;Подключение...&lt;/span&gt;</code><br><code>&lt;/div&gt;</code></p><h4>CSS стили:</h4><p><code>.status-connected .dot { background: green; }</code><br><code>.status-disconnected .dot { background: red; }</code><br><code>.status-connecting .dot {</code><br><code>&nbsp;&nbsp;background: orange;</code><br><code>&nbsp;&nbsp;animation: blink 1s infinite;</code><br><code>}</code></p><h4>Расширенный статус с качеством соединения:</h4><p><code>class AdvancedConnectionStatus {</code><br><code>&nbsp;&nbsp;constructor(ws) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.latency = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.measureLatency();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;measureLatency() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const start = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({ type: 'ping' }));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = JSON.parse(event.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data.type === 'pong') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.latency = Date.now() - start;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateLatencyDisplay();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 5000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'middle',
    tags: ['WebSocket', 'UX', 'статус соединения', 'индикатор']
  },
  {
    id: 45,
    question: "Какие популярные библиотеки существуют для работы с WebSocket и в чем их преимущества?",
    answer: "<p>Существует несколько популярных библиотек, упрощающих работу с WebSocket:</p><h4>1. Socket.IO</h4><p><strong>Преимущества:</strong></p><ul><li>Автоматический fallback (WebSocket → Long Polling)</li><li>Автопереподключение из коробки</li><li>Поддержка комнат (rooms) и namespace</li><li>Broadcasting и группы</li><li>Бинарные данные</li><li>Middleware поддержка</li></ul><p><code>import io from 'socket.io-client';</code><br><code>const socket = io('http://localhost:3000');</code><br><code>socket.on('message', (data) => console.log(data));</code><br><code>socket.emit('message', { text: 'Hello!' });</code></p><h4>2. ws (Node.js)</h4><p><strong>Преимущества:</strong></p><ul><li>Самая быстрая WebSocket библиотека для Node.js</li><li>Минимальные зависимости</li><li>Простой API</li><li>Отличная производительность</li><li>Поддержка перфоманс тестов</li></ul><p><code>const WebSocket = require('ws');</code><br><code>const wss = new WebSocket.Server({ port: 3000 });</code></p><h4>3. SockJS</h4><p><strong>Преимущества:</strong></p><ul><li>WebSocket-подобный API</li><li>Множество транспортов (fallback)</li><li>Работает в старых браузерах</li><li>CORS поддержка</li><li>Прозрачный fallback</li></ul><h4>4. Firebase Realtime Database</h4><p><strong>Преимущества:</strong></p><ul><li>Backend-as-a-Service (не нужен свой сервер)</li><li>Автоматическая синхронизация данных</li><li>Offline поддержка</li><li>Аутентификация встроена</li><li>Автоматическое масштабирование</li></ul><h4>5. SignalR (Microsoft)</h4><p><strong>Преимущества:</strong></p><ul><li>Отличная интеграция с .NET</li><li>Автоматический fallback</li><li>Strongly-typed hubs</li><li>Группы и broadcasting</li><li>Поддержка Azure</li></ul><h4>Когда использовать библиотеки:</h4><p><strong>Socket.IO:</strong> Когда нужен быстрый старт и автоматический fallback</p><p><strong>ws:</strong> Когда важна максимальная производительность</p><p><strong>Нативный WebSocket:</strong> Для простых сценариев и полного контроля</p>",
    difficulty: 'middle',
    tags: ['библиотеки', 'Socket.IO', 'ws', 'инструменты']
  },
  {
    id: 46,
    question: "Что такое IntersectionObserver и для чего он используется?",
    answer: "<p><strong>IntersectionObserver</strong> — это API для асинхронного отслеживания пересечения элемента с viewport или с другим элементом-предком:</p><h4>Основное назначение:</h4><p>Позволяет эффективно отслеживать, когда элемент становится видимым на странице, без блокировки main thread.</p><h4>Синтаксис:</h4><p><code>const observer = new IntersectionObserver(callback, options);</code><br><code>observer.observe(element);</code></p><h4>Основные применения:</h4><ul><li><strong>Lazy loading:</strong> Отложенная загрузка изображений и контента</li><li><strong>Infinite scroll:</strong> Бесконечная прокрутка списков</li><li><strong>Аналитика:</strong> Отслеживание просмотров элементов</li><li><strong>Анимации:</strong> Запуск анимаций при появлении элемента</li><li><strong>Автовоспроизведение:</strong> Воспроизведение видео при появлении в viewport</li></ul><h4>Преимущества:</h4><ul><li>Асинхронная работа — не блокирует UI</li><li>Высокая производительность — вычисления в отдельном потоке</li><li>Простой API — не нужен throttle/debounce</li><li>Нет layout thrashing — браузер оптимизирует вычисления</li></ul><p><em>Важно:</em> IntersectionObserver работает значительно эффективнее, чем отслеживание через scroll event + getBoundingClientRect().</p>",
    difficulty: 'junior',
    tags: ['IntersectionObserver', 'Web API', 'производительность', 'основы']
  },
  {
    id: 47,
    question: "Как реализовать InfinityScroll с помощью IntersectionObserver?",
    answer: "<p>InfinityScroll реализуется через создание <strong>sentinel элемента</strong> в конце списка и наблюдение за ним:</p><h4>Базовая реализация:</h4><p><code>class InfiniteScroll {</code><br><code>&nbsp;&nbsp;constructor(container) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.page = 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loading = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.hasMore = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем sentinel</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(this.sentinel);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer с предзагрузкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ rootMargin: '100px' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entries[0].isIntersecting && !this.loading && this.hasMore) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await this.loadMore();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async loadMore() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loading = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await fetch(\`/api/items?page=\${this.page}\`).then(r => r.json());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (data.length === 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hasMore = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.renderItems(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.page++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loading = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Ключевые моменты:</h4><ul><li><strong>Sentinel элемент:</strong> Маркер в конце списка, за которым наблюдаем</li><li><strong>loading флаг:</strong> Предотвращает дублирование запросов</li><li><strong>hasMore флаг:</strong> Останавливает загрузку при отсутствии данных</li><li><strong>rootMargin:</strong> Загружает данные заранее (за 100px до конца)</li></ul><p><em>Преимущество:</em> Sentinel всегда остается в конце, в отличие от наблюдения за последним элементом данных.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'InfinityScroll', 'паттерны', 'реализация']
  },
  {
    id: 48,
    question: "Какие существуют способы оптимизации InfinityScroll?",
    answer: "<p>Существует множество техник оптимизации InfinityScroll для улучшения производительности и UX:</p><h4>1. Виртуализация списка:</h4><p>Рендерить только видимые элементы. Критично для списков >1000 элементов.</p><p><code>// Рендерим только элементы в viewport + буфер</code><br><code>const startIndex = Math.floor(scrollTop / itemHeight);</code><br><code>const endIndex = startIndex + visibleCount;</code></p><h4>2. Батчинг запросов:</h4><p>Загружать несколько страниц за один раз, уменьшая количество HTTP-запросов:</p><p><code>const promises = [</code><br><code>&nbsp;&nbsp;fetch(\`/api/items?page=\${page}\`),</code><br><code>&nbsp;&nbsp;fetch(\`/api/items?page=\${page + 1}\`),</code><br><code>&nbsp;&nbsp;fetch(\`/api/items?page=\${page + 2}\`)</code><br><code>];</code><br><code>const results = await Promise.all(promises);</code></p><h4>3. Предзагрузка (Prefetching):</h4><p>Загружать следующую страницу заранее и кэшировать в Map:</p><p><code>async prefetchNext() {</code><br><code>&nbsp;&nbsp;if (!this.cache.has(this.page + 1)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await this.fetchData(this.page + 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cache.set(this.page + 1, data);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>4. Дебаунс callback:</h4><p>Ограничить частоту вызовов для быстрого скролла.</p><h4>5. Отмена запросов:</h4><p>Использовать AbortController для отмены предыдущих запросов:</p><p><code>if (this.abortController) {</code><br><code>&nbsp;&nbsp;this.abortController.abort();</code><br><code>}</code><br><code>this.abortController = new AbortController();</code></p><h4>6. Lazy loading изображений:</h4><p>Отдельный IntersectionObserver для изображений внутри элементов.</p><h4>7. Скелетон-загрузчики:</h4><p>Показывать placeholder'ы вместо индикаторов загрузки для лучшего UX.</p><p><em>Комбинация этих техник:</em> Для максимальной производительности используйте несколько оптимизаций одновременно.</p>",
    difficulty: 'senior',
    tags: ['IntersectionObserver', 'оптимизация', 'производительность', 'InfinityScroll']
  },
  {
    id: 49,
    question: "Что такое threshold и rootMargin в IntersectionObserver?",
    answer: "<p>Это два ключевых параметра настройки IntersectionObserver, определяющие когда срабатывает callback:</p><h4>threshold (порог видимости):</h4><p>Определяет, при какой видимости элемента (от 0.0 до 1.0) должен сработать callback.</p><p><strong>Значения:</strong></p><ul><li><code>0</code> — callback при любом пересечении (даже 1 пиксель)</li><li><code>0.5</code> — callback когда видно 50% элемента</li><li><code>1.0</code> — callback когда виден весь элемент полностью</li><li><code>[0, 0.5, 1.0]</code> — массив порогов, callback при каждом</li></ul><p><code>new IntersectionObserver(callback, {</code><br><code>&nbsp;&nbsp;threshold: [0, 0.25, 0.5, 0.75, 1.0]</code><br><code>});</code></p><h4>rootMargin (отступы от границ):</h4><p>Работает как CSS margin — изменяет область наблюдения root элемента.</p><p><strong>Синтаксис:</strong> <code>'top right bottom left'</code> (как в CSS)</p><p><strong>Примеры:</strong></p><ul><li><code>'0px'</code> — без отступов (по умолчанию)</li><li><code>'100px'</code> — увеличивает область на 100px со всех сторон</li><li><code>'0px 0px -100px 0px'</code> — уменьшает нижнюю границу на 100px</li><li><code>'200px 0px 200px 0px'</code> — предзагрузка за 200px сверху и снизу</li></ul><p><code>new IntersectionObserver(callback, {</code><br><code>&nbsp;&nbsp;rootMargin: '100px' // Загружаем за 100px до края</code><br><code>});</code></p><h4>Применение для InfinityScroll:</h4><p><code>rootMargin: '200px'</code> позволяет начать загрузку данных за 200px до того, как пользователь доскроллит до конца, создавая ощущение бесконечного списка.</p><p><em>Важно:</em> Значения rootMargin должны быть с единицами измерения (px или %).</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'threshold', 'rootMargin', 'конфигурация']
  },
  {
    id: 50,
    question: "Как обрабатывать пересечения нескольких элементов с помощью IntersectionObserver?",
    answer: "<p>Один IntersectionObserver может эффективно наблюдать за множеством элементов с разной логикой:</p><h4>Базовый подход — одинаковая логика:</h4><p><code>const observer = new IntersectionObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry.target.classList.add('visible');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>// Наблюдаем за всеми</code><br><code>document.querySelectorAll('.animate').forEach(el => {</code><br><code>&nbsp;&nbsp;observer.observe(el);</code><br><code>});</code></p><h4>Разная логика для разных элементов:</h4><p><code>class MultiElementObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.handlers = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;observe(element, handler) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.handlers.set(element, handler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const handler = this.handlers.get(entry.target);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (handler) handler(entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const multiObserver = new MultiElementObserver();</code><br><code></code><br><code>multiObserver.observe(header, (entry) => {</code><br><code>&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Header visible');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code><br><code></code><br><code>multiObserver.observe(sidebar, (entry) => {</code><br><code>&nbsp;&nbsp;if (entry.intersectionRatio > 0.5) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;sidebar.classList.add('sticky');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Преимущества подхода:</h4><ul><li>Один Observer для всех элементов — эффективнее памяти</li><li>Централизованное управление</li><li>Легко добавлять/удалять элементы</li><li>Индивидуальная логика для каждого элемента</li></ul><p><em>Best practice:</em> Избегайте создания отдельного Observer для каждого элемента — это расточительно.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'несколько элементов', 'паттерны', 'производительность']
  },
  {
    id: 51,
    question: "В чем разница между IntersectionObserver и scroll event?",
    answer: "<p>Это два принципиально разных подхода к отслеживанию позиции элементов на странице:</p><h4>IntersectionObserver:</h4><p><strong>Преимущества:</strong></p><ul><li><strong>Асинхронный:</strong> Работает в отдельном потоке, не блокирует main thread</li><li><strong>Производительный:</strong> Браузер оптимизирует вычисления</li><li><strong>Простой API:</strong> Не требует throttle/debounce</li><li><strong>Точный:</strong> Встроенные вычисления пересечений</li><li><strong>Нет layout thrashing:</strong> Вычисления батчатся браузером</li></ul><p><strong>Недостатки:</strong></p><ul><li>Требует полифилл для старых браузеров</li><li>Ограниченная кастомизация логики</li></ul><h4>Scroll Event:</h4><p><strong>Преимущества:</strong></p><ul><li><strong>Универсальная поддержка:</strong> Работает везде</li><li><strong>Полный контроль:</strong> Любая кастомная логика</li><li><strong>Доступ к scroll позиции:</strong> scrollTop, scrollLeft</li></ul><p><strong>Недостатки:</strong></p><ul><li><strong>Синхронный:</strong> Блокирует main thread</li><li><strong>Низкая производительность:</strong> Вызывается очень часто</li><li><strong>Требует оптимизации:</strong> Обязателен throttle/debounce</li><li><strong>Layout thrashing:</strong> getBoundingClientRect() вызывает reflow</li><li><strong>Сложнее:</strong> Нужно вручную считать пересечения</li></ul><h4>Сравнение кода:</h4><p><code>// ❌ Scroll Event — требует оптимизации</code><br><code>let timeout;</code><br><code>window.addEventListener('scroll', () => {</code><br><code>&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;timeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const rect = element.getBoundingClientRect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (rect.top < window.innerHeight) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// логика</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, 100);</code><br><code>});</code></p><p><code>// ✅ IntersectionObserver — просто и эффективно</code><br><code>const observer = new IntersectionObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (entries[0].isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// логика</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code><br><code>observer.observe(element);</code></p><p><em>Вывод:</em> Для lazy loading, infinite scroll и отслеживания видимости используйте IntersectionObserver. Scroll event — только для специфичных задач.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'scroll event', 'сравнение', 'производительность']
  },
  {
    id: 52,
    question: "Как правильно очищать IntersectionObserver при размонтировании компонента?",
    answer: "<p>Правильная очистка IntersectionObserver критична для предотвращения утечек памяти:</p><h4>Методы очистки:</h4><p><strong>1. disconnect():</strong> Останавливает все наблюдения</p><p><code>observer.disconnect();</code></p><p><strong>2. unobserve(element):</strong> Прекращает наблюдение за конкретным элементом</p><p><code>observer.unobserve(element);</code></p><h4>В vanilla JavaScript:</h4><p><code>class Component {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(this.callback.bind(this));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;mount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements.forEach(el => this.observer.observe(el));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;unmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// ВАЖНО: Очистка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>В React:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new IntersectionObserver(callback);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const element = elementRef.current;</code><br><code>&nbsp;&nbsp;if (element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup функция</code><br><code>&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;};</code><br><code>}, []);</code></p><h4>В Vue:</h4><p><code>export default {</code><br><code>&nbsp;&nbsp;mounted() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.$el);</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;beforeUnmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Cleanup</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.observer) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Когда использовать unobserve vs disconnect:</h4><ul><li><strong>unobserve:</strong> Когда нужно прекратить наблюдение за одним элементом (например, после загрузки изображения), но продолжить наблюдать за другими</li><li><strong>disconnect:</strong> При полном размонтировании компонента или когда нужно остановить все наблюдения</li></ul><p><em>Критично:</em> Всегда вызывайте disconnect() при размонтировании, иначе Observer будет продолжать работать и занимать память.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'cleanup', 'утечки памяти', 'lifecycle']
  },
  {
    id: 53,
    question: "Как реализовать lazy loading изображений с IntersectionObserver?",
    answer: "<p>Lazy loading изображений — классическое применение IntersectionObserver для оптимизации производительности:</p><h4>HTML разметка:</h4><p><code>&lt;img data-src=\"image.jpg\" data-srcset=\"image-2x.jpg 2x\" class=\"lazy\" alt=\"Description\"&gt;</code></p><h4>Реализация:</h4><p><code>class LazyImageLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '50px', // Загружаем за 50px</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.01</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.images = document.querySelectorAll('img[data-src]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.images.forEach(img => this.observer.observe(img));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadImage(entry.target);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loadImage(img) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Устанавливаем src</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.src = img.dataset.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Опционально: srcset для responsive</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (img.dataset.srcset) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.srcset = img.dataset.srcset;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Добавляем класс для fade-in анимации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.classList.add('loaded');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// После загрузки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.classList.remove('lazy');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.src = 'placeholder-error.jpg';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Прекращаем наблюдение</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.unobserve(img);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>CSS для плавного появления:</h4><p><code>.lazy {</code><br><code>&nbsp;&nbsp;opacity: 0;</code><br><code>&nbsp;&nbsp;transition: opacity 0.3s;</code><br><code>}</code><br><code></code><br><code>.lazy.loaded {</code><br><code>&nbsp;&nbsp;opacity: 1;</code><br><code>}</code></p><h4>С placeholder'ом:</h4><p><code>&lt;img src=\"placeholder.jpg\" data-src=\"real-image.jpg\" class=\"lazy\"&gt;</code></p><h4>Преимущества подхода:</h4><ul><li>Изображения загружаются только когда видны</li><li>Экономия трафика и улучшение начальной загрузки страницы</li><li>Плавная анимация появления</li><li>Автоматическая обработка ошибок</li><li>Поддержка responsive изображений (srcset)</li></ul><p><em>Важно:</em> rootMargin: '50px' начинает загрузку чуть заранее, чтобы изображение успело загрузиться до прокрутки.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'lazy loading', 'изображения', 'оптимизация']
  },
  {
    id: 54,
    question: "Как использовать IntersectionObserver для отслеживания аналитики просмотров?",
    answer: "<p>IntersectionObserver идеален для отслеживания, какие элементы увидел пользователь:</p><h4>HTML разметка:</h4><p><code>&lt;div data-track-view=\"article-123\"&gt;Article content&lt;/div&gt;</code><br><code>&lt;div data-track-view=\"product-456\"&gt;Product card&lt;/div&gt;</code></p><h4>Реализация отслеживания:</h4><p><code>class ViewTracking {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.tracked = new Set();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5, // 50% элемента должно быть видно</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '0px'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Находим все отслеживаемые элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.trackableElements = document.querySelectorAll('[data-track-view]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.trackableElements.forEach(el => this.observer.observe(el));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const trackId = element.dataset.trackView;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Отслеживаем только один раз</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.tracked.has(trackId)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.tracked.add(trackId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendAnalytics(trackId, entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Прекращаем наблюдение</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;sendAnalytics(trackId, entry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: trackId,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visibilityRatio: entry.intersectionRatio,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elementPosition: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top: entry.boundingClientRect.top,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottom: entry.boundingClientRect.bottom</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewportHeight: window.innerHeight</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправляем данные (не блокирует UI)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;navigator.sendBeacon('/analytics/view', JSON.stringify(data));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('View tracked:', trackId);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отслеживание времени просмотра:</h4><p><code>class DurationTracking {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.viewTimes = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ threshold: 0.5 }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const id = entry.target.dataset.trackView;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Начинаем отсчет</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.viewTimes.set(id, Date.now());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Останавливаем и отправляем</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const startTime = this.viewTimes.get(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (startTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const duration = Date.now() - startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendDuration(id, duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.viewTimes.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Применения:</h4><ul><li>Отслеживание просмотров статей/товаров</li><li>Impressions для рекламных баннеров</li><li>A/B тестирование видимости элементов</li><li>Метрики вовлеченности пользователей</li></ul><p><em>Важно:</em> Используйте navigator.sendBeacon() для гарантированной отправки данных даже при закрытии страницы.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'аналитика', 'tracking', 'метрики']
  },
  {
    id: 55,
    question: "Как оптимизировать производительность при использовании IntersectionObserver?",
    answer: "<p>Существует множество техник для максимальной производительности IntersectionObserver:</p><h4>1. Переиспользование одного Observer:</h4><p><code>// ❌ ПЛОХО - создаем Observer для каждого элемента</code><br><code>elements.forEach(el => {</code><br><code>&nbsp;&nbsp;const observer = new IntersectionObserver(callback);</code><br><code>&nbsp;&nbsp;observer.observe(el);</code><br><code>});</code></p><p><code>// ✅ ХОРОШО - один Observer для всех</code><br><code>const observer = new IntersectionObserver(callback);</code><br><code>elements.forEach(el => observer.observe(el));</code></p><h4>2. Оптимизация threshold:</h4><p><code>// ❌ ПЛОХО - слишком много порогов</code><br><code>threshold: Array.from({ length: 101 }, (_, i) => i / 100)</code></p><p><code>// ✅ ХОРОШО - только нужные пороги</code><br><code>threshold: [0, 0.5, 1.0]</code></p><h4>3. Батчинг обновлений через RAF:</h4><p><code>class LayoutOptimizedObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingUpdates = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.rafId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;scheduleUpdate(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingUpdates.push(...entries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.rafId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.processBatch();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;processBatch() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Читаем все размеры (read phase)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = this.pendingUpdates.map(entry => ({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element: entry.target,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isIntersecting: entry.isIntersecting</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем изменения (write phase)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data.forEach(({ element, isIntersecting }) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.toggle('visible', isIntersecting);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingUpdates = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.rafId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>4. Throttle для частых событий:</h4><p><code>class ThrottledObserver {</code><br><code>&nbsp;&nbsp;constructor(delay = 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (now - this.lastCall >= delay) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = now;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection(entries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>5. Управление памятью:</h4><p><code>class MemoryEfficientObserver {</code><br><code>&nbsp;&nbsp;constructor(maxElements = 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxElements = maxElements;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observedElements = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;observe(element, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Если достигли лимита, удаляем старые</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.observedElements.size >= this.maxElements) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const first = this.observedElements.keys().next().value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.unobserve(first);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observedElements.set(element, data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Остановка наблюдения после обработки:</h4><p><code>if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;// Обработали элемент</code><br><code>&nbsp;&nbsp;processElement(entry.target);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Прекращаем наблюдение (например, для lazy loading)</code><br><code>&nbsp;&nbsp;observer.unobserve(entry.target);</code><br><code>}</code></p><h4>7. Мониторинг производительности:</h4><p><code>const start = performance.now();</code><br><code>// Логика callback</code><br><code>const duration = performance.now() - start;</code><br><code></code><br><code>if (duration > 16.67) { // Больше 1 фрейма (60fps)</code><br><code>&nbsp;&nbsp;console.warn('Slow callback:', duration);</code><br><code>}</code></p><p><em>Золотое правило:</em> Callback должен выполняться быстро (<16ms для 60fps). Тяжелые операции выносить в Web Workers.</p>",
    difficulty: 'senior',
    tags: ['IntersectionObserver', 'оптимизация', 'производительность', 'best practices']
  },
  {
    id: 56,
    question: "Что такое sentinel элемент в контексте InfinityScroll и зачем он нужен?",
    answer: "<p><strong>Sentinel элемент</strong> — это специальный маркерный элемент, размещаемый в конце списка для отслеживания момента загрузки новых данных:</p><h4>Зачем нужен sentinel:</h4><ul><li><strong>Надежность:</strong> Всегда находится в конце списка, в отличие от последнего элемента данных</li><li><strong>Простота:</strong> Не зависит от структуры элементов данных</li><li><strong>Независимость:</strong> Не смешивается с логикой отображения данных</li><li><strong>Контроль:</strong> Легко управлять его видимостью и состоянием</li></ul><h4>Создание sentinel:</h4><p><code>class InfiniteScroll {</code><br><code>&nbsp;&nbsp;constructor(container) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем sentinel элемент</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.className = 'sentinel';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.height = '1px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Помещаем в конец контейнера</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(this.sentinel);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за ним</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ rootMargin: '100px' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;renderItems(items) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const fragment = document.createDocumentFragment();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(item => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const element = this.createItemElement(item);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment.appendChild(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вставляем ПЕРЕД sentinel</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.insertBefore(fragment, this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entries[0].isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sentinel виден — загружаем данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadMore();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Состояния sentinel:</h4><p><code>// Загрузка</code><br><code>this.sentinel.innerHTML = '&lt;div class=\"loader\"&gt;Loading...&lt;/div&gt;';</code></p><p><code>// Ошибка</code><br><code>this.sentinel.innerHTML = '&lt;div class=\"error\"&gt;Error loading&lt;/div&gt;';</code></p><p><code>// Конец данных</code><br><code>if (!hasMore) {</code><br><code>&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;this.sentinel.innerHTML = '&lt;div&gt;All items loaded&lt;/div&gt;';</code><br><code>}</code></p><h4>Альтернатива без sentinel (не рекомендуется):</h4><p><code>// ❌ Наблюдение за последним элементом данных</code><br><code>const lastItem = container.lastElementChild;</code><br><code>observer.observe(lastItem);</code><br><code>// Проблема: нужно переподписываться при добавлении новых элементов</code></p><h4>CSS для sentinel:</h4><p><code>.sentinel {</code><br><code>&nbsp;&nbsp;height: 1px;</code><br><code>&nbsp;&nbsp;visibility: hidden;</code><br><code>}</code></p><p><em>Best practice:</em> Sentinel должен быть невидимым элементом минимальной высоты, который всегда остается в конце списка.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'InfinityScroll', 'sentinel', 'паттерны']
  },
  {
    id: 57,
    question: "Как реализовать автовоспроизведение видео с помощью IntersectionObserver?",
    answer: "<p>Автовоспроизведение видео при появлении в viewport — частая задача для улучшения UX:</p><h4>HTML разметка:</h4><p><code>&lt;video data-autoplay muted loop&gt;</code><br><code>&nbsp;&nbsp;&lt;source src=\"video.mp4\" type=\"video/mp4\"&gt;</code><br><code>&lt;/video&gt;</code></p><p><em>Примечание:</em> Атрибут <code>muted</code> обязателен для autoplay в большинстве браузеров.</p><h4>Реализация:</h4><p><code>class VideoAutoplay {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5 // Играть когда видно 50% видео</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.videos = document.querySelectorAll('video[data-autoplay]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.videos.forEach(video => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Предзагрузка метаданных</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.preload = 'metadata';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const video = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Видео видно — воспроизводим</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.play().catch(err => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Autoplay prevented:', err);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Видео вне viewport — ставим на паузу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.pause();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Расширенная версия с lazy loading:</h4><p><code>class SmartVideoLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '100px' // Загружаем заранее</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadedVideos = new Set();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const video = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Загружаем source если еще не загружен</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.loadedVideos.has(video)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadVideo(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedVideos.add(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Воспроизводим</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.play().catch(err => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Показываем кнопку play если autoplay запрещен</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showPlayButton(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.pause();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loadVideo(video) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const source = video.querySelector('source');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (source && source.dataset.src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source.src = source.dataset.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.load();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;showPlayButton(video) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const button = document.createElement('button');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;button.textContent = '▶ Play';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;button.onclick = () => video.play();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;video.parentElement.appendChild(button);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>HTML для lazy loading:</h4><p><code>&lt;video data-autoplay muted loop&gt;</code><br><code>&nbsp;&nbsp;&lt;source data-src=\"video.mp4\" type=\"video/mp4\"&gt;</code><br><code>&lt;/video&gt;</code></p><h4>Применения:</h4><ul><li>Автовоспроизведение промо-видео</li><li>Видео-фоны секций</li><li>Анимированные истории</li><li>Видео-превью в галереях</li></ul><p><em>Важно:</em> Всегда обрабатывайте .catch() для video.play(), так как браузеры могут блокировать autoplay.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'видео', 'autoplay', 'UX']
  },
  {
    id: 58,
    question: "Как использовать IntersectionObserver для анимаций при появлении элементов?",
    answer: "<p>IntersectionObserver идеален для запуска анимаций когда элемент появляется в viewport:</p><h4>HTML разметка с data-атрибутами:</h4><p><code>&lt;div data-animate=\"fade-in\" data-delay=\"0\"&gt;Content 1&lt;/div&gt;</code><br><code>&lt;div data-animate=\"slide-up\" data-delay=\"100\"&gt;Content 2&lt;/div&gt;</code><br><code>&lt;div data-animate=\"scale-in\" data-delay=\"200\"&gt;Content 3&lt;/div&gt;</code></p><h4>Реализация:</h4><p><code>class AnimatedElementsObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.1,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '0px 0px -100px 0px' // Триггер чуть выше низа viewport</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animatedElements = document.querySelectorAll('[data-animate]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Добавляем начальное состояние</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animatedElements.forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el.classList.add('before-animation');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(el);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const animationType = element.dataset.animate;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = parseInt(element.dataset.delay) || 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Запускаем анимацию с задержкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.remove('before-animation');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.add(\`animate-\${animationType}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Останавливаем наблюдение после анимации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>CSS анимации:</h4><p><code>/* Начальное состояние */</code><br><code>.before-animation {</code><br><code>&nbsp;&nbsp;opacity: 0;</code><br><code>}</code></p><p><code>/* Fade In */</code><br><code>.animate-fade-in {</code><br><code>&nbsp;&nbsp;animation: fadeIn 0.6s ease-out forwards;</code><br><code>}</code><br><code></code><br><code>@keyframes fadeIn {</code><br><code>&nbsp;&nbsp;from { opacity: 0; }</code><br><code>&nbsp;&nbsp;to { opacity: 1; }</code><br><code>}</code></p><p><code>/* Slide Up */</code><br><code>.animate-slide-up {</code><br><code>&nbsp;&nbsp;animation: slideUp 0.6s ease-out forwards;</code><br><code>}</code><br><code></code><br><code>@keyframes slideUp {</code><br><code>&nbsp;&nbsp;from {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: translateY(50px);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;to {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: translateY(0);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>/* Scale In */</code><br><code>.animate-scale-in {</code><br><code>&nbsp;&nbsp;animation: scaleIn 0.5s ease-out forwards;</code><br><code>}</code><br><code></code><br><code>@keyframes scaleIn {</code><br><code>&nbsp;&nbsp;from {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: scale(0.8);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;to {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: scale(1);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Повторяющиеся анимации:</h4><p><code>// Не останавливаем наблюдение для повторных анимаций</code><br><code>handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.add('animated');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.remove('animated');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Применения:</h4><ul><li>Появление элементов при прокрутке</li><li>Последовательные анимации списков</li><li>Параллакс эффекты</li><li>Прогрессивное раскрытие контента</li></ul><p><em>Best practice:</em> Останавливайте наблюдение после первой анимации для экономии ресурсов, если не нужны повторные анимации.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'анимации', 'CSS', 'UX']
  },
  {
    id: 59,
    question: "Как реализовать sticky navigation с изменением стилей через IntersectionObserver?",
    answer: "<p>IntersectionObserver позволяет элегантно отслеживать когда пользователь проскроллил страницу и изменять sticky header:</p><h4>HTML структура:</h4><p><code>&lt;header class=\"header\"&gt;</code><br><code>&nbsp;&nbsp;&lt;nav&gt;Navigation&lt;/nav&gt;</code><br><code>&lt;/header&gt;</code><br><code></code><br><code>&lt;main&gt;</code><br><code>&nbsp;&nbsp;&lt;!-- Контент --&gt;</code><br><code>&lt;/main&gt;</code></p><h4>Реализация с sentinel:</h4><p><code>class StickyHeaderObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.header = document.querySelector('header');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем невидимый sentinel элемент в начале страницы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.height = '1px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.position = 'absolute';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.top = '0';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.width = '100%';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.body.prepend(this.sentinel);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: [0, 1],</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '0px'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проскроллили вниз — делаем header компактным</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.header.classList.add('scrolled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Вернулись наверх — восстанавливаем обычный вид</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.header.classList.remove('scrolled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>CSS стили:</h4><p><code>header {</code><br><code>&nbsp;&nbsp;position: sticky;</code><br><code>&nbsp;&nbsp;top: 0;</code><br><code>&nbsp;&nbsp;padding: 20px;</code><br><code>&nbsp;&nbsp;background: white;</code><br><code>&nbsp;&nbsp;transition: all 0.3s ease;</code><br><code>&nbsp;&nbsp;box-shadow: none;</code><br><code>}</code></p><p><code>header.scrolled {</code><br><code>&nbsp;&nbsp;padding: 10px;</code><br><code>&nbsp;&nbsp;background: rgba(255, 255, 255, 0.95);</code><br><code>&nbsp;&nbsp;backdrop-filter: blur(10px);</code><br><code>&nbsp;&nbsp;box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);</code><br><code>}</code></p><p><code>header.scrolled nav {</code><br><code>&nbsp;&nbsp;font-size: 14px;</code><br><code>}</code></p><h4>Альтернатива — наблюдение за секциями:</h4><p><code>class SectionBasedNavigation {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sections = document.querySelectorAll('section');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.nav = document.querySelector('nav');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentSection = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '-100px 0px -100px 0px'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sections.forEach(section => this.observer.observe(section));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentSection = entry.target.id;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateNavigation();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;updateNavigation() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Убираем active со всех ссылок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const navLinks = this.nav.querySelectorAll('a');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;navLinks.forEach(link => link.classList.remove('active'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Добавляем active к текущей секции</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const currentLink = this.nav.querySelector(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`a[href=\"#\${this.currentSection}\"]\`</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (currentLink) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentLink.classList.add('active');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Применения:</h4><ul><li>Изменение внешнего вида header при скролле</li><li>Подсветка активной секции в навигации</li><li>Показ/скрытие элементов header</li><li>Изменение цветовой схемы</li></ul><p><em>Преимущество:</em> Не нужно слушать scroll event и вычислять позицию вручную — IntersectionObserver делает это эффективно.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'navigation', 'sticky header', 'UX']
  },
  {
    id: 60,
    question: "Какие есть подводные камни и ограничения при работе с IntersectionObserver?",
    answer: "<p>При работе с IntersectionObserver важно знать о возможных проблемах и ограничениях:</p><h4>1. Поддержка браузеров:</h4><p><strong>Проблема:</strong> Не поддерживается в старых браузерах (IE, старые Safari).</p><p><strong>Решение:</strong> Использовать полифилл или проверку поддержки:</p><p><code>if ('IntersectionObserver' in window) {</code><br><code>&nbsp;&nbsp;// Используем IntersectionObserver</code><br><code>} else {</code><br><code>&nbsp;&nbsp;// Fallback на scroll event</code><br><code>&nbsp;&nbsp;import('intersection-observer'); // полифилл</code><br><code>}</code></p><h4>2. Асинхронность callback:</h4><p><strong>Проблема:</strong> Callback не вызывается мгновенно, есть небольшая задержка.</p><p><strong>Решение:</strong> Учитывать задержку в логике, использовать rootMargin для предзагрузки.</p><h4>3. Изменение размеров элемента:</h4><p><strong>Проблема:</strong> Observer не отслеживает изменения размеров элемента автоматически.</p><p><strong>Решение:</strong> Использовать ResizeObserver в дополнение или переподписываться при изменениях:</p><p><code>const resizeObserver = new ResizeObserver(() => {</code><br><code>&nbsp;&nbsp;intersectionObserver.unobserve(element);</code><br><code>&nbsp;&nbsp;intersectionObserver.observe(element);</code><br><code>});</code></p><h4>4. Проблемы с iframe:</h4><p><strong>Проблема:</strong> IntersectionObserver не работает корректно для отслеживания элементов внутри iframe.</p><p><strong>Решение:</strong> Создавать отдельный Observer внутри iframe или использовать альтернативные методы.</p><h4>5. Производительность при большом количестве элементов:</h4><p><strong>Проблема:</strong> Наблюдение за тысячами элементов может снизить производительность.</p><p><strong>Решение:</strong> Ограничивать количество наблюдаемых элементов, использовать виртуализацию:</p><p><code>class MemoryEfficientObserver {</code><br><code>&nbsp;&nbsp;constructor(maxElements = 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxElements = maxElements;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Логика управления количеством</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Неточность при быстром скролле:</h4><p><strong>Проблема:</strong> При очень быстрой прокрутке callback может не успеть вызваться.</p><p><strong>Решение:</strong> Использовать больший rootMargin для предзагрузки.</p><h4>7. Нет контроля над порядком вызовов:</h4><p><strong>Проблема:</strong> При одновременном пересечении нескольких элементов порядок entries не гарантирован.</p><p><strong>Решение:</strong> Сортировать entries вручную если порядок важен:</p><p><code>entries.sort((a, b) => {</code><br><code>&nbsp;&nbsp;return a.boundingClientRect.top - b.boundingClientRect.top;</code><br><code>});</code></p><h4>8. Утечки памяти:</h4><p><strong>Проблема:</strong> Забытый Observer продолжает работать и занимать память.</p><p><strong>Решение:</strong> Всегда вызывать disconnect() при размонтировании:</p><p><code>componentWillUnmount() {</code><br><code>&nbsp;&nbsp;this.observer.disconnect();</code><br><code>}</code></p><h4>9. Root элемент с overflow:hidden:</h4><p><strong>Проблема:</strong> Может некорректно определять пересечения в некоторых случаях.</p><p><strong>Решение:</strong> Тестировать конкретные сценарии, возможно использовать родительский элемент как root.</p><h4>10. SSR проблемы:</h4><p><strong>Проблема:</strong> IntersectionObserver недоступен на сервере (Node.js).</p><p><strong>Решение:</strong> Создавать Observer только на клиенте:</p><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;if (typeof window !== 'undefined') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new IntersectionObserver(...);</code><br><code>&nbsp;&nbsp;}</code><br><code>}, []);</code></p><p><em>Вывод:</em> IntersectionObserver — мощный API, но требует понимания ограничений и правильной обработки edge cases.</p>",
    difficulty: 'senior',
    tags: ['IntersectionObserver', 'ограничения', 'проблемы', 'troubleshooting']
  }
];
