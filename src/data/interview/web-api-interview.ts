export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webAPIInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое Blob и для чего он используется?",
    answer: "<p><strong>Blob</strong> (Binary Large Object) — это объект, представляющий неизменяемые необработанные данные произвольного размера в двоичном формате.</p><p>Blob используется для работы с файлоподобными данными в браузере, когда нужно хранить, обрабатывать или передавать бинарные данные.</p><h4>Основные применения:</h4><ul><li><strong>Работа с файлами:</strong> Загрузка, скачивание, обработка файлов</li><li><strong>Медиа-контент:</strong> Создание URL для изображений, видео, аудио</li><li><strong>Генерация файлов:</strong> Создание текстовых файлов, CSV, JSON для скачивания</li><li><strong>Работа с Canvas:</strong> Экспорт изображений из canvas</li><li><strong>Передача данных:</strong> Отправка бинарных данных через Fetch API или XMLHttpRequest</li></ul><p>Blob имеет два основных свойства: <code>size</code> (размер в байтах) и <code>type</code> (MIME-тип данных). Данные внутри Blob неизменяемы, но можно создавать новые Blob на основе существующих.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'основы', 'бинарные данные']
  },
  {
    id: 2,
    question: "В чем разница между Blob и File?",
    answer: "<p><strong>File</strong> — это специализированный тип Blob, который содержит дополнительную информацию о файле.</p><h4>Ключевые различия:</h4><p><strong>File наследуется от Blob</strong> и добавляет дополнительные свойства:</p><ul><li><code>name</code> — имя файла</li><li><code>lastModified</code> — временная метка последнего изменения</li><li><code>lastModifiedDate</code> (устаревшее) — дата последнего изменения</li></ul><p><strong>Blob</strong> — это более общий объект для произвольных бинарных данных, который не связан с файловой системой.</p><h4>Создание:</h4><p>Blob создается программно через конструктор, а File обычно получается из <code>input[type='file']</code>, drag-and-drop или создается через конструктор File с указанием имени.</p><h4>Использование:</h4><p>File используется когда важна информация о файле (имя, дата), Blob — для работы с чистыми данными без метаинформации.</p><p><em>На практике:</em> File можно использовать везде, где ожидается Blob, так как File является его расширением.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'File', 'различия', 'наследование']
  },
  {
    id: 3,
    question: "Как создать Blob из различных типов данных?",
    answer: "<p>Blob можно создать из разных типов данных используя конструктор <code>new Blob()</code>:</p><h4>Из строки:</h4><p>Самый простой случай — передать массив со строкой. Второй параметр определяет MIME-тип.</p><p>Например: <code>new Blob(['Привет, мир!'], { type: 'text/plain' })</code></p><h4>Из ArrayBuffer:</h4><p>Для работы с бинарными данными можно использовать типизированные массивы:</p><p><code>const buffer = new Uint8Array([72, 101, 108, 108, 111]);</code><br><code>const blob = new Blob([buffer], { type: 'application/octet-stream' });</code></p><h4>Из другого Blob:</h4><p>Можно комбинировать несколько Blob в один новый Blob:</p><p><code>new Blob([blob1, blob2, 'текст'], { type: 'text/plain' })</code></p><h4>Из JSON:</h4><p>Полезно для создания файлов JSON:</p><p><code>const data = { name: 'John', age: 30 };</code><br><code>const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });</code></p><p><em>Важно:</em> Первый параметр конструктора всегда должен быть массивом, даже если передается один элемент.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'создание', 'конструктор', 'типы данных']
  },
  {
    id: 4,
    question: "Что такое Blob URL и как его создать?",
    answer: "<p><strong>Blob URL</strong> — это специальный URL-адрес, указывающий на Blob-объект в памяти браузера. Он позволяет работать с Blob как с обычным файлом по URL.</p><h4>Создание Blob URL:</h4><p>Используется метод <code>URL.createObjectURL(blob)</code>, который создает уникальную строку вида <code>blob:https://example.com/550e8400-e29b-41d4-a716-446655440000</code></p><h4>Применение:</h4><ul><li><strong>Отображение изображений:</strong> Установка blob URL как src для img элемента</li><li><strong>Скачивание файлов:</strong> Создание ссылки для загрузки сгенерированного контента</li><li><strong>Воспроизведение медиа:</strong> Использование в video или audio элементах</li><li><strong>Открытие в новой вкладке:</strong> window.open с blob URL</li></ul><h4>Освобождение памяти:</h4><p>Blob URL занимает память, пока существует. Важно освобождать его через <code>URL.revokeObjectURL(blobUrl)</code> когда он больше не нужен.</p><p><em>Best practice:</em> Всегда вызывайте revokeObjectURL после использования, особенно в long-running приложениях, чтобы избежать утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['Blob URL', 'память', 'createObjectURL', 'revokeObjectURL']
  },
  {
    id: 5,
    question: "Как прочитать содержимое Blob или File?",
    answer: "<p>Для чтения содержимого Blob/File используется <strong>FileReader API</strong>:</p><h4>Основные методы FileReader:</h4><p><strong>readAsText():</strong> Читает содержимое как текст. Можно указать кодировку вторым параметром.</p><p><strong>readAsDataURL():</strong> Преобразует в Data URL (base64). Удобно для отображения изображений.</p><p><strong>readAsArrayBuffer():</strong> Читает как ArrayBuffer для работы с бинарными данными.</p><p><strong>readAsBinaryString():</strong> Читает как бинарную строку (устаревший метод).</p><h4>События FileReader:</h4><ul><li><code>onload</code> — успешное чтение</li><li><code>onerror</code> — ошибка чтения</li><li><code>onprogress</code> — процесс чтения (для больших файлов)</li><li><code>onloadend</code> — завершение чтения (успешное или с ошибкой)</li></ul><h4>Современный подход:</h4><p>Можно использовать методы самого Blob: <code>text()</code>, <code>arrayBuffer()</code>, которые возвращают Promise:</p><p><code>const text = await blob.text();</code><br><code>const buffer = await blob.arrayBuffer();</code></p><p><em>Преимущество:</em> Promise-based API проще для работы с async/await.</p>",
    difficulty: 'middle',
    tags: ['FileReader', 'чтение', 'асинхронность', 'методы']
  },
  {
    id: 6,
    question: "Как реализовать скачивание файла, созданного в браузере?",
    answer: "<p>Скачивание файла из браузера реализуется через создание временной ссылки с Blob URL:</p><h4>Базовая реализация:</h4><p>1. Создаем Blob с нужным содержимым<br>2. Создаем Blob URL через <code>URL.createObjectURL()</code><br>3. Создаем ссылку (a элемент)<br>4. Устанавливаем href на Blob URL<br>5. Устанавливаем атрибут download с именем файла<br>6. Программно кликаем по ссылке<br>7. Удаляем ссылку и освобождаем URL</p><h4>Пример функции:</h4><p><code>function downloadFile(content, filename, type) {</code><br><code>&nbsp;&nbsp;const blob = new Blob([content], { type });</code><br><code>&nbsp;&nbsp;const url = URL.createObjectURL(blob);</code><br><code>&nbsp;&nbsp;const a = document.createElement('a');</code><br><code>&nbsp;&nbsp;a.href = url;</code><br><code>&nbsp;&nbsp;a.download = filename;</code><br><code>&nbsp;&nbsp;a.click();</code><br><code>&nbsp;&nbsp;URL.revokeObjectURL(url);</code><br><code>}</code></p><h4>Применение:</h4><p>Скачивание сгенерированных CSV, JSON, текстовых файлов, экспорт данных из canvas, сохранение пользовательского контента.</p><p><em>Важно:</em> Атрибут download работает только для same-origin URL и blob URL.</p>",
    difficulty: 'middle',
    tags: ['скачивание', 'download', 'практика', 'пользовательский опыт']
  },
  {
    id: 7,
    question: "Как работать с частями Blob через метод slice()?",
    answer: "<p>Метод <code>slice()</code> позволяет <strong>извлекать части Blob</strong> без копирования данных в память:</p><h4>Синтаксис:</h4><p><code>blob.slice(start, end, contentType)</code></p><ul><li><code>start</code> — начальная позиция (байт), по умолчанию 0</li><li><code>end</code> — конечная позиция (не включительно), по умолчанию blob.size</li><li><code>contentType</code> — MIME-тип нового Blob, по умолчанию пустая строка</li></ul><h4>Особенности:</h4><p>Slice не копирует данные в памяти — создается <strong>ссылка на часть оригинального Blob</strong>. Это делает операцию очень быстрой даже для больших файлов.</p><h4>Применение:</h4><p><strong>Chunked upload:</strong> Разделение большого файла на части для загрузки по частям.</p><p><strong>Чтение больших файлов:</strong> Обработка файла по частям, чтобы не загружать весь в память.</p><p><strong>Извлечение заголовков:</strong> Чтение первых байтов файла для определения типа.</p><p><strong>Манипуляция данными:</strong> Удаление или замена частей файла.</p><p><em>Производительность:</em> Slice работает за O(1), так как не копирует данные, только создает новый Blob-дескриптор.</p>",
    difficulty: 'middle',
    tags: ['slice', 'chunking', 'производительность', 'память']
  },
  {
    id: 8,
    question: "Как реализовать загрузку большого файла по частям (chunked upload)?",
    answer: "<p><strong>Chunked upload</strong> — это техника загрузки больших файлов по частям, что улучшает надежность и позволяет показывать прогресс:</p><h4>Алгоритм реализации:</h4><p><strong>1. Разбиение файла:</strong> Используем метод <code>slice()</code> для деления файла на части (chunks) фиксированного размера, например 1MB.</p><p><strong>2. Последовательная загрузка:</strong> Отправляем каждую часть отдельным запросом с информацией о позиции.</p><p><strong>3. Отслеживание прогресса:</strong> После каждой успешной загрузки обновляем прогресс-бар.</p><p><strong>4. Обработка ошибок:</strong> При неудаче повторяем загрузку конкретного chunk, а не всего файла.</p><p><strong>5. Финализация:</strong> После загрузки всех частей сервер собирает их в единый файл.</p><h4>Преимущества:</h4><ul><li>Возможность паузы и возобновления загрузки</li><li>Точный прогресс загрузки</li><li>Автоматическое восстановление после сетевых ошибок</li><li>Меньше нагрузка на память — загружаем по частям</li></ul><h4>На сервере:</h4><p>Сервер должен поддерживать прием частей, сохранять их с метаданными и собирать в финальный файл после получения всех chunk.</p>",
    difficulty: 'senior',
    tags: ['chunked upload', 'большие файлы', 'производительность', 'надежность']
  },
  {
    id: 9,
    question: "Как конвертировать изображение из canvas в Blob?",
    answer: "<p>Конвертация canvas в Blob используется для сохранения или загрузки изображений, созданных или отредактированных в браузере:</p><h4>Метод toBlob():</h4><p>Canvas предоставляет асинхронный метод <code>toBlob(callback, type, quality)</code>:</p><ul><li><code>callback</code> — функция, получающая созданный Blob</li><li><code>type</code> — MIME-тип (по умолчанию 'image/png')</li><li><code>quality</code> — качество для JPEG/WebP от 0 до 1</li></ul><h4>Промисификация:</h4><p>Для удобства можно обернуть в Promise:</p><p><code>function canvasToBlob(canvas, type, quality) {</code><br><code>&nbsp;&nbsp;return new Promise(resolve => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.toBlob(resolve, type, quality);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Применение:</h4><ul><li>Экспорт отредактированных изображений</li><li>Создание превью перед загрузкой</li><li>Применение фильтров и эффектов</li><li>Водяные знаки и аннотации</li><li>Оптимизация размера изображения</li></ul><h4>Форматы:</h4><p>Поддерживаются 'image/png', 'image/jpeg', 'image/webp'. PNG поддерживает прозрачность, JPEG — регулируемое качество для меньшего размера.</p>",
    difficulty: 'middle',
    tags: ['canvas', 'изображения', 'конвертация', 'toBlob']
  },
  {
    id: 10,
    question: "В чем разница между Data URL и Blob URL?",
    answer: "<p>Data URL и Blob URL — два способа представления бинарных данных в виде URL, но с разными характеристиками:</p><h4>Data URL:</h4><p><strong>Формат:</strong> <code>data:[MIME-type];base64,[закодированные данные]</code></p><p><strong>Характеристики:</strong></p><ul><li>Данные встроены прямо в URL</li><li>Очень длинная строка для больших файлов</li><li>Увеличивает размер на ~33% из-за base64</li><li>Можно копировать, сохранять, передавать</li><li>Работает везде, где принимается URL</li><li>Не требует освобождения памяти</li></ul><h4>Blob URL:</h4><p><strong>Формат:</strong> <code>blob:https://example.com/uuid</code></p><p><strong>Характеристики:</strong></p><ul><li>Короткая строка-ссылка на данные в памяти</li><li>Не увеличивает размер — ссылка фиксированной длины</li><li>Работает только в текущей сессии браузера</li><li>Требует явного освобождения памяти</li><li>Быстрее для больших файлов</li><li>Нельзя передать между страницами/вкладками</li></ul><h4>Когда использовать:</h4><p><strong>Data URL:</strong> Маленькие изображения, иконки, inline-вставки, когда нужна переносимость.</p><p><strong>Blob URL:</strong> Большие файлы, временный контент, когда важна производительность.</p>",
    difficulty: 'middle',
    tags: ['Data URL', 'Blob URL', 'различия', 'производительность']
  },
  {
    id: 11,
    question: "Как обработать drag-and-drop файлов?",
    answer: "<p>Drag-and-drop файлов реализуется через <strong>HTML5 Drag and Drop API</strong> в сочетании с File API:</p><h4>Основные события:</h4><p><strong>dragover:</strong> Срабатывает когда элемент перетаскивается над зоной. Нужно вызвать <code>preventDefault()</code> для разрешения drop.</p><p><strong>drop:</strong> Срабатывает когда элемент отпускают в зоне. Здесь получаем файлы.</p><p><strong>dragleave:</strong> Срабатывает когда элемент покидает зону (для визуального feedback).</p><h4>Получение файлов:</h4><p>Файлы доступны через <code>event.dataTransfer.files</code> — это FileList, похожий на массив File объектов.</p><h4>Реализация:</h4><p><code>dropZone.addEventListener('dragover', (e) => {</code><br><code>&nbsp;&nbsp;e.preventDefault();</code><br><code>&nbsp;&nbsp;dropZone.classList.add('drag-over');</code><br><code>});</code></p><p><code>dropZone.addEventListener('drop', async (e) => {</code><br><code>&nbsp;&nbsp;e.preventDefault();</code><br><code>&nbsp;&nbsp;const files = Array.from(e.dataTransfer.files);</code><br><code>&nbsp;&nbsp;// обработка файлов</code><br><code>});</code></p><h4>Улучшения UX:</h4><ul><li>Визуальный feedback при наведении</li><li>Валидация типов файлов</li><li>Превью изображений</li><li>Прогресс загрузки</li></ul>",
    difficulty: 'middle',
    tags: ['drag-and-drop', 'File API', 'UX', 'события']
  },
  {
    id: 12,
    question: "Как проверить MIME-тип файла на клиенте?",
    answer: "<p>Проверка MIME-типа файла важна для валидации загружаемых файлов:</p><h4>Свойство file.type:</h4><p>File объект имеет свойство <code>type</code>, содержащее MIME-тип, например 'image/jpeg', 'application/pdf'.</p><p><strong>Ограничение:</strong> Это значение определяется по расширению файла и может быть легко подделано. Нельзя полагаться только на него для безопасности.</p><h4>Проверка сигнатуры (magic numbers):</h4><p>Для надежной проверки читаем первые байты файла и сравниваем с известными сигнатурами:</p><ul><li>JPEG: FF D8 FF</li><li>PNG: 89 50 4E 47</li><li>PDF: 25 50 44 46</li><li>ZIP: 50 4B 03 04</li></ul><p>Читаем начало файла через <code>slice()</code> и <code>arrayBuffer()</code>, затем сравниваем байты.</p><h4>Комплексный подход:</h4><p><strong>1. Базовая проверка:</strong> file.type для быстрой фильтрации</p><p><strong>2. Сигнатура:</strong> Проверка magic numbers для важных файлов</p><p><strong>3. Серверная валидация:</strong> Окончательная проверка на сервере</p><p><em>Безопасность:</em> Клиентская проверка — только для UX. Всегда валидируйте на сервере.</p>",
    difficulty: 'senior',
    tags: ['MIME-тип', 'валидация', 'безопасность', 'magic numbers']
  },
  {
    id: 13,
    question: "Как работать с Blob в Service Worker?",
    answer: "<p>Service Worker может работать с Blob для <strong>кэширования, оффлайн-доступа и обработки файлов</strong>:</p><h4>Кэширование Blob:</h4><p>В Service Worker можно перехватывать запросы и создавать Response с Blob:</p><p><code>const blob = new Blob(['cached content'], { type: 'text/html' });</code><br><code>return new Response(blob, { status: 200 });</code></p><h4>Обработка файлов:</h4><p>Service Worker может получать файлы через <code>fetch()</code>, обрабатывать их и возвращать модифицированный Blob.</p><h4>Offline-first стратегия:</h4><p>При отсутствии сети Service Worker может отдавать закэшированные Blob-ресурсы из Cache API.</p><h4>Особенности:</h4><ul><li>Blob можно сохранять в Cache API</li><li>Можно создавать синтетические Response с Blob</li><li>Полезно для обработки изображений, оптимизации</li><li>Можно проксировать и трансформировать контент</li></ul><h4>Применение:</h4><p>Оффлайн-режим для медиа-контента, динамическая генерация ресурсов, оптимизация изображений на лету, прокси для внешних ресурсов.</p><p><em>Важно:</em> Blob в Service Worker работает асинхронно, используйте Promise API.</p>",
    difficulty: 'senior',
    tags: ['Service Worker', 'кэширование', 'offline', 'производительность']
  },
  {
    id: 14,
    question: "Какие есть ограничения и best practices при работе с Blob?",
    answer: "<p>При работе с Blob важно понимать ограничения и следовать лучшим практикам:</p><h4>Ограничения памяти:</h4><p><strong>Размер:</strong> Blob хранится в памяти браузера. Для очень больших файлов (гигабайты) может не хватить памяти.</p><p><strong>Blob URL:</strong> Каждый созданный Blob URL занимает память до вызова <code>revokeObjectURL()</code>.</p><h4>Best Practices:</h4><p><strong>Освобождение ресурсов:</strong> Всегда вызывайте <code>URL.revokeObjectURL()</code> после использования Blob URL.</p><p><strong>Обработка по частям:</strong> Для больших файлов используйте <code>slice()</code> и обрабатывайте chunk за chunk.</p><p><strong>Проверка размера:</strong> Проверяйте <code>blob.size</code> перед обработкой и устанавливайте лимиты.</p><p><strong>Типизация:</strong> Всегда указывайте правильный MIME-тип при создании Blob.</p><p><strong>Обработка ошибок:</strong> FileReader может выбросить ошибку при чтении, всегда обрабатывайте <code>onerror</code>.</p><h4>Производительность:</h4><ul><li>Используйте Workers для обработки больших файлов</li><li>Избегайте создания множества Blob URL одновременно</li><li>Кэшируйте обработанные Blob где возможно</li></ul>",
    difficulty: 'senior',
    tags: ['ограничения', 'best practices', 'производительность', 'память']
  },
  {
    id: 15,
    question: "Как использовать Blob с Web Workers?",
    answer: "<p>Web Workers позволяют обрабатывать Blob в <strong>отдельном потоке</strong>, не блокируя основной поток:</p><h4>Передача Blob в Worker:</h4><p>Blob можно передать в Worker через <code>postMessage()</code>. Браузер автоматически клонирует Blob, используя structured clone algorithm.</p><p><code>worker.postMessage({ blob: myBlob });</code></p><h4>Transferable Objects:</h4><p>Для больших данных можно использовать <strong>transferable objects</strong> с ArrayBuffer, чтобы передать владение без копирования:</p><p><code>const buffer = await blob.arrayBuffer();</code><br><code>worker.postMessage({ buffer }, [buffer]);</code></p><h4>Применение:</h4><p><strong>Обработка изображений:</strong> Ресайз, фильтры, компрессия в фоне.</p><p><strong>Парсинг файлов:</strong> CSV, JSON, XML больших размеров.</p><p><strong>Шифрование/дешифрование:</strong> Криптографические операции.</p><p><strong>Генерация контента:</strong> Создание PDF, ZIP файлов.</p><h4>Паттерн использования:</h4><p>1. Передаем Blob/ArrayBuffer в Worker<br>2. Worker обрабатывает данные<br>3. Worker возвращает результат (Blob или данные)<br>4. Основной поток использует результат</p><p><em>Преимущество:</em> Интерфейс остается отзывчивым во время тяжелых операций с файлами.</p>",
    difficulty: 'senior',
    tags: ['Web Workers', 'многопоточность', 'производительность', 'асинхронность']
  },
  {
    id: 16,
    question: "В чем главное различие между Fetch API и XMLHttpRequest?",
    answer: "<p>Основные различия между Fetch API и XMLHttpRequest:</p><h4>Fetch API:</h4><ul><li><strong>Promise-based:</strong> Возвращает Promise, отлично работает с async/await</li><li><strong>Современный синтаксис:</strong> Более чистый и читаемый код</li><li><strong>Streaming:</strong> Поддержка ReadableStream для прогресса скачивания</li><li><strong>Только асинхронный:</strong> Нет синхронных запросов</li></ul><h4>XMLHttpRequest:</h4><ul><li><strong>Callback-based:</strong> Использует события (onload, onerror)</li><li><strong>Upload progress:</strong> Единственный способ отследить прогресс ОТПРАВКИ через xhr.upload.onprogress</li><li><strong>Синхронные запросы:</strong> Поддерживает (хотя deprecated)</li><li><strong>Встроенный timeout:</strong> Свойство xhr.timeout</li></ul><p><em>Ключевое отличие:</em> XMLHttpRequest — единственный способ получить прогресс загрузки файла на сервер, что критично для upload с progress bar.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'XMLHttpRequest', 'различия', 'HTTP']
  },
  {
    id: 17,
    question: "Как отследить прогресс загрузки файла на сервер?",
    answer: "<p>Прогресс загрузки файла на сервер можно отследить <strong>только через XMLHttpRequest</strong> с использованием события <code>xhr.upload.onprogress</code>:</p><h4>Реализация:</h4><p><code>const xhr = new XMLHttpRequest();</code><br><code>const formData = new FormData();</code><br><code>formData.append('file', file);</code></p><p><code>xhr.upload.onprogress = (event) => {</code><br><code>&nbsp;&nbsp;if (event.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const percent = (event.loaded / event.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Загружено: ' + percent + '%');</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><p><code>xhr.open('POST', '/upload');</code><br><code>xhr.send(formData);</code></p><h4>Важные события xhr.upload:</h4><ul><li><code>onloadstart</code> — начало отправки</li><li><code>onprogress</code> — процесс отправки (ключевое!)</li><li><code>onload</code> — файл отправлен на сервер</li><li><code>onerror</code> — ошибка при отправке</li><li><code>onabort</code> — отправка отменена</li></ul><p><strong>Критично:</strong> Fetch API НЕ предоставляет возможности отслеживать прогресс отправки! Fetch может отслеживать только прогресс скачивания через ReadableStream.</p>",
    difficulty: 'middle',
    tags: ['XMLHttpRequest', 'upload progress', 'файлы', 'события']
  },
  {
    id: 18,
    question: "Почему Fetch API не подходит для событий beforeunload/unload?",
    answer: "<p>Fetch API может не успеть выполниться при закрытии страницы, так как браузер может прервать асинхронные операции:</p><h4>Проблема с Fetch:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;fetch('/analytics', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({ event: 'page_close' })</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;// ⚠️ Запрос может быть прерван!</code><br><code>});</code></p><h4>Правильные решения:</h4><p><strong>1. navigator.sendBeacon (ЛУЧШИЙ):</strong></p><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;navigator.sendBeacon('/analytics', JSON.stringify(data));</code><br><code>});</code></p><p><strong>2. Fetch с keepalive:</strong></p><p><code>fetch('/analytics', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: JSON.stringify(data),</code><br><code>&nbsp;&nbsp;keepalive: true  // Гарантирует завершение</code><br><code>});</code></p><p><strong>3. XMLHttpRequest синхронный (fallback):</strong></p><p><code>const xhr = new XMLHttpRequest();</code><br><code>xhr.open('POST', '/analytics', false);  // синхронный</code><br><code>xhr.send(JSON.stringify(data));</code></p><p><em>Вывод:</em> Для beforeunload используйте sendBeacon или keepalive, обычный Fetch ненадежен.</p>",
    difficulty: 'senior',
    tags: ['Fetch', 'beforeunload', 'sendBeacon', 'XMLHttpRequest']
  },
  {
    id: 19,
    question: "Что такое navigator.sendBeacon и когда его использовать?",
    answer: "<p><strong>navigator.sendBeacon</strong> — метод для надежной отправки небольших данных на сервер, который гарантирует доставку даже при закрытии страницы:</p><h4>Синтаксис:</h4><p><code>navigator.sendBeacon(url, data)</code></p><p>Возвращает <code>true</code> если данные успешно поставлены в очередь, иначе <code>false</code>.</p><h4>Особенности:</h4><ul><li><strong>Асинхронный:</strong> Не блокирует закрытие страницы</li><li><strong>Гарантированная отправка:</strong> Браузер отправит данные даже после закрытия</li><li><strong>Ограничение размера:</strong> Обычно до 64KB</li><li><strong>POST запрос:</strong> Всегда отправляется как POST</li><li><strong>Нет ответа:</strong> Невозможно получить response</li></ul><h4>Типичное использование:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;const data = JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;event: 'page_close',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;url: window.location.href</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;navigator.sendBeacon('/analytics', data);</code><br><code>});</code></p><h4>Когда использовать:</h4><ul><li>Отправка аналитики при закрытии страницы</li><li>Сбор метрик времени на странице</li><li>Логирование пользовательских действий</li><li>Отправка статистики сессии</li></ul>",
    difficulty: 'middle',
    tags: ['sendBeacon', 'аналитика', 'beforeunload', 'Web API']
  },
  {
    id: 20,
    question: "Как отменить Fetch запрос?",
    answer: "<p>Для отмены Fetch запроса используется <strong>AbortController</strong>:</p><h4>Базовая отмена:</h4><p><code>const controller = new AbortController();</code></p><p><code>fetch('/api/data', {</code><br><code>&nbsp;&nbsp;signal: controller.signal</code><br><code>})</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить запрос</code><br><code>controller.abort();</code></p><h4>Timeout через AbortController:</h4><p><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Request timeout');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отмена предыдущих запросов:</h4><p><code>let controller;</code><br><code>searchInput.addEventListener('input', async (e) => {</code><br><code>&nbsp;&nbsp;if (controller) controller.abort();</code><br><code>&nbsp;&nbsp;controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const results = await fetch('/search?q=' + e.target.value, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p>",
    difficulty: 'middle',
    tags: ['Fetch', 'AbortController', 'отмена запроса', 'timeout']
  },
  {
    id: 21,
    question: "Почему Fetch не выбрасывает ошибку для HTTP 404 или 500?",
    answer: "<p>Fetch считает любой полученный HTTP-ответ успешным выполнением Promise, даже если это код ошибки (4xx, 5xx):</p><h4>Поведение Fetch:</h4><p><code>fetch('/api/users/999')</code><br><code>&nbsp;&nbsp;.then(response => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(response.status);  // 404</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(response.ok);      // false</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Promise НЕ rejected!</code><br><code>&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сюда попадем только при СЕТЕВОЙ ошибке</code><br><code>&nbsp;&nbsp;});</code></p><h4>Правильная обработка:</h4><p><code>async function fetchUser(id) {</code><br><code>&nbsp;&nbsp;const response = await fetch(\`/api/users/\${id}\`);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP error! status: \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.json();</code><br><code>}</code></p><h4>Универсальная обертка:</h4><p><code>async function safeFetch(url, options) {</code><br><code>&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const error = new Error('HTTP Error');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.status = response.status;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.response = response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response;</code><br><code>}</code></p><p><strong>Причина:</strong> Promise отклоняется только при сетевых ошибках (нет интернета, DNS ошибка), но НЕ при HTTP ошибках. Всегда проверяйте <code>response.ok</code> или <code>response.status</code>.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'обработка ошибок', 'HTTP статусы', 'Promise']
  },
  {
    id: 22,
    question: "В чем разница между прогрессом загрузки (download) и прогрессом отправки (upload)?",
    answer: "<p>Это два разных процесса передачи данных, требующие разных подходов для отслеживания:</p><h4>Download Progress (скачивание с сервера):</h4><p><strong>Fetch API — ReadableStream:</strong></p><p><code>const response = await fetch('/large-file');</code><br><code>const reader = response.body.getReader();</code><br><code>const contentLength = +response.headers.get('Content-Length');</code><br><code>let receivedLength = 0;</code><br><code></code><br><code>while (true) {</code><br><code>&nbsp;&nbsp;const { done, value } = await reader.read();</code><br><code>&nbsp;&nbsp;if (done) break;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;receivedLength += value.length;</code><br><code>&nbsp;&nbsp;const percent = (receivedLength / contentLength) * 100;</code><br><code>}</code></p><p><strong>XMLHttpRequest — onprogress:</strong></p><p><code>xhr.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>};</code></p><h4>Upload Progress (отправка на сервер):</h4><p><strong>Только XMLHttpRequest — upload.onprogress:</strong></p><p><code>xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;console.log('Отправлено на сервер: ' + percent + '%');</code><br><code>};</code></p><p><strong>❌ Fetch НЕ поддерживает:</strong> Нет способа отследить прогресс отправки данных на сервер через Fetch API!</p><h4>Ключевое различие:</h4><ul><li><strong>Download:</strong> Fetch ✅ (через ReadableStream), XHR ✅ (через onprogress)</li><li><strong>Upload:</strong> Fetch ❌ (нет API), XHR ✅ (через upload.onprogress)</li></ul>",
    difficulty: 'senior',
    tags: ['progress', 'upload', 'download', 'ReadableStream']
  },
  {
    id: 23,
    question: "Как реализовать retry механизм для Fetch?",
    answer: "<p>Retry механизм позволяет автоматически повторять неудачные запросы с exponential backoff:</p><h4>Базовая реализация:</h4><p><code>async function fetchWithRetry(url, options = {}, maxRetries = 3) {</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === maxRetries) throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exponential backoff: 1s, 2s, 4s...</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.pow(2, attempt) * 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${maxRetries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await new Promise(resolve => setTimeout(resolve, delay));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>С селективным retry:</h4><p><code>async function smartRetry(url, options = {}, config = {}) {</code><br><code>&nbsp;&nbsp;const {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;maxRetries = 3,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;retryOn = [500, 502, 503, 504],  // Только серверные ошибки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;retryDelay = 1000</code><br><code>&nbsp;&nbsp;} = config;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response.ok) return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Не retry для 4xx ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!retryOn.includes(response.status)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt < maxRetries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await new Promise(r => setTimeout(r, retryDelay * (attempt + 1)));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === maxRetries) throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'senior',
    tags: ['Fetch', 'retry', 'надежность', 'error handling']
  },
  {
    id: 24,
    question: "Как обрабатывать различные типы ответов в Fetch?",
    answer: "<p>Fetch предоставляет разные методы для обработки различных типов контента:</p><h4>Основные методы Response:</h4><p><code>response.json()</code> — парсит JSON<br><code>response.text()</code> — возвращает текст<br><code>response.blob()</code> — возвращает Blob (файлы, изображения)<br><code>response.arrayBuffer()</code> — возвращает ArrayBuffer (бинарные данные)<br><code>response.formData()</code> — парсит FormData</p><h4>Автоматическое определение типа:</h4><p><code>async function handleResponse(response) {</code><br><code>&nbsp;&nbsp;const contentType = response.headers.get('content-type');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('application/json')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('text/')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.text();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('image/')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.blob();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.arrayBuffer();</code><br><code>}</code></p><h4>Работа с изображениями:</h4><p><code>const response = await fetch('/image.jpg');</code><br><code>const blob = await response.blob();</code><br><code>const imageUrl = URL.createObjectURL(blob);</code><br><code>img.src = imageUrl;</code></p><h4>Работа с файлами:</h4><p><code>const response = await fetch('/document.pdf');</code><br><code>const blob = await response.blob();</code><br><code>const url = URL.createObjectURL(blob);</code><br><code>const a = document.createElement('a');</code><br><code>a.href = url;</code><br><code>a.download = 'document.pdf';</code><br><code>a.click();</code></p><p><strong>Важно:</strong> Методы response.json(), text(), blob() можно вызвать только ОДИН раз!</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'Response', 'типы данных', 'content-type']
  },
  {
    id: 25,
    question: "Как работает chunked upload большого файла?",
    answer: "<p><strong>Chunked upload</strong> — техника загрузки больших файлов по частям для повышения надежности и отображения прогресса:</p><h4>Алгоритм:</h4><p><strong>1. Разбиение файла:</strong> Используем <code>file.slice()</code> для деления на chunks</p><p><code>const chunkSize = 1024 * 1024;  // 1MB</code><br><code>const totalChunks = Math.ceil(file.size / chunkSize);</code></p><p><strong>2. Отправка chunk:</strong></p><p><code>for (let i = 0; i < totalChunks; i++) {</code><br><code>&nbsp;&nbsp;const start = i * chunkSize;</code><br><code>&nbsp;&nbsp;const end = Math.min(start + chunkSize, file.size);</code><br><code>&nbsp;&nbsp;const chunk = file.slice(start, end);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const formData = new FormData();</code><br><code>&nbsp;&nbsp;formData.append('chunk', chunk);</code><br><code>&nbsp;&nbsp;formData.append('chunkIndex', i);</code><br><code>&nbsp;&nbsp;formData.append('totalChunks', totalChunks);</code><br><code>&nbsp;&nbsp;formData.append('filename', file.name);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;await uploadChunk(formData, i);</code><br><code>}</code></p><p><strong>3. Отслеживание прогресса:</strong> Используем XMLHttpRequest для каждого chunk:</p><p><code>function uploadChunk(formData, index) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const chunkProgress = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const totalProgress = ((index + chunkProgress/100) / totalChunks) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateProgressBar(totalProgress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => reject();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('POST', '/upload-chunk');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(formData);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Преимущества:</h4><ul><li>Возможность паузы и возобновления</li><li>Автоматический retry при ошибке chunk</li><li>Точный прогресс загрузки</li><li>Меньше нагрузка на память</li></ul>",
    difficulty: 'senior',
    tags: ['chunked upload', 'большие файлы', 'XMLHttpRequest', 'производительность']
  },
  {
    id: 26,
    question: "Какие заголовки важны при работе с Fetch и как их устанавливать?",
    answer: "<p>Заголовки (headers) критичны для правильной работы HTTP-запросов:</p><h4>Установка заголовков:</h4><p><code>fetch('/api/users', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;headers: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Content-Type': 'application/json',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Authorization': 'Bearer token123',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Accept': 'application/json'</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;body: JSON.stringify({ name: 'John' })</code><br><code>});</code></p><h4>Важные заголовки запроса:</h4><ul><li><code>Content-Type</code> — тип отправляемых данных (application/json, multipart/form-data)</li><li><code>Authorization</code> — токен аутентификации (Bearer, Basic)</li><li><code>Accept</code> — ожидаемый тип ответа</li><li><code>Accept-Language</code> — предпочитаемый язык</li></ul><h4>Работа с Headers API:</h4><p><code>const headers = new Headers();</code><br><code>headers.append('Content-Type', 'application/json');</code><br><code>headers.append('Authorization', 'Bearer token');</code><br><code></code><br><code>fetch('/api/data', { headers });</code></p><h4>Чтение заголовков ответа:</h4><p><code>const response = await fetch('/api/data');</code><br><code></code><br><code>const contentType = response.headers.get('content-type');</code><br><code>const date = response.headers.get('date');</code><br><code></code><br><code>// Итерация по всем заголовкам</code><br><code>for (let [key, value] of response.headers) {</code><br><code>&nbsp;&nbsp;console.log(\`\${key}: \${value}\`);</code><br><code>}</code></p><h4>Важно для FormData:</h4><p><code>const formData = new FormData();</code><br><code>formData.append('file', file);</code><br><code></code><br><code>fetch('/upload', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: formData</code><br><code>&nbsp;&nbsp;// НЕ устанавливайте Content-Type!</code><br><code>&nbsp;&nbsp;// Браузер установит правильный multipart/form-data с boundary</code><br><code>});</code></p>",
    difficulty: 'middle',
    tags: ['Fetch', 'headers', 'HTTP', 'Content-Type']
  },
  {
    id: 27,
    question: "Как реализовать универсальную функцию для HTTP-запросов, которая использует Fetch или XHR в зависимости от задачи?",
    answer: "<p>Универсальная функция должна автоматически выбирать между Fetch и XMLHttpRequest в зависимости от требований:</p><h4>Реализация:</h4><p><code>async function universalRequest(url, options = {}) {</code><br><code>&nbsp;&nbsp;const {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method = 'GET',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers = {},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;uploadProgress,    // Если нужен — используем XHR</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;downloadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = 0</code><br><code>&nbsp;&nbsp;} = options;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Если нужен upload progress — ТОЛЬКО XHR</code><br><code>&nbsp;&nbsp;if (uploadProgress) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return xhrRequest(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uploadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;downloadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Иначе используем Fetch</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (timeout) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.json();</code><br><code>}</code></p><h4>XHR часть:</h4><p><code>function xhrRequest(url, options) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (options.uploadProgress) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options.uploadProgress((e.loaded / e.total) * 100);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (xhr.status >= 200 && xhr.status < 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(JSON.parse(xhr.responseText));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error(\`HTTP \${xhr.status}\`));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open(options.method, url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(options.body);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p>",
    difficulty: 'senior',
    tags: ['Fetch', 'XMLHttpRequest', 'универсальность', 'API wrapper']
  },
  {
    id: 28,
    question: "Что такое keepalive в Fetch и когда его использовать?",
    answer: "<p>Опция <code>keepalive: true</code> в Fetch гарантирует, что запрос будет завершен даже если страница закрывается:</p><h4>Синтаксис:</h4><p><code>fetch('/analytics', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: JSON.stringify(data),</code><br><code>&nbsp;&nbsp;keepalive: true  // Ключевая опция!</code><br><code>});</code></p><h4>Назначение:</h4><ul><li>Запрос продолжит выполняться после закрытия страницы</li><li>Браузер гарантирует завершение запроса</li><li>Не блокирует UI как синхронный XHR</li></ul><h4>Использование в beforeunload:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;fetch('/analytics', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event: 'page_close',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;keepalive: true</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Ограничения:</h4><ul><li>Размер тела запроса ограничен (обычно ~64KB)</li><li>Невозможно получить response (запрос асинхронный)</li><li>Подходит только для POST запросов с небольшими данными</li></ul><h4>Сравнение с альтернативами:</h4><table><tr><th>Метод</th><th>Гарантия</th><th>Размер</th><th>Блокировка UI</th></tr><tr><td>sendBeacon</td><td>✅</td><td>~64KB</td><td>❌</td></tr><tr><td>Fetch keepalive</td><td>✅</td><td>~64KB</td><td>❌</td></tr><tr><td>XHR sync</td><td>✅</td><td>Без ограничений</td><td>✅ (плохо!)</td></tr><tr><td>Обычный Fetch</td><td>❌</td><td>Без ограничений</td><td>❌</td></tr></table><p><em>Вывод:</em> Для аналитики при закрытии страницы используйте sendBeacon или Fetch с keepalive.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'keepalive', 'beforeunload', 'аналитика']
  },
  {
    id: 29,
    question: "Как обрабатывать CORS ошибки в Fetch?",
    answer: "<p>CORS (Cross-Origin Resource Sharing) ошибки возникают при запросах к другому домену:</p><h4>Типичная CORS ошибка:</h4><p><code>fetch('https://api.example.com/data')</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// TypeError: Failed to fetch</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// (может быть CORS или сетевая ошибка)</code><br><code>&nbsp;&nbsp;});</code></p><h4>Режимы CORS:</h4><p><code>fetch(url, {</code><br><code>&nbsp;&nbsp;mode: 'cors',        // По умолчанию, требует CORS заголовков</code><br><code>&nbsp;&nbsp;mode: 'no-cors',     // Непрозрачный ответ, нельзя прочитать</code><br><code>&nbsp;&nbsp;mode: 'same-origin'  // Только same-origin запросы</code><br><code>});</code></p><h4>Отправка credentials:</h4><p><code>fetch('https://api.example.com/data', {</code><br><code>&nbsp;&nbsp;credentials: 'include'  // Отправляет cookies cross-origin</code><br><code>});</code></p><p>Опции: <code>'omit'</code> (не отправлять), <code>'same-origin'</code> (только same-origin), <code>'include'</code> (всегда)</p><h4>Обработка CORS ошибок:</h4><p><code>async function fetchWithCORSHandling(url) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode: 'cors',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;credentials: 'include'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error instanceof TypeError) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Вероятно CORS или сетевая ошибка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('CORS or network error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Не удалось подключиться к серверу');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Важно помнить:</h4><ul><li>CORS настраивается на СЕРВЕРЕ, не на клиенте</li><li>Fetch не может обойти CORS</li><li>mode: 'no-cors' не решает проблему (нельзя прочитать ответ)</li><li>Для development используйте прокси или CORS плагин</li></ul>",
    difficulty: 'middle',
    tags: ['Fetch', 'CORS', 'безопасность', 'cross-origin']
  },
  {
    id: 30,
    question: "Как отследить прогресс скачивания файла через Fetch?",
    answer: "<p>Для отслеживания прогресса скачивания Fetch использует <strong>ReadableStream API</strong>:</p><h4>Базовая реализация:</h4><p><code>async function downloadWithProgress(url, onProgress) {</code><br><code>&nbsp;&nbsp;const response = await fetch(url);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Получаем общий размер</code><br><code>&nbsp;&nbsp;const contentLength = +response.headers.get('Content-Length');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Создаем reader для чтения потока</code><br><code>&nbsp;&nbsp;const reader = response.body.getReader();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;let receivedLength = 0;</code><br><code>&nbsp;&nbsp;const chunks = [];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;while (true) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const { done, value } = await reader.read();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (done) break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;chunks.push(value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;receivedLength += value.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызываем callback прогресса</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const percent = (receivedLength / contentLength) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;onProgress(percent, receivedLength, contentLength);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Собираем все chunk в один Blob</code><br><code>&nbsp;&nbsp;return new Blob(chunks);</code><br><code>}</code></p><h4>Использование:</h4><p><code>const blob = await downloadWithProgress(</code><br><code>&nbsp;&nbsp;'/large-file.zip',</code><br><code>&nbsp;&nbsp;(percent, loaded, total) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Скачано: \${percent.toFixed(2)}%\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${loaded} из \${total} байт\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обновление UI</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;progressBar.style.width = percent + '%';</code><br><code>&nbsp;&nbsp;}</code><br><code>);</code><br><code></code><br><code>// Сохранение файла</code><br><code>const url = URL.createObjectURL(blob);</code><br><code>const a = document.createElement('a');</code><br><code>a.href = url;</code><br><code>a.download = 'file.zip';</code><br><code>a.click();</code></p><h4>Важное отличие:</h4><ul><li><strong>Fetch ReadableStream:</strong> Прогресс СКАЧИВАНИЯ (download) ✅</li><li><strong>XHR upload.onprogress:</strong> Прогресс ОТПРАВКИ (upload) ✅</li></ul>",
    difficulty: 'senior',
    tags: ['Fetch', 'ReadableStream', 'download progress', 'скачивание']
  }
];
