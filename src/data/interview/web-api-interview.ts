export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const webAPIInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое Blob и для чего он используется?",
    answer: "<p><strong>Blob</strong> (Binary Large Object) — это объект, представляющий неизменяемые необработанные данные произвольного размера в двоичном формате.</p><p>Blob используется для работы с файлоподобными данными в браузере, когда нужно хранить, обрабатывать или передавать бинарные данные.</p><h4>Основные применения:</h4><ul><li><strong>Работа с файлами:</strong> Загрузка, скачивание, обработка файлов</li><li><strong>Медиа-контент:</strong> Создание URL для изображений, видео, аудио</li><li><strong>Генерация файлов:</strong> Создание текстовых файлов, CSV, JSON для скачивания</li><li><strong>Работа с Canvas:</strong> Экспорт изображений из canvas</li><li><strong>Передача данных:</strong> Отправка бинарных данных через Fetch API или XMLHttpRequest</li></ul><p>Blob имеет два основных свойства: <code>size</code> (размер в байтах) и <code>type</code> (MIME-тип данных). Данные внутри Blob неизменяемы, но можно создавать новые Blob на основе существующих.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'основы', 'бинарные данные']
  },
  {
    id: 2,
    question: "В чем разница между Blob и File?",
    answer: "<p><strong>File</strong> — это специализированный тип Blob, который содержит дополнительную информацию о файле.</p><h4>Ключевые различия:</h4><p><strong>File наследуется от Blob</strong> и добавляет дополнительные свойства:</p><ul><li><code>name</code> — имя файла</li><li><code>lastModified</code> — временная метка последнего изменения</li><li><code>lastModifiedDate</code> (устаревшее) — дата последнего изменения</li></ul><p><strong>Blob</strong> — это более общий объект для произвольных бинарных данных, который не связан с файловой системой.</p><h4>Создание:</h4><p>Blob создается программно через конструктор, а File обычно получается из <code>input[type='file']</code>, drag-and-drop или создается через конструктор File с указанием имени.</p><h4>Использование:</h4><p>File используется когда важна информация о файле (имя, дата), Blob — для работы с чистыми данными без метаинформации.</p><p><em>На практике:</em> File можно использовать везде, где ожидается Blob, так как File является его расширением.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'File', 'различия', 'наследование']
  },
  {
    id: 3,
    question: "Как создать Blob из различных типов данных?",
    answer: "<p>Blob можно создать из разных типов данных используя конструктор <code>new Blob()</code>:</p><h4>Из строки:</h4><p>Самый простой случай — передать массив со строкой. Второй параметр определяет MIME-тип.</p><p>Например: <code>new Blob(['Привет, мир!'], { type: 'text/plain' })</code></p><h4>Из ArrayBuffer:</h4><p>Для работы с бинарными данными можно использовать типизированные массивы:</p><p><code>const buffer = new Uint8Array([72, 101, 108, 108, 111]);</code><br><code>const blob = new Blob([buffer], { type: 'application/octet-stream' });</code></p><h4>Из другого Blob:</h4><p>Можно комбинировать несколько Blob в один новый Blob:</p><p><code>new Blob([blob1, blob2, 'текст'], { type: 'text/plain' })</code></p><h4>Из JSON:</h4><p>Полезно для создания файлов JSON:</p><p><code>const data = { name: 'John', age: 30 };</code><br><code>const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });</code></p><p><em>Важно:</em> Первый параметр конструктора всегда должен быть массивом, даже если передается один элемент.</p>",
    difficulty: 'junior',
    tags: ['Blob', 'создание', 'конструктор', 'типы данных']
  },
  {
    id: 4,
    question: "Что такое Blob URL и как его создать?",
    answer: "<p><strong>Blob URL</strong> — это специальный URL-адрес, указывающий на Blob-объект в памяти браузера. Он позволяет работать с Blob как с обычным файлом по URL.</p><h4>Создание Blob URL:</h4><p>Используется метод <code>URL.createObjectURL(blob)</code>, который создает уникальную строку вида <code>blob:https://example.com/550e8400-e29b-41d4-a716-446655440000</code></p><h4>Применение:</h4><ul><li><strong>Отображение изображений:</strong> Установка blob URL как src для img элемента</li><li><strong>Скачивание файлов:</strong> Создание ссылки для загрузки сгенерированного контента</li><li><strong>Воспроизведение медиа:</strong> Использование в video или audio элементах</li><li><strong>Открытие в новой вкладке:</strong> window.open с blob URL</li></ul><h4>Освобождение памяти:</h4><p>Blob URL занимает память, пока существует. Важно освобождать его через <code>URL.revokeObjectURL(blobUrl)</code> когда он больше не нужен.</p><p><em>Best practice:</em> Всегда вызывайте revokeObjectURL после использования, особенно в long-running приложениях, чтобы избежать утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['Blob URL', 'память', 'createObjectURL', 'revokeObjectURL']
  },
  {
    id: 5,
    question: "Как прочитать содержимое Blob или File?",
    answer: "<p>Для чтения содержимого Blob/File используется <strong>FileReader API</strong>:</p><h4>Основные методы FileReader:</h4><p><strong>readAsText():</strong> Читает содержимое как текст. Можно указать кодировку вторым параметром.</p><p><strong>readAsDataURL():</strong> Преобразует в Data URL (base64). Удобно для отображения изображений.</p><p><strong>readAsArrayBuffer():</strong> Читает как ArrayBuffer для работы с бинарными данными.</p><p><strong>readAsBinaryString():</strong> Читает как бинарную строку (устаревший метод).</p><h4>События FileReader:</h4><ul><li><code>onload</code> — успешное чтение</li><li><code>onerror</code> — ошибка чтения</li><li><code>onprogress</code> — процесс чтения (для больших файлов)</li><li><code>onloadend</code> — завершение чтения (успешное или с ошибкой)</li></ul><h4>Современный подход:</h4><p>Можно использовать методы самого Blob: <code>text()</code>, <code>arrayBuffer()</code>, которые возвращают Promise:</p><p><code>const text = await blob.text();</code><br><code>const buffer = await blob.arrayBuffer();</code></p><p><em>Преимущество:</em> Promise-based API проще для работы с async/await.</p>",
    difficulty: 'middle',
    tags: ['FileReader', 'чтение', 'асинхронность', 'методы']
  },
  {
    id: 6,
    question: "Как реализовать скачивание файла, созданного в браузере?",
    answer: "<p>Скачивание файла из браузера реализуется через создание временной ссылки с Blob URL:</p><h4>Базовая реализация:</h4><p>1. Создаем Blob с нужным содержимым<br>2. Создаем Blob URL через <code>URL.createObjectURL()</code><br>3. Создаем ссылку (a элемент)<br>4. Устанавливаем href на Blob URL<br>5. Устанавливаем атрибут download с именем файла<br>6. Программно кликаем по ссылке<br>7. Удаляем ссылку и освобождаем URL</p><h4>Пример функции:</h4><p><code>function downloadFile(content, filename, type) {</code><br><code>&nbsp;&nbsp;const blob = new Blob([content], { type });</code><br><code>&nbsp;&nbsp;const url = URL.createObjectURL(blob);</code><br><code>&nbsp;&nbsp;const a = document.createElement('a');</code><br><code>&nbsp;&nbsp;a.href = url;</code><br><code>&nbsp;&nbsp;a.download = filename;</code><br><code>&nbsp;&nbsp;a.click();</code><br><code>&nbsp;&nbsp;URL.revokeObjectURL(url);</code><br><code>}</code></p><h4>Применение:</h4><p>Скачивание сгенерированных CSV, JSON, текстовых файлов, экспорт данных из canvas, сохранение пользовательского контента.</p><p><em>Важно:</em> Атрибут download работает только для same-origin URL и blob URL.</p>",
    difficulty: 'middle',
    tags: ['скачивание', 'download', 'практика', 'пользовательский опыт']
  },
  {
    id: 7,
    question: "Как работать с частями Blob через метод slice()?",
    answer: "<p>Метод <code>slice()</code> позволяет <strong>извлекать части Blob</strong> без копирования данных в память:</p><h4>Синтаксис:</h4><p><code>blob.slice(start, end, contentType)</code></p><ul><li><code>start</code> — начальная позиция (байт), по умолчанию 0</li><li><code>end</code> — конечная позиция (не включительно), по умолчанию blob.size</li><li><code>contentType</code> — MIME-тип нового Blob, по умолчанию пустая строка</li></ul><h4>Особенности:</h4><p>Slice не копирует данные в памяти — создается <strong>ссылка на часть оригинального Blob</strong>. Это делает операцию очень быстрой даже для больших файлов.</p><h4>Применение:</h4><p><strong>Chunked upload:</strong> Разделение большого файла на части для загрузки по частям.</p><p><strong>Чтение больших файлов:</strong> Обработка файла по частям, чтобы не загружать весь в память.</p><p><strong>Извлечение заголовков:</strong> Чтение первых байтов файла для определения типа.</p><p><strong>Манипуляция данными:</strong> Удаление или замена частей файла.</p><p><em>Производительность:</em> Slice работает за O(1), так как не копирует данные, только создает новый Blob-дескриптор.</p>",
    difficulty: 'middle',
    tags: ['slice', 'chunking', 'производительность', 'память']
  },
  {
    id: 8,
    question: "Как реализовать загрузку большого файла по частям (chunked upload)?",
    answer: "<p><strong>Chunked upload</strong> — это техника загрузки больших файлов по частям, что улучшает надежность и позволяет показывать прогресс:</p><h4>Алгоритм реализации:</h4><p><strong>1. Разбиение файла:</strong> Используем метод <code>slice()</code> для деления файла на части (chunks) фиксированного размера, например 1MB.</p><p><strong>2. Последовательная загрузка:</strong> Отправляем каждую часть отдельным запросом с информацией о позиции.</p><p><strong>3. Отслеживание прогресса:</strong> После каждой успешной загрузки обновляем прогресс-бар.</p><p><strong>4. Обработка ошибок:</strong> При неудаче повторяем загрузку конкретного chunk, а не всего файла.</p><p><strong>5. Финализация:</strong> После загрузки всех частей сервер собирает их в единый файл.</p><h4>Преимущества:</h4><ul><li>Возможность паузы и возобновления загрузки</li><li>Точный прогресс загрузки</li><li>Автоматическое восстановление после сетевых ошибок</li><li>Меньше нагрузка на память — загружаем по частям</li></ul><h4>На сервере:</h4><p>Сервер должен поддерживать прием частей, сохранять их с метаданными и собирать в финальный файл после получения всех chunk.</p>",
    difficulty: 'senior',
    tags: ['chunked upload', 'большие файлы', 'производительность', 'надежность']
  },
  {
    id: 9,
    question: "Как конвертировать изображение из canvas в Blob?",
    answer: "<p>Конвертация canvas в Blob используется для сохранения или загрузки изображений, созданных или отредактированных в браузере:</p><h4>Метод toBlob():</h4><p>Canvas предоставляет асинхронный метод <code>toBlob(callback, type, quality)</code>:</p><ul><li><code>callback</code> — функция, получающая созданный Blob</li><li><code>type</code> — MIME-тип (по умолчанию 'image/png')</li><li><code>quality</code> — качество для JPEG/WebP от 0 до 1</li></ul><h4>Промисификация:</h4><p>Для удобства можно обернуть в Promise:</p><p><code>function canvasToBlob(canvas, type, quality) {</code><br><code>&nbsp;&nbsp;return new Promise(resolve => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.toBlob(resolve, type, quality);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Применение:</h4><ul><li>Экспорт отредактированных изображений</li><li>Создание превью перед загрузкой</li><li>Применение фильтров и эффектов</li><li>Водяные знаки и аннотации</li><li>Оптимизация размера изображения</li></ul><h4>Форматы:</h4><p>Поддерживаются 'image/png', 'image/jpeg', 'image/webp'. PNG поддерживает прозрачность, JPEG — регулируемое качество для меньшего размера.</p>",
    difficulty: 'middle',
    tags: ['canvas', 'изображения', 'конвертация', 'toBlob']
  },
  {
    id: 10,
    question: "В чем разница между Data URL и Blob URL?",
    answer: "<p>Data URL и Blob URL — два способа представления бинарных данных в виде URL, но с разными характеристиками:</p><h4>Data URL:</h4><p><strong>Формат:</strong> <code>data:[MIME-type];base64,[закодированные данные]</code></p><p><strong>Характеристики:</strong></p><ul><li>Данные встроены прямо в URL</li><li>Очень длинная строка для больших файлов</li><li>Увеличивает размер на ~33% из-за base64</li><li>Можно копировать, сохранять, передавать</li><li>Работает везде, где принимается URL</li><li>Не требует освобождения памяти</li></ul><h4>Blob URL:</h4><p><strong>Формат:</strong> <code>blob:https://example.com/uuid</code></p><p><strong>Характеристики:</strong></p><ul><li>Короткая строка-ссылка на данные в памяти</li><li>Не увеличивает размер — ссылка фиксированной длины</li><li>Работает только в текущей сессии браузера</li><li>Требует явного освобождения памяти</li><li>Быстрее для больших файлов</li><li>Нельзя передать между страницами/вкладками</li></ul><h4>Когда использовать:</h4><p><strong>Data URL:</strong> Маленькие изображения, иконки, inline-вставки, когда нужна переносимость.</p><p><strong>Blob URL:</strong> Большие файлы, временный контент, когда важна производительность.</p>",
    difficulty: 'middle',
    tags: ['Data URL', 'Blob URL', 'различия', 'производительность']
  },
  {
    id: 11,
    question: "Как обработать drag-and-drop файлов?",
    answer: "<p>Drag-and-drop файлов реализуется через <strong>HTML5 Drag and Drop API</strong> в сочетании с File API:</p><h4>Основные события:</h4><p><strong>dragover:</strong> Срабатывает когда элемент перетаскивается над зоной. Нужно вызвать <code>preventDefault()</code> для разрешения drop.</p><p><strong>drop:</strong> Срабатывает когда элемент отпускают в зоне. Здесь получаем файлы.</p><p><strong>dragleave:</strong> Срабатывает когда элемент покидает зону (для визуального feedback).</p><h4>Получение файлов:</h4><p>Файлы доступны через <code>event.dataTransfer.files</code> — это FileList, похожий на массив File объектов.</p><h4>Реализация:</h4><p><code>dropZone.addEventListener('dragover', (e) => {</code><br><code>&nbsp;&nbsp;e.preventDefault();</code><br><code>&nbsp;&nbsp;dropZone.classList.add('drag-over');</code><br><code>});</code></p><p><code>dropZone.addEventListener('drop', async (e) => {</code><br><code>&nbsp;&nbsp;e.preventDefault();</code><br><code>&nbsp;&nbsp;const files = Array.from(e.dataTransfer.files);</code><br><code>&nbsp;&nbsp;// обработка файлов</code><br><code>});</code></p><h4>Улучшения UX:</h4><ul><li>Визуальный feedback при наведении</li><li>Валидация типов файлов</li><li>Превью изображений</li><li>Прогресс загрузки</li></ul>",
    difficulty: 'middle',
    tags: ['drag-and-drop', 'File API', 'UX', 'события']
  },
  {
    id: 12,
    question: "Как проверить MIME-тип файла на клиенте?",
    answer: "<p>Проверка MIME-типа файла важна для валидации загружаемых файлов:</p><h4>Свойство file.type:</h4><p>File объект имеет свойство <code>type</code>, содержащее MIME-тип, например 'image/jpeg', 'application/pdf'.</p><p><strong>Ограничение:</strong> Это значение определяется по расширению файла и может быть легко подделано. Нельзя полагаться только на него для безопасности.</p><h4>Проверка сигнатуры (magic numbers):</h4><p>Для надежной проверки читаем первые байты файла и сравниваем с известными сигнатурами:</p><ul><li>JPEG: FF D8 FF</li><li>PNG: 89 50 4E 47</li><li>PDF: 25 50 44 46</li><li>ZIP: 50 4B 03 04</li></ul><p>Читаем начало файла через <code>slice()</code> и <code>arrayBuffer()</code>, затем сравниваем байты.</p><h4>Комплексный подход:</h4><p><strong>1. Базовая проверка:</strong> file.type для быстрой фильтрации</p><p><strong>2. Сигнатура:</strong> Проверка magic numbers для важных файлов</p><p><strong>3. Серверная валидация:</strong> Окончательная проверка на сервере</p><p><em>Безопасность:</em> Клиентская проверка — только для UX. Всегда валидируйте на сервере.</p>",
    difficulty: 'senior',
    tags: ['MIME-тип', 'валидация', 'безопасность', 'magic numbers']
  },
  {
    id: 13,
    question: "Как работать с Blob в Service Worker?",
    answer: "<p>Service Worker может работать с Blob для <strong>кэширования, оффлайн-доступа и обработки файлов</strong>:</p><h4>Кэширование Blob:</h4><p>В Service Worker можно перехватывать запросы и создавать Response с Blob:</p><p><code>const blob = new Blob(['cached content'], { type: 'text/html' });</code><br><code>return new Response(blob, { status: 200 });</code></p><h4>Обработка файлов:</h4><p>Service Worker может получать файлы через <code>fetch()</code>, обрабатывать их и возвращать модифицированный Blob.</p><h4>Offline-first стратегия:</h4><p>При отсутствии сети Service Worker может отдавать закэшированные Blob-ресурсы из Cache API.</p><h4>Особенности:</h4><ul><li>Blob можно сохранять в Cache API</li><li>Можно создавать синтетические Response с Blob</li><li>Полезно для обработки изображений, оптимизации</li><li>Можно проксировать и трансформировать контент</li></ul><h4>Применение:</h4><p>Оффлайн-режим для медиа-контента, динамическая генерация ресурсов, оптимизация изображений на лету, прокси для внешних ресурсов.</p><p><em>Важно:</em> Blob в Service Worker работает асинхронно, используйте Promise API.</p>",
    difficulty: 'senior',
    tags: ['Service Worker', 'кэширование', 'offline', 'производительность']
  },
  {
    id: 14,
    question: "Какие есть ограничения и best practices при работе с Blob?",
    answer: "<p>При работе с Blob важно понимать ограничения и следовать лучшим практикам:</p><h4>Ограничения памяти:</h4><p><strong>Размер:</strong> Blob хранится в памяти браузера. Для очень больших файлов (гигабайты) может не хватить памяти.</p><p><strong>Blob URL:</strong> Каждый созданный Blob URL занимает память до вызова <code>revokeObjectURL()</code>.</p><h4>Best Practices:</h4><p><strong>Освобождение ресурсов:</strong> Всегда вызывайте <code>URL.revokeObjectURL()</code> после использования Blob URL.</p><p><strong>Обработка по частям:</strong> Для больших файлов используйте <code>slice()</code> и обрабатывайте chunk за chunk.</p><p><strong>Проверка размера:</strong> Проверяйте <code>blob.size</code> перед обработкой и устанавливайте лимиты.</p><p><strong>Типизация:</strong> Всегда указывайте правильный MIME-тип при создании Blob.</p><p><strong>Обработка ошибок:</strong> FileReader может выбросить ошибку при чтении, всегда обрабатывайте <code>onerror</code>.</p><h4>Производительность:</h4><ul><li>Используйте Workers для обработки больших файлов</li><li>Избегайте создания множества Blob URL одновременно</li><li>Кэшируйте обработанные Blob где возможно</li></ul>",
    difficulty: 'senior',
    tags: ['ограничения', 'best practices', 'производительность', 'память']
  },
  {
    id: 15,
    question: "Как использовать Blob с Web Workers?",
    answer: "<p>Web Workers позволяют обрабатывать Blob в <strong>отдельном потоке</strong>, не блокируя основной поток:</p><h4>Передача Blob в Worker:</h4><p>Blob можно передать в Worker через <code>postMessage()</code>. Браузер автоматически клонирует Blob, используя structured clone algorithm.</p><p><code>worker.postMessage({ blob: myBlob });</code></p><h4>Transferable Objects:</h4><p>Для больших данных можно использовать <strong>transferable objects</strong> с ArrayBuffer, чтобы передать владение без копирования:</p><p><code>const buffer = await blob.arrayBuffer();</code><br><code>worker.postMessage({ buffer }, [buffer]);</code></p><h4>Применение:</h4><p><strong>Обработка изображений:</strong> Ресайз, фильтры, компрессия в фоне.</p><p><strong>Парсинг файлов:</strong> CSV, JSON, XML больших размеров.</p><p><strong>Шифрование/дешифрование:</strong> Криптографические операции.</p><p><strong>Генерация контента:</strong> Создание PDF, ZIP файлов.</p><h4>Паттерн использования:</h4><p>1. Передаем Blob/ArrayBuffer в Worker<br>2. Worker обрабатывает данные<br>3. Worker возвращает результат (Blob или данные)<br>4. Основной поток использует результат</p><p><em>Преимущество:</em> Интерфейс остается отзывчивым во время тяжелых операций с файлами.</p>",
    difficulty: 'senior',
    tags: ['Web Workers', 'многопоточность', 'производительность', 'асинхронность']
  },
  {
    id: 16,
    question: "В чем главное различие между Fetch API и XMLHttpRequest?",
    answer: "<p>Основные различия между Fetch API и XMLHttpRequest:</p><h4>Fetch API:</h4><ul><li><strong>Promise-based:</strong> Возвращает Promise, отлично работает с async/await</li><li><strong>Современный синтаксис:</strong> Более чистый и читаемый код</li><li><strong>Streaming:</strong> Поддержка ReadableStream для прогресса скачивания</li><li><strong>Только асинхронный:</strong> Нет синхронных запросов</li></ul><h4>XMLHttpRequest:</h4><ul><li><strong>Callback-based:</strong> Использует события (onload, onerror)</li><li><strong>Upload progress:</strong> Единственный способ отследить прогресс ОТПРАВКИ через xhr.upload.onprogress</li><li><strong>Синхронные запросы:</strong> Поддерживает (хотя deprecated)</li><li><strong>Встроенный timeout:</strong> Свойство xhr.timeout</li></ul><p><em>Ключевое отличие:</em> XMLHttpRequest — единственный способ получить прогресс загрузки файла на сервер, что критично для upload с progress bar.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'XMLHttpRequest', 'различия', 'HTTP']
  },
  {
    id: 17,
    question: "Как отследить прогресс загрузки файла на сервер?",
    answer: "<p>Прогресс загрузки файла на сервер можно отследить <strong>только через XMLHttpRequest</strong> с использованием события <code>xhr.upload.onprogress</code>:</p><h4>Реализация:</h4><p><code>const xhr = new XMLHttpRequest();</code><br><code>const formData = new FormData();</code><br><code>formData.append('file', file);</code></p><p><code>xhr.upload.onprogress = (event) => {</code><br><code>&nbsp;&nbsp;if (event.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const percent = (event.loaded / event.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Загружено: ' + percent + '%');</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><p><code>xhr.open('POST', '/upload');</code><br><code>xhr.send(formData);</code></p><h4>Важные события xhr.upload:</h4><ul><li><code>onloadstart</code> — начало отправки</li><li><code>onprogress</code> — процесс отправки (ключевое!)</li><li><code>onload</code> — файл отправлен на сервер</li><li><code>onerror</code> — ошибка при отправке</li><li><code>onabort</code> — отправка отменена</li></ul><p><strong>Критично:</strong> Fetch API НЕ предоставляет возможности отслеживать прогресс отправки! Fetch может отслеживать только прогресс скачивания через ReadableStream.</p>",
    difficulty: 'middle',
    tags: ['XMLHttpRequest', 'upload progress', 'файлы', 'события']
  },
  {
    id: 18,
    question: "Почему Fetch API не подходит для событий beforeunload/unload?",
    answer: "<p>Fetch API может не успеть выполниться при закрытии страницы, так как браузер может прервать асинхронные операции:</p><h4>Проблема с Fetch:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;fetch('/analytics', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({ event: 'page_close' })</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;// ⚠️ Запрос может быть прерван!</code><br><code>});</code></p><h4>Правильные решения:</h4><p><strong>1. navigator.sendBeacon (ЛУЧШИЙ):</strong></p><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;navigator.sendBeacon('/analytics', JSON.stringify(data));</code><br><code>});</code></p><p><strong>2. Fetch с keepalive:</strong></p><p><code>fetch('/analytics', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: JSON.stringify(data),</code><br><code>&nbsp;&nbsp;keepalive: true  // Гарантирует завершение</code><br><code>});</code></p><p><strong>3. XMLHttpRequest синхронный (fallback):</strong></p><p><code>const xhr = new XMLHttpRequest();</code><br><code>xhr.open('POST', '/analytics', false);  // синхронный</code><br><code>xhr.send(JSON.stringify(data));</code></p><p><em>Вывод:</em> Для beforeunload используйте sendBeacon или keepalive, обычный Fetch ненадежен.</p>",
    difficulty: 'senior',
    tags: ['Fetch', 'beforeunload', 'sendBeacon', 'XMLHttpRequest']
  },
  {
    id: 19,
    question: "Что такое navigator.sendBeacon и когда его использовать?",
    answer: "<p><strong>navigator.sendBeacon</strong> — метод для надежной отправки небольших данных на сервер, который гарантирует доставку даже при закрытии страницы:</p><h4>Синтаксис:</h4><p><code>navigator.sendBeacon(url, data)</code></p><p>Возвращает <code>true</code> если данные успешно поставлены в очередь, иначе <code>false</code>.</p><h4>Особенности:</h4><ul><li><strong>Асинхронный:</strong> Не блокирует закрытие страницы</li><li><strong>Гарантированная отправка:</strong> Браузер отправит данные даже после закрытия</li><li><strong>Ограничение размера:</strong> Обычно до 64KB</li><li><strong>POST запрос:</strong> Всегда отправляется как POST</li><li><strong>Нет ответа:</strong> Невозможно получить response</li></ul><h4>Типичное использование:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;const data = JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;event: 'page_close',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;url: window.location.href</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;navigator.sendBeacon('/analytics', data);</code><br><code>});</code></p><h4>Когда использовать:</h4><ul><li>Отправка аналитики при закрытии страницы</li><li>Сбор метрик времени на странице</li><li>Логирование пользовательских действий</li><li>Отправка статистики сессии</li></ul>",
    difficulty: 'middle',
    tags: ['sendBeacon', 'аналитика', 'beforeunload', 'Web API']
  },
  {
    id: 20,
    question: "Как отменить Fetch запрос?",
    answer: "<p>Для отмены Fetch запроса используется <strong>AbortController</strong>:</p><h4>Базовая отмена:</h4><p><code>const controller = new AbortController();</code></p><p><code>fetch('/api/data', {</code><br><code>&nbsp;&nbsp;signal: controller.signal</code><br><code>})</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить запрос</code><br><code>controller.abort();</code></p><h4>Timeout через AbortController:</h4><p><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Request timeout');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отмена предыдущих запросов:</h4><p><code>let controller;</code><br><code>searchInput.addEventListener('input', async (e) => {</code><br><code>&nbsp;&nbsp;if (controller) controller.abort();</code><br><code>&nbsp;&nbsp;controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const results = await fetch('/search?q=' + e.target.value, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p>",
    difficulty: 'middle',
    tags: ['Fetch', 'AbortController', 'отмена запроса', 'timeout']
  },
  {
    id: 21,
    question: "Почему Fetch не выбрасывает ошибку для HTTP 404 или 500?",
    answer: "<p>Fetch считает любой полученный HTTP-ответ успешным выполнением Promise, даже если это код ошибки (4xx, 5xx):</p><h4>Поведение Fetch:</h4><p><code>fetch('/api/users/999')</code><br><code>&nbsp;&nbsp;.then(response => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(response.status);  // 404</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(response.ok);      // false</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Promise НЕ rejected!</code><br><code>&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сюда попадем только при СЕТЕВОЙ ошибке</code><br><code>&nbsp;&nbsp;});</code></p><h4>Правильная обработка:</h4><p><code>async function fetchUser(id) {</code><br><code>&nbsp;&nbsp;const response = await fetch(\`/api/users/\${id}\`);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP error! status: \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.json();</code><br><code>}</code></p><h4>Универсальная обертка:</h4><p><code>async function safeFetch(url, options) {</code><br><code>&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const error = new Error('HTTP Error');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.status = response.status;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.response = response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response;</code><br><code>}</code></p><p><strong>Причина:</strong> Promise отклоняется только при сетевых ошибках (нет интернета, DNS ошибка), но НЕ при HTTP ошибках. Всегда проверяйте <code>response.ok</code> или <code>response.status</code>.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'обработка ошибок', 'HTTP статусы', 'Promise']
  },
  {
    id: 22,
    question: "В чем разница между прогрессом загрузки (download) и прогрессом отправки (upload)?",
    answer: "<p>Это два разных процесса передачи данных, требующие разных подходов для отслеживания:</p><h4>Download Progress (скачивание с сервера):</h4><p><strong>Fetch API — ReadableStream:</strong></p><p><code>const response = await fetch('/large-file');</code><br><code>const reader = response.body.getReader();</code><br><code>const contentLength = +response.headers.get('Content-Length');</code><br><code>let receivedLength = 0;</code><br><code></code><br><code>while (true) {</code><br><code>&nbsp;&nbsp;const { done, value } = await reader.read();</code><br><code>&nbsp;&nbsp;if (done) break;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;receivedLength += value.length;</code><br><code>&nbsp;&nbsp;const percent = (receivedLength / contentLength) * 100;</code><br><code>}</code></p><p><strong>XMLHttpRequest — onprogress:</strong></p><p><code>xhr.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>};</code></p><h4>Upload Progress (отправка на сервер):</h4><p><strong>Только XMLHttpRequest — upload.onprogress:</strong></p><p><code>xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;console.log('Отправлено на сервер: ' + percent + '%');</code><br><code>};</code></p><p><strong>❌ Fetch НЕ поддерживает:</strong> Нет способа отследить прогресс отправки данных на сервер через Fetch API!</p><h4>Ключевое различие:</h4><ul><li><strong>Download:</strong> Fetch ✅ (через ReadableStream), XHR ✅ (через onprogress)</li><li><strong>Upload:</strong> Fetch ❌ (нет API), XHR ✅ (через upload.onprogress)</li></ul>",
    difficulty: 'senior',
    tags: ['progress', 'upload', 'download', 'ReadableStream']
  },
  {
    id: 23,
    question: "Как реализовать retry механизм для Fetch?",
    answer: "<p>Retry механизм позволяет автоматически повторять неудачные запросы с exponential backoff:</p><h4>Базовая реализация:</h4><p><code>async function fetchWithRetry(url, options = {}, maxRetries = 3) {</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === maxRetries) throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exponential backoff: 1s, 2s, 4s...</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.pow(2, attempt) * 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${maxRetries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await new Promise(resolve => setTimeout(resolve, delay));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>С селективным retry:</h4><p><code>async function smartRetry(url, options = {}, config = {}) {</code><br><code>&nbsp;&nbsp;const {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;maxRetries = 3,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;retryOn = [500, 502, 503, 504],  // Только серверные ошибки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;retryDelay = 1000</code><br><code>&nbsp;&nbsp;} = config;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, options);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response.ok) return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Не retry для 4xx ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!retryOn.includes(response.status)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt < maxRetries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await new Promise(r => setTimeout(r, retryDelay * (attempt + 1)));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === maxRetries) throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'senior',
    tags: ['Fetch', 'retry', 'надежность', 'error handling']
  },
  {
    id: 24,
    question: "Как обрабатывать различные типы ответов в Fetch?",
    answer: "<p>Fetch предоставляет разные методы для обработки различных типов контента:</p><h4>Основные методы Response:</h4><p><code>response.json()</code> — парсит JSON<br><code>response.text()</code> — возвращает текст<br><code>response.blob()</code> — возвращает Blob (файлы, изображения)<br><code>response.arrayBuffer()</code> — возвращает ArrayBuffer (бинарные данные)<br><code>response.formData()</code> — парсит FormData</p><h4>Автоматическое определение типа:</h4><p><code>async function handleResponse(response) {</code><br><code>&nbsp;&nbsp;const contentType = response.headers.get('content-type');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('application/json')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('text/')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.text();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (contentType?.includes('image/')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.blob();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.arrayBuffer();</code><br><code>}</code></p><h4>Работа с изображениями:</h4><p><code>const response = await fetch('/image.jpg');</code><br><code>const blob = await response.blob();</code><br><code>const imageUrl = URL.createObjectURL(blob);</code><br><code>img.src = imageUrl;</code></p><h4>Работа с файлами:</h4><p><code>const response = await fetch('/document.pdf');</code><br><code>const blob = await response.blob();</code><br><code>const url = URL.createObjectURL(blob);</code><br><code>const a = document.createElement('a');</code><br><code>a.href = url;</code><br><code>a.download = 'document.pdf';</code><br><code>a.click();</code></p><p><strong>Важно:</strong> Методы response.json(), text(), blob() можно вызвать только ОДИН раз!</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'Response', 'типы данных', 'content-type']
  },
  {
    id: 25,
    question: "Как работает chunked upload большого файла?",
    answer: "<p><strong>Chunked upload</strong> — техника загрузки больших файлов по частям для повышения надежности и отображения прогресса:</p><h4>Алгоритм:</h4><p><strong>1. Разбиение файла:</strong> Используем <code>file.slice()</code> для деления на chunks</p><p><code>const chunkSize = 1024 * 1024;  // 1MB</code><br><code>const totalChunks = Math.ceil(file.size / chunkSize);</code></p><p><strong>2. Отправка chunk:</strong></p><p><code>for (let i = 0; i < totalChunks; i++) {</code><br><code>&nbsp;&nbsp;const start = i * chunkSize;</code><br><code>&nbsp;&nbsp;const end = Math.min(start + chunkSize, file.size);</code><br><code>&nbsp;&nbsp;const chunk = file.slice(start, end);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const formData = new FormData();</code><br><code>&nbsp;&nbsp;formData.append('chunk', chunk);</code><br><code>&nbsp;&nbsp;formData.append('chunkIndex', i);</code><br><code>&nbsp;&nbsp;formData.append('totalChunks', totalChunks);</code><br><code>&nbsp;&nbsp;formData.append('filename', file.name);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;await uploadChunk(formData, i);</code><br><code>}</code></p><p><strong>3. Отслеживание прогресса:</strong> Используем XMLHttpRequest для каждого chunk:</p><p><code>function uploadChunk(formData, index) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const chunkProgress = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const totalProgress = ((index + chunkProgress/100) / totalChunks) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateProgressBar(totalProgress);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => reject();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('POST', '/upload-chunk');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(formData);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Преимущества:</h4><ul><li>Возможность паузы и возобновления</li><li>Автоматический retry при ошибке chunk</li><li>Точный прогресс загрузки</li><li>Меньше нагрузка на память</li></ul>",
    difficulty: 'senior',
    tags: ['chunked upload', 'большие файлы', 'XMLHttpRequest', 'производительность']
  },
  {
    id: 26,
    question: "Какие заголовки важны при работе с Fetch и как их устанавливать?",
    answer: "<p>Заголовки (headers) критичны для правильной работы HTTP-запросов:</p><h4>Установка заголовков:</h4><p><code>fetch('/api/users', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;headers: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Content-Type': 'application/json',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Authorization': 'Bearer token123',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'Accept': 'application/json'</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;body: JSON.stringify({ name: 'John' })</code><br><code>});</code></p><h4>Важные заголовки запроса:</h4><ul><li><code>Content-Type</code> — тип отправляемых данных (application/json, multipart/form-data)</li><li><code>Authorization</code> — токен аутентификации (Bearer, Basic)</li><li><code>Accept</code> — ожидаемый тип ответа</li><li><code>Accept-Language</code> — предпочитаемый язык</li></ul><h4>Работа с Headers API:</h4><p><code>const headers = new Headers();</code><br><code>headers.append('Content-Type', 'application/json');</code><br><code>headers.append('Authorization', 'Bearer token');</code><br><code></code><br><code>fetch('/api/data', { headers });</code></p><h4>Чтение заголовков ответа:</h4><p><code>const response = await fetch('/api/data');</code><br><code></code><br><code>const contentType = response.headers.get('content-type');</code><br><code>const date = response.headers.get('date');</code><br><code></code><br><code>// Итерация по всем заголовкам</code><br><code>for (let [key, value] of response.headers) {</code><br><code>&nbsp;&nbsp;console.log(\`\${key}: \${value}\`);</code><br><code>}</code></p><h4>Важно для FormData:</h4><p><code>const formData = new FormData();</code><br><code>formData.append('file', file);</code><br><code></code><br><code>fetch('/upload', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: formData</code><br><code>&nbsp;&nbsp;// НЕ устанавливайте Content-Type!</code><br><code>&nbsp;&nbsp;// Браузер установит правильный multipart/form-data с boundary</code><br><code>});</code></p>",
    difficulty: 'middle',
    tags: ['Fetch', 'headers', 'HTTP', 'Content-Type']
  },
  {
    id: 27,
    question: "Как реализовать универсальную функцию для HTTP-запросов, которая использует Fetch или XHR в зависимости от задачи?",
    answer: "<p>Универсальная функция должна автоматически выбирать между Fetch и XMLHttpRequest в зависимости от требований:</p><h4>Реализация:</h4><p><code>async function universalRequest(url, options = {}) {</code><br><code>&nbsp;&nbsp;const {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method = 'GET',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers = {},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;uploadProgress,    // Если нужен — используем XHR</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;downloadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = 0</code><br><code>&nbsp;&nbsp;} = options;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Если нужен upload progress — ТОЛЬКО XHR</code><br><code>&nbsp;&nbsp;if (uploadProgress) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return xhrRequest(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uploadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;downloadProgress,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Иначе используем Fetch</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (timeout) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return response.json();</code><br><code>}</code></p><h4>XHR часть:</h4><p><code>function xhrRequest(url, options) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (options.uploadProgress) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options.uploadProgress((e.loaded / e.total) * 100);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (xhr.status >= 200 && xhr.status < 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(JSON.parse(xhr.responseText));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error(\`HTTP \${xhr.status}\`));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open(options.method, url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(options.body);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p>",
    difficulty: 'senior',
    tags: ['Fetch', 'XMLHttpRequest', 'универсальность', 'API wrapper']
  },
  {
    id: 28,
    question: "Что такое keepalive в Fetch и когда его использовать?",
    answer: "<p>Опция <code>keepalive: true</code> в Fetch гарантирует, что запрос будет завершен даже если страница закрывается:</p><h4>Синтаксис:</h4><p><code>fetch('/analytics', {</code><br><code>&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;body: JSON.stringify(data),</code><br><code>&nbsp;&nbsp;keepalive: true  // Ключевая опция!</code><br><code>});</code></p><h4>Назначение:</h4><ul><li>Запрос продолжит выполняться после закрытия страницы</li><li>Браузер гарантирует завершение запроса</li><li>Не блокирует UI как синхронный XHR</li></ul><h4>Использование в beforeunload:</h4><p><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;fetch('/analytics', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event: 'page_close',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;keepalive: true</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Ограничения:</h4><ul><li>Размер тела запроса ограничен (обычно ~64KB)</li><li>Невозможно получить response (запрос асинхронный)</li><li>Подходит только для POST запросов с небольшими данными</li></ul><h4>Сравнение с альтернативами:</h4><table><tr><th>Метод</th><th>Гарантия</th><th>Размер</th><th>Блокировка UI</th></tr><tr><td>sendBeacon</td><td>✅</td><td>~64KB</td><td>❌</td></tr><tr><td>Fetch keepalive</td><td>✅</td><td>~64KB</td><td>❌</td></tr><tr><td>XHR sync</td><td>✅</td><td>Без ограничений</td><td>✅ (плохо!)</td></tr><tr><td>Обычный Fetch</td><td>❌</td><td>Без ограничений</td><td>❌</td></tr></table><p><em>Вывод:</em> Для аналитики при закрытии страницы используйте sendBeacon или Fetch с keepalive.</p>",
    difficulty: 'middle',
    tags: ['Fetch', 'keepalive', 'beforeunload', 'аналитика']
  },
  {
    id: 29,
    question: "Как обрабатывать CORS ошибки в Fetch?",
    answer: "<p>CORS (Cross-Origin Resource Sharing) ошибки возникают при запросах к другому домену:</p><h4>Типичная CORS ошибка:</h4><p><code>fetch('https://api.example.com/data')</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// TypeError: Failed to fetch</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// (может быть CORS или сетевая ошибка)</code><br><code>&nbsp;&nbsp;});</code></p><h4>Режимы CORS:</h4><p><code>fetch(url, {</code><br><code>&nbsp;&nbsp;mode: 'cors',        // По умолчанию, требует CORS заголовков</code><br><code>&nbsp;&nbsp;mode: 'no-cors',     // Непрозрачный ответ, нельзя прочитать</code><br><code>&nbsp;&nbsp;mode: 'same-origin'  // Только same-origin запросы</code><br><code>});</code></p><h4>Отправка credentials:</h4><p><code>fetch('https://api.example.com/data', {</code><br><code>&nbsp;&nbsp;credentials: 'include'  // Отправляет cookies cross-origin</code><br><code>});</code></p><p>Опции: <code>'omit'</code> (не отправлять), <code>'same-origin'</code> (только same-origin), <code>'include'</code> (всегда)</p><h4>Обработка CORS ошибок:</h4><p><code>async function fetchWithCORSHandling(url) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode: 'cors',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;credentials: 'include'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error instanceof TypeError) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Вероятно CORS или сетевая ошибка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('CORS or network error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Не удалось подключиться к серверу');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Важно помнить:</h4><ul><li>CORS настраивается на СЕРВЕРЕ, не на клиенте</li><li>Fetch не может обойти CORS</li><li>mode: 'no-cors' не решает проблему (нельзя прочитать ответ)</li><li>Для development используйте прокси или CORS плагин</li></ul>",
    difficulty: 'middle',
    tags: ['Fetch', 'CORS', 'безопасность', 'cross-origin']
  },
  {
    id: 30,
    question: "Как отследить прогресс скачивания файла через Fetch?",
    answer: "<p>Для отслеживания прогресса скачивания Fetch использует <strong>ReadableStream API</strong>:</p><h4>Базовая реализация:</h4><p><code>async function downloadWithProgress(url, onProgress) {</code><br><code>&nbsp;&nbsp;const response = await fetch(url);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Получаем общий размер</code><br><code>&nbsp;&nbsp;const contentLength = +response.headers.get('Content-Length');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Создаем reader для чтения потока</code><br><code>&nbsp;&nbsp;const reader = response.body.getReader();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;let receivedLength = 0;</code><br><code>&nbsp;&nbsp;const chunks = [];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;while (true) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const { done, value } = await reader.read();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (done) break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;chunks.push(value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;receivedLength += value.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызываем callback прогресса</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const percent = (receivedLength / contentLength) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;onProgress(percent, receivedLength, contentLength);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Собираем все chunk в один Blob</code><br><code>&nbsp;&nbsp;return new Blob(chunks);</code><br><code>}</code></p><h4>Использование:</h4><p><code>const blob = await downloadWithProgress(</code><br><code>&nbsp;&nbsp;'/large-file.zip',</code><br><code>&nbsp;&nbsp;(percent, loaded, total) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Скачано: \${percent.toFixed(2)}%\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${loaded} из \${total} байт\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обновление UI</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;progressBar.style.width = percent + '%';</code><br><code>&nbsp;&nbsp;}</code><br><code>);</code><br><code></code><br><code>// Сохранение файла</code><br><code>const url = URL.createObjectURL(blob);</code><br><code>const a = document.createElement('a');</code><br><code>a.href = url;</code><br><code>a.download = 'file.zip';</code><br><code>a.click();</code></p><h4>Важное отличие:</h4><ul><li><strong>Fetch ReadableStream:</strong> Прогресс СКАЧИВАНИЯ (download) ✅</li><li><strong>XHR upload.onprogress:</strong> Прогресс ОТПРАВКИ (upload) ✅</li></ul>",
    difficulty: 'senior',
    tags: ['Fetch', 'ReadableStream', 'download progress', 'скачивание']
  },
  {
    id: 31,
    question: "Какие методы поддержания постоянного соединения с сервером существуют в JavaScript?",
    answer: "<p>В JavaScript существует несколько методов поддержания постоянного соединения с сервером:</p><h4>1. WebSocket</h4><p>Двусторонняя связь через протокол ws:// или wss://. Позволяет клиенту и серверу отправлять данные в любое время.</p><h4>2. Server-Sent Events (EventSource)</h4><p>Односторонняя связь от сервера к клиенту через HTTP. Автоматическое переподключение встроено.</p><h4>3. Long Polling</h4><p>Клиент отправляет запрос, сервер держит соединение открытым до появления данных, затем клиент сразу делает новый запрос.</p><h4>4. Short Polling (Regular Polling)</h4><p>Клиент периодически опрашивает сервер через обычные HTTP запросы с фиксированным интервалом.</p><h4>Сравнение методов:</h4><ul><li><strong>WebSocket:</strong> Лучшая производительность, минимальный overhead, требует специальный сервер</li><li><strong>EventSource:</strong> Проще в использовании, работает через HTTP, только от сервера к клиенту</li><li><strong>Long Polling:</strong> Универсальный fallback, больше нагрузка на сервер</li><li><strong>Short Polling:</strong> Самый простой, но неэффективный метод</li></ul><p><em>Выбор метода:</em> Зависит от требований к latency, направлению передачи данных, поддержки браузеров и инфраструктурных ограничений.</p>",
    difficulty: 'junior',
    tags: ['WebSocket', 'EventSource', 'Long Polling', 'методы соединения']
  },
  {
    id: 32,
    question: "Что такое WebSocket и как установить WebSocket соединение?",
    answer: "<p><strong>WebSocket</strong> — это протокол для двусторонней связи между клиентом и сервером через единое TCP соединение.</p><h4>Установка соединения:</h4><p><code>const ws = new WebSocket('ws://localhost:3000');</code></p><p>Для защищенного соединения используется wss:// протокол.</p><h4>Процесс установки соединения:</h4><p><strong>1. HTTP Upgrade:</strong> Клиент отправляет HTTP запрос с заголовками:<br><code>Upgrade: websocket</code><br><code>Connection: Upgrade</code></p><p><strong>2. Handshake:</strong> Сервер соглашается и отправляет статус 101 Switching Protocols</p><p><strong>3. Переключение:</strong> Соединение переключается с HTTP на WebSocket протокол</p><h4>События WebSocket:</h4><p><code>ws.onopen = () => console.log('Подключено');</code><br><code>ws.onmessage = (event) => console.log(event.data);</code><br><code>ws.onerror = (error) => console.error(error);</code><br><code>ws.onclose = () => console.log('Закрыто');</code></p><h4>Отправка данных:</h4><p><code>ws.send('Hello Server!');</code><br><code>ws.send(JSON.stringify({ type: 'message' }));</code><br><code>ws.send(new Uint8Array([1, 2, 3]));</code></p><p><em>Важно:</em> Перед отправкой проверяйте <code>ws.readyState === WebSocket.OPEN</code></p>",
    difficulty: 'junior',
    tags: ['WebSocket', 'соединение', 'протокол', 'handshake']
  },
  {
    id: 33,
    question: "Какие состояния (readyState) имеет WebSocket соединение?",
    answer: "<p>WebSocket имеет 4 состояния, доступных через свойство <code>readyState</code>:</p><h4>WebSocket.CONNECTING (0)</h4><p>Соединение устанавливается. WebSocket создан, но handshake еще не завершен. Отправка данных невозможна.</p><h4>WebSocket.OPEN (1)</h4><p>Соединение установлено и готово к обмену данными. Можно отправлять и получать сообщения.</p><p><code>if (ws.readyState === WebSocket.OPEN) {</code><br><code>&nbsp;&nbsp;ws.send('message');</code><br><code>}</code></p><h4>WebSocket.CLOSING (2)</h4><p>Соединение закрывается. Метод <code>close()</code> был вызван, но соединение еще не закрыто полностью.</p><h4>WebSocket.CLOSED (3)</h4><p>Соединение закрыто или не удалось установить. Больше нельзя отправлять или получать данные.</p><h4>Проверка состояния:</h4><p><code>console.log(ws.readyState);</code><br><code>// 0 - CONNECTING</code><br><code>// 1 - OPEN</code><br><code>// 2 - CLOSING</code><br><code>// 3 - CLOSED</code></p><h4>Практическое применение:</h4><p><code>function sendMessage(message) {</code><br><code>&nbsp;&nbsp;if (ws.readyState === WebSocket.OPEN) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.send(message);</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('WebSocket не готов');</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'middle',
    tags: ['WebSocket', 'readyState', 'состояния', 'lifecycle']
  },
  {
    id: 34,
    question: "Как реализовать автоматическое переподключение WebSocket при разрыве соединения?",
    answer: "<p>Автоматическое переподключение критично для надежности WebSocket соединений:</p><h4>Базовая реализация:</h4><p><code>class ReconnectingWebSocket {</code><br><code>&nbsp;&nbsp;constructor(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.url = url;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectInterval = options.reconnectInterval || 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxReconnectInterval = options.maxReconnectInterval || 30000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectDecay = options.reconnectDecay || 1.5;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectAttempts = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.forcedClose = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.messageQueue = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.connect();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;connect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = new WebSocket(this.url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onopen = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectAttempts = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.flushQueue();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onclose = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.forcedClose) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;reconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.min(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.maxReconnectInterval</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reconnectAttempts++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => this.connect(), delay);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Ключевые моменты:</h4><ul><li><strong>Экспоненциальная задержка:</strong> Увеличивает интервал между попытками</li><li><strong>Очередь сообщений:</strong> Сохраняет неотправленные сообщения</li><li><strong>Принудительное закрытие:</strong> Флаг для отличия намеренного закрытия от ошибки</li><li><strong>Ограничение задержки:</strong> Максимальный интервал переподключения</li></ul>",
    difficulty: 'senior',
    tags: ['WebSocket', 'переподключение', 'reconnection', 'надежность']
  },
  {
    id: 35,
    question: "Что такое heartbeat (ping-pong) в WebSocket и зачем он нужен?",
    answer: "<p><strong>Heartbeat (ping-pong)</strong> — механизм проверки жизнеспособности WebSocket соединения через периодическую отправку ping сообщений.</p><h4>Зачем нужен heartbeat:</h4><ul><li><strong>Обнаружение разрыва:</strong> Определяет неактивное соединение быстрее чем TCP timeout</li><li><strong>Keep-alive:</strong> Предотвращает закрытие соединения прокси/firewall</li><li><strong>Проверка доступности:</strong> Убеждается что сервер отвечает</li></ul><h4>Реализация:</h4><p><code>class WebSocketWithHeartbeat {</code><br><code>&nbsp;&nbsp;constructor(url, heartbeatInterval = 30000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = new WebSocket(url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.heartbeatInterval = heartbeatInterval;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.heartbeatTimer = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pongTimeout = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onopen = () => this.startHeartbeat();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onclose = () => this.stopHeartbeat();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = JSON.parse(event.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data.type === 'pong') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.pongTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;startHeartbeat() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.heartbeatTimer = setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({ type: 'ping' }));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pongTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Нет ответа на ping, переподключение...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.close();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 5000);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.heartbeatInterval);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>На сервере:</h4><p>Сервер должен отвечать на ping сообщения pong ответом для подтверждения активности.</p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'heartbeat', 'ping-pong', 'keep-alive']
  },
  {
    id: 36,
    question: "Что такое Server-Sent Events (EventSource) и как он работает?",
    answer: "<p><strong>Server-Sent Events (SSE)</strong> — технология для односторонней передачи данных от сервера к клиенту через HTTP.</p><h4>Создание EventSource:</h4><p><code>const eventSource = new EventSource('/api/events');</code></p><h4>Как работает:</h4><p><strong>1. Клиент:</strong> Отправляет обычный HTTP GET запрос на сервер</p><p><strong>2. Сервер:</strong> Отвечает с заголовками:<br><code>Content-Type: text/event-stream</code><br><code>Cache-Control: no-cache</code><br><code>Connection: keep-alive</code></p><p><strong>3. Поток данных:</strong> Сервер держит соединение открытым и отправляет данные в формате:<br><code>data: сообщение\\n\\n</code></p><h4>Обработка событий:</h4><p><code>eventSource.onopen = () => {</code><br><code>&nbsp;&nbsp;console.log('Соединение установлено');</code><br><code>};</code></p><p><code>eventSource.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;console.log('Данные:', event.data);</code><br><code>&nbsp;&nbsp;console.log('ID:', event.lastEventId);</code><br><code>};</code></p><p><code>eventSource.onerror = (error) => {</code><br><code>&nbsp;&nbsp;console.error('Ошибка:', error);</code><br><code>};</code></p><h4>Именованные события:</h4><p><code>eventSource.addEventListener('notification', (event) => {</code><br><code>&nbsp;&nbsp;const data = JSON.parse(event.data);</code><br><code>&nbsp;&nbsp;showNotification(data);</code><br><code>});</code></p><h4>Ключевые особенности:</h4><ul><li><strong>Автоматическое переподключение:</strong> Браузер сам переподключается при разрыве</li><li><strong>lastEventId:</strong> Восстановление с последнего события</li><li><strong>Только текст:</strong> Нельзя отправлять бинарные данные</li><li><strong>Только GET:</strong> Нельзя установить кастомные заголовки</li></ul>",
    difficulty: 'middle',
    tags: ['EventSource', 'Server-Sent Events', 'SSE', 'односторонняя связь']
  },
  {
    id: 37,
    question: "В чем главные отличия EventSource от WebSocket?",
    answer: "<p>EventSource и WebSocket решают разные задачи и имеют существенные различия:</p><h4>Направление передачи данных:</h4><p><strong>EventSource:</strong> Только от сервера к клиенту (односторонняя). Клиент не может отправлять данные через EventSource.</p><p><strong>WebSocket:</strong> Двусторонняя связь (full-duplex). Клиент и сервер могут отправлять данные в любое время.</p><h4>Протокол:</h4><p><strong>EventSource:</strong> Работает через обычный HTTP/HTTPS. Использует стандартные HTTP запросы.</p><p><strong>WebSocket:</strong> Отдельный протокол ws:// или wss://. Требует HTTP Upgrade для установки соединения.</p><h4>Автопереподключение:</h4><p><strong>EventSource:</strong> Автоматическое переподключение встроено в браузер. Не требует дополнительного кода.</p><p><strong>WebSocket:</strong> Нет автоматического переподключения. Нужно реализовывать вручную.</p><h4>Типы данных:</h4><p><strong>EventSource:</strong> Только текстовые данные (строки). Нельзя отправлять бинарные данные.</p><p><strong>WebSocket:</strong> Текст и бинарные данные (ArrayBuffer, Blob, TypedArray).</p><h4>Overhead:</h4><p><strong>EventSource:</strong> HTTP заголовки в каждом сообщении (больше overhead).</p><p><strong>WebSocket:</strong> Минимальный overhead (2-14 байт на кадр).</p><h4>Когда использовать:</h4><p><strong>EventSource:</strong> Уведомления, новостные ленты, мониторинг, прогресс операций — когда данные только от сервера.</p><p><strong>WebSocket:</strong> Чаты, игры, collaborative editing, трейдинг — когда нужна двусторонняя связь в реальном времени.</p>",
    difficulty: 'middle',
    tags: ['EventSource', 'WebSocket', 'сравнение', 'различия']
  },
  {
    id: 38,
    question: "Что такое Long Polling и когда его следует использовать?",
    answer: "<p><strong>Long Polling</strong> — техника, при которой клиент отправляет HTTP запрос, а сервер держит соединение открытым до появления новых данных или таймаута.</p><h4>Как работает:</h4><p><strong>1. Запрос:</strong> Клиент отправляет HTTP запрос на сервер</p><p><strong>2. Ожидание:</strong> Сервер НЕ отвечает сразу, держит соединение открытым</p><p><strong>3. Ответ:</strong> Когда появляются данные или истекает таймаут, сервер отправляет ответ</p><p><strong>4. Повтор:</strong> Клиент сразу отправляет новый запрос</p><h4>Реализация:</h4><p><code>async function longPoll() {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/long-poll', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: AbortSignal.timeout(30000)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;handleData(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сразу делаем следующий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;longPoll();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Повтор с задержкой при ошибке</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(longPoll, 5000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Когда использовать:</h4><ul><li><strong>Fallback:</strong> Когда WebSocket/EventSource недоступны</li><li><strong>Старые браузеры:</strong> Где нет поддержки современных технологий</li><li><strong>Строгие firewall:</strong> Корпоративные сети, блокирующие WebSocket</li><li><strong>Нечастые обновления:</strong> Данные появляются раз в несколько секунд</li><li><strong>Простота:</strong> Когда нужна максимальная совместимость</li></ul><h4>Недостатки:</h4><ul><li>Больше overhead чем WebSocket (HTTP заголовки)</li><li>Выше latency</li><li>Больше нагрузка на сервер</li><li>Сложнее масштабировать</li></ul>",
    difficulty: 'middle',
    tags: ['Long Polling', 'HTTP', 'fallback', 'совместимость']
  },
  {
    id: 39,
    question: "Какие коды закрытия (close codes) существуют в WebSocket и что они означают?",
    answer: "<p>WebSocket использует коды закрытия для указания причины разрыва соединения:</p><h4>Стандартные коды (1000-1015):</h4><p><strong>1000 - Normal Closure:</strong> Нормальное закрытие соединения. Задача выполнена успешно.</p><p><strong>1001 - Going Away:</strong> Endpoint уходит (например, сервер выключается или пользователь покидает страницу).</p><p><strong>1002 - Protocol Error:</strong> Ошибка протокола. Получены некорректные данные.</p><p><strong>1003 - Unsupported Data:</strong> Получен неподдерживаемый тип данных (например, только текст, а пришли бинарные).</p><p><strong>1006 - Abnormal Closure:</strong> Соединение закрыто ненормально (без close frame). Используется браузером, нельзя отправить явно.</p><p><strong>1007 - Invalid Payload:</strong> Некорректная кодировка данных (например, не UTF-8 в текстовом фрейме).</p><p><strong>1008 - Policy Violation:</strong> Нарушение политики (например, аутентификация не прошла).</p><p><strong>1009 - Message Too Big:</strong> Сообщение слишком большое для обработки.</p><p><strong>1010 - Mandatory Extension:</strong> Клиент ожидал расширение, которое сервер не согласовал.</p><p><strong>1011 - Internal Server Error:</strong> Внутренняя ошибка сервера.</p><h4>Использование:</h4><p><code>ws.close(1000, 'Normal close');</code><br><code>ws.close(1008, 'Authentication failed');</code></p><p><code>ws.onclose = (event) => {</code><br><code>&nbsp;&nbsp;console.log('Code:', event.code);</code><br><code>&nbsp;&nbsp;console.log('Reason:', event.reason);</code><br><code>&nbsp;&nbsp;console.log('Clean:', event.wasClean);</code><br><code>};</code></p><h4>Кастомные коды (3000-4999):</h4><p>Можно использовать для специфичных нужд приложения:<br><code>ws.close(4000, 'Custom error');</code></p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'close codes', 'коды закрытия', 'протокол']
  },
  {
    id: 40,
    question: "Как отправлять и получать бинарные данные через WebSocket?",
    answer: "<p>WebSocket поддерживает отправку и получение бинарных данных через ArrayBuffer и Blob:</p><h4>Настройка типа бинарных данных:</h4><p><code>ws.binaryType = 'arraybuffer';  // по умолчанию</code><br><code>// или</code><br><code>ws.binaryType = 'blob';</code></p><h4>Отправка бинарных данных:</h4><p><strong>1. ArrayBuffer:</strong></p><p><code>const buffer = new ArrayBuffer(8);</code><br><code>const view = new Uint8Array(buffer);</code><br><code>view[0] = 1;</code><br><code>view[1] = 2;</code><br><code>ws.send(buffer);</code></p><p><strong>2. TypedArray:</strong></p><p><code>const bytes = new Uint8Array([1, 2, 3, 4, 5]);</code><br><code>ws.send(bytes);</code></p><p><strong>3. Blob:</strong></p><p><code>const blob = new Blob(['Binary data'], {</code><br><code>&nbsp;&nbsp;type: 'application/octet-stream'</code><br><code>});</code><br><code>ws.send(blob);</code></p><h4>Получение бинарных данных:</h4><p><code>ws.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;if (event.data instanceof ArrayBuffer) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const view = new Uint8Array(event.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('ArrayBuffer:', view);</code><br><code>&nbsp;&nbsp;} else if (event.data instanceof Blob) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;event.data.arrayBuffer().then(buffer => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Blob as ArrayBuffer:', buffer);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Text:', event.data);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Практический пример - отправка файла:</h4><p><code>async function sendFile(file) {</code><br><code>&nbsp;&nbsp;const buffer = await file.arrayBuffer();</code><br><code>&nbsp;&nbsp;ws.send(buffer);</code><br><code>}</code></p><p><em>Преимущество:</em> Бинарные данные передаются эффективнее текстовых (нет base64 кодирования).</p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'бинарные данные', 'ArrayBuffer', 'Blob']
  },
  {
    id: 41,
    question: "Как реализовать систему комнат (rooms) с WebSocket?",
    answer: "<p>Система комнат позволяет группировать пользователей и отправлять сообщения только участникам конкретной комнаты:</p><h4>Клиентская часть:</h4><p><code>class ChatClient {</code><br><code>&nbsp;&nbsp;constructor(url) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = new WebSocket(url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentRoom = null;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;joinRoom(roomId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentRoom = roomId;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'join',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomId: roomId</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;leaveRoom(roomId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'leave',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomId: roomId</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentRoom = null;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;sendToRoom(message) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'message',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomId: this.currentRoom,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: message</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Серверная часть (Node.js + ws):</h4><p><code>const rooms = new Map(); // roomId -> Set of clients</code></p><p><code>wss.on('connection', (ws) => {</code><br><code>&nbsp;&nbsp;ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (message.type === 'join') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!rooms.has(message.roomId)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rooms.set(message.roomId, new Set());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rooms.get(message.roomId).add(ws);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ws.currentRoom = message.roomId;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (message.type === 'message') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const roomClients = rooms.get(message.roomId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomClients?.forEach(client => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (client.readyState === WebSocket.OPEN) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client.send(JSON.stringify(message));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'rooms', 'комнаты', 'групповые сообщения']
  },
  {
    id: 42,
    question: "Какие существуют fallback стратегии если WebSocket недоступен?",
    answer: "<p>Fallback стратегии обеспечивают работу приложения когда WebSocket не поддерживается или заблокирован:</p><h4>1. EventSource (Server-Sent Events)</h4><p>Первый fallback - пробуем EventSource для односторонней связи от сервера:</p><p><code>if ('EventSource' in window) {</code><br><code>&nbsp;&nbsp;const es = new EventSource('/api/events');</code><br><code>}</code></p><h4>2. Long Polling</h4><p>Если EventSource недоступен, используем Long Polling:</p><p><code>async function longPoll() {</code><br><code>&nbsp;&nbsp;const response = await fetch('/api/long-poll');</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;handleData(data);</code><br><code>&nbsp;&nbsp;longPoll(); // Сразу следующий запрос</code><br><code>}</code></p><h4>3. Short Polling</h4><p>Последняя опция - регулярный опрос сервера:</p><p><code>setInterval(() => {</code><br><code>&nbsp;&nbsp;fetch('/api/messages')</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.then(handleData);</code><br><code>}, 5000);</code></p><h4>Универсальный клиент с auto-fallback:</h4><p><code>class UniversalClient {</code><br><code>&nbsp;&nbsp;async connect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const methods = [</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tryWebSocket(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tryEventSource(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tryLongPolling()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (const method of methods) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await method();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; // Успех</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Trying next method...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Библиотеки с auto-fallback:</h4><ul><li><strong>Socket.IO:</strong> Автоматический fallback WebSocket → Polling</li><li><strong>SockJS:</strong> WebSocket эмуляция для старых браузеров</li><li><strong>SignalR:</strong> Microsoft's решение с auto-fallback</li></ul>",
    difficulty: 'senior',
    tags: ['fallback', 'совместимость', 'graceful degradation', 'стратегии']
  },
  {
    id: 43,
    question: "Как обеспечить безопасность WebSocket соединений?",
    answer: "<p>Безопасность WebSocket критична для защиты данных и предотвращения атак:</p><h4>1. Использовать WSS (WebSocket Secure)</h4><p>Всегда используйте wss:// вместо ws:// для шифрования соединения:</p><p><code>const ws = new WebSocket('wss://example.com');</code></p><h4>2. Валидация Origin</h4><p>На сервере проверяйте заголовок Origin для предотвращения CSRF:</p><p><code>wss.on('connection', (ws, request) => {</code><br><code>&nbsp;&nbsp;const origin = request.headers.origin;</code><br><code>&nbsp;&nbsp;if (origin !== 'https://trusted-domain.com') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1008, 'Unauthorized origin');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>3. Аутентификация и авторизация</h4><p>Проверяйте токены при установке соединения:</p><p><code>ws.onopen = () => {</code><br><code>&nbsp;&nbsp;ws.send(JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;type: 'auth',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;token: localStorage.getItem('authToken')</code><br><code>&nbsp;&nbsp;}));</code><br><code>};</code></p><p>На сервере:</p><p><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;const message = JSON.parse(data);</code><br><code>&nbsp;&nbsp;if (message.type === 'auth') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!verifyToken(message.token)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1008, 'Invalid token');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>4. Rate Limiting</h4><p>Ограничивайте частоту сообщений от клиента:</p><p><code>const messageLimit = new Map();</code><br><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;const count = messageLimit.get(ws) || 0;</code><br><code>&nbsp;&nbsp;if (count > 100) { // 100 сообщений в минуту</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1008, 'Rate limit exceeded');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>5. Валидация данных</h4><p>Всегда валидируйте входящие данные:</p><p><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!validateMessage(message)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1003, 'Invalid data');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1002, 'Parse error');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>6. Ограничение размера сообщений</h4><p><code>ws.on('message', (data) => {</code><br><code>&nbsp;&nbsp;if (data.length > 1024 * 1024) { // 1MB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;ws.close(1009, 'Message too big');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p>",
    difficulty: 'senior',
    tags: ['WebSocket', 'безопасность', 'аутентификация', 'валидация']
  },
  {
    id: 44,
    question: "Как отслеживать и отображать статус соединения для пользователя?",
    answer: "<p>Отображение статуса соединения улучшает UX и помогает пользователю понять состояние приложения:</p><h4>Реализация индикатора статуса:</h4><p><code>class ConnectionStatus {</code><br><code>&nbsp;&nbsp;constructor(ws) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws = ws;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator = document.getElementById('status');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupListeners();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupListeners() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onopen = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setStatus('connected', 'Подключено');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onclose = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setStatus('disconnected', 'Отключено');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setStatus('error', 'Ошибка соединения');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setStatus(state, message) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = \`status-\${state}\`;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = message;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Уведомление</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (state === 'disconnected') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showNotification('Соединение потеряно');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>HTML индикатор:</h4><p><code>&lt;div id=\"status\" class=\"status-connecting\"&gt;</code><br><code>&nbsp;&nbsp;&lt;span class=\"dot\"&gt;&lt;/span&gt;</code><br><code>&nbsp;&nbsp;&lt;span class=\"text\"&gt;Подключение...&lt;/span&gt;</code><br><code>&lt;/div&gt;</code></p><h4>CSS стили:</h4><p><code>.status-connected .dot { background: green; }</code><br><code>.status-disconnected .dot { background: red; }</code><br><code>.status-connecting .dot {</code><br><code>&nbsp;&nbsp;background: orange;</code><br><code>&nbsp;&nbsp;animation: blink 1s infinite;</code><br><code>}</code></p><h4>Расширенный статус с качеством соединения:</h4><p><code>class AdvancedConnectionStatus {</code><br><code>&nbsp;&nbsp;constructor(ws) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.latency = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.measureLatency();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;measureLatency() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const start = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.send(JSON.stringify({ type: 'ping' }));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ws.onmessage = (event) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = JSON.parse(event.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data.type === 'pong') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.latency = Date.now() - start;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateLatencyDisplay();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 5000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p>",
    difficulty: 'middle',
    tags: ['WebSocket', 'UX', 'статус соединения', 'индикатор']
  },
  {
    id: 45,
    question: "Какие популярные библиотеки существуют для работы с WebSocket и в чем их преимущества?",
    answer: "<p>Существует несколько популярных библиотек, упрощающих работу с WebSocket:</p><h4>1. Socket.IO</h4><p><strong>Преимущества:</strong></p><ul><li>Автоматический fallback (WebSocket → Long Polling)</li><li>Автопереподключение из коробки</li><li>Поддержка комнат (rooms) и namespace</li><li>Broadcasting и группы</li><li>Бинарные данные</li><li>Middleware поддержка</li></ul><p><code>import io from 'socket.io-client';</code><br><code>const socket = io('http://localhost:3000');</code><br><code>socket.on('message', (data) => console.log(data));</code><br><code>socket.emit('message', { text: 'Hello!' });</code></p><h4>2. ws (Node.js)</h4><p><strong>Преимущества:</strong></p><ul><li>Самая быстрая WebSocket библиотека для Node.js</li><li>Минимальные зависимости</li><li>Простой API</li><li>Отличная производительность</li><li>Поддержка перфоманс тестов</li></ul><p><code>const WebSocket = require('ws');</code><br><code>const wss = new WebSocket.Server({ port: 3000 });</code></p><h4>3. SockJS</h4><p><strong>Преимущества:</strong></p><ul><li>WebSocket-подобный API</li><li>Множество транспортов (fallback)</li><li>Работает в старых браузерах</li><li>CORS поддержка</li><li>Прозрачный fallback</li></ul><h4>4. Firebase Realtime Database</h4><p><strong>Преимущества:</strong></p><ul><li>Backend-as-a-Service (не нужен свой сервер)</li><li>Автоматическая синхронизация данных</li><li>Offline поддержка</li><li>Аутентификация встроена</li><li>Автоматическое масштабирование</li></ul><h4>5. SignalR (Microsoft)</h4><p><strong>Преимущества:</strong></p><ul><li>Отличная интеграция с .NET</li><li>Автоматический fallback</li><li>Strongly-typed hubs</li><li>Группы и broadcasting</li><li>Поддержка Azure</li></ul><h4>Когда использовать библиотеки:</h4><p><strong>Socket.IO:</strong> Когда нужен быстрый старт и автоматический fallback</p><p><strong>ws:</strong> Когда важна максимальная производительность</p><p><strong>Нативный WebSocket:</strong> Для простых сценариев и полного контроля</p>",
    difficulty: 'middle',
    tags: ['библиотеки', 'Socket.IO', 'ws', 'инструменты']
  },
  {
    id: 46,
    question: "Что такое IntersectionObserver и для чего он используется?",
    answer: "<p><strong>IntersectionObserver</strong> — это API для асинхронного отслеживания пересечения элемента с viewport или с другим элементом-предком:</p><h4>Основное назначение:</h4><p>Позволяет эффективно отслеживать, когда элемент становится видимым на странице, без блокировки main thread.</p><h4>Синтаксис:</h4><p><code>const observer = new IntersectionObserver(callback, options);</code><br><code>observer.observe(element);</code></p><h4>Основные применения:</h4><ul><li><strong>Lazy loading:</strong> Отложенная загрузка изображений и контента</li><li><strong>Infinite scroll:</strong> Бесконечная прокрутка списков</li><li><strong>Аналитика:</strong> Отслеживание просмотров элементов</li><li><strong>Анимации:</strong> Запуск анимаций при появлении элемента</li><li><strong>Автовоспроизведение:</strong> Воспроизведение видео при появлении в viewport</li></ul><h4>Преимущества:</h4><ul><li>Асинхронная работа — не блокирует UI</li><li>Высокая производительность — вычисления в отдельном потоке</li><li>Простой API — не нужен throttle/debounce</li><li>Нет layout thrashing — браузер оптимизирует вычисления</li></ul><p><em>Важно:</em> IntersectionObserver работает значительно эффективнее, чем отслеживание через scroll event + getBoundingClientRect().</p>",
    difficulty: 'junior',
    tags: ['IntersectionObserver', 'Web API', 'производительность', 'основы']
  },
  {
    id: 47,
    question: "Как реализовать InfinityScroll с помощью IntersectionObserver?",
    answer: "<p>InfinityScroll реализуется через создание <strong>sentinel элемента</strong> в конце списка и наблюдение за ним:</p><h4>Базовая реализация:</h4><p><code>class InfiniteScroll {</code><br><code>&nbsp;&nbsp;constructor(container) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.page = 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loading = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.hasMore = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем sentinel</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(this.sentinel);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer с предзагрузкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ rootMargin: '100px' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entries[0].isIntersecting && !this.loading && this.hasMore) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await this.loadMore();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async loadMore() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loading = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await fetch(\`/api/items?page=\${this.page}\`).then(r => r.json());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (data.length === 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hasMore = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.renderItems(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.page++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loading = false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Ключевые моменты:</h4><ul><li><strong>Sentinel элемент:</strong> Маркер в конце списка, за которым наблюдаем</li><li><strong>loading флаг:</strong> Предотвращает дублирование запросов</li><li><strong>hasMore флаг:</strong> Останавливает загрузку при отсутствии данных</li><li><strong>rootMargin:</strong> Загружает данные заранее (за 100px до конца)</li></ul><p><em>Преимущество:</em> Sentinel всегда остается в конце, в отличие от наблюдения за последним элементом данных.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'InfinityScroll', 'паттерны', 'реализация']
  },
  {
    id: 48,
    question: "Какие существуют способы оптимизации InfinityScroll?",
    answer: "<p>Существует множество техник оптимизации InfinityScroll для улучшения производительности и UX:</p><h4>1. Виртуализация списка:</h4><p>Рендерить только видимые элементы. Критично для списков >1000 элементов.</p><p><code>// Рендерим только элементы в viewport + буфер</code><br><code>const startIndex = Math.floor(scrollTop / itemHeight);</code><br><code>const endIndex = startIndex + visibleCount;</code></p><h4>2. Батчинг запросов:</h4><p>Загружать несколько страниц за один раз, уменьшая количество HTTP-запросов:</p><p><code>const promises = [</code><br><code>&nbsp;&nbsp;fetch(\`/api/items?page=\${page}\`),</code><br><code>&nbsp;&nbsp;fetch(\`/api/items?page=\${page + 1}\`),</code><br><code>&nbsp;&nbsp;fetch(\`/api/items?page=\${page + 2}\`)</code><br><code>];</code><br><code>const results = await Promise.all(promises);</code></p><h4>3. Предзагрузка (Prefetching):</h4><p>Загружать следующую страницу заранее и кэшировать в Map:</p><p><code>async prefetchNext() {</code><br><code>&nbsp;&nbsp;if (!this.cache.has(this.page + 1)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await this.fetchData(this.page + 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cache.set(this.page + 1, data);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>4. Дебаунс callback:</h4><p>Ограничить частоту вызовов для быстрого скролла.</p><h4>5. Отмена запросов:</h4><p>Использовать AbortController для отмены предыдущих запросов:</p><p><code>if (this.abortController) {</code><br><code>&nbsp;&nbsp;this.abortController.abort();</code><br><code>}</code><br><code>this.abortController = new AbortController();</code></p><h4>6. Lazy loading изображений:</h4><p>Отдельный IntersectionObserver для изображений внутри элементов.</p><h4>7. Скелетон-загрузчики:</h4><p>Показывать placeholder'ы вместо индикаторов загрузки для лучшего UX.</p><p><em>Комбинация этих техник:</em> Для максимальной производительности используйте несколько оптимизаций одновременно.</p>",
    difficulty: 'senior',
    tags: ['IntersectionObserver', 'оптимизация', 'производительность', 'InfinityScroll']
  },
  {
    id: 49,
    question: "Что такое threshold и rootMargin в IntersectionObserver?",
    answer: "<p>Это два ключевых параметра настройки IntersectionObserver, определяющие когда срабатывает callback:</p><h4>threshold (порог видимости):</h4><p>Определяет, при какой видимости элемента (от 0.0 до 1.0) должен сработать callback.</p><p><strong>Значения:</strong></p><ul><li><code>0</code> — callback при любом пересечении (даже 1 пиксель)</li><li><code>0.5</code> — callback когда видно 50% элемента</li><li><code>1.0</code> — callback когда виден весь элемент полностью</li><li><code>[0, 0.5, 1.0]</code> — массив порогов, callback при каждом</li></ul><p><code>new IntersectionObserver(callback, {</code><br><code>&nbsp;&nbsp;threshold: [0, 0.25, 0.5, 0.75, 1.0]</code><br><code>});</code></p><h4>rootMargin (отступы от границ):</h4><p>Работает как CSS margin — изменяет область наблюдения root элемента.</p><p><strong>Синтаксис:</strong> <code>'top right bottom left'</code> (как в CSS)</p><p><strong>Примеры:</strong></p><ul><li><code>'0px'</code> — без отступов (по умолчанию)</li><li><code>'100px'</code> — увеличивает область на 100px со всех сторон</li><li><code>'0px 0px -100px 0px'</code> — уменьшает нижнюю границу на 100px</li><li><code>'200px 0px 200px 0px'</code> — предзагрузка за 200px сверху и снизу</li></ul><p><code>new IntersectionObserver(callback, {</code><br><code>&nbsp;&nbsp;rootMargin: '100px' // Загружаем за 100px до края</code><br><code>});</code></p><h4>Применение для InfinityScroll:</h4><p><code>rootMargin: '200px'</code> позволяет начать загрузку данных за 200px до того, как пользователь доскроллит до конца, создавая ощущение бесконечного списка.</p><p><em>Важно:</em> Значения rootMargin должны быть с единицами измерения (px или %).</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'threshold', 'rootMargin', 'конфигурация']
  },
  {
    id: 50,
    question: "Как обрабатывать пересечения нескольких элементов с помощью IntersectionObserver?",
    answer: "<p>Один IntersectionObserver может эффективно наблюдать за множеством элементов с разной логикой:</p><h4>Базовый подход — одинаковая логика:</h4><p><code>const observer = new IntersectionObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry.target.classList.add('visible');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code><br><code></code><br><code>// Наблюдаем за всеми</code><br><code>document.querySelectorAll('.animate').forEach(el => {</code><br><code>&nbsp;&nbsp;observer.observe(el);</code><br><code>});</code></p><h4>Разная логика для разных элементов:</h4><p><code>class MultiElementObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.handlers = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;observe(element, handler) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.handlers.set(element, handler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const handler = this.handlers.get(entry.target);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (handler) handler(entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const multiObserver = new MultiElementObserver();</code><br><code></code><br><code>multiObserver.observe(header, (entry) => {</code><br><code>&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Header visible');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code><br><code></code><br><code>multiObserver.observe(sidebar, (entry) => {</code><br><code>&nbsp;&nbsp;if (entry.intersectionRatio > 0.5) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;sidebar.classList.add('sticky');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Преимущества подхода:</h4><ul><li>Один Observer для всех элементов — эффективнее памяти</li><li>Централизованное управление</li><li>Легко добавлять/удалять элементы</li><li>Индивидуальная логика для каждого элемента</li></ul><p><em>Best practice:</em> Избегайте создания отдельного Observer для каждого элемента — это расточительно.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'несколько элементов', 'паттерны', 'производительность']
  },
  {
    id: 51,
    question: "В чем разница между IntersectionObserver и scroll event?",
    answer: "<p>Это два принципиально разных подхода к отслеживанию позиции элементов на странице:</p><h4>IntersectionObserver:</h4><p><strong>Преимущества:</strong></p><ul><li><strong>Асинхронный:</strong> Работает в отдельном потоке, не блокирует main thread</li><li><strong>Производительный:</strong> Браузер оптимизирует вычисления</li><li><strong>Простой API:</strong> Не требует throttle/debounce</li><li><strong>Точный:</strong> Встроенные вычисления пересечений</li><li><strong>Нет layout thrashing:</strong> Вычисления батчатся браузером</li></ul><p><strong>Недостатки:</strong></p><ul><li>Требует полифилл для старых браузеров</li><li>Ограниченная кастомизация логики</li></ul><h4>Scroll Event:</h4><p><strong>Преимущества:</strong></p><ul><li><strong>Универсальная поддержка:</strong> Работает везде</li><li><strong>Полный контроль:</strong> Любая кастомная логика</li><li><strong>Доступ к scroll позиции:</strong> scrollTop, scrollLeft</li></ul><p><strong>Недостатки:</strong></p><ul><li><strong>Синхронный:</strong> Блокирует main thread</li><li><strong>Низкая производительность:</strong> Вызывается очень часто</li><li><strong>Требует оптимизации:</strong> Обязателен throttle/debounce</li><li><strong>Layout thrashing:</strong> getBoundingClientRect() вызывает reflow</li><li><strong>Сложнее:</strong> Нужно вручную считать пересечения</li></ul><h4>Сравнение кода:</h4><p><code>// ❌ Scroll Event — требует оптимизации</code><br><code>let timeout;</code><br><code>window.addEventListener('scroll', () => {</code><br><code>&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;timeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const rect = element.getBoundingClientRect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (rect.top < window.innerHeight) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// логика</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, 100);</code><br><code>});</code></p><p><code>// ✅ IntersectionObserver — просто и эффективно</code><br><code>const observer = new IntersectionObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (entries[0].isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// логика</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code><br><code>observer.observe(element);</code></p><p><em>Вывод:</em> Для lazy loading, infinite scroll и отслеживания видимости используйте IntersectionObserver. Scroll event — только для специфичных задач.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'scroll event', 'сравнение', 'производительность']
  },
  {
    id: 52,
    question: "Как правильно очищать IntersectionObserver при размонтировании компонента?",
    answer: "<p>Правильная очистка IntersectionObserver критична для предотвращения утечек памяти:</p><h4>Методы очистки:</h4><p><strong>1. disconnect():</strong> Останавливает все наблюдения</p><p><code>observer.disconnect();</code></p><p><strong>2. unobserve(element):</strong> Прекращает наблюдение за конкретным элементом</p><p><code>observer.unobserve(element);</code></p><h4>В vanilla JavaScript:</h4><p><code>class Component {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(this.callback.bind(this));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;mount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements.forEach(el => this.observer.observe(el));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;unmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// ВАЖНО: Очистка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>В React:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new IntersectionObserver(callback);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const element = elementRef.current;</code><br><code>&nbsp;&nbsp;if (element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup функция</code><br><code>&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;};</code><br><code>}, []);</code></p><h4>В Vue:</h4><p><code>export default {</code><br><code>&nbsp;&nbsp;mounted() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.$el);</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;beforeUnmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Cleanup</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.observer) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Когда использовать unobserve vs disconnect:</h4><ul><li><strong>unobserve:</strong> Когда нужно прекратить наблюдение за одним элементом (например, после загрузки изображения), но продолжить наблюдать за другими</li><li><strong>disconnect:</strong> При полном размонтировании компонента или когда нужно остановить все наблюдения</li></ul><p><em>Критично:</em> Всегда вызывайте disconnect() при размонтировании, иначе Observer будет продолжать работать и занимать память.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'cleanup', 'утечки памяти', 'lifecycle']
  },
  {
    id: 53,
    question: "Как реализовать lazy loading изображений с IntersectionObserver?",
    answer: "<p>Lazy loading изображений — классическое применение IntersectionObserver для оптимизации производительности:</p><h4>HTML разметка:</h4><p><code>&lt;img data-src=\"image.jpg\" data-srcset=\"image-2x.jpg 2x\" class=\"lazy\" alt=\"Description\"&gt;</code></p><h4>Реализация:</h4><p><code>class LazyImageLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '50px', // Загружаем за 50px</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.01</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.images = document.querySelectorAll('img[data-src]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.images.forEach(img => this.observer.observe(img));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadImage(entry.target);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loadImage(img) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Устанавливаем src</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.src = img.dataset.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Опционально: srcset для responsive</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (img.dataset.srcset) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.srcset = img.dataset.srcset;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Добавляем класс для fade-in анимации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.classList.add('loaded');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// После загрузки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.classList.remove('lazy');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.src = 'placeholder-error.jpg';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Прекращаем наблюдение</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.unobserve(img);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>CSS для плавного появления:</h4><p><code>.lazy {</code><br><code>&nbsp;&nbsp;opacity: 0;</code><br><code>&nbsp;&nbsp;transition: opacity 0.3s;</code><br><code>}</code><br><code></code><br><code>.lazy.loaded {</code><br><code>&nbsp;&nbsp;opacity: 1;</code><br><code>}</code></p><h4>С placeholder'ом:</h4><p><code>&lt;img src=\"placeholder.jpg\" data-src=\"real-image.jpg\" class=\"lazy\"&gt;</code></p><h4>Преимущества подхода:</h4><ul><li>Изображения загружаются только когда видны</li><li>Экономия трафика и улучшение начальной загрузки страницы</li><li>Плавная анимация появления</li><li>Автоматическая обработка ошибок</li><li>Поддержка responsive изображений (srcset)</li></ul><p><em>Важно:</em> rootMargin: '50px' начинает загрузку чуть заранее, чтобы изображение успело загрузиться до прокрутки.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'lazy loading', 'изображения', 'оптимизация']
  },
  {
    id: 54,
    question: "Как использовать IntersectionObserver для отслеживания аналитики просмотров?",
    answer: "<p>IntersectionObserver идеален для отслеживания, какие элементы увидел пользователь:</p><h4>HTML разметка:</h4><p><code>&lt;div data-track-view=\"article-123\"&gt;Article content&lt;/div&gt;</code><br><code>&lt;div data-track-view=\"product-456\"&gt;Product card&lt;/div&gt;</code></p><h4>Реализация отслеживания:</h4><p><code>class ViewTracking {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.tracked = new Set();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5, // 50% элемента должно быть видно</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '0px'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Находим все отслеживаемые элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.trackableElements = document.querySelectorAll('[data-track-view]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.trackableElements.forEach(el => this.observer.observe(el));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const trackId = element.dataset.trackView;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Отслеживаем только один раз</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.tracked.has(trackId)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.tracked.add(trackId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendAnalytics(trackId, entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Прекращаем наблюдение</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;sendAnalytics(trackId, entry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: trackId,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visibilityRatio: entry.intersectionRatio,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elementPosition: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top: entry.boundingClientRect.top,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottom: entry.boundingClientRect.bottom</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewportHeight: window.innerHeight</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправляем данные (не блокирует UI)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;navigator.sendBeacon('/analytics/view', JSON.stringify(data));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('View tracked:', trackId);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отслеживание времени просмотра:</h4><p><code>class DurationTracking {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.viewTimes = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ threshold: 0.5 }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const id = entry.target.dataset.trackView;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Начинаем отсчет</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.viewTimes.set(id, Date.now());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Останавливаем и отправляем</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const startTime = this.viewTimes.get(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (startTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const duration = Date.now() - startTime;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sendDuration(id, duration);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.viewTimes.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Применения:</h4><ul><li>Отслеживание просмотров статей/товаров</li><li>Impressions для рекламных баннеров</li><li>A/B тестирование видимости элементов</li><li>Метрики вовлеченности пользователей</li></ul><p><em>Важно:</em> Используйте navigator.sendBeacon() для гарантированной отправки данных даже при закрытии страницы.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'аналитика', 'tracking', 'метрики']
  },
  {
    id: 55,
    question: "Как оптимизировать производительность при использовании IntersectionObserver?",
    answer: "<p>Существует множество техник для максимальной производительности IntersectionObserver:</p><h4>1. Переиспользование одного Observer:</h4><p><code>// ❌ ПЛОХО - создаем Observer для каждого элемента</code><br><code>elements.forEach(el => {</code><br><code>&nbsp;&nbsp;const observer = new IntersectionObserver(callback);</code><br><code>&nbsp;&nbsp;observer.observe(el);</code><br><code>});</code></p><p><code>// ✅ ХОРОШО - один Observer для всех</code><br><code>const observer = new IntersectionObserver(callback);</code><br><code>elements.forEach(el => observer.observe(el));</code></p><h4>2. Оптимизация threshold:</h4><p><code>// ❌ ПЛОХО - слишком много порогов</code><br><code>threshold: Array.from({ length: 101 }, (_, i) => i / 100)</code></p><p><code>// ✅ ХОРОШО - только нужные пороги</code><br><code>threshold: [0, 0.5, 1.0]</code></p><h4>3. Батчинг обновлений через RAF:</h4><p><code>class LayoutOptimizedObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingUpdates = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.rafId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;scheduleUpdate(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingUpdates.push(...entries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.rafId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.processBatch();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;processBatch() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Читаем все размеры (read phase)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = this.pendingUpdates.map(entry => ({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element: entry.target,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isIntersecting: entry.isIntersecting</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем изменения (write phase)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data.forEach(({ element, isIntersecting }) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.toggle('visible', isIntersecting);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingUpdates = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.rafId = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>4. Throttle для частых событий:</h4><p><code>class ThrottledObserver {</code><br><code>&nbsp;&nbsp;constructor(delay = 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (now - this.lastCall >= delay) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = now;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection(entries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>5. Управление памятью:</h4><p><code>class MemoryEfficientObserver {</code><br><code>&nbsp;&nbsp;constructor(maxElements = 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxElements = maxElements;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observedElements = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;observe(element, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Если достигли лимита, удаляем старые</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.observedElements.size >= this.maxElements) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const first = this.observedElements.keys().next().value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.unobserve(first);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observedElements.set(element, data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Остановка наблюдения после обработки:</h4><p><code>if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;// Обработали элемент</code><br><code>&nbsp;&nbsp;processElement(entry.target);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Прекращаем наблюдение (например, для lazy loading)</code><br><code>&nbsp;&nbsp;observer.unobserve(entry.target);</code><br><code>}</code></p><h4>7. Мониторинг производительности:</h4><p><code>const start = performance.now();</code><br><code>// Логика callback</code><br><code>const duration = performance.now() - start;</code><br><code></code><br><code>if (duration > 16.67) { // Больше 1 фрейма (60fps)</code><br><code>&nbsp;&nbsp;console.warn('Slow callback:', duration);</code><br><code>}</code></p><p><em>Золотое правило:</em> Callback должен выполняться быстро (<16ms для 60fps). Тяжелые операции выносить в Web Workers.</p>",
    difficulty: 'senior',
    tags: ['IntersectionObserver', 'оптимизация', 'производительность', 'best practices']
  },
  {
    id: 56,
    question: "Что такое sentinel элемент в контексте InfinityScroll и зачем он нужен?",
    answer: "<p><strong>Sentinel элемент</strong> — это специальный маркерный элемент, размещаемый в конце списка для отслеживания момента загрузки новых данных:</p><h4>Зачем нужен sentinel:</h4><ul><li><strong>Надежность:</strong> Всегда находится в конце списка, в отличие от последнего элемента данных</li><li><strong>Простота:</strong> Не зависит от структуры элементов данных</li><li><strong>Независимость:</strong> Не смешивается с логикой отображения данных</li><li><strong>Контроль:</strong> Легко управлять его видимостью и состоянием</li></ul><h4>Создание sentinel:</h4><p><code>class InfiniteScroll {</code><br><code>&nbsp;&nbsp;constructor(container) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем sentinel элемент</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.className = 'sentinel';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.height = '1px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Помещаем в конец контейнера</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(this.sentinel);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за ним</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ rootMargin: '100px' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;renderItems(items) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const fragment = document.createDocumentFragment();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(item => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const element = this.createItemElement(item);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment.appendChild(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вставляем ПЕРЕД sentinel</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.insertBefore(fragment, this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entries[0].isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sentinel виден — загружаем данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadMore();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Состояния sentinel:</h4><p><code>// Загрузка</code><br><code>this.sentinel.innerHTML = '&lt;div class=\"loader\"&gt;Loading...&lt;/div&gt;';</code></p><p><code>// Ошибка</code><br><code>this.sentinel.innerHTML = '&lt;div class=\"error\"&gt;Error loading&lt;/div&gt;';</code></p><p><code>// Конец данных</code><br><code>if (!hasMore) {</code><br><code>&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;this.sentinel.innerHTML = '&lt;div&gt;All items loaded&lt;/div&gt;';</code><br><code>}</code></p><h4>Альтернатива без sentinel (не рекомендуется):</h4><p><code>// ❌ Наблюдение за последним элементом данных</code><br><code>const lastItem = container.lastElementChild;</code><br><code>observer.observe(lastItem);</code><br><code>// Проблема: нужно переподписываться при добавлении новых элементов</code></p><h4>CSS для sentinel:</h4><p><code>.sentinel {</code><br><code>&nbsp;&nbsp;height: 1px;</code><br><code>&nbsp;&nbsp;visibility: hidden;</code><br><code>}</code></p><p><em>Best practice:</em> Sentinel должен быть невидимым элементом минимальной высоты, который всегда остается в конце списка.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'InfinityScroll', 'sentinel', 'паттерны']
  },
  {
    id: 57,
    question: "Как реализовать автовоспроизведение видео с помощью IntersectionObserver?",
    answer: "<p>Автовоспроизведение видео при появлении в viewport — частая задача для улучшения UX:</p><h4>HTML разметка:</h4><p><code>&lt;video data-autoplay muted loop&gt;</code><br><code>&nbsp;&nbsp;&lt;source src=\"video.mp4\" type=\"video/mp4\"&gt;</code><br><code>&lt;/video&gt;</code></p><p><em>Примечание:</em> Атрибут <code>muted</code> обязателен для autoplay в большинстве браузеров.</p><h4>Реализация:</h4><p><code>class VideoAutoplay {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5 // Играть когда видно 50% видео</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.videos = document.querySelectorAll('video[data-autoplay]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.videos.forEach(video => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Предзагрузка метаданных</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.preload = 'metadata';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const video = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Видео видно — воспроизводим</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.play().catch(err => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Autoplay prevented:', err);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Видео вне viewport — ставим на паузу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.pause();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Расширенная версия с lazy loading:</h4><p><code>class SmartVideoLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '100px' // Загружаем заранее</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadedVideos = new Set();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const video = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Загружаем source если еще не загружен</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.loadedVideos.has(video)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadVideo(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedVideos.add(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Воспроизводим</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.play().catch(err => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Показываем кнопку play если autoplay запрещен</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showPlayButton(video);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.pause();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;loadVideo(video) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const source = video.querySelector('source');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (source && source.dataset.src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source.src = source.dataset.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video.load();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;showPlayButton(video) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const button = document.createElement('button');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;button.textContent = '▶ Play';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;button.onclick = () => video.play();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;video.parentElement.appendChild(button);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>HTML для lazy loading:</h4><p><code>&lt;video data-autoplay muted loop&gt;</code><br><code>&nbsp;&nbsp;&lt;source data-src=\"video.mp4\" type=\"video/mp4\"&gt;</code><br><code>&lt;/video&gt;</code></p><h4>Применения:</h4><ul><li>Автовоспроизведение промо-видео</li><li>Видео-фоны секций</li><li>Анимированные истории</li><li>Видео-превью в галереях</li></ul><p><em>Важно:</em> Всегда обрабатывайте .catch() для video.play(), так как браузеры могут блокировать autoplay.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'видео', 'autoplay', 'UX']
  },
  {
    id: 58,
    question: "Как использовать IntersectionObserver для анимаций при появлении элементов?",
    answer: "<p>IntersectionObserver идеален для запуска анимаций когда элемент появляется в viewport:</p><h4>HTML разметка с data-атрибутами:</h4><p><code>&lt;div data-animate=\"fade-in\" data-delay=\"0\"&gt;Content 1&lt;/div&gt;</code><br><code>&lt;div data-animate=\"slide-up\" data-delay=\"100\"&gt;Content 2&lt;/div&gt;</code><br><code>&lt;div data-animate=\"scale-in\" data-delay=\"200\"&gt;Content 3&lt;/div&gt;</code></p><h4>Реализация:</h4><p><code>class AnimatedElementsObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.1,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '0px 0px -100px 0px' // Триггер чуть выше низа viewport</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animatedElements = document.querySelectorAll('[data-animate]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Добавляем начальное состояние</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.animatedElements.forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el.classList.add('before-animation');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(el);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const animationType = element.dataset.animate;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = parseInt(element.dataset.delay) || 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Запускаем анимацию с задержкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.remove('before-animation');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.add(\`animate-\${animationType}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Останавливаем наблюдение после анимации</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>CSS анимации:</h4><p><code>/* Начальное состояние */</code><br><code>.before-animation {</code><br><code>&nbsp;&nbsp;opacity: 0;</code><br><code>}</code></p><p><code>/* Fade In */</code><br><code>.animate-fade-in {</code><br><code>&nbsp;&nbsp;animation: fadeIn 0.6s ease-out forwards;</code><br><code>}</code><br><code></code><br><code>@keyframes fadeIn {</code><br><code>&nbsp;&nbsp;from { opacity: 0; }</code><br><code>&nbsp;&nbsp;to { opacity: 1; }</code><br><code>}</code></p><p><code>/* Slide Up */</code><br><code>.animate-slide-up {</code><br><code>&nbsp;&nbsp;animation: slideUp 0.6s ease-out forwards;</code><br><code>}</code><br><code></code><br><code>@keyframes slideUp {</code><br><code>&nbsp;&nbsp;from {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: translateY(50px);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;to {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: translateY(0);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>/* Scale In */</code><br><code>.animate-scale-in {</code><br><code>&nbsp;&nbsp;animation: scaleIn 0.5s ease-out forwards;</code><br><code>}</code><br><code></code><br><code>@keyframes scaleIn {</code><br><code>&nbsp;&nbsp;from {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: scale(0.8);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;to {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;opacity: 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;transform: scale(1);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Повторяющиеся анимации:</h4><p><code>// Не останавливаем наблюдение для повторных анимаций</code><br><code>handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.add('animated');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.classList.remove('animated');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Применения:</h4><ul><li>Появление элементов при прокрутке</li><li>Последовательные анимации списков</li><li>Параллакс эффекты</li><li>Прогрессивное раскрытие контента</li></ul><p><em>Best practice:</em> Останавливайте наблюдение после первой анимации для экономии ресурсов, если не нужны повторные анимации.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'анимации', 'CSS', 'UX']
  },
  {
    id: 59,
    question: "Как реализовать sticky navigation с изменением стилей через IntersectionObserver?",
    answer: "<p>IntersectionObserver позволяет элегантно отслеживать когда пользователь проскроллил страницу и изменять sticky header:</p><h4>HTML структура:</h4><p><code>&lt;header class=\"header\"&gt;</code><br><code>&nbsp;&nbsp;&lt;nav&gt;Navigation&lt;/nav&gt;</code><br><code>&lt;/header&gt;</code><br><code></code><br><code>&lt;main&gt;</code><br><code>&nbsp;&nbsp;&lt;!-- Контент --&gt;</code><br><code>&lt;/main&gt;</code></p><h4>Реализация с sentinel:</h4><p><code>class StickyHeaderObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.header = document.querySelector('header');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем невидимый sentinel элемент в начале страницы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.height = '1px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.position = 'absolute';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.top = '0';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sentinel.style.width = '100%';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.body.prepend(this.sentinel);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: [0, 1],</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '0px'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.sentinel);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проскроллили вниз — делаем header компактным</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.header.classList.add('scrolled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Вернулись наверх — восстанавливаем обычный вид</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.header.classList.remove('scrolled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>CSS стили:</h4><p><code>header {</code><br><code>&nbsp;&nbsp;position: sticky;</code><br><code>&nbsp;&nbsp;top: 0;</code><br><code>&nbsp;&nbsp;padding: 20px;</code><br><code>&nbsp;&nbsp;background: white;</code><br><code>&nbsp;&nbsp;transition: all 0.3s ease;</code><br><code>&nbsp;&nbsp;box-shadow: none;</code><br><code>}</code></p><p><code>header.scrolled {</code><br><code>&nbsp;&nbsp;padding: 10px;</code><br><code>&nbsp;&nbsp;background: rgba(255, 255, 255, 0.95);</code><br><code>&nbsp;&nbsp;backdrop-filter: blur(10px);</code><br><code>&nbsp;&nbsp;box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);</code><br><code>}</code></p><p><code>header.scrolled nav {</code><br><code>&nbsp;&nbsp;font-size: 14px;</code><br><code>}</code></p><h4>Альтернатива — наблюдение за секциями:</h4><p><code>class SectionBasedNavigation {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sections = document.querySelectorAll('section');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.nav = document.querySelector('nav');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentSection = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new IntersectionObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleIntersection.bind(this),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold: 0.5,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rootMargin: '-100px 0px -100px 0px'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sections.forEach(section => this.observer.observe(section));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;handleIntersection(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (entry.isIntersecting) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentSection = entry.target.id;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateNavigation();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;updateNavigation() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Убираем active со всех ссылок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const navLinks = this.nav.querySelectorAll('a');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;navLinks.forEach(link => link.classList.remove('active'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Добавляем active к текущей секции</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const currentLink = this.nav.querySelector(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\`a[href=\"#\${this.currentSection}\"]\`</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (currentLink) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentLink.classList.add('active');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Применения:</h4><ul><li>Изменение внешнего вида header при скролле</li><li>Подсветка активной секции в навигации</li><li>Показ/скрытие элементов header</li><li>Изменение цветовой схемы</li></ul><p><em>Преимущество:</em> Не нужно слушать scroll event и вычислять позицию вручную — IntersectionObserver делает это эффективно.</p>",
    difficulty: 'middle',
    tags: ['IntersectionObserver', 'navigation', 'sticky header', 'UX']
  },
  {
    id: 60,
    question: "Какие есть подводные камни и ограничения при работе с IntersectionObserver?",
    answer: "<p>При работе с IntersectionObserver важно знать о возможных проблемах и ограничениях:</p><h4>1. Поддержка браузеров:</h4><p><strong>Проблема:</strong> Не поддерживается в старых браузерах (IE, старые Safari).</p><p><strong>Решение:</strong> Использовать полифилл или проверку поддержки:</p><p><code>if ('IntersectionObserver' in window) {</code><br><code>&nbsp;&nbsp;// Используем IntersectionObserver</code><br><code>} else {</code><br><code>&nbsp;&nbsp;// Fallback на scroll event</code><br><code>&nbsp;&nbsp;import('intersection-observer'); // полифилл</code><br><code>}</code></p><h4>2. Асинхронность callback:</h4><p><strong>Проблема:</strong> Callback не вызывается мгновенно, есть небольшая задержка.</p><p><strong>Решение:</strong> Учитывать задержку в логике, использовать rootMargin для предзагрузки.</p><h4>3. Изменение размеров элемента:</h4><p><strong>Проблема:</strong> Observer не отслеживает изменения размеров элемента автоматически.</p><p><strong>Решение:</strong> Использовать ResizeObserver в дополнение или переподписываться при изменениях:</p><p><code>const resizeObserver = new ResizeObserver(() => {</code><br><code>&nbsp;&nbsp;intersectionObserver.unobserve(element);</code><br><code>&nbsp;&nbsp;intersectionObserver.observe(element);</code><br><code>});</code></p><h4>4. Проблемы с iframe:</h4><p><strong>Проблема:</strong> IntersectionObserver не работает корректно для отслеживания элементов внутри iframe.</p><p><strong>Решение:</strong> Создавать отдельный Observer внутри iframe или использовать альтернативные методы.</p><h4>5. Производительность при большом количестве элементов:</h4><p><strong>Проблема:</strong> Наблюдение за тысячами элементов может снизить производительность.</p><p><strong>Решение:</strong> Ограничивать количество наблюдаемых элементов, использовать виртуализацию:</p><p><code>class MemoryEfficientObserver {</code><br><code>&nbsp;&nbsp;constructor(maxElements = 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxElements = maxElements;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Логика управления количеством</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Неточность при быстром скролле:</h4><p><strong>Проблема:</strong> При очень быстрой прокрутке callback может не успеть вызваться.</p><p><strong>Решение:</strong> Использовать больший rootMargin для предзагрузки.</p><h4>7. Нет контроля над порядком вызовов:</h4><p><strong>Проблема:</strong> При одновременном пересечении нескольких элементов порядок entries не гарантирован.</p><p><strong>Решение:</strong> Сортировать entries вручную если порядок важен:</p><p><code>entries.sort((a, b) => {</code><br><code>&nbsp;&nbsp;return a.boundingClientRect.top - b.boundingClientRect.top;</code><br><code>});</code></p><h4>8. Утечки памяти:</h4><p><strong>Проблема:</strong> Забытый Observer продолжает работать и занимать память.</p><p><strong>Решение:</strong> Всегда вызывать disconnect() при размонтировании:</p><p><code>componentWillUnmount() {</code><br><code>&nbsp;&nbsp;this.observer.disconnect();</code><br><code>}</code></p><h4>9. Root элемент с overflow:hidden:</h4><p><strong>Проблема:</strong> Может некорректно определять пересечения в некоторых случаях.</p><p><strong>Решение:</strong> Тестировать конкретные сценарии, возможно использовать родительский элемент как root.</p><h4>10. SSR проблемы:</h4><p><strong>Проблема:</strong> IntersectionObserver недоступен на сервере (Node.js).</p><p><strong>Решение:</strong> Создавать Observer только на клиенте:</p><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;if (typeof window !== 'undefined') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new IntersectionObserver(...);</code><br><code>&nbsp;&nbsp;}</code><br><code>}, []);</code></p><p><em>Вывод:</em> IntersectionObserver — мощный API, но требует понимания ограничений и правильной обработки edge cases.</p>",
    difficulty: 'senior',
    tags: ['IntersectionObserver', 'ограничения', 'проблемы', 'troubleshooting']
  },
  {
    id: 61,
    question: "Что такое ResizeObserver и для чего он используется?",
    answer: "<p><strong>ResizeObserver</strong> — это Web API для асинхронного отслеживания изменений размеров DOM элементов:</p><h4>Основное назначение:</h4><p>Позволяет эффективно отслеживать когда элементы меняют свои размеры, в отличие от <code>window.resize</code> который отслеживает только размер окна браузера.</p><h4>Создание и использование:</h4><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;for (const entry of entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Width:', entry.contentRect.width);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Height:', entry.contentRect.height);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>observer.observe(element);</code></p><h4>Основные применения:</h4><ul><li><strong>Container Queries:</strong> Адаптивные компоненты на основе их размера</li><li><strong>Canvas:</strong> Обновление разрешения при изменении размера</li><li><strong>Виртуализация:</strong> Отслеживание высот элементов в списках</li><li><strong>Адаптивная типографика:</strong> Изменение размера шрифта</li><li><strong>Grid layouts:</strong> Динамическое количество колонок</li></ul><p><em>Ключевое отличие:</em> Реагирует на изменения размеров конкретных элементов из-за CSS, контента, родительских контейнеров — не только viewport.</p>",
    difficulty: 'junior',
    tags: ['ResizeObserver', 'основы', 'Web API', 'DOM']
  },
  {
    id: 62,
    question: "Каким образом можно отслеживать изменения размеров нескольких элементов с помощью ResizeObserver?",
    answer: "<p>Один ResizeObserver может эффективно наблюдать за множеством элементов одновременно:</p><h4>Базовый подход:</h4><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = entry.target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const width = entry.contentRect.width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Element \${element.id}: \${width}px\`);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>// Наблюдаем за несколькими элементами</code><br><code>const sidebar = document.querySelector('.sidebar');</code><br><code>const main = document.querySelector('.main');</code><br><code>const footer = document.querySelector('.footer');</code></p><p><code>observer.observe(sidebar);</code><br><code>observer.observe(main);</code><br><code>observer.observe(footer);</code></p><h4>С индивидуальными callback:</h4><p><code>const callbacks = new Map();</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const callback = callbacks.get(entry.target);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (callback) callback(entry);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>function observeElement(element, callback) {</code><br><code>&nbsp;&nbsp;callbacks.set(element, callback);</code><br><code>&nbsp;&nbsp;observer.observe(element);</code><br><code>}</code></p><p><code>observeElement(sidebar, (entry) => {</code><br><code>&nbsp;&nbsp;console.log('Sidebar:', entry.contentRect.width);</code><br><code>});</code></p><p><em>Преимущество:</em> Браузер оптимизирует вызовы callback, батчируя изменения всех наблюдаемых элементов.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'несколько элементов', 'оптимизация', 'паттерны']
  },
  {
    id: 63,
    question: "В чем разница между contentRect, contentBoxSize и borderBoxSize в ResizeObserver?",
    answer: "<p>ResizeObserver предоставляет три способа получения размеров элемента с разными box models:</p><h4>1. contentRect (устаревший, но широко поддерживается):</h4><p>Возвращает размеры <strong>content-box</strong> — только контент без padding.</p><p><code>observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;const height = entries[0].contentRect.height;</code><br><code>});</code></p><h4>2. contentBoxSize (современный):</h4><p>Массив размеров content-box с <code>inlineSize</code> и <code>blockSize</code>:</p><p><code>const size = Array.isArray(entry.contentBoxSize)</code><br><code>&nbsp;&nbsp;? entry.contentBoxSize[0]</code><br><code>&nbsp;&nbsp;: entry.contentBoxSize;</code></p><p><code>console.log('Width:', size.inlineSize);</code><br><code>console.log('Height:', size.blockSize);</code></p><h4>3. borderBoxSize:</h4><p>Размеры <strong>border-box</strong> — включая padding и border:</p><p><code>const size = Array.isArray(entry.borderBoxSize)</code><br><code>&nbsp;&nbsp;? entry.borderBoxSize[0]</code><br><code>&nbsp;&nbsp;: entry.borderBoxSize;</code></p><h4>4. devicePixelContentBoxSize:</h4><p>Размеры в device pixels для canvas и Retina дисплеев:</p><p><code>const size = entry.devicePixelContentBoxSize[0];</code><br><code>canvas.width = size.inlineSize;</code><br><code>canvas.height = size.blockSize;</code></p><h4>Указание box model при наблюдении:</h4><p><code>observer.observe(element, { box: 'border-box' });</code><br><code>// Опции: 'content-box', 'border-box', 'device-pixel-content-box'</code></p><p><em>Когда использовать:</em> content-box для контента, border-box для общих размеров элемента, device-pixel-content-box для canvas с правильным DPI.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'box model', 'contentRect', 'размеры']
  },
  {
    id: 64,
    question: "Как правильно освобождать ресурсы ResizeObserver при размонтировании компонента?",
    answer: "<p>Правильная очистка ResizeObserver критична для предотвращения утечек памяти:</p><h4>Методы очистки:</h4><p><strong>disconnect():</strong> Останавливает наблюдение за всеми элементами</p><p><code>observer.disconnect();</code></p><p><strong>unobserve(element):</strong> Прекращает наблюдение за конкретным элементом</p><p><code>observer.unobserve(element);</code></p><h4>В vanilla JavaScript:</h4><p><code>class Component {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;mount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.element);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;unmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>В React:</h4><p><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;const element = elementRef.current;</code></p><p><code>&nbsp;&nbsp;if (element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element) observer.unobserve(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;};</code><br><code>}, []);</code></p><h4>В Vue:</h4><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;observer.value = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;observer.value.observe(element.value);</code><br><code>});</code></p><p><code>onUnmounted(() => {</code><br><code>&nbsp;&nbsp;observer.value?.disconnect();</code><br><code>&nbsp;&nbsp;observer.value = null;</code><br><code>});</code></p><p><em>Критично:</em> Всегда вызывайте disconnect() или unobserve() при размонтировании, иначе observer продолжит работать и занимать память.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'cleanup', 'утечки памяти', 'lifecycle']
  },
  {
    id: 65,
    question: "Как оптимизировать производительность при использовании ResizeObserver для частых изменений?",
    answer: "<p>ResizeObserver callback может вызываться очень часто, требуя оптимизации:</p><h4>1. Debounce для тяжелых операций:</h4><p><code>function debounce(func, wait) {</code><br><code>&nbsp;&nbsp;let timeout;</code><br><code>&nbsp;&nbsp;return (...args) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = setTimeout(() => func(...args), wait);</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>const debouncedHandler = debounce((entry) => {</code><br><code>&nbsp;&nbsp;// Тяжелые вычисления</code><br><code>}, 250);</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(debouncedHandler);</code><br><code>});</code></p><h4>2. requestAnimationFrame для обновлений DOM:</h4><p><code>let rafId = null;</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (rafId) cancelAnimationFrame(rafId);</code></p><p><code>&nbsp;&nbsp;rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обновление DOM</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;rafId = null;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>3. Батчинг обновлений:</h4><p><code>class BatchedObserver {</code><br><code>&nbsp;&nbsp;constructor(callback, delay = 16) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pending = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.set(entry.target, entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(Array.from(this.pending.values()));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.clear();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>4. Условное наблюдение:</h4><p><code>class ConditionalObserver {</code><br><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.elements.forEach(el => this.observer.observe(el));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer?.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Золотое правило:</em> Callback должен быть быстрым. Тяжелые операции выносить в Web Workers или оптимизировать через debounce/RAF.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'производительность', 'оптимизация', 'debounce']
  },
  {
    id: 66,
    question: "Как использовать ResizeObserver для адаптивных компонентов (Container Queries)?",
    answer: "<p>ResizeObserver позволяет создавать адаптивные компоненты на основе их собственного размера, а не viewport:</p><h4>Базовая реализация:</h4><p><code>const card = document.querySelector('.card');</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;// Удаляем старые классы</code><br><code>&nbsp;&nbsp;card.classList.remove('small', 'medium', 'large');</code></p><p><code>&nbsp;&nbsp;// Добавляем класс в зависимости от ширины компонента</code><br><code>&nbsp;&nbsp;if (width < 400) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;card.classList.add('small');</code><br><code>&nbsp;&nbsp;} else if (width < 800) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;card.classList.add('medium');</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;card.classList.add('large');</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>observer.observe(card);</code></p><h4>CSS стили для разных размеров:</h4><p><code>.card.small {</code><br><code>&nbsp;&nbsp;flex-direction: column;</code><br><code>&nbsp;&nbsp;font-size: 14px;</code><br><code>}</code></p><p><code>.card.medium {</code><br><code>&nbsp;&nbsp;flex-direction: row;</code><br><code>&nbsp;&nbsp;font-size: 16px;</code><br><code>}</code></p><p><code>.card.large {</code><br><code>&nbsp;&nbsp;font-size: 20px;</code><br><code>}</code></p><h4>Адаптивная grid система:</h4><p><code>const grid = document.querySelector('.grid');</code></p><p><code>const gridObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;const minColumnWidth = 200;</code><br><code>&nbsp;&nbsp;const columns = Math.max(1, Math.floor(width / minColumnWidth));</code></p><p><code>&nbsp;&nbsp;grid.style.gridTemplateColumns = \`repeat(\${columns}, 1fr)\`;</code><br><code>});</code></p><p><code>gridObserver.observe(grid);</code></p><h4>В React хук:</h4><p><code>function useContainerQuery(breakpoints) {</code><br><code>&nbsp;&nbsp;const [size, setSize] = useState('large');</code><br><code>&nbsp;&nbsp;const ref = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (width < breakpoints.small) setSize('small');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (width < breakpoints.medium) setSize('medium');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else setSize('large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (ref.current) observer.observe(ref.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return [ref, size];</code><br><code>}</code></p><p><em>Преимущество:</em> Компонент адаптируется к своему контейнеру, а не к размеру экрана — идеально для переиспользуемых компонентов.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'Container Queries', 'адаптивность', 'компоненты']
  },
  {
    id: 67,
    question: "Как использовать ResizeObserver для правильного масштабирования canvas на Retina дисплеях?",
    answer: "<p>ResizeObserver с <code>device-pixel-content-box</code> позволяет правильно масштабировать canvas для Retina дисплеев:</p><h4>Проблема без ResizeObserver:</h4><p><code>// ❌ Размытый canvas на Retina</code><br><code>canvas.width = canvas.offsetWidth;</code><br><code>canvas.height = canvas.offsetHeight;</code></p><h4>Решение с ResizeObserver:</h4><p><code>const canvas = document.querySelector('canvas');</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;for (const entry of entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let width, height;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Используем device-pixel-content-box если доступен</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (entry.devicePixelContentBoxSize) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const size = Array.isArray(entry.devicePixelContentBoxSize)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? entry.devicePixelContentBoxSize[0]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: entry.devicePixelContentBoxSize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width = size.inlineSize;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = size.blockSize;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fallback для старых браузеров</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const dpr = window.devicePixelRatio || 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width = entry.contentRect.width * dpr;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = entry.contentRect.height * dpr;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Устанавливаем размеры canvas в device pixels</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.width = width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.height = height;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// CSS размеры остаются в CSS pixels</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.style.width = entry.contentRect.width + 'px';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;canvas.style.height = entry.contentRect.height + 'px';</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Перерисовка canvas</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;redrawCanvas();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>// Указываем box model для device pixels</code><br><code>observer.observe(canvas, { box: 'device-pixel-content-box' });</code></p><h4>Класс-обертка для canvas:</h4><p><code>class ResponsiveCanvas {</code><br><code>&nbsp;&nbsp;constructor(canvas) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.canvas = canvas;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.ctx = canvas.getContext('2d');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(canvas, { box: 'device-pixel-content-box' });</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const entry = entries[0];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Логика из примера выше</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Результат:</em> Четкий canvas на всех дисплеях, включая Retina, с автоматическим обновлением при изменении размеров.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'canvas', 'Retina', 'device pixels']
  },
  {
    id: 68,
    question: "В чем разница между ResizeObserver и window.resize event?",
    answer: "<p>ResizeObserver и window.resize решают разные задачи и имеют существенные различия:</p><h4>window.resize event:</h4><p><strong>Что отслеживает:</strong> Только изменения размера окна браузера (viewport)</p><p><code>window.addEventListener('resize', () => {</code><br><code>&nbsp;&nbsp;const width = window.innerWidth;</code><br><code>&nbsp;&nbsp;console.log('Window width:', width);</code><br><code>});</code></p><p><strong>Проблемы:</strong></p><ul><li>Не реагирует на изменения размеров элементов</li><li>Срабатывает очень часто (требует throttle)</li><li>Нужно вручную вычислять размеры элементов</li><li>getBoundingClientRect() вызывает reflow</li></ul><h4>ResizeObserver:</h4><p><strong>Что отслеживает:</strong> Размеры конкретных DOM элементов</p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;console.log('Element width:', width);</code><br><code>});</code><br><code>observer.observe(element);</code></p><p><strong>Преимущества:</strong></p><ul><li>Реагирует на CSS изменения, добавление контента</li><li>Работает с элементами внутри скролла</li><li>Браузер оптимизирует вызовы (батчинг)</li><li>Асинхронные вычисления без reflow</li><li>Не требует throttle из коробки</li></ul><h4>Сравнение кода:</h4><p><code>// ❌ window.resize - неэффективно для элементов</code><br><code>let timeout;</code><br><code>window.addEventListener('resize', () => {</code><br><code>&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;timeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const rect = element.getBoundingClientRect(); // Reflow!</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Width:', rect.width);</code><br><code>&nbsp;&nbsp;}, 100);</code><br><code>});</code></p><p><code>// ✅ ResizeObserver - эффективно и просто</code><br><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;console.log('Width:', entries[0].contentRect.width);</code><br><code>});</code><br><code>observer.observe(element);</code></p><h4>Когда использовать:</h4><p><strong>window.resize:</strong> Адаптивность на уровне viewport, медиа-запросы в JS</p><p><strong>ResizeObserver:</strong> Адаптивные компоненты, Container Queries, элемент-специфичная логика</p><p><em>Вывод:</em> Для отслеживания размеров элементов всегда используйте ResizeObserver — он эффективнее и точнее.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'window.resize', 'сравнение', 'различия']
  },
  {
    id: 69,
    question: "Как интегрировать ResizeObserver в React компонент?",
    answer: "<p>Существует несколько паттернов интеграции ResizeObserver с React:</p><h4>1. Хук useResizeObserver:</h4><p><code>import { useEffect, useRef } from 'react';</code></p><p><code>function useResizeObserver(callback) {</code><br><code>&nbsp;&nbsp;const observerRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observerRef.current?.disconnect();</code><br><code>&nbsp;&nbsp;}, [callback]);</code></p><p><code>&nbsp;&nbsp;const observe = (element) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element) observerRef.current?.observe(element);</code><br><code>&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;return { observe };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function MyComponent() {</code><br><code>&nbsp;&nbsp;const divRef = useRef(null);</code><br><code>&nbsp;&nbsp;const [size, setSize] = useState({ width: 0, height: 0 });</code></p><p><code>&nbsp;&nbsp;const { observe } = useResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const { width, height } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setSize({ width, height });</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (divRef.current) observe(divRef.current);</code><br><code>&nbsp;&nbsp;}, [observe]);</code></p><p><code>&nbsp;&nbsp;return &lt;div ref={divRef}&gt;{size.width}x{size.height}&lt;/div&gt;;</code><br><code>}</code></p><h4>2. Хук с ref:</h4><p><code>function useElementSize() {</code><br><code>&nbsp;&nbsp;const [size, setSize] = useState({ width: 0, height: 0 });</code><br><code>&nbsp;&nbsp;const elementRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = elementRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!element) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const { width, height } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setSize({ width, height });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return [elementRef, size];</code><br><code>}</code></p><p><code>// Использование</code><br><code>function Component() {</code><br><code>&nbsp;&nbsp;const [ref, size] = useElementSize();</code><br><code>&nbsp;&nbsp;return &lt;div ref={ref}&gt;Width: {size.width}px&lt;/div&gt;;</code><br><code>}</code></p><h4>3. Адаптивный компонент:</h4><p><code>function AdaptiveCard() {</code><br><code>&nbsp;&nbsp;const [layout, setLayout] = useState('large');</code><br><code>&nbsp;&nbsp;const cardRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (width < 300) setLayout('small');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (width < 600) setLayout('medium');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else setLayout('large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (cardRef.current) observer.observe(cardRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return &lt;div ref={cardRef} className={\`card--\${layout}\`}&gt;...&lt;/div&gt;;</code><br><code>}</code></p><p><em>Best practice:</em> Всегда очищайте observer в cleanup функции useEffect для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'React', 'hooks', 'интеграция']
  },
  {
    id: 70,
    question: "Как интегрировать ResizeObserver в Vue компонент?",
    answer: "<p>В Vue 3 ResizeObserver интегрируется через composables и директивы:</p><h4>1. Composable useResizeObserver:</h4><p><code>import { ref, onMounted, onUnmounted } from 'vue';</code></p><p><code>export function useResizeObserver(callback, options = {}) {</code><br><code>&nbsp;&nbsp;const observer = ref(null);</code></p><p><code>&nbsp;&nbsp;const observe = (element) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!element) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!observer.value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observer.value = new ResizeObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.value.observe(element, options);</code><br><code>&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;const disconnect = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.value?.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.value = null;</code><br><code>&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;onUnmounted(() => disconnect());</code></p><p><code>&nbsp;&nbsp;return { observe, disconnect };</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>const boxRef = ref(null);</code><br><code>const size = ref({ width: 0, height: 0 });</code></p><p><code>const { observe } = useResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const { width, height } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;size.value = { width, height };</code><br><code>});</code></p><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;if (boxRef.value) observe(boxRef.value);</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div ref=\"boxRef\"&gt;{{ size.width }}x{{ size.height }}&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>2. Composable для размеров элемента:</h4><p><code>export function useElementSize(elementRef) {</code><br><code>&nbsp;&nbsp;const width = ref(0);</code><br><code>&nbsp;&nbsp;const height = ref(0);</code></p><p><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!elementRef.value) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const { width: w, height: h } = entries[0].contentRect;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width.value = w;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height.value = h;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(elementRef.value);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;onUnmounted(() => observer.disconnect());</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;return { width, height };</code><br><code>}</code></p><h4>3. Директива v-resize:</h4><p><code>export const vResize = {</code><br><code>&nbsp;&nbsp;mounted(el, binding) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const callback = binding.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof callback !== 'function') return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;el._resizeObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(entries[0]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;el._resizeObserver.observe(el);</code><br><code>&nbsp;&nbsp;},</code></p><p><code>&nbsp;&nbsp;unmounted(el) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;el._resizeObserver?.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;delete el._resizeObserver;</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><p><code>// Использование</code><br><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div v-resize=\"handleResize\"&gt;Content&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><p><code>&lt;script setup&gt;</code><br><code>function handleResize(entry) {</code><br><code>&nbsp;&nbsp;console.log('Width:', entry.contentRect.width);</code><br><code>}</code><br><code>&lt;/script&gt;</code></p><p><em>Best practice:</em> Используйте composables для переиспользуемой логики и директивы для простых случаев.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'Vue', 'composables', 'директивы']
  },
  {
    id: 71,
    question: "Какие есть подводные камни и ограничения при работе с ResizeObserver?",
    answer: "<p>При работе с ResizeObserver важно знать о возможных проблемах и ограничениях:</p><h4>1. Infinite loop при изменении размеров в callback:</h4><p><strong>Проблема:</strong> Изменение размеров элемента внутри callback вызывает новый resize</p><p><code>// ❌ Бесконечный цикл!</code><br><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const element = entries[0].target;</code><br><code>&nbsp;&nbsp;element.style.width = entries[0].contentRect.width + 10 + 'px';</code><br><code>});</code></p><p><strong>Решение:</strong> Не изменять размеры наблюдаемых элементов в callback</p><h4>2. Частые вызовы callback:</h4><p><strong>Проблема:</strong> Callback может вызываться очень часто при анимациях</p><p><strong>Решение:</strong> Использовать debounce или requestAnimationFrame</p><h4>3. Поддержка браузеров:</h4><p><strong>Проблема:</strong> Не поддерживается в старых браузерах (IE, старые Safari)</p><p><strong>Решение:</strong> Использовать полифил или проверку поддержки:</p><p><code>if ('ResizeObserver' in window) {</code><br><code>&nbsp;&nbsp;// Используем ResizeObserver</code><br><code>} else {</code><br><code>&nbsp;&nbsp;// Fallback на window.resize</code><br><code>}</code></p><h4>4. Асинхронность callback:</h4><p><strong>Проблема:</strong> Callback вызывается асинхронно, есть небольшая задержка</p><p><strong>Решение:</strong> Учитывать задержку, использовать rootMargin для предзагрузки</p><h4>5. Не отслеживает изменения размеров автоматически:</h4><p><strong>Проблема:</strong> Нужно явно вызвать observe() для каждого элемента</p><p><strong>Решение:</strong> Использовать MutationObserver для динамически добавляемых элементов</p><h4>6. Проблемы с display:none:</h4><p><strong>Проблема:</strong> Может некорректно работать с элементами display:none</p><p><strong>Решение:</strong> Начинать наблюдение после отображения элемента</p><h4>7. Производительность при большом количестве элементов:</h4><p><strong>Проблема:</strong> Наблюдение за тысячами элементов может снизить производительность</p><p><strong>Решение:</strong> Ограничивать количество, использовать виртуализацию</p><h4>8. SSR проблемы:</h4><p><strong>Проблема:</strong> ResizeObserver недоступен на сервере</p><p><strong>Решение:</strong> Создавать observer только на клиенте:</p><p><code>if (typeof window !== 'undefined') {</code><br><code>&nbsp;&nbsp;const observer = new ResizeObserver(...);</code><br><code>}</code></p><h4>9. Утечки памяти:</h4><p><strong>Проблема:</strong> Забытый observer продолжает работать</p><p><strong>Решение:</strong> Всегда вызывать disconnect() при размонтировании</p><p><em>Вывод:</em> ResizeObserver — мощный API, но требует понимания ограничений и правильной обработки edge cases.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'ограничения', 'проблемы', 'troubleshooting']
  },
  {
    id: 72,
    question: "Как реализовать виртуализацию списка с динамической высотой элементов через ResizeObserver?",
    answer: "<p>ResizeObserver идеален для виртуализации списков где элементы имеют неизвестную высоту:</p><h4>Проблема виртуализации:</h4><p>В классической виртуализации нужно знать высоту элементов заранее. ResizeObserver позволяет измерять реальные высоты.</p><h4>Базовая реализация:</h4><p><code>class VirtualList {</code><br><code>&nbsp;&nbsp;constructor(container, items) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.items = items;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.itemHeights = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.estimatedHeight = 50; // Примерная высота</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;renderItem(item, index) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const element = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.className = 'list-item';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.textContent = item;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;element.dataset.index = index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за каждым элементом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return element;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const index = parseInt(entry.target.dataset.index);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const height = entry.contentRect.height;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем реальную высоту</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.itemHeights.set(index, height);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Пересчитываем виртуальный скролл</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateVirtualScroll();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;getItemOffset(index) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let offset = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < index; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += this.itemHeights.get(i) || this.estimatedHeight;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return offset;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;updateVirtualScroll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const scrollTop = this.container.scrollTop;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const viewportHeight = this.container.clientHeight;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Находим видимые элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let startIndex = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let currentOffset = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;while (currentOffset < scrollTop && startIndex < this.items.length) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentOffset += this.itemHeights.get(startIndex) || this.estimatedHeight;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startIndex++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Рендерим видимые элементы + буфер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.render(startIndex);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React реализация:</h4><p><code>function VirtualList({ items }) {</code><br><code>&nbsp;&nbsp;const [itemHeights, setItemHeights] = useState(new Map());</code><br><code>&nbsp;&nbsp;const observerRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newHeights = new Map(itemHeights);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const index = parseInt(entry.target.dataset.index);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newHeights.set(index, entry.contentRect.height);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setItemHeights(newHeights);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observerRef.current?.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;// Логика виртуализации...</code><br><code>}</code></p><p><em>Преимущество:</em> Виртуализация работает даже с элементами неизвестной и изменяющейся высоты.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'виртуализация', 'списки', 'производительность']
  },
  {
    id: 73,
    question: "Как использовать ResizeObserver для адаптивной типографики?",
    answer: "<p>ResizeObserver позволяет создавать адаптивную типографику на уровне компонента:</p><h4>Базовый пример — масштабирование шрифта:</h4><p><code>const textElement = document.querySelector('.responsive-text');</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;// Адаптивный размер шрифта</code><br><code>&nbsp;&nbsp;let fontSize;</code><br><code>&nbsp;&nbsp;if (width < 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '14px';</code><br><code>&nbsp;&nbsp;} else if (width < 600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '16px';</code><br><code>&nbsp;&nbsp;} else if (width < 900) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '18px';</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fontSize = '20px';</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;textElement.style.fontSize = fontSize;</code><br><code>});</code></p><p><code>observer.observe(textElement);</code></p><h4>Fluid typography с формулой:</h4><p><code>const fluidObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;// Линейная интерполяция</code><br><code>&nbsp;&nbsp;const minWidth = 320;</code><br><code>&nbsp;&nbsp;const maxWidth = 1200;</code><br><code>&nbsp;&nbsp;const minFontSize = 16;</code><br><code>&nbsp;&nbsp;const maxFontSize = 24;</code></p><p><code>&nbsp;&nbsp;const clampedWidth = Math.max(minWidth, Math.min(width, maxWidth));</code><br><code>&nbsp;&nbsp;const fontSize = minFontSize + </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;(maxFontSize - minFontSize) * </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;((clampedWidth - minWidth) / (maxWidth - minWidth));</code></p><p><code>&nbsp;&nbsp;textElement.style.fontSize = fontSize + 'px';</code><br><code>});</code></p><h4>Адаптация всей типографики:</h4><p><code>class ResponsiveTypography {</code><br><code>&nbsp;&nbsp;constructor(container) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container = container;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(container);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Базовый размер шрифта</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const baseFontSize = this.calculateFontSize(width, 16, 20);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.fontSize = baseFontSize + 'px';</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Межстрочный интервал</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const lineHeight = width < 600 ? 1.5 : 1.6;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.lineHeight = lineHeight;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Ширина контента</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const maxWidth = width < 800 ? '100%' : '70ch';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.maxWidth = maxWidth;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отступы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const padding = width < 600 ? '1rem' : '2rem';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.padding = padding;</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;calculateFontSize(width, min, max) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const minWidth = 320;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const maxWidth = 1200;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const clampedWidth = Math.max(minWidth, Math.min(width, maxWidth));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return min + (max - min) * ((clampedWidth - minWidth) / (maxWidth - minWidth));</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React компонент:</h4><p><code>function ResponsiveText({ children }) {</code><br><code>&nbsp;&nbsp;const [fontSize, setFontSize] = useState(16);</code><br><code>&nbsp;&nbsp;const textRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const size = 14 + (width / 100);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setFontSize(Math.min(24, Math.max(14, size)));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (textRef.current) observer.observe(textRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => observer.disconnect();</code><br><code>&nbsp;&nbsp;}, []);</code></p><p><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div ref={textRef} style={{ fontSize: \`\${fontSize}px\` }}&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{children}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Применение:</em> Карточки товаров, адаптивные заголовки, текст в sidebar, модальные окна — везде где размер контейнера непредсказуем.</p>",
    difficulty: 'middle',
    tags: ['ResizeObserver', 'типографика', 'адаптивность', 'responsive']
  },
  {
    id: 74,
    question: "Как реализовать debounce и throttle для ResizeObserver?",
    answer: "<p>ResizeObserver callback может вызываться очень часто, особенно при анимациях. Debounce и throttle помогают оптимизировать:</p><h4>1. Debounce (задержка до последнего изменения):</h4><p><code>function debounce(func, wait) {</code><br><code>&nbsp;&nbsp;let timeout;</code><br><code>&nbsp;&nbsp;return function executedFunction(...args) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const later = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func(...args);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeout = setTimeout(later, wait);</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>const debouncedHandler = debounce((entry) => {</code><br><code>&nbsp;&nbsp;console.log('Debounced resize:', entry.contentRect.width);</code><br><code>&nbsp;&nbsp;// Тяжелые вычисления</code><br><code>}, 250);</code></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(debouncedHandler);</code><br><code>});</code></p><h4>2. Throttle (ограничение частоты):</h4><p><code>function throttle(func, limit) {</code><br><code>&nbsp;&nbsp;let inThrottle;</code><br><code>&nbsp;&nbsp;return function(...args) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!inThrottle) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func.apply(this, args);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inThrottle = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => inThrottle = false, limit);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><code>const throttledHandler = throttle((entry) => {</code><br><code>&nbsp;&nbsp;console.log('Throttled resize:', entry.contentRect.width);</code><br><code>}, 100);</code></p><p><code>const throttledObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;entries.forEach(throttledHandler);</code><br><code>});</code></p><h4>3. requestAnimationFrame подход:</h4><p><code>let rafId = null;</code></p><p><code>const rafObserver = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (rafId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;cancelAnimationFrame(rafId);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('RAF resize:', entry.contentRect.width);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обновление DOM</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;rafId = null;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>4. Батчинг с задержкой:</h4><p><code>class BatchedResizeObserver {</code><br><code>&nbsp;&nbsp;constructor(callback, delay = 16) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pending = new Map();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timeoutId = null;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new ResizeObserver(this.handleResize.bind(this));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;handleResize(entries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Собираем все изменения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;entries.forEach(entry => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.set(entry.target, entry);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Откладываем обработку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.timeoutId) clearTimeout(this.timeoutId);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const entries = Array.from(this.pending.values());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback(entries);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pending.clear();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;observe(element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(element);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const batchedObserver = new BatchedResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;console.log('Batched resize for', entries.length, 'elements');</code><br><code>});</code></p><h4>Когда использовать:</h4><ul><li><strong>Debounce:</strong> Тяжелые вычисления после завершения изменений</li><li><strong>Throttle:</strong> Регулярные обновления во время изменений</li><li><strong>RAF:</strong> Визуальные обновления DOM</li><li><strong>Батчинг:</strong> Множество элементов, одна обработка</li></ul><p><em>Важно:</em> Не все случаи требуют оптимизации — простые операции можно выполнять напрямую.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'debounce', 'throttle', 'оптимизация']
  },
  {
    id: 75,
    question: "Когда следует использовать ResizeObserver вместо CSS Container Queries?",
    answer: "<p>CSS Container Queries и ResizeObserver решают похожие задачи, но имеют разные применения:</p><h4>CSS Container Queries (современный стандарт):</h4><p><strong>Что это:</strong> CSS правила, зависящие от размера контейнера</p><p><code>/* CSS */</code><br><code>.container {</code><br><code>&nbsp;&nbsp;container-type: inline-size;</code><br><code>}</code></p><p><code>@container (min-width: 400px) {</code><br><code>&nbsp;&nbsp;.card {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;flex-direction: row;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><strong>Преимущества:</strong></p><ul><li>Декларативный подход</li><li>Оптимизирован браузером</li><li>Нет JavaScript</li><li>Работает с CSS transitions/animations</li></ul><p><strong>Ограничения:</strong></p><ul><li>Только стили, нет логики</li><li>Поддержка браузеров (2023+)</li><li>Нельзя читать размеры в JS</li></ul><h4>ResizeObserver:</h4><p><strong>Когда использовать:</strong></p><p><strong>1. Нужна логика в JavaScript:</strong></p><p><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Сложная логика</code><br><code>&nbsp;&nbsp;if (shouldLoadMore(width)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loadMoreItems();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><strong>2. Canvas или WebGL:</strong></p><p><code>observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const size = entries[0].devicePixelContentBoxSize[0];</code><br><code>&nbsp;&nbsp;canvas.width = size.inlineSize;</code><br><code>&nbsp;&nbsp;canvas.height = size.blockSize;</code><br><code>&nbsp;&nbsp;redraw();</code><br><code>});</code></p><p><strong>3. Динамические вычисления:</strong></p><p><code>observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;const width = entries[0].contentRect.width;</code><br><code>&nbsp;&nbsp;const columns = Math.floor(width / 200);</code><br><code>&nbsp;&nbsp;updateGridColumns(columns);</code><br><code>});</code></p><p><strong>4. Интеграция с фреймворками:</strong></p><p><code>// React state обновления</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setWidth(entries[0].contentRect.width);</code><br><code>&nbsp;&nbsp;});</code><br><code>}, []);</code></p><p><strong>5. Старые браузеры:</strong></p><p>Container Queries поддерживаются с 2023, ResizeObserver — с 2019</p><h4>Сравнение применений:</h4><table><tr><th>Задача</th><th>Лучший выбор</th></tr><tr><td>Адаптивные стили</td><td>Container Queries</td></tr><tr><td>Canvas размеры</td><td>ResizeObserver</td></tr><tr><td>Grid columns</td><td>Container Queries или ResizeObserver</td></tr><tr><td>Виртуализация</td><td>ResizeObserver</td></tr><tr><td>Вызов API</td><td>ResizeObserver</td></tr><tr><td>Анимации</td><td>Container Queries</td></tr></table><h4>Комбинированный подход:</h4><p><code>/* CSS для стилей */</code><br><code>@container (min-width: 600px) {</code><br><code>&nbsp;&nbsp;.card { ... }</code><br><code>}</code></p><p><code>// JS для логики</code><br><code>const observer = new ResizeObserver((entries) => {</code><br><code>&nbsp;&nbsp;if (entries[0].contentRect.width > 600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loadHighResImages();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><em>Вывод:</em> Container Queries для стилей, ResizeObserver для логики. Используйте оба при необходимости.</p>",
    difficulty: 'senior',
    tags: ['ResizeObserver', 'Container Queries', 'сравнение', 'CSS']
  },
  {
    id: 76,
    question: "Что такое MutationObserver и для чего он используется?",
    answer: "<p><strong>MutationObserver</strong> — это Web API для асинхронного отслеживания изменений в DOM-дереве:</p><h4>Основное назначение:</h4><p>Позволяет наблюдать за добавлением/удалением элементов, изменением атрибутов и текстового содержимого, предоставляя механизм реагирования на DOM-мутации.</p><h4>Создание наблюдателя:</h4><p><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Тип изменения:', mutation.type);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Целевой элемент:', mutation.target);</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>observer.observe(targetElement, {</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;subtree: true</code><br><code>});</code></p><h4>Основные применения:</h4><ul><li><strong>Мониторинг:</strong> Отслеживание изменений для аналитики</li><li><strong>Автоматизация:</strong> Автосохранение, анимации при появлении</li><li><strong>Интеграция:</strong> Работа со сторонними библиотеками</li><li><strong>Безопасность:</strong> Обнаружение инъекций скриптов</li><li><strong>Ленивая загрузка:</strong> Загрузка контента при появлении</li></ul><p><em>Ключевое отличие:</em> Асинхронный и эффективный в отличие от setInterval для проверки DOM.</p>",
    difficulty: 'junior',
    tags: ['MutationObserver', 'основы', 'Web API', 'DOM']
  },

  {
    id: 77,
    question: "Какие типы изменений может отслеживать MutationObserver?",
    answer: "<p>MutationObserver может отслеживать три основных типа изменений в DOM:</p><h4>1. childList - изменения дочерних элементов:</h4><p><code>observer.observe(element, {</code><br><code>&nbsp;&nbsp;childList: true</code><br><code>});</code></p><p>Отслеживает добавление и удаление дочерних узлов. Свойства MutationRecord: <code>addedNodes</code>, <code>removedNodes</code>, <code>previousSibling</code>, <code>nextSibling</code></p><h4>2. attributes - изменения атрибутов:</h4><p><code>observer.observe(element, {</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;attributeOldValue: true,</code><br><code>&nbsp;&nbsp;attributeFilter: ['class', 'style']</code><br><code>});</code></p><p>Отслеживает изменения атрибутов элемента. Свойства: <code>attributeName</code>, <code>oldValue</code></p><h4>3. characterData - изменения текста:</h4><p><code>observer.observe(textNode, {</code><br><code>&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;characterDataOldValue: true</code><br><code>});</code></p><p>Отслеживает изменения текстового содержимого узлов. Свойства: <code>oldValue</code>, <code>target.data</code></p><h4>Дополнительные опции:</h4><ul><li><code>subtree: true</code> — наблюдать за всем поддеревом</li><li><code>attributeOldValue: true</code> — сохранять предыдущие значения атрибутов</li><li><code>characterDataOldValue: true</code> — сохранять предыдущий текст</li><li><code>attributeFilter: ['attr1', 'attr2']</code> — отслеживать только указанные атрибуты</li></ul><p><em>Важно:</em> Хотя бы одна из основных опций (childList, attributes, characterData) обязательна.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'типы мутаций', 'конфигурация', 'API']
  },

  {
    id: 78,
    question: "Как правильно настроить конфигурацию MutationObserver?",
    answer: "<p>Конфигурация определяет какие изменения отслеживать и как их обрабатывать:</p><h4>Минимальная конфигурация:</h4><p><code>const config = {</code><br><code>&nbsp;&nbsp;childList: true // Обязательна хотя бы одна опция</code><br><code>};</code></p><h4>Полная конфигурация:</h4><p><code>const fullConfig = {</code><br><code>&nbsp;&nbsp;// Основные опции (хотя бы одна обязательна)</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Расширенные опции</code><br><code>&nbsp;&nbsp;subtree: true,</code><br><code>&nbsp;&nbsp;attributeOldValue: true,</code><br><code>&nbsp;&nbsp;characterDataOldValue: true,</code><br><code>&nbsp;&nbsp;attributeFilter: ['class', 'id', 'data-state']</code><br><code>};</code></p><h4>Примеры под задачи:</h4><p><strong>Отслеживание классов:</strong></p><p><code>{ attributes: true, attributeFilter: ['class'] }</code></p><p><strong>Глубокое наблюдение:</strong></p><p><code>{ childList: true, subtree: true }</code></p><p><strong>Мониторинг редактора:</strong></p><p><code>{ childList: true, characterData: true, subtree: true }</code></p><h4>Типичные ошибки:</h4><p><code>// ❌ Нет основной опции</code><br><code>{ subtree: true }</code></p><p><code>// ❌ attributeOldValue без attributes</code><br><code>{ childList: true, attributeOldValue: true }</code></p><p><code>// ✅ Правильно</code><br><code>{ attributes: true, attributeOldValue: true }</code></p><p><em>Best practice:</em> Используйте только необходимые опции для оптимизации производительности.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'конфигурация', 'опции', 'настройка']
  },

  {
    id: 79,
    question: "Как работать с MutationRecord и какая информация в нем доступна?",
    answer: "<p><strong>MutationRecord</strong> — объект, описывающий одно изменение в DOM, передается в callback:</p><h4>Общие свойства для всех типов:</h4><p><code>mutation.type</code> — тип изменения ('childList', 'attributes', 'characterData')</p><p><code>mutation.target</code> — элемент, в котором произошло изменение</p><h4>Для childList мутаций:</h4><p><code>mutation.addedNodes</code> — NodeList добавленных узлов</p><p><code>mutation.removedNodes</code> — NodeList удаленных узлов</p><p><code>mutation.previousSibling</code> — предыдущий сосед</p><p><code>mutation.nextSibling</code> — следующий сосед</p><h4>Для attributes мутаций:</h4><p><code>mutation.attributeName</code> — имя измененного атрибута</p><p><code>mutation.oldValue</code> — предыдущее значение (если attributeOldValue: true)</p><h4>Для characterData мутаций:</h4><p><code>mutation.oldValue</code> — предыдущий текст (если characterDataOldValue: true)</p><p><code>mutation.target.data</code> — новый текст</p><h4>Пример обработки:</h4><p><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (mutation.type) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'childList':</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Добавлено:', mutation.addedNodes.length);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Удалено:', mutation.removedNodes.length);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'attributes':</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newValue = mutation.target.getAttribute(mutation.attributeName);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`\${mutation.attributeName}: \${mutation.oldValue} → \${newValue}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'characterData':</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Текст: \${mutation.oldValue} → \${mutation.target.data}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><em>Важно:</em> Проверяйте nodeType добавленных/удаленных узлов — могут быть текстовые узлы и комментарии.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'MutationRecord', 'свойства', 'обработка']
  },

  {
    id: 80,
    question: "В чем разница между disconnect(), takeRecords() и unobserve()?",
    answer: "<p>MutationObserver предоставляет три метода управления наблюдением:</p><h4>1. disconnect() - полная остановка:</h4><p><code>observer.disconnect();</code></p><p><strong>Что делает:</strong></p><ul><li>Останавливает все наблюдение</li><li>Очищает очередь накопленных мутаций</li><li>Освобождает ресурсы</li></ul><p><strong>Когда использовать:</strong> При размонтировании компонента, когда observer больше не нужен</p><h4>2. takeRecords() - синхронное получение:</h4><p><code>const pendingMutations = observer.takeRecords();</code></p><p><strong>Что делает:</strong></p><ul><li>Возвращает массив накопленных мутаций</li><li>Очищает очередь мутаций</li><li>НЕ останавливает наблюдение</li><li>НЕ вызывает callback</li></ul><p><strong>Когда использовать:</strong> Для синхронной обработки перед disconnect, для немедленной обработки без ожидания callback</p><p><code>// Пример использования</code><br><code>window.addEventListener('beforeunload', () => {</code><br><code>&nbsp;&nbsp;const mutations = observer.takeRecords();</code><br><code>&nbsp;&nbsp;if (mutations.length > 0) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Синхронная обработка перед закрытием</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;processMutations(mutations);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;observer.disconnect();</code><br><code>});</code></p><h4>3. unobserve() - НЕ существует!</h4><p><strong>Важно:</strong> В отличие от IntersectionObserver и ResizeObserver, у MutationObserver НЕТ метода unobserve(). Можно только полностью остановить наблюдение через disconnect() и затем создать новый observer с нужной конфигурацией.</p><h4>Сравнение:</h4><table><tr><th>Метод</th><th>Останавливает</th><th>Очищает очередь</th><th>Возвращает мутации</th></tr><tr><td>disconnect()</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>takeRecords()</td><td>❌</td><td>✅</td><td>✅</td></tr></table><p><em>Best practice:</em> Всегда вызывайте disconnect() при удалении компонента для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'методы', 'управление', 'lifecycle']
  },

  {
    id: 81,
    question: "Как реализовать автосохранение контента с помощью MutationObserver?",
    answer: "<p>Автосохранение при редактировании — классическое применение MutationObserver:</p><h4>Базовая реализация с debounce:</h4><p><code>class AutoSave {</code><br><code>&nbsp;&nbsp;constructor(element, saveCallback, delay = 2000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.element = element;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.saveCallback = saveCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.saveTimeout = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.hasUnsavedChanges = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hasUnsavedChanges = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.scheduleSave();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.element, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;scheduleSave() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.saveTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.saveTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.save();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;async save() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.hasUnsavedChanges) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const content = this.element.innerHTML;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Автосохранение...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await this.saveCallback(content);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hasUnsavedChanges = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showSaveStatus('Сохранено');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.showSaveStatus('Ошибка сохранения', 'error');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;showSaveStatus(message, type = 'success') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Показать индикатор статуса</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;destroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.saveTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const editor = document.querySelector('#editor');</code><br><code>const autoSave = new AutoSave(editor, async (content) => {</code><br><code>&nbsp;&nbsp;// Сохранение в localStorage</code><br><code>&nbsp;&nbsp;localStorage.setItem('draft', content);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Или отправка на сервер</code><br><code>&nbsp;&nbsp;await fetch('/api/save', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({ content }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;headers: { 'Content-Type': 'application/json' }</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>Расширенная версия с индикатором:</h4><p><code>class AdvancedAutoSave extends AutoSave {</code><br><code>&nbsp;&nbsp;constructor(element, saveCallback, delay) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super(element, saveCallback, delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.createStatusIndicator();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;createStatusIndicator() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator = document.createElement('div');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = 'save-status';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.element.parentElement.appendChild(this.indicator);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;scheduleSave() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super.scheduleSave();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = 'Несохраненные изменения...';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = 'save-status pending';</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;showSaveStatus(message, type) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = message;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.className = \`save-status \${type}\`;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.indicator.textContent = '';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 2000);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Ключевые моменты:</em> Debounce для предотвращения частых сохранений, индикатор статуса для UX, обработка ошибок, cleanup при уничтожении.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'автосохранение', 'практика', 'UX']
  },

  {
    id: 82,
    question: "Как отслеживать появление элементов в DOM для lazy loading?",
    answer: "<p>MutationObserver идеален для отслеживания динамически добавляемых элементов:</p><h4>Реализация lazy loader:</h4><p><code>class LazyLoadObserver {</code><br><code>&nbsp;&nbsp;constructor(selector, loadCallback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.selector = selector;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback = loadCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements = new WeakSet();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.checkExistingElements();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем сам узел</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.nodeType === Node.ELEMENT_NODE) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkElement(node);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем потомков</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const elements = node.querySelectorAll(this.selector);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements.forEach(el => this.checkElement(el));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkExistingElements() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем уже существующие элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.querySelectorAll(this.selector).forEach(el => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkElement(el);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkElement(element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (element.matches && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.matches(this.selector) && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!this.loadedElements.has(element)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements.add(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование для изображений:</h4><p><code>// HTML: &lt;img data-src=\"image.jpg\" class=\"lazy\"&gt;</code></p><p><code>const lazyImages = new LazyLoadObserver('img[data-src]', (img) => {</code><br><code>&nbsp;&nbsp;img.src = img.dataset.src;</code><br><code>&nbsp;&nbsp;img.classList.add('loaded');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.classList.add('fade-in');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Загружено:', img.dataset.src);</code><br><code>&nbsp;&nbsp;};</code><br><code>});</code></p><h4>Для динамических компонентов:</h4><p><code>const componentLoader = new LazyLoadObserver('[data-component]', (element) => {</code><br><code>&nbsp;&nbsp;const componentName = element.dataset.component;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Динамическая загрузка модуля</code><br><code>&nbsp;&nbsp;import(\`./components/\${componentName}.js\`)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.then(module => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module.init(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;.catch(err => console.error('Ошибка загрузки:', err));</code><br><code>});</code></p><h4>С приоритетами загрузки:</h4><p><code>class PriorityLazyLoader extends LazyLoadObserver {</code><br><code>&nbsp;&nbsp;checkElement(element) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.loadedElements.has(element)) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const priority = element.dataset.priority || 'normal';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (priority === 'high') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements.add(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestIdleCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadCallback(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loadedElements.add(element);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Преимущество:</em> Автоматически обрабатывает все элементы, добавляемые в DOM в любой момент, без необходимости явных вызовов.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'lazy loading', 'динамический контент', 'производительность']
  },

  {
    id: 83,
    question: "Как использовать MutationObserver для отслеживания изменений темы (светлая/темная)?",
    answer: "<p>Отслеживание изменений темы полезно для обновления зависимых компонентов:</p><h4>Базовая реализация:</h4><p><code>class ThemeObserver {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentTheme = this.detectTheme();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;detectTheme() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return document.body.classList.contains('dark-theme') </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? 'dark' </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 'light';</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mutation.type === 'attributes' && </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.attributeName === 'class') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newTheme = this.detectTheme();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newTheme !== this.currentTheme) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentTheme = newTheme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.notifyThemeChange(newTheme);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributeFilter: ['class']</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;onThemeChange(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.push(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызываем сразу с текущей темой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;callback(this.currentTheme);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;offThemeChange(callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const index = this.callbacks.indexOf(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (index > -1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.splice(index, 1);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;notifyThemeChange(theme) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Тема изменена на:', theme);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callbacks.forEach(callback => callback(theme));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const themeObserver = new ThemeObserver();</code></p><p><code>// Обновление графиков</code><br><code>themeObserver.onThemeChange((theme) => {</code><br><code>&nbsp;&nbsp;chart.updateOptions({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;theme: { mode: theme }</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>// Обновление карты</code><br><code>themeObserver.onThemeChange((theme) => {</code><br><code>&nbsp;&nbsp;map.setStyle(theme === 'dark' ? 'dark-style' : 'light-style');</code><br><code>});</code></p><p><code>// Сохранение в localStorage</code><br><code>themeObserver.onThemeChange((theme) => {</code><br><code>&nbsp;&nbsp;localStorage.setItem('preferred-theme', theme);</code><br><code>});</code></p><h4>Расширенная версия с data-атрибутом:</h4><p><code>class AdvancedThemeObserver extends ThemeObserver {</code><br><code>&nbsp;&nbsp;detectTheme() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const dataTheme = document.body.dataset.theme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (dataTheme) return dataTheme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Fallback на класс</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return super.detectTheme();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mutation.type === 'attributes') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newTheme = this.detectTheme();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newTheme !== this.currentTheme) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentTheme = newTheme;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.notifyThemeChange(newTheme);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributeFilter: ['class', 'data-theme']</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Применение:</em> Синхронизация UI компонентов, графиков, карт, видео-плееров с текущей темой без prop drilling.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'темы', 'UI синхронизация', 'практика']
  },

  {
    id: 84,
    question: "Как оптимизировать производительность MutationObserver при частых изменениях?",
    answer: "<p>MutationObserver callback может вызываться очень часто, требуя оптимизации:</p><h4>1. Debounce для тяжелых операций:</h4><p><code>class DebouncedObserver {</code><br><code>&nbsp;&nbsp;constructor(target, config, callback, delay = 250) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.timeout = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations.push(...mutations);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback(this.pendingMutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(target, config);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>2. Throttle для ограничения частоты:</h4><p><code>class ThrottledObserver {</code><br><code>&nbsp;&nbsp;constructor(target, config, callback, interval = 1000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.interval = interval;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations.push(...mutations);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const timeSinceLastCall = now - this.lastCall;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timeSinceLastCall >= this.interval) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.callback(this.pendingMutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pendingMutations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastCall = now;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(target, config);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>3. requestAnimationFrame для DOM обновлений:</h4><p><code>let rafId = null;</code></p><p><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;if (rafId) cancelAnimationFrame(rafId);</code></p><p><code>&nbsp;&nbsp;rafId = requestAnimationFrame(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обновления DOM синхронизированы с браузером</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateUI(mutation);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;rafId = null;</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><h4>4. Batch DOM операций:</h4><p><code>// ❌ ПЛОХО - observer срабатывает для каждого appendChild</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;const div = document.createElement('div');</code><br><code>&nbsp;&nbsp;div.textContent = item;</code><br><code>&nbsp;&nbsp;container.appendChild(div);</code><br><code>});</code></p><p><code>// ✅ ХОРОШО - observer срабатывает ОДИН раз</code><br><code>const fragment = document.createDocumentFragment();</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;const div = document.createElement('div');</code><br><code>&nbsp;&nbsp;div.textContent = item;</code><br><code>&nbsp;&nbsp;fragment.appendChild(div);</code><br><code>});</code><br><code>container.appendChild(fragment);</code></p><h4>5. Отключение при неактивности:</h4><p><code>class SmartObserver {</code><br><code>&nbsp;&nbsp;constructor(target, config, callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.target = target;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.config = config;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupVisibilityListener();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.start();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupVisibilityListener() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener('visibilitychange', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (document.hidden) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.stop();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.start();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;start() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.observer) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.target, this.config);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;stop() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.observer) return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Ограничение конфигурации:</h4><p><code>// ❌ Слишком широкая конфигурация</code><br><code>{ childList: true, attributes: true, subtree: true }</code></p><p><code>// ✅ Только необходимое</code><br><code>{ attributes: true, attributeFilter: ['class'] }</code></p><p><em>Золотое правило:</em> Callback должен выполняться быстро. Тяжелые операции — в Web Workers или через debounce/throttle.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'оптимизация', 'производительность', 'debounce']
  },

  {
    id: 85,
    question: "Как отслеживать добавление скриптов для обеспечения безопасности?",
    answer: "<p>MutationObserver можно использовать для обнаружения инъекций вредоносных скриптов:</p><h4>Детектор инъекций скриптов:</h4><p><code>class ScriptInjectionDetector {</code><br><code>&nbsp;&nbsp;constructor(allowedScripts = []) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.allowedScripts = new Set(allowedScripts);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.tagName === 'SCRIPT') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkScript(node);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за всем документом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.documentElement, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkScript(scriptElement) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const src = scriptElement.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const inlineCode = scriptElement.textContent;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка внешнего скрипта</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (src && !this.isAllowed(src)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('🚨 Неавторизованный скрипт:', src);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scriptElement.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportToServer({ type: 'external', src });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка inline скрипта</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (inlineCode && !this.isAllowedInline(inlineCode)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('🚨 Подозрительный inline скрипт:', inlineCode);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scriptElement.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportToServer({ type: 'inline', code: inlineCode });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;isAllowed(src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка по whitelist</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.allowedScripts.has(src)) return true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка по домену</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const url = new URL(src);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const allowedDomains = ['cdn.example.com', 'analytics.google.com'];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return allowedDomains.some(domain => url.hostname === domain);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;isAllowedInline(code) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка на подозрительные паттерны</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const suspiciousPatterns = [</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/eval\\(/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/Function\\(/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/document\\.write\\(/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/innerHTML\\s*=/,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/crypto/i</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return !suspiciousPatterns.some(pattern => pattern.test(code));</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;reportToServer(incident) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/security/report', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers: { 'Content-Type': 'application/json' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...incident,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: window.location.href,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userAgent: navigator.userAgent</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}).catch(console.error);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const detector = new ScriptInjectionDetector([</code><br><code>&nbsp;&nbsp;'https://cdn.example.com/app.js',</code><br><code>&nbsp;&nbsp;'https://www.google-analytics.com/analytics.js'</code><br><code>]);</code></p><h4>Расширенная версия с CSP проверкой:</h4><p><code>class AdvancedSecurityObserver extends ScriptInjectionDetector {</code><br><code>&nbsp;&nbsp;constructor(allowedScripts) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super(allowedScripts);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.checkCSP();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkCSP() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const csp = document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!csp) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('⚠️ CSP не настроен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super.setupObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Также отслеживаем iframe</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const iframeObserver = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.tagName === 'IFRAME') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.checkIframe(node);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;iframeObserver.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;checkIframe(iframe) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const src = iframe.src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (src && !this.isAllowed(src)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('🚨 Подозрительный iframe:', src);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iframe.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reportToServer({ type: 'iframe', src });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Применение:</em> Защита от XSS, обнаружение вредоносных расширений браузера, мониторинг целостности приложения.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'безопасность', 'XSS', 'защита']
  },

  {
    id: 86,
    question: "Как использовать MutationObserver для мониторинга производительности рендеринга?",
    answer: "<p>MutationObserver можно использовать для обнаружения проблем с производительностью DOM:</p><h4>Монитор производительности:</h4><p><code>class PerformanceMonitor {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.mutationCount = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.mutationRate = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.mutationsByType = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: 0,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characterData: 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.slowMutations = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObserver();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.startReporting();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObserver() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const startTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationCount += mutations.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationsByType[mutation.type]++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const endTime = performance.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const duration = endTime - startTime;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обнаружение медленных обработок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (duration > 16) { // > 1 фрейма при 60fps</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.slowMutations.push({</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duration,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: mutations.length,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn(\`⚠️ Медленная обработка мутаций: \${duration.toFixed(2)}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Предупреждение о высокой частоте</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.mutationCount > 100) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('⚠️ Высокая частота DOM мутаций:', this.mutationCount);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.logMutationsSummary(mutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characterData: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;startReporting() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отчет каждую секунду</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationRate = this.mutationCount;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutationCount = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.mutationRate > 50) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Мутаций/сек: \${this.mutationRate}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.table(this.mutationsByType);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 1000);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Детальный отчет каждые 10 секунд</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setInterval(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.generateReport();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, 10000);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;logMutationsSummary(mutations) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const summary = mutations.reduce((acc, m) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const key = \`\${m.type}:\${m.target.tagName || m.target.nodeName}\`;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc[key] = (acc[key] || 0) + 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return acc;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, {});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;console.table(summary);</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;generateReport() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const report = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalMutations: Object.values(this.mutationsByType).reduce((a, b) => a + b, 0),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutationsByType: { ...this.mutationsByType },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowMutationsCount: this.slowMutations.length,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;averageSlowDuration: this.slowMutations.length > 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? this.slowMutations.reduce((sum, m) => sum + m.duration, 0) / this.slowMutations.length</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('📊 Отчет производительности:');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.table(report);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка на сервер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.sendToAnalytics(report);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сброс данных</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.slowMutations = [];</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;sendToAnalytics(report) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отправка метрик</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if ('sendBeacon' in navigator) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.sendBeacon('/api/metrics', JSON.stringify(report));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const perfMonitor = new PerformanceMonitor();</code></p><p><code>// В продакшене - условная активация</code><br><code>if (window.location.search.includes('debug=perf')) {</code><br><code>&nbsp;&nbsp;new PerformanceMonitor();</code><br><code>}</code></p><p><em>Применение:</em> Обнаружение проблем производительности, оптимизация рендеринга, мониторинг в production, A/B тестирование.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'производительность', 'мониторинг', 'метрики']
  },

  {
    id: 87,
    question: "В чем разница между MutationObserver и другими методами отслеживания DOM?",
    answer: "<p>Существует несколько способов отслеживания изменений DOM, каждый со своими особенностями:</p><h4>MutationObserver:</h4><p><strong>Преимущества:</strong></p><ul><li>Асинхронный — не блокирует main thread</li><li>Эффективный — batch обработка мутаций</li><li>Детальная информация о каждом изменении</li><li>Поддержка всех типов изменений (childList, attributes, characterData)</li><li>Может наблюдать за всем поддеревом (subtree)</li></ul><p><strong>Недостатки:</strong></p><ul><li>Более сложный API</li><li>Требует понимания конфигурации</li><li>Не поддерживается в IE10 и ниже</li></ul><h4>DOM Events (DOMSubtreeModified и др.):</h4><p><code>element.addEventListener('DOMSubtreeModified', handler);</code></p><p><strong>Недостатки:</strong></p><ul><li>❌ Deprecated (устарел)</li><li>Синхронный — блокирует выполнение</li><li>Очень низкая производительность</li><li>Вызывается для КАЖДОГО изменения</li><li>Не рекомендуется к использованию</li></ul><h4>setInterval проверка:</h4><p><code>setInterval(() => {</code><br><code>&nbsp;&nbsp;const currentState = element.innerHTML;</code><br><code>&nbsp;&nbsp;if (currentState !== lastState) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Изменение обнаружено</code><br><code>&nbsp;&nbsp;}</code><br><code>}, 100);</code></p><p><strong>Недостатки:</strong></p><ul><li>Очень неэффективно</li><li>Может пропускать быстрые изменения</li><li>Постоянно работает даже без изменений</li><li>Нет информации о типе изменения</li></ul><h4>Custom Events:</h4><p><code>element.dispatchEvent(new CustomEvent('contentChanged'));</code></p><p><strong>Преимущества:</strong></p><ul><li>Простой и явный контроль</li><li>Можете передавать данные</li></ul><p><strong>Недостатки:</strong></p><ul><li>Требует явных вызовов в коде</li><li>Не работает для изменений извне</li><li>Не подходит для сторонних библиотек</li></ul><h4>Proxy для данных:</h4><p><code>const proxy = new Proxy(data, {</code><br><code>&nbsp;&nbsp;set(target, property, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;target[property] = value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;updateDOM();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><strong>Применение:</strong> Реактивность данных (Vue, MobX), но НЕ для отслеживания DOM</p><h4>Сравнительная таблица:</h4><table><tr><th>Метод</th><th>Производительность</th><th>Детальность</th><th>Асинхронность</th><th>Использование</th></tr><tr><td>MutationObserver</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>✅</td><td>✅ Рекомендуется</td></tr><tr><td>DOM Events</td><td>⭐</td><td>⭐⭐</td><td>❌</td><td>❌ Deprecated</td></tr><tr><td>setInterval</td><td>⭐</td><td>⭐</td><td>❌</td><td>❌ Не использовать</td></tr><tr><td>Custom Events</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>✅</td><td>✅ Для своего кода</td></tr></table><p><em>Вывод:</em> MutationObserver — современный стандарт для отслеживания DOM. Не используйте DOMSubtreeModified или setInterval.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'сравнение', 'альтернативы', 'производительность']
  },

  {
    id: 88,
    question: "Как работает MutationObserver с Shadow DOM?",
    answer: "<p>MutationObserver и Shadow DOM имеют специфическое взаимодействие:</p><h4>Основное правило:</h4><p>MutationObserver наблюдает только за тем деревом, на котором вызван <code>observe()</code>. Изменения внутри Shadow DOM невидимы для observer'а, подключенного к light DOM.</p><h4>Наблюдение за light DOM:</h4><p><code>// Этот observer НЕ увидит изменения внутри shadowRoot</code><br><code>const observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;console.log('Light DOM изменен');</code><br><code>});</code></p><p><code>observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;subtree: true</code><br><code>});</code></p><h4>Наблюдение за Shadow DOM:</h4><p><code>class MyElement extends HTMLElement {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;super();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.attachShadow({ mode: 'open' });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer для Shadow DOM</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shadowObserver = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Shadow DOM изменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Наблюдаем за shadowRoot</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shadowObserver.observe(this.shadowRoot, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnectedCallback() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.shadowObserver.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Универсальный wrapper для компонентов:</h4><p><code>class ShadowDOMObserver {</code><br><code>&nbsp;&nbsp;constructor(hostElement, callback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.hostElement = hostElement;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.callback = callback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.setupObservers();</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;setupObservers() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer для host элемента (light DOM)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const lightObserver = new MutationObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;lightObserver.observe(this.hostElement, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers.push(lightObserver);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;// Observer для shadow DOM если есть</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.hostElement.shadowRoot) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const shadowObserver = new MutationObserver(this.callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowObserver.observe(this.hostElement.shadowRoot, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.observers.push(shadowObserver);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;disconnect() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers.forEach(obs => obs.disconnect());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observers = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const myComponent = document.querySelector('my-component');</code><br><code>const observer = new ShadowDOMObserver(myComponent, (mutations) => {</code><br><code>&nbsp;&nbsp;console.log('Изменения в компоненте:', mutations);</code><br><code>});</code></p><h4>Особенности:</h4><ul><li><strong>mode: 'closed':</strong> Если shadowRoot закрыт, наблюдение невозможно извне</li><li><strong>Slotted content:</strong> Slotted элементы остаются в light DOM, видны light observer'у</li><li><strong>События:</strong> События из Shadow DOM всплывают в light DOM с retargeting</li></ul><h4>Отслеживание динамических компонентов:</h4><p><code>// Автоматическое подключение к новым shadow DOM</code><br><code>const globalObserver = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;mutations.forEach(mutation => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.shadowRoot) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Подключаем observer к новому shadowRoot</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observeShadowRoot(node.shadowRoot);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>globalObserver.observe(document.body, {</code><br><code>&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;subtree: true</code><br><code>});</code></p><p><em>Ключевой момент:</em> Для каждого Shadow DOM нужен отдельный MutationObserver, подключенный к shadowRoot.</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'Shadow DOM', 'Web Components', 'инкапсуляция']
  },

  {
    id: 89,
    question: "Какие есть best practices и подводные камни при работе с MutationObserver?",
    answer: "<p>При работе с MutationObserver важно следовать лучшим практикам и избегать распространенных ошибок:</p><h4>✅ Best Practices:</h4><p><strong>1. Всегда вызывайте disconnect():</strong></p><p><code>// React</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const observer = new MutationObserver(callback);</code><br><code>&nbsp;&nbsp;observer.observe(element, config);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return () => observer.disconnect(); // Cleanup!</code><br><code>}, []);</code></p><p><strong>2. Используйте attributeFilter:</strong></p><p><code>// ❌ Плохо - наблюдает за всеми атрибутами</code><br><code>{ attributes: true }</code></p><p><code>// ✅ Хорошо - только нужные атрибуты</code><br><code>{ attributes: true, attributeFilter: ['class', 'data-state'] }</code></p><p><strong>3. Batch DOM операции:</strong></p><p><code>// ✅ Используйте DocumentFragment</code><br><code>const fragment = document.createDocumentFragment();</code><br><code>items.forEach(item => fragment.appendChild(createItem(item)));</code><br><code>container.appendChild(fragment); // Один observer callback</code></p><p><strong>4. Debounce/throttle для частых изменений:</strong></p><p><code>let timeout;</code><br><code>const observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;timeout = setTimeout(heavyOperation, 250);</code><br><code>});</code></p><p><strong>5. Проверяйте nodeType:</strong></p><p><code>mutation.addedNodes.forEach(node => {</code><br><code>&nbsp;&nbsp;if (node.nodeType === Node.ELEMENT_NODE) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка только элементов</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><strong>6. Используйте WeakSet для отслеженных элементов:</strong></p><p><code>const processed = new WeakSet();</code><br><code>if (!processed.has(element)) {</code><br><code>&nbsp;&nbsp;processed.add(element);</code><br><code>&nbsp;&nbsp;processElement(element);</code><br><code>}</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Бесконечные циклы:</strong></p><p><code>// ❌ ОПАСНО - бесконечный цикл!</code><br><code>const observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;element.classList.toggle('active'); // Вызовет новую мутацию!</code><br><code>});</code><br><code>observer.observe(element, { attributes: true });</code></p><p><code>// ✅ Решение - временно отключать observer</code><br><code>const observer = new MutationObserver(() => {</code><br><code>&nbsp;&nbsp;observer.disconnect();</code><br><code>&nbsp;&nbsp;element.classList.toggle('active');</code><br><code>&nbsp;&nbsp;observer.observe(element, config);</code><br><code>});</code></p><p><strong>2. Забытые observers:</strong></p><p><code>// ❌ Утечка памяти</code><br><code>const observer = new MutationObserver(callback);</code><br><code>observer.observe(element, config);</code><br><code>// Никогда не вызывается disconnect()!</code></p><p><strong>3. Асинхронность callback:</strong></p><p><code>// ❌ Неправильное понимание</code><br><code>element.appendChild(newNode);</code><br><code>console.log('Callback вызван'); // Это выполнится РАНЬШЕ callback!</code></p><p><strong>4. Производительность при subtree: true:</strong></p><p><code>// ❌ Очень затратно для больших деревьев</code><br><code>observer.observe(document.body, {</code><br><code>&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;subtree: true // Наблюдает за ВСЕМ в body!</code><br><code>});</code></p><p><strong>5. Неправильная конфигурация:</strong></p><p><code>// ❌ Ошибка - нет основной опции</code><br><code>{ subtree: true, attributeOldValue: true }</code></p><p><code>// ✅ Правильно</code><br><code>{ attributes: true, subtree: true, attributeOldValue: true }</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не отключать observer при размонтировании</li><li>Тяжелые операции в callback</li><li>Модификация DOM внутри callback → бесконечный цикл</li><li>Использование для пользовательских событий (используйте addEventListener)</li><li>Ожидание синхронного выполнения callback</li><li>Забывать про nodeType проверку</li></ol><h4>🎯 Когда НЕ использовать:</h4><ul><li>Для событий click, input, change — используйте DOM events</li><li>Для контроля собственного кода — структурируйте логику</li><li>Для реактивности данных — используйте Proxy, фреймворки</li><li>Для проверки каждую секунду — используйте setInterval (если действительно нужно)</li></ul><p><em>Золотое правило:</em> MutationObserver для наблюдения за изменениями, которые вы НЕ контролируете (сторонние библиотеки, расширения, динамический контент).</p>",
    difficulty: 'senior',
    tags: ['MutationObserver', 'best practices', 'подводные камни', 'ошибки']
  },
  {
    id: 90,
    question: "Как интегрировать MutationObserver в современные фреймворки (React/Vue/Angular)?",
    answer: "<p>MutationObserver можно эффективно использовать в современных фреймворках:</p><h4>React интеграция:</h4><p><code>// Хук useMutationObserver</code><br><code>import { useEffect, useRef } from 'react';</code></p><p><code>function useMutationObserver(callback, config) {</code><br><code>&nbsp;&nbsp;const targetRef = useRef(null);</code><br><code>&nbsp;&nbsp;const observerRef = useRef(null);</code></p><p><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!targetRef.current) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current = new MutationObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current.observe(targetRef.current, config);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observerRef.current?.disconnect();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}, [callback, config]);</code></p><p><code>&nbsp;&nbsp;return targetRef;</code><br><code>}</code></p><p><code>// Использование</code><br><code>function MyComponent() {</code><br><code>&nbsp;&nbsp;const [mutationCount, setMutationCount] = useState(0);</code></p><p><code>&nbsp;&nbsp;const elementRef = useMutationObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;(mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setMutationCount(prev => prev + mutations.length);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{ childList: true, subtree: true }</code><br><code>&nbsp;&nbsp;);</code></p><p><code>&nbsp;&nbsp;return &lt;div ref={elementRef}&gt;Mutations: {mutationCount}&lt;/div&gt;;</code><br><code>}</code></p><h4>Vue 3 Composition API:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, onMounted, onUnmounted } from 'vue';</code></p><p><code>const elementRef = ref(null);</code><br><code>const mutationCount = ref(0);</code><br><code>let observer = null;</code></p><p><code>onMounted(() => {</code><br><code>&nbsp;&nbsp;if (!elementRef.value) return;</code></p><p><code>&nbsp;&nbsp;observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;mutationCount.value += mutations.length;</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;observer.observe(elementRef.value, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;});</code><br><code>});</code></p><p><code>onUnmounted(() => {</code><br><code>&nbsp;&nbsp;observer?.disconnect();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div ref=\"elementRef\"&gt;Mutations: {{ mutationCount }}&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>Vue Composable:</h4><p><code>// composables/useMutationObserver.js</code><br><code>import { onMounted, onUnmounted } from 'vue';</code></p><p><code>export function useMutationObserver(targetRef, callback, options) {</code><br><code>&nbsp;&nbsp;let observer = null;</code></p><p><code>&nbsp;&nbsp;onMounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!targetRef.value) return;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;observer = new MutationObserver(callback);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(targetRef.value, options);</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;onUnmounted(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;observer?.disconnect();</code><br><code>&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;return { observer };</code><br><code>}</code></p><h4>Angular интеграция:</h4><p><code>import { Directive, ElementRef, Output, EventEmitter, OnDestroy, OnInit } from '@angular/core';</code></p><p><code>@Directive({</code><br><code>&nbsp;&nbsp;selector: '[appMutationObserver]'</code><br><code>})</code><br><code>export class MutationObserverDirective implements OnInit, OnDestroy {</code><br><code>&nbsp;&nbsp;@Output() mutations = new EventEmitter&lt;MutationRecord[]&gt;();</code><br><code>&nbsp;&nbsp;private observer: MutationObserver;</code></p><p><code>&nbsp;&nbsp;constructor(private elementRef: ElementRef) {}</code></p><p><code>&nbsp;&nbsp;ngOnInit() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer = new MutationObserver((mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mutations.emit(mutations);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer.observe(this.elementRef.nativeElement, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childList: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes: true,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree: true</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code></p><p><code>&nbsp;&nbsp;ngOnDestroy() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.observer?.disconnect();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;div appMutationObserver (mutations)=\"onMutations($event)\"&gt;</code><br><code>&nbsp;&nbsp;Content</code><br><code>&lt;/div&gt;</code></p><h4>Важные моменты:</h4><ul><li><strong>React:</strong> Используйте useRef для элемента, useEffect для lifecycle</li><li><strong>Vue:</strong> onMounted/onUnmounted для управления observer</li><li><strong>Angular:</strong> Директивы или сервисы с ngOnDestroy cleanup</li><li><strong>Всегда:</strong> Отключайте observer при размонтировании компонента</li></ul><h4>Мониторинг сторонних компонентов:</h4><p><code>// React - наблюдение за компонентом библиотеки</code><br><code>function ThirdPartyWrapper() {</code><br><code>&nbsp;&nbsp;const wrapperRef = useMutationObserver(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;(mutations) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Реагируем на изменения внутри библиотечного компонента</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Library component changed');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{ childList: true, subtree: true }</code><br><code>&nbsp;&nbsp;);</code></p><p><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div ref={wrapperRef}&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ThirdPartyComponent /&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Best practice:</em> Создавайте переиспользуемые хуки/composables/директивы для MutationObserver вместо дублирования кода.</p>",
    difficulty: 'middle',
    tags: ['MutationObserver', 'React', 'Vue', 'Angular', 'интеграция']
  },
  {
    id: 91,
    question: "Что такое AbortController и для чего он используется?",
    answer: "<p><strong>AbortController</strong> — это Web API для отмены асинхронных операций, таких как Fetch запросы, чтение файлов или другие длительные операции:</p><h4>Основное назначение:</h4><p>Позволяет программно прерывать операции, которые больше не нужны, экономя ресурсы и улучшая производительность.</p><h4>Создание и использование:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code><br><code></code><br><code>fetch('/api/data', { signal })</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code></code><br><code>// Отмена запроса</code><br><code>controller.abort();</code></p><h4>Основные применения:</h4><ul><li><strong>Отмена запросов:</strong> Прерывание Fetch при навигации</li><li><strong>Timeout:</strong> Автоматическая отмена по таймауту</li><li><strong>Debounce поиска:</strong> Отмена предыдущих запросов</li><li><strong>Отмена загрузки:</strong> Прерывание загрузки файлов</li><li><strong>Cleanup:</strong> Отмена операций при размонтировании</li></ul><h4>Основные компоненты:</h4><p><strong>AbortController:</strong> Контроллер для управления отменой</p><p><strong>AbortSignal:</strong> Сигнал, передаваемый в операции</p><p><strong>abort():</strong> Метод для отмены операций</p><p><em>Важно:</em> После вызова abort() signal становится aborted навсегда, нельзя переиспользовать.</p>",
    difficulty: 'junior',
    tags: ['AbortController', 'основы', 'отмена запросов', 'Web API']
  },
  {
    id: 92,
    question: "Как отменить Fetch запрос с помощью AbortController?",
    answer: "<p>AbortController — стандартный способ отмены Fetch запросов:</p><h4>Базовое использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>fetch('https://api.example.com/data', {</code><br><code>&nbsp;&nbsp;signal: controller.signal</code><br><code>})</code><br><code>&nbsp;&nbsp;.then(response => response.json())</code><br><code>&nbsp;&nbsp;.then(data => console.log(data))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос был отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Ошибка:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить запрос</code><br><code>controller.abort();</code></p><h4>С async/await:</h4><p><code>async function fetchWithAbort() {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return data;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Запрос отменен');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Отмена по кнопке:</h4><p><code>let currentController;</code></p><p><code>async function loadData() {</code><br><code>&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;if (currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;currentController.abort();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;currentController = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;displayData(data);</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Ошибка загрузки:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// HTML</code><br><code>// &lt;button onclick=\"loadData()\"&gt;Загрузить&lt;/button&gt;</code><br><code>// &lt;button onclick=\"currentController?.abort()\"&gt;Отменить&lt;/button&gt;</code></p><h4>Проверка состояния signal:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code></p><p><code>console.log(signal.aborted); // false</code></p><p><code>controller.abort();</code></p><p><code>console.log(signal.aborted); // true</code></p><p><em>Важно:</em> Всегда проверяйте <code>error.name === 'AbortError'</code> для отличия отмены от реальных ошибок.</p>",
    difficulty: 'junior',
    tags: ['AbortController', 'Fetch', 'отмена запроса', 'базовое использование']
  },
  {
    id: 93,
    question: "Как реализовать timeout для Fetch запроса с помощью AbortController?",
    answer: "<p>AbortController идеален для реализации timeout'ов для Fetch запросов:</p><h4>Базовая реализация:</h4><p><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Автоматическая отмена через timeout</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => controller.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем таймер при успехе</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Request timeout after \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>try {</code><br><code>&nbsp;&nbsp;const response = await fetchWithTimeout('/api/data', 3000);</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;console.log(data);</code><br><code>} catch (error) {</code><br><code>&nbsp;&nbsp;console.error(error.message); // 'Request timeout after 3000ms'</code><br><code>}</code></p><h4>С использованием AbortSignal.timeout() (современный подход):</h4><p><code>// Chrome 103+, Safari 16+, Firefox 100+</code><br><code>async function fetchWithTimeout(url, timeout = 5000) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: AbortSignal.timeout(timeout)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'TimeoutError' || error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Request timeout after \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Комбинирование нескольких сигналов:</h4><p><code>async function fetchWithTimeoutAndCancel(url, timeout, userController) {</code><br><code>&nbsp;&nbsp;const timeoutController = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutId = setTimeout(() => timeoutController.abort(), timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Слушаем оба сигнала</code><br><code>&nbsp;&nbsp;userController.signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutController.abort();</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: timeoutController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Универсальная обертка:</h4><p><code>class FetchWithTimeout {</code><br><code>&nbsp;&nbsp;constructor(defaultTimeout = 10000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.defaultTimeout = defaultTimeout;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeout = options.timeout || this.defaultTimeout;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeoutId = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Timeout: Request exceeded \${timeout}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const fetcher = new FetchWithTimeout(5000);</code><br><code>const response = await fetcher.fetch('/api/data', { timeout: 3000 });</code></p><p><em>Best practice:</em> Всегда очищайте timeout через clearTimeout() для избежания утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'timeout', 'Fetch', 'таймауты']
  },
  {
    id: 94,
    question: "Как отменить предыдущие запросы при быстрой печати в поиске (debounce с отменой)?",
    answer: "<p>AbortController позволяет отменять устаревшие поисковые запросы при быстрой печати:</p><h4>Базовая реализация:</h4><p><code>class SearchWithAbort {</code><br><code>&nbsp;&nbsp;constructor(searchCallback) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback = searchCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async search(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentController.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Создаем новый контроллер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/search?q=\${query}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback(results);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Search error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование с input:</h4><p><code>const search = new SearchWithAbort((results) => {</code><br><code>&nbsp;&nbsp;displaySearchResults(results);</code><br><code>});</code></p><p><code>const searchInput = document.querySelector('#search');</code><br><code>searchInput.addEventListener('input', (e) => {</code><br><code>&nbsp;&nbsp;search.search(e.target.value);</code><br><code>});</code></p><h4>С debounce:</h4><p><code>class DebouncedSearch {</code><br><code>&nbsp;&nbsp;constructor(searchCallback, delay = 300) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback = searchCallback;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.delay = delay;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.debounceTimeout = null;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;search(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий таймер</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(this.debounceTimeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this.currentController) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.currentController.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Запускаем с задержкой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.debounceTimeout = setTimeout(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.performSearch(query);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, this.delay);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async performSearch(query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.currentController = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/search?q=\${query}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.currentController.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchCallback(results);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Search error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React хук:</h4><p><code>function useSearchWithAbort(searchFn, delay = 300) {</code><br><code>&nbsp;&nbsp;const [results, setResults] = useState([]);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;const timeoutRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const search = useCallback((query) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка предыдущих</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!query) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResults([]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutRef.current = setTimeout(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const data = await searchFn(query, controllerRef.current.signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setResults(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, delay);</code><br><code>&nbsp;&nbsp;}, [searchFn, delay]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeoutRef.current);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { results, loading, search };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function SearchComponent() {</code><br><code>&nbsp;&nbsp;const { results, loading, search } = useSearchWithAbort(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;async (query, signal) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const res = await fetch(\`/api/search?q=\${query}\`, { signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;input </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={(e) => search(e.target.value)}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder=\"Поиск...\"</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;/&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Преимущество:</em> Экономит bandwidth и ресурсы сервера, отменяя устаревшие запросы.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'поиск', 'debounce', 'оптимизация']
  },
  {
    id: 95,
    question: "Как использовать AbortSignal для прослушивания события отмены?",
    answer: "<p>AbortSignal предоставляет событие 'abort' для реагирования на отмену операций:</p><h4>Базовое прослушивание:</h4><p><code>const controller = new AbortController();</code><br><code>const signal = controller.signal;</code></p><p><code>signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;console.log('Операция отменена!');</code><br><code>&nbsp;&nbsp;console.log('Причина:', signal.reason);</code><br><code>});</code></p><p><code>controller.abort('Отменено пользователем');</code></p><h4>Проверка состояния:</h4><p><code>const signal = controller.signal;</code></p><p><code>// Проверка до операции</code><br><code>if (signal.aborted) {</code><br><code>&nbsp;&nbsp;console.log('Уже отменено');</code><br><code>&nbsp;&nbsp;return;</code><br><code>}</code></p><p><code>// Реактивная проверка</code><br><code>signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;// Прерывание операции</code><br><code>});</code></p><h4>Использование в асинхронной функции:</h4><p><code>async function processWithAbort(signal) {</code><br><code>&nbsp;&nbsp;// Проверяем в начале</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Already aborted');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Прерываем обработку...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;cleanup();</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Длительная операция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < 1000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Периодическая проверка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Operation aborted');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка слушателя</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Создание Promise с отменой:</h4><p><code>function createAbortablePromise(signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем сразу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Aborted'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Слушаем отмену</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Aborted'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Асинхронная операция</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;doAsyncWork()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Передача причины отмены:</h4><p><code>const controller = new AbortController();</code></p><p><code>controller.signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;const reason = controller.signal.reason;</code><br><code>&nbsp;&nbsp;console.log('Причина отмены:', reason);</code><br><code>});</code></p><p><code>// Отмена с причиной</code><br><code>controller.abort('Timeout exceeded');</code><br><code>// или</code><br><code>controller.abort(new Error('User cancelled'));</code></p><h4>Очистка ресурсов при отмене:</h4><p><code>class ResourceManager {</code><br><code>&nbsp;&nbsp;constructor(signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources = [];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cleanup();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;allocate(resource) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources.push(resource);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cleanup() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Очистка ресурсов...');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources.forEach(r => r.dispose());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.resources = [];</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Всегда удаляйте слушателей abort события для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortSignal', 'события', 'прослушивание', 'cleanup']
  },
  {
    id: 96,
    question: "Как комбинировать несколько AbortSignal (AbortSignal.any)?",
    answer: "<p>Иногда нужно отменить операцию по нескольким условиям — для этого используется <code>AbortSignal.any()</code>:</p><h4>Базовое использование AbortSignal.any():</h4><p><code>const userController = new AbortController();</code><br><code>const timeoutController = new AbortController();</code></p><p><code>// Комбинируем сигналы</code><br><code>const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;userController.signal,</code><br><code>&nbsp;&nbsp;timeoutController.signal</code><br><code>]);</code></p><p><code>fetch('/api/data', { signal: combinedSignal })</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Отменено (пользователем или таймаутом)');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отмена таймаутом через 5 секунд</code><br><code>setTimeout(() => timeoutController.abort(), 5000);</code></p><p><code>// Или пользователем</code><br><code>// userController.abort();</code></p><h4>Практический пример - запрос с таймаутом и ручной отменой:</h4><p><code>async function fetchWithTimeoutAndCancel(url, timeout, userSignal) {</code><br><code>&nbsp;&nbsp;// Создаем сигнал для таймаута</code><br><code>&nbsp;&nbsp;const timeoutSignal = AbortSignal.timeout(timeout);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Комбинируем</code><br><code>&nbsp;&nbsp;const combinedSignal = AbortSignal.any([userSignal, timeoutSignal]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError' || error.name === 'TimeoutError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timeoutSignal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Timeout');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (userSignal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('User cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Polyfill для старых браузеров:</h4><p><code>if (!AbortSignal.any) {</code><br><code>&nbsp;&nbsp;AbortSignal.any = function(signals) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signals.forEach(signal => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort(signal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort(signal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, { once: true });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return controller.signal;</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><h4>Множественные условия отмены:</h4><p><code>async function complexFetch(url) {</code><br><code>&nbsp;&nbsp;const userController = new AbortController();</code><br><code>&nbsp;&nbsp;const timeoutSignal = AbortSignal.timeout(10000);</code><br><code>&nbsp;&nbsp;const networkController = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Отмена при потере сети</code><br><code>&nbsp;&nbsp;window.addEventListener('offline', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;networkController.abort('Network lost');</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;userController.signal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;timeoutSignal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;networkController.signal</code><br><code>&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Abort reason:', combinedSignal.reason);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>React пример:</h4><p><code>function DataLoader() {</code><br><code>&nbsp;&nbsp;const userControllerRef = useRef(new AbortController());</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = userControllerRef.current;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отмена при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const loadData = async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const combinedSignal = AbortSignal.any([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userControllerRef.current.signal,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbortSignal.timeout(5000)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', { signal: combinedSignal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// ...</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><p><em>Поддержка:</em> AbortSignal.any() доступен в Chrome 116+, Safari 17+, Firefox 115+. Используйте polyfill для старых браузеров.</p>",
    difficulty: 'senior',
    tags: ['AbortSignal', 'комбинирование', 'AbortSignal.any', 'продвинутое']
  },
  {
    id: 97,
    question: "Как использовать AbortController с XMLHttpRequest?",
    answer: "<p>XMLHttpRequest не поддерживает AbortSignal напрямую, но можно реализовать отмену вручную:</p><h4>Базовая реализация:</h4><p><code>function xhrWithAbort(url, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед запуском</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Слушатель отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(xhr.responseText);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Network error'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('GET', url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send();</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>xhrWithAbort('/api/data', controller.signal)</code><br><code>&nbsp;&nbsp;.then(data => console.log(data))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('XHR request aborted');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отмена</code><br><code>controller.abort();</code></p><h4>С upload progress:</h4><p><code>function uploadWithAbort(url, formData, signal, onProgress) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Upload progress</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onProgress?.(percent);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(xhr.responseText);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Upload failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('POST', url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(formData);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Класс-обертка:</h4><p><code>class XHRWithAbortSignal {</code><br><code>&nbsp;&nbsp;constructor(url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.url = url;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.options = options;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.xhr = new XMLHttpRequest();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async send(signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.onload = () => resolve(this.xhr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.onerror = () => reject(new Error('Network error'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.open(this.options.method || 'GET', this.url);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Установка заголовков</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.options.headers) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.entries(this.options.headers).forEach(([key, value]) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.setRequestHeader(key, value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xhr.send(this.options.body);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const controller = new AbortController();</code><br><code>const xhr = new XHRWithAbortSignal('/api/data');</code></p><p><code>xhr.send(controller.signal)</code><br><code>&nbsp;&nbsp;.then(xhr => console.log(xhr.responseText))</code><br><code>&nbsp;&nbsp;.catch(error => console.error(error));</code></p><p><em>Важно:</em> Всегда очищайте слушателей abort события для предотвращения утечек памяти.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'XMLHttpRequest', 'интеграция', 'upload']
  },
  {
    id: 98,
    question: "Как отменить чтение файла с FileReader?",
    answer: "<p>FileReader API не поддерживает AbortSignal напрямую, но можно реализовать отмену:</p><h4>Обертка с AbortController:</h4><p><code>function readFileWithAbort(file, signal, method = 'readAsText') {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const reader = new FileReader();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед началом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Вызов нужного метода</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader[method](file);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code><br><code>const fileInput = document.querySelector('input[type=\"file\"]');</code></p><p><code>fileInput.addEventListener('change', async (e) => {</code><br><code>&nbsp;&nbsp;const file = e.target.files[0];</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const content = await readFileWithAbort(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.signal, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'readAsText'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('File content:', content);</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('File reading cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><code>// Отмена чтения</code><br><code>cancelButton.onclick = () => controller.abort();</code></p><h4>С прогрессом:</h4><p><code>function readFileWithProgress(file, signal, onProgress) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const reader = new FileReader();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Прогресс чтения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onprogress = (e) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.lengthComputable) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const percent = (e.loaded / e.total) * 100;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onProgress?.(percent);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;reader.readAsDataURL(file);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Класс FileReaderWithAbort:</h4><p><code>class FileReaderWithAbort {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.reader = new FileReader();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;read(file, method, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(this.reader.result);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(this.reader.error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader.onabort = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal?.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.reader[method](file);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsText(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsText', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsDataURL(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsDataURL', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;readAsArrayBuffer(file, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return this.read(file, 'readAsArrayBuffer', signal);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const reader = new FileReaderWithAbort();</code><br><code>const controller = new AbortController();</code></p><p><code>reader.readAsText(file, controller.signal)</code><br><code>&nbsp;&nbsp;.then(content => console.log(content))</code><br><code>&nbsp;&nbsp;.catch(err => console.error(err));</code></p><p><em>Применение:</em> Отмена чтения больших файлов, обработка изображений, парсинг CSV/JSON.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'FileReader', 'файлы', 'чтение']
  },
  {
    id: 99,
    question: "Как использовать AbortController в React для отмены запросов при размонтировании?",
    answer: "<p>AbortController критичен для предотвращения утечек памяти и ошибок при размонтировании компонентов:</p><h4>Базовая интеграция с useEffect:</h4><p><code>import { useEffect, useState } from 'react';</code></p><p><code>function DataComponent() {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/data', { signal: controller.signal })</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(setData)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;</code><br><code>}</code></p><h4>Переиспользуемый хук useFetch:</h4><p><code>function useFetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const [error, setError] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(url, { </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options, </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal </code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(data => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.finally(() => setLoading(false));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, [url]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function App() {</code><br><code>&nbsp;&nbsp;const { data, loading, error } = useFetch('/api/users');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;</code><br><code>&nbsp;&nbsp;if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;</code><br><code>}</code></p><h4>С ручной отменой:</h4><p><code>function useFetchWithManualAbort(url) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controllerRef.current.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, [url]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const cancel = useCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function DataLoader() {</code><br><code>&nbsp;&nbsp;const { data, loading, execute, cancel } = useFetchWithManualAbort('/api/data');</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={execute}&gt;Загрузить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cancel}&gt;Отменить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{loading && &lt;div&gt;Loading...&lt;/div&gt;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{data && &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><h4>С зависимостями:</h4><p><code>function UserProfile({ userId }) {</code><br><code>&nbsp;&nbsp;const [user, setUser] = useState(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/users/\${userId}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;})</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(setUser)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем при изменении userId или размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controller.abort();</code><br><code>&nbsp;&nbsp;}, [userId]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return &lt;div&gt;{user?.name}&lt;/div&gt;;</code><br><code>}</code></p><p><em>Критически важно:</em> Всегда возвращайте cleanup функцию с abort() из useEffect для предотвращения ошибок \"Can't perform a React state update on an unmounted component\".</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'React', 'hooks', 'useEffect']
  },
  {
    id: 100,
    question: "Как использовать AbortController в Vue для отмены запросов?",
    answer: "<p>В Vue 3 AbortController интегрируется через lifecycle hooks и composables:</p><h4>Options API с lifecycle hooks:</h4><p><code>export default {</code><br><code>&nbsp;&nbsp;data() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: null,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller: null</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;mounted() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.loadData();</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;beforeUnmount() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем запрос при размонтировании</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controller?.abort();</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;methods: {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;async loadData() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: this.controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.data = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Composition API с onBeforeUnmount:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, onMounted, onBeforeUnmount } from 'vue';</code></p><p><code>const data = ref(null);</code><br><code>const controller = ref(null);</code></p><p><code>async function loadData() {</code><br><code>&nbsp;&nbsp;controller.value = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch('/api/data', {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.value.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data.value = await response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>onMounted(() => loadData());</code></p><p><code>onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;controller.value?.abort();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><h4>Переиспользуемый composable useFetch:</h4><p><code>// composables/useFetch.js</code><br><code>import { ref, onBeforeUnmount } from 'vue';</code></p><p><code>export function useFetch(url, options = {}) {</code><br><code>&nbsp;&nbsp;const data = ref(null);</code><br><code>&nbsp;&nbsp;const loading = ref(false);</code><br><code>&nbsp;&nbsp;const error = ref(null);</code><br><code>&nbsp;&nbsp;const controller = ref(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async function execute() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;loading.value = true;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;error.value = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.value.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.value = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.value = err;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loading.value = false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;function cancel() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Cleanup при размонтировании</code><br><code>&nbsp;&nbsp;onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.value?.abort();</code><br><code>&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error, execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>&lt;script setup&gt;</code><br><code>import { useFetch } from '@/composables/useFetch';</code></p><p><code>const { data, loading, error, execute, cancel } = useFetch('/api/users');</code><br><code></code><br><code>// Автоматически загрузить при монтировании</code><br><code>onMounted(() => execute());</code><br><code>&lt;/script&gt;</code></p><p><code>&lt;template&gt;</code><br><code>&nbsp;&nbsp;&lt;div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click=\"execute\"&gt;Загрузить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click=\"cancel\"&gt;Отменить&lt;/button&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-if=\"loading\"&gt;Загрузка...&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-else-if=\"error\"&gt;Ошибка: {{ error.message }}&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div v-else-if=\"data\"&gt;{{ data }}&lt;/div&gt;</code><br><code>&nbsp;&nbsp;&lt;/div&gt;</code><br><code>&lt;/template&gt;</code></p><h4>С watch для реактивных зависимостей:</h4><p><code>&lt;script setup&gt;</code><br><code>import { ref, watch, onBeforeUnmount } from 'vue';</code></p><p><code>const props = defineProps(['userId']);</code><br><code>const user = ref(null);</code><br><code>let controller = null;</code></p><p><code>async function loadUser(id) {</code><br><code>&nbsp;&nbsp;// Отменяем предыдущий запрос</code><br><code>&nbsp;&nbsp;controller?.abort();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;controller = new AbortController();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(\`/api/users/\${id}\`, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;user.value = await response.json();</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Загружаем при изменении userId</code><br><code>watch(() => props.userId, (newId) => {</code><br><code>&nbsp;&nbsp;if (newId) loadUser(newId);</code><br><code>}, { immediate: true });</code></p><p><code>onBeforeUnmount(() => {</code><br><code>&nbsp;&nbsp;controller?.abort();</code><br><code>});</code><br><code>&lt;/script&gt;</code></p><p><em>Best practice:</em> Создавайте переиспользуемые composables для логики с AbortController вместо дублирования кода в каждом компоненте.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'Vue', 'Composition API', 'composables']
  },
  {
    id: 101,
    question: "Как отменить загрузку изображений, скриптов и других ресурсов?",
    answer: "<p>Отмена загрузки ресурсов полезна для оптимизации и экономии трафика:</p><h4>Отмена загрузки изображений:</h4><p><code>function loadImageWithAbort(src, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка перед началом</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const img = new Image();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработчик отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Прерываем загрузку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.src = '';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(img);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Image load failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;img.src = src;</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>loadImageWithAbort('/image.jpg', controller.signal)</code><br><code>&nbsp;&nbsp;.then(img => document.body.appendChild(img))</code><br><code>&nbsp;&nbsp;.catch(error => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('Image loading cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code></p><p><code>// Отменить загрузку</code><br><code>controller.abort();</code></p><h4>Отмена загрузки скриптов:</h4><p><code>function loadScriptWithAbort(src, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const script = document.createElement('script');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.src = src;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const abortHandler = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal.addEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.onload = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(script);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;script.onerror = () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal.removeEventListener('abort', abortHandler);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.remove();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new Error('Script load failed'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;document.head.appendChild(script);</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Менеджер загрузки ресурсов:</h4><p><code>class ResourceLoader {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async loadImage(id, src) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.set(id, controller);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const img = await loadImageWithAbort(src, controller.signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelLoad(id) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = this.controllers.get(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (controller) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.delete(id);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelAll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.forEach(controller => controller.abort());</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.controllers.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const loader = new ResourceLoader();</code></p><p><code>loader.loadImage('hero', '/hero.jpg')</code><br><code>&nbsp;&nbsp;.then(img => document.body.appendChild(img));</code></p><p><code>// Отменить конкретную загрузку</code><br><code>loader.cancelLoad('hero');</code></p><p><code>// Или все загрузки</code><br><code>loader.cancelAll();</code></p><p><em>Применение:</em> Карусели изображений, ленивая загрузка, отмена при смене роута, экономия трафика.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'изображения', 'ресурсы', 'загрузка']
  },
  {
    id: 102,
    question: "Какие есть best practices и подводные камни при работе с AbortController?",
    answer: "<p>При работе с AbortController важно следовать лучшим практикам и избегать распространенных ошибок:</p><h4>✅ Best Practices:</h4><p><strong>1. Всегда проверяйте signal.aborted:</strong></p><p><code>async function operation(signal) {</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Already aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Длительная операция...</code><br><code>}</code></p><p><strong>2. Очищайте слушателей событий:</strong></p><p><code>const abortHandler = () => cleanup();</code><br><code>signal.addEventListener('abort', abortHandler);</code><br><code></code><br><code>// В конце</code><br><code>signal.removeEventListener('abort', abortHandler);</code></p><p><strong>3. Используйте { once: true } для автоочистки:</strong></p><p><code>signal.addEventListener('abort', handler, { once: true });</code></p><p><strong>4. Проверяйте error.name === 'AbortError':</strong></p><p><code>catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Это нормальная отмена, не логируем как ошибку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;console.error('Реальная ошибка:', error);</code><br><code>}</code></p><p><strong>5. Создавайте новый контроллер для каждой операции:</strong></p><p><code>// ❌ Плохо - переиспользование</code><br><code>const controller = new AbortController();</code><br><code>controller.abort();</code><br><code>// Нельзя переиспользовать!</code></p><p><code>// ✅ Хорошо - новый контроллер</code><br><code>function makeRequest() {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;return { controller, promise: fetch(url, { signal: controller.signal }) };</code><br><code>}</code></p><p><strong>6. Передавайте причину отмены:</strong></p><p><code>controller.abort('User cancelled');</code><br><code>// или</code><br><code>controller.abort(new Error('Timeout exceeded'));</code></p><h4>❌ Подводные камни:</h4><p><strong>1. Забытые cleanup:</strong></p><p><code>// ❌ Утечка памяти в React</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;// Забыли return cleanup!</code><br><code>}, []);</code></p><p><code>// ✅ Правильно</code><br><code>useEffect(() => {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;fetch(url, { signal: controller.signal });</code><br><code>&nbsp;&nbsp;return () => controller.abort();</code><br><code>}, []);</code></p><p><strong>2. Переиспользование AbortSignal:</strong></p><p><code>// ❌ Нельзя переиспользовать</code><br><code>const signal = controller.signal;</code><br><code>controller.abort();</code><br><code>// signal.aborted === true навсегда!</code></p><p><strong>3. Игнорирование AbortError:</strong></p><p><code>// ❌ Плохо - логируем нормальную отмену</code><br><code>catch (error) {</code><br><code>&nbsp;&nbsp;console.error('Error:', error); // Логирует AbortError</code><br><code>}</code></p><p><code>// ✅ Хорошо</code><br><code>catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error:', error);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><strong>4. Забытые слушатели:</strong></p><p><code>// ❌ Слушатель не удален</code><br><code>signal.addEventListener('abort', handler);</code><br><code>// Работает постоянно!</code></p><p><code>// ✅ Используйте once или удаляйте</code><br><code>signal.addEventListener('abort', handler, { once: true });</code></p><p><strong>5. Неправильное использование в циклах:</strong></p><p><code>// ❌ Плохо - все запросы с одним signal</code><br><code>const controller = new AbortController();</code><br><code>items.forEach(item => {</code><br><code>&nbsp;&nbsp;fetch(item.url, { signal: controller.signal });</code><br><code>});</code><br><code>// abort() отменит ВСЕ запросы</code></p><p><strong>6. Отсутствие обработки в long operations:</strong></p><p><code>// ❌ Плохо - нет проверки abort</code><br><code>async function longOperation(signal) {</code><br><code>&nbsp;&nbsp;for (let i = 0; i < 10000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i); // Нельзя прервать!</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// ✅ Хорошо - периодическая проверка</code><br><code>async function longOperation(signal) {</code><br><code>&nbsp;&nbsp;for (let i = 0; i < 10000; i++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;await processItem(i);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>⚠️ Частые ошибки:</h4><ol><li>Не отменять запросы при размонтировании компонентов</li><li>Переиспользовать уже отмененный контроллер</li><li>Забывать проверять signal.aborted в длительных операциях</li><li>Не обрабатывать AbortError отдельно от других ошибок</li><li>Создавать глобальные контроллеры вместо локальных</li></ol><h4>🎯 Когда НЕ использовать:</h4><ul><li>Для простых синхронных операций</li><li>Когда запрос уже завершился</li><li>Для отмены setTimeout (используйте clearTimeout)</li><li>Для отмены setInterval (используйте clearInterval)</li></ul><p><em>Золотое правило:</em> Создавайте новый AbortController для каждой отменяемой операции, всегда очищайте ресурсы.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'best practices', 'подводные камни', 'ошибки']
  },
  {
    id: 103,
    question: "Как использовать AbortController для отмены нескольких связанных запросов?",
    answer: "<p>Часто нужно отменить группу связанных запросов одновременно:</p><h4>Базовый подход - один контроллер для всех:</h4><p><code>async function loadPageData(pageId) {</code><br><code>&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;const signal = controller.signal;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Параллельные запросы с одним signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const [user, posts, comments] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/users/\${pageId}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/posts?userId=\${pageId}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/comments?userId=\${pageId}\`, { signal })</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: await user.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posts: await posts.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comments: await comments.json()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('All requests cancelled');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>const controller = new AbortController();</code><br><code>loadPageData(123);</code><br><code></code><br><code>// Отменяет ВСЕ три запроса</code><br><code>controller.abort();</code></p><h4>Менеджер запросов с группировкой:</h4><p><code>class RequestManager {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups = new Map();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;createGroup(groupId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const controller = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.set(groupId, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests: []</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return controller.signal;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(groupId, url, options = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const group = this.groups.get(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!group) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`Group \${groupId} not found\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const promise = fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: group.controller.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;group.requests.push(promise);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return promise;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelGroup(groupId) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const group = this.groups.get(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (group) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.groups.delete(groupId);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cancelAll() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.forEach((group, groupId) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.controller.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.groups.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const manager = new RequestManager();</code></p><p><code>async function loadDashboard() {</code><br><code>&nbsp;&nbsp;const groupId = 'dashboard';</code><br><code>&nbsp;&nbsp;manager.createGroup(groupId);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const [users, stats, activities] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/users'),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/stats'),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.fetch(groupId, '/api/activities')</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return { users, stats, activities };</code><br><code>&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error(error);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Отменить группу запросов</code><br><code>manager.cancelGroup('dashboard');</code></p><h4>Последовательные запросы с общей отменой:</h4><p><code>async function loadWithDependencies(signal) {</code><br><code>&nbsp;&nbsp;// Шаг 1: Загружаем пользователя</code><br><code>&nbsp;&nbsp;const userRes = await fetch('/api/user', { signal });</code><br><code>&nbsp;&nbsp;const user = await userRes.json();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Проверка перед следующим шагом</code><br><code>&nbsp;&nbsp;if (signal.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Шаг 2: Загружаем данные пользователя</code><br><code>&nbsp;&nbsp;const [posts, followers] = await Promise.all([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/posts?userId=\${user.id}\`, { signal }),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;fetch(\`/api/followers?userId=\${user.id}\`, { signal })</code><br><code>&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;user,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;posts: await posts.json(),</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;followers: await followers.json()</code><br><code>&nbsp;&nbsp;};</code><br><code>}</code></p><h4>React хук для группы запросов:</h4><p><code>function useGroupedRequests() {</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async (requests) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Отменяем предыдущую группу</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const signal = controllerRef.current.signal;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Выполняем все запросы с одним signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const results = await Promise.all(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests.map(req => fetch(req.url, { ...req.options, signal }))</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Promise.all(results.map(r => r.json()));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const cancel = useCallback(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { execute, cancel };</code><br><code>}</code></p><p><code>// Использование</code><br><code>function Dashboard() {</code><br><code>&nbsp;&nbsp;const { execute, cancel } = useGroupedRequests();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const loadData = async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const data = await execute([</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/users' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/stats' },</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ url: '/api/activities' }</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;]);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Обработка данных</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cancel}&gt;Cancel All&lt;/button&gt;</code><br><code>&nbsp;&nbsp;);</code><br><code>}</code></p><p><em>Применение:</em> Загрузка связанных данных, dashboard с множеством виджетов, отмена при смене роута.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'множественные запросы', 'группировка', 'Promise.all']
  },
  {
    id: 104,
    question: "Как реализовать retry механизм с поддержкой отмены через AbortController?",
    answer: "<p>Комбинирование retry логики с возможностью отмены повышает надежность приложения:</p><h4>Базовая реализация retry с abort:</h4><p><code>async function fetchWithRetry(url, options = {}, retries = 3, signal) {</code><br><code>&nbsp;&nbsp;for (let attempt = 0; attempt <= retries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка отмены перед попыткой</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Не retry при отмене</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Последняя попытка - выбрасываем ошибку</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt === retries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exponential backoff</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = Math.pow(2, attempt) * 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${retries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Ожидание с проверкой отмены</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await sleep(delay, signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Функция sleep с поддержкой abort</code><br><code>function sleep(ms, signal) {</code><br><code>&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const timeout = setTimeout(resolve, ms);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;signal?.addEventListener('abort', () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timeout);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(new DOMException('Aborted', 'AbortError'));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}, { once: true });</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>Использование:</h4><p><code>const controller = new AbortController();</code></p><p><code>try {</code><br><code>&nbsp;&nbsp;const response = await fetchWithRetry(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;'/api/data',</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;{},</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;3, // 3 попытки</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controller.signal</code><br><code>&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const data = await response.json();</code><br><code>&nbsp;&nbsp;console.log(data);</code><br><code>} catch (error) {</code><br><code>&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.log('Request cancelled during retry');</code><br><code>&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.error('All retries failed:', error);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Отменить в любой момент (даже во время ожидания retry)</code><br><code>controller.abort();</code></p><h4>Класс с конфигурируемым retry:</h4><p><code>class RetryableFetch {</code><br><code>&nbsp;&nbsp;constructor(config = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.maxRetries = config.maxRetries || 3;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.retryDelay = config.retryDelay || 1000;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.retryOn = config.retryOn || [500, 502, 503, 504];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.backoffMultiplier = config.backoffMultiplier || 2;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async fetch(url, options = {}, signal) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let lastError;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let attempt = 0; attempt <= this.maxRetries; attempt++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (signal?.aborted) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new DOMException('Aborted', 'AbortError');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url, { ...options, signal });</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Успех</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response.ok) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем, нужен ли retry для этого статуса</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.retryOn.includes(response.status)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response; // Не retry для 4xx ошибок</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error(\`HTTP \${response.status}\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (error) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error.name === 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastError = error;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (attempt < this.maxRetries) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const delay = this.retryDelay * Math.pow(this.backoffMultiplier, attempt);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\`Retry \${attempt + 1}/\${this.maxRetries} after \${delay}ms\`);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await sleep(delay, signal);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw lastError;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>// Использование</code><br><code>const fetcher = new RetryableFetch({</code><br><code>&nbsp;&nbsp;maxRetries: 5,</code><br><code>&nbsp;&nbsp;retryDelay: 1000,</code><br><code>&nbsp;&nbsp;retryOn: [500, 502, 503, 504],</code><br><code>&nbsp;&nbsp;backoffMultiplier: 2</code><br><code>});</code></p><p><code>const controller = new AbortController();</code></p><p><code>fetcher.fetch('/api/data', {}, controller.signal)</code><br><code>&nbsp;&nbsp;.then(res => res.json())</code><br><code>&nbsp;&nbsp;.then(data => console.log(data));</code></p><p><code>// Отменить retry</code><br><code>setTimeout(() => controller.abort(), 5000);</code></p><h4>React хук с retry:</h4><p><code>function useFetchWithRetry(url, options = {}, retries = 3) {</code><br><code>&nbsp;&nbsp;const [data, setData] = useState(null);</code><br><code>&nbsp;&nbsp;const [loading, setLoading] = useState(false);</code><br><code>&nbsp;&nbsp;const [error, setError] = useState(null);</code><br><code>&nbsp;&nbsp;const controllerRef = useRef(null);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const execute = useCallback(async () => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current = new AbortController();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setLoading(true);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;setError(null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const response = await fetchWithRetry(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retries,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controllerRef.current.signal</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = await response.json();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setData(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err.name !== 'AbortError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setError(err);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLoading(false);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}, [url, retries]);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;useEffect(() => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return () => controllerRef.current?.abort();</code><br><code>&nbsp;&nbsp;}, []);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return { data, loading, error, execute };</code><br><code>}</code></p><p><em>Применение:</em> Ненадежные API, временные проблемы с сетью, rate limiting, улучшение UX при проблемах соединения.</p>",
    difficulty: 'senior',
    tags: ['AbortController', 'retry', 'надежность', 'error handling']
  },
  {
    id: 105,
    question: "В чем разница между AbortController и другими методами отмены операций?",
    answer: "<p>Существует несколько способов отмены асинхронных операций, каждый со своими особенностями:</p><h4>AbortController (современный стандарт):</h4><p><strong>Преимущества:</strong></p><ul><li>Стандартизированный Web API</li><li>Работает с Fetch, ReadableStream, addEventListener</li><li>Поддержка причины отмены (signal.reason)</li><li>Можно комбинировать сигналы (AbortSignal.any)</li><li>Событие 'abort' для реактивной обработки</li><li>Встроенная поддержка в браузерах</li></ul><p><strong>Недостатки:</strong></p><ul><li>Нельзя переиспользовать после abort()</li><li>Не работает с setTimeout/setInterval напрямую</li><li>Требует ручной интеграции в старых API</li></ul><h4>Promise cancellation паттерны:</h4><p><code>// Старый подход - флаг отмены</code><br><code>let cancelled = false;</code><br><code></code><br><code>async function operation() {</code><br><code>&nbsp;&nbsp;if (cancelled) return;</code><br><code>&nbsp;&nbsp;await step1();</code><br><code>&nbsp;&nbsp;if (cancelled) return;</code><br><code>&nbsp;&nbsp;await step2();</code><br><code>}</code></p><p><strong>Проблемы:</strong></p><ul><li>Нет стандартизации</li><li>Нужно вручную проверять флаг</li><li>Сложно с вложенными операциями</li><li>Нет событий отмены</li></ul><h4>Библиотечные решения (Bluebird, Axios):</h4><p><code>// Bluebird cancellable promises</code><br><code>const promise = new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;// ...</code><br><code>}).cancellable();</code></p><p><code>promise.cancel();</code></p><p><code>// Axios CancelToken (устаревший)</code><br><code>const CancelToken = axios.CancelToken;</code><br><code>const source = CancelToken.source();</code><br><code></code><br><code>axios.get('/api/data', {</code><br><code>&nbsp;&nbsp;cancelToken: source.token</code><br><code>});</code><br><code></code><br><code>source.cancel('Cancelled');</code></p><p><strong>Проблемы:</strong></p><ul><li>Не стандарт, зависимость от библиотеки</li><li>Axios перешел на AbortController</li><li>Разные API в разных библиотеках</li></ul><h4>clearTimeout / clearInterval:</h4><p><code>const timeoutId = setTimeout(callback, 1000);</code><br><code>clearTimeout(timeoutId);</code></p><p><strong>Применение:</strong> Только для таймеров, не для fetch/promises</p><h4>removeEventListener:</h4><p><code>element.addEventListener('click', handler);</code><br><code>element.removeEventListener('click', handler);</code></p><p><strong>Применение:</strong> Только для DOM событий</p><h4>Сравнительная таблица:</h4><table><tr><th>Метод</th><th>Стандарт</th><th>Fetch</th><th>Универсальность</th><th>Причина отмены</th></tr><tr><td>AbortController</td><td>✅ Web API</td><td>✅</td><td>⭐⭐⭐⭐⭐</td><td>✅</td></tr><tr><td>Флаг cancelled</td><td>❌</td><td>❌</td><td>⭐⭐</td><td>❌</td></tr><tr><td>Bluebird</td><td>❌</td><td>❌</td><td>⭐⭐⭐</td><td>✅</td></tr><tr><td>Axios CancelToken</td><td>❌</td><td>N/A</td><td>⭐⭐⭐</td><td>✅</td></tr><tr><td>clearTimeout</td><td>✅</td><td>❌</td><td>⭐</td><td>❌</td></tr></table><h4>Миграция на AbortController:</h4><p><code>// ❌ Старый Axios</code><br><code>const source = axios.CancelToken.source();</code><br><code>axios.get(url, { cancelToken: source.token });</code><br><code>source.cancel();</code></p><p><code>// ✅ Новый Axios с AbortController</code><br><code>const controller = new AbortController();</code><br><code>axios.get(url, { signal: controller.signal });</code><br><code>controller.abort();</code></p><h4>Когда использовать что:</h4><ul><li><strong>AbortController:</strong> Fetch, потоки, современные async операции</li><li><strong>clearTimeout:</strong> Только для setTimeout/setInterval</li><li><strong>removeEventListener:</strong> Только для DOM событий</li><li><strong>Флаги:</strong> Простые внутренние операции (не рекомендуется)</li></ul><p><em>Вывод:</em> AbortController — современный стандарт для отмены асинхронных операций. Мигрируйте с устаревших подходов.</p>",
    difficulty: 'middle',
    tags: ['AbortController', 'сравнение', 'альтернативы', 'стандарты']
  },
  {
    id: 106,
    question: "Что такое Web Storage API и какие два типа хранилищ он предоставляет?",
    answer: "<p><strong>Web Storage API</strong> — это механизм для хранения пар ключ-значение в браузере на стороне клиента:</p><h4>Два типа хранилищ:</h4><p><strong>localStorage:</strong> Постоянное хранилище без срока действия. Данные сохраняются даже после закрытия браузера и перезагрузки компьютера.</p><p><strong>sessionStorage:</strong> Временное хранилище на время сессии. Данные удаляются при закрытии вкладки или браузера.</p><h4>Основные характеристики:</h4><ul><li>Синхронный API</li><li>Хранение только строк</li><li>Ограничение ~5-10 МБ на домен</li><li>Доступ только с того же origin</li><li>Не отправляются на сервер автоматически</li></ul><p><em>Ключевое отличие от cookies:</em> Web Storage не отправляется с каждым HTTP-запросом, что экономит bandwidth.</p>",
    difficulty: 'junior',
    tags: ['Web Storage', 'localStorage', 'sessionStorage', 'основы']
  },
  {
    id: 107,
    question: "В чем разница между localStorage и sessionStorage?",
    answer: "<p>localStorage и sessionStorage имеют одинаковый API, но разную область видимости и время жизни:</p><h4>localStorage:</h4><ul><li><strong>Время жизни:</strong> Постоянное, до явного удаления</li><li><strong>Область:</strong> Общий для всех вкладок и окон одного origin</li><li><strong>Сохранение:</strong> Остается после закрытия браузера</li><li><strong>Удаление:</strong> Только программно или через настройки браузера</li></ul><h4>sessionStorage:</h4><ul><li><strong>Время жизни:</strong> До закрытия вкладки/окна</li><li><strong>Область:</strong> Уникальный для каждой вкладки</li><li><strong>Сохранение:</strong> Удаляется при закрытии вкладки</li><li><strong>Удаление:</strong> Автоматически при закрытии</li></ul><h4>Когда использовать:</h4><p><strong>localStorage:</strong> Настройки темы, язык интерфейса, токены, preferences, кэш данных</p><p><strong>sessionStorage:</strong> Данные формы, состояние wizard'а, временные фильтры, одноразовые данные</p><p><em>Важно:</em> Даже дублирование вкладки (Ctrl+Shift+T) создает новый sessionStorage.</p>",
    difficulty: 'junior',
    tags: ['localStorage', 'sessionStorage', 'различия', 'область видимости']
  },
  {
    id: 108,
    question: "Какие типы данных можно сохранять в localStorage/sessionStorage?",
    answer: "<p>Web Storage может хранить <strong>только строки</strong>. Все остальные типы нужно преобразовывать:</p><h4>Строки — напрямую:</h4><p><code>localStorage.setItem('name', 'John');</code></p><h4>Числа — преобразуются в строку:</h4><p><code>localStorage.setItem('age', 25); // Сохранится как '25'</code><br><code>const age = Number(localStorage.getItem('age')); // Обратно в число</code></p><h4>Булевы значения — преобразуются в строку:</h4><p><code>localStorage.setItem('isActive', true); // Сохранится как 'true'</code><br><code>const isActive = localStorage.getItem('isActive') === 'true';</code></p><h4>Объекты и массивы — через JSON:</h4><p><code>const user = { name: 'John', age: 25 };</code><br><code>localStorage.setItem('user', JSON.stringify(user));</code><br><code></code><br><code>const savedUser = JSON.parse(localStorage.getItem('user'));</code></p><h4>Date — преобразование через ISO:</h4><p><code>const date = new Date();</code><br><code>localStorage.setItem('date', date.toISOString());</code><br><code></code><br><code>const savedDate = new Date(localStorage.getItem('date'));</code></p><h4>Что нельзя сохранить:</h4><ul><li>Функции (потеряются при JSON.stringify)</li><li>Symbol (не сериализуются)</li><li>undefined (превратится в строку 'undefined')</li><li>Циклические ссылки (ошибка при stringify)</li></ul><p><em>Best practice:</em> Всегда оборачивайте JSON.parse в try-catch для обработки невалидных данных.</p>",
    difficulty: 'junior',
    tags: ['localStorage', 'типы данных', 'JSON', 'сериализация']
  },
  {
    id: 109,
    question: "Как проверить доступность и размер Web Storage?",
    answer: "<p>Важно проверять доступность и ограничения Storage перед использованием:</p><h4>Проверка поддержки:</h4><p><code>function isStorageAvailable(type) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const storage = window[type];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const test = '__storage_test__';</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;storage.setItem(test, test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;storage.removeItem(test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>if (isStorageAvailable('localStorage')) {</code><br><code>&nbsp;&nbsp;// Можно использовать</code><br><code>}</code></p><h4>Определение размера хранилища:</h4><p><code>function getStorageSize() {</code><br><code>&nbsp;&nbsp;let total = 0;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;for (let key in localStorage) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (localStorage.hasOwnProperty(key)) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total += localStorage[key].length + key.length;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return (total / 1024).toFixed(2) + ' KB';</code><br><code>}</code></p><h4>Проверка лимита:</h4><p><code>function getStorageLimit() {</code><br><code>&nbsp;&nbsp;let max = 0;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const test = '0'.repeat(1024); // 1KB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let i = 0;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;while (i < 10000) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem('test' + i, test);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;max = i;</code><br><code>&nbsp;&nbsp;} finally {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Очистка</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let j = 0; j < i; j++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem('test' + j);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return max + ' KB примерно';</code><br><code>}</code></p><h4>Причины недоступности:</h4><ul><li>Режим приватного просмотра (некоторые браузеры)</li><li>Пользователь отключил Storage в настройках</li><li>Хранилище переполнено (QuotaExceededError)</li><li>Старые браузеры без поддержки</li></ul><p><em>Типичный лимит:</em> 5MB для localStorage и sessionStorage в большинстве браузеров.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'проверка доступности', 'размер', 'ограничения']
  },
  {
    id: 110,
    question: "Как обрабатывать ошибку QuotaExceededError при переполнении Storage?",
    answer: "<p>QuotaExceededError возникает когда Storage переполнен. Важно правильно обрабатывать эту ошибку:</p><h4>Базовая обработка:</h4><p><code>function safeSetItem(key, value) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, value);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return true;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Storage full');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;throw e;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Автоматическая очистка старых данных:</h4><p><code>function setItemWithExpiry(key, value, ttl) {</code><br><code>&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;value: value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttl</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Очищаем истекшие элементы</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanupExpired();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Пробуем снова</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e2) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Storage still full');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><code>function cleanupExpired() {</code><br><code>&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.expiry && item.expiry < now) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Невалидные данные - можно удалить</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;});</code><br><code>}</code></p><h4>LRU (Least Recently Used) стратегия:</h4><p><code>class LRUStorage {</code><br><code>&nbsp;&nbsp;set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastUsed: Date.now()</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.name === 'QuotaExceededError') {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeLeastRecentlyUsed();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;removeLeastRecentlyUsed() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let oldestKey = null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let oldestTime = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.lastUsed < oldestTime) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldestTime = item.lastUsed;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldestKey = key;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (oldestKey) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(oldestKey);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Всегда оборачивайте setItem в try-catch и имейте стратегию очистки.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'QuotaExceededError', 'обработка ошибок', 'очистка']
  },
  {
    id: 111,
    question: "Как работать с событием storage для синхронизации между вкладками?",
    answer: "<p>Событие <code>storage</code> позволяет синхронизировать данные между вкладками одного origin:</p><h4>Базовое использование:</h4><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;console.log('Key:', e.key);</code><br><code>&nbsp;&nbsp;console.log('Old value:', e.oldValue);</code><br><code>&nbsp;&nbsp;console.log('New value:', e.newValue);</code><br><code>&nbsp;&nbsp;console.log('URL:', e.url);</code><br><code>&nbsp;&nbsp;console.log('Storage:', e.storageArea);</code><br><code>});</code></p><h4>Важные особенности:</h4><ul><li>Срабатывает ТОЛЬКО в других вкладках, не в той где произошло изменение</li><li>Работает только для localStorage, не для sessionStorage</li><li>e.key === null при вызове clear()</li><li>e.oldValue и e.newValue всегда строки</li></ul><h4>Синхронизация темы между вкладками:</h4><p><code>// Во вкладке 1</code><br><code>function setTheme(theme) {</code><br><code>&nbsp;&nbsp;localStorage.setItem('theme', theme);</code><br><code>&nbsp;&nbsp;applyTheme(theme);</code><br><code>}</code></p><p><code>// Во вкладке 2 - автообновление</code><br><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'theme' && e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;applyTheme(e.newValue);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Синхронизация состояния аутентификации:</h4><p><code>// Logout во всех вкладках</code><br><code>function logout() {</code><br><code>&nbsp;&nbsp;localStorage.removeItem('token');</code><br><code>&nbsp;&nbsp;redirectToLogin();</code><br><code>}</code></p><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'token' && !e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Токен удален в другой вкладке</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;redirectToLogin();</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><h4>Broadcast сообщений между вкладками:</h4><p><code>function broadcastMessage(type, data) {</code><br><code>&nbsp;&nbsp;const message = { type, data, timestamp: Date.now() };</code><br><code>&nbsp;&nbsp;localStorage.setItem('broadcast', JSON.stringify(message));</code><br><code>&nbsp;&nbsp;localStorage.removeItem('broadcast'); // Триггер события</code><br><code>}</code></p><p><code>window.addEventListener('storage', (e) => {</code><br><code>&nbsp;&nbsp;if (e.key === 'broadcast' && e.newValue) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const message = JSON.parse(e.newValue);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;handleMessage(message);</code><br><code>&nbsp;&nbsp;}</code><br><code>});</code></p><p><em>Альтернатива:</em> Для более надежной коммуникации используйте BroadcastChannel API.</p>",
    difficulty: 'middle',
    tags: ['storage event', 'синхронизация', 'вкладки', 'коммуникация']
  },
  {
    id: 112,
    question: "Как реализовать хранение данных с TTL (временем жизни)?",
    answer: "<p>TTL (Time To Live) позволяет автоматически удалять устаревшие данные:</p><h4>Базовая реализация:</h4><p><code>const StorageWithTTL = {</code><br><code>&nbsp;&nbsp;set(key, value, ttlMinutes) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttlMinutes * 60 * 1000</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemStr = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!itemStr) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(itemStr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверка истечения</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (Date.now() > item.expiry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return item.value;</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>// Сохранить на 30 минут</code><br><code>StorageWithTTL.set('sessionData', userData, 30);</code></p><p><code>// Получить (вернет null если истекло)</code><br><code>const data = StorageWithTTL.get('sessionData');</code></p><h4>Класс с автоочисткой:</h4><p><code>class CacheStorage {</code><br><code>&nbsp;&nbsp;constructor() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.cleanup(); // Очистка при инициализации</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, value, ttlSeconds = 3600) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expiry: Date.now() + ttlSeconds * 1000</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemStr = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!itemStr) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(itemStr);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Date.now() > item.expiry) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item.value;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;remove(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;cleanup() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const now = Date.now();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(localStorage).forEach(key => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = JSON.parse(localStorage.getItem(key));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (item.expiry && item.expiry < now) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.remove(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Игнорируем невалидные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><p><em>Best practice:</em> Запускайте cleanup() при инициализации приложения для удаления истекших данных.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'TTL', 'кэширование', 'expiry']
  },
  {
    id: 113,
    question: "В чем разница между Web Storage и Cookies?",
    answer: "<p>Web Storage и Cookies решают похожие задачи, но имеют существенные различия:</p><h4>Web Storage (localStorage/sessionStorage):</h4><ul><li><strong>Размер:</strong> ~5-10 МБ</li><li><strong>Отправка на сервер:</strong> Никогда, только клиентская сторона</li><li><strong>API:</strong> Простой и синхронный</li><li><strong>Доступ:</strong> Только JavaScript</li><li><strong>Срок жизни:</strong> localStorage - постоянно, sessionStorage - до закрытия вкладки</li></ul><h4>Cookies:</h4><ul><li><strong>Размер:</strong> ~4 КБ</li><li><strong>Отправка на сервер:</strong> С каждым HTTP-запросом</li><li><strong>API:</strong> Строка document.cookie, неудобный</li><li><strong>Доступ:</strong> JavaScript и сервер</li><li><strong>Срок жизни:</strong> Настраивается через expires/max-age</li><li><strong>Безопасность:</strong> HttpOnly, Secure, SameSite флаги</li></ul><h4>Когда использовать:</h4><p><strong>Web Storage:</strong></p><ul><li>Настройки UI (тема, язык)</li><li>Кэширование данных</li><li>Временное состояние приложения</li><li>Большие объемы данных</li></ul><p><strong>Cookies:</strong></p><ul><li>Аутентификация (токены)</li><li>Сессии на сервере</li><li>Tracking и аналитика</li><li>Данные, нужные серверу</li></ul><h4>Производительность:</h4><p>Web Storage не увеличивает размер HTTP-запросов, в отличие от cookies которые отправляются с каждым запросом.</p><p><em>Вывод:</em> Используйте Web Storage для клиентских данных, cookies - для серверной коммуникации.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'Cookies', 'сравнение', 'различия']
  },
  {
    id: 114,
    question: "Какие существуют best practices при работе с Web Storage?",
    answer: "<p>Следование best practices критично для безопасности и производительности:</p><h4>1. Всегда оборачивайте в try-catch:</h4><p><code>try {</code><br><code>&nbsp;&nbsp;localStorage.setItem('key', 'value');</code><br><code>} catch (e) {</code><br><code>&nbsp;&nbsp;// QuotaExceededError или другие ошибки</code><br><code>}</code></p><h4>2. Проверяйте доступность:</h4><p><code>if (typeof Storage !== 'undefined') {</code><br><code>&nbsp;&nbsp;// Storage доступен</code><br><code>}</code></p><h4>3. Не храните чувствительные данные:</h4><p>❌ НЕ хранить: пароли, номера карт, SSN, приватные ключи</p><p>✅ Можно: публичные настройки, кэш, UI состояние</p><h4>4. Используйте префиксы для ключей:</h4><p><code>const APP_PREFIX = 'myapp_';</code><br><code>localStorage.setItem(APP_PREFIX + 'theme', 'dark');</code></p><h4>5. Валидируйте данные при чтении:</h4><p><code>function safeGetItem(key) {</code><br><code>&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return item ? JSON.parse(item) : null;</code><br><code>&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key); // Удаляем невалидные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>6. Ограничивайте размер данных:</h4><p><code>function setItemIfFits(key, value) {</code><br><code>&nbsp;&nbsp;const str = JSON.stringify(value);</code><br><code>&nbsp;&nbsp;if (str.length > 1024 * 1024) { // > 1MB</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;console.warn('Data too large');</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;localStorage.setItem(key, str);</code><br><code>}</code></p><h4>7. Очищайте старые данные:</h4><p><code>// При инициализации приложения</code><br><code>function cleanupOldData() {</code><br><code>&nbsp;&nbsp;const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;</code><br><code>&nbsp;&nbsp;// Логика очистки...</code><br><code>}</code></p><h4>8. Используйте namespace:</h4><p><code>const storage = {</code><br><code>&nbsp;&nbsp;prefix: 'myapp_',</code><br><code>&nbsp;&nbsp;set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(this.prefix + key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(localStorage.getItem(this.prefix + key));</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>9. Минимизируйте частоту записи:</h4><p>Используйте debounce для частых обновлений, так как Storage операции синхронные.</p><h4>10. Документируйте структуру данных:</h4><p>Ведите документацию какие ключи используются и их формат.</p><p><em>Критично:</em> Storage доступен любому JavaScript на странице - не храните секреты!</p>",
    difficulty: 'senior',
    tags: ['Web Storage', 'best practices', 'безопасность', 'производительность']
  },
  {
    id: 115,
    question: "Какие существуют альтернативы Web Storage для хранения данных?",
    answer: "<p>Существует несколько альтернатив Web Storage для разных сценариев:</p><h4>1. IndexedDB:</h4><p><strong>Когда использовать:</strong> Большие объемы структурированных данных (>10MB), офлайн приложения</p><p><strong>Преимущества:</strong></p><ul><li>Практически неограниченный размер</li><li>Асинхронный API</li><li>Поддержка индексов и транзакций</li><li>Хранение объектов без сериализации</li></ul><p><strong>Недостатки:</strong> Сложный API</p><h4>2. Cache API:</h4><p><strong>Когда использовать:</strong> Кэширование HTTP-запросов, офлайн PWA</p><p><strong>Преимущества:</strong></p><ul><li>Оптимизирован для Response объектов</li><li>Работает с Service Workers</li><li>Большой размер</li></ul><h4>3. Cookies:</h4><p><strong>Когда использовать:</strong> Аутентификация, данные для сервера</p><p><strong>Преимущества:</strong></p><ul><li>Автоматическая отправка на сервер</li><li>HttpOnly для безопасности</li><li>Контроль срока жизни</li></ul><p><strong>Недостатки:</strong> Маленький размер (4KB)</p><h4>4. File System Access API:</h4><p><strong>Когда использовать:</strong> Работа с файловой системой, редакторы</p><p><strong>Преимущества:</strong> Доступ к реальным файлам пользователя</p><h4>5. WebSQL (устаревший):</h4><p><strong>Статус:</strong> Deprecated, не использовать</p><h4>6. Memory (переменные):</h4><p><strong>Когда использовать:</strong> Временные данные в рамках сессии</p><p><strong>Недостатки:</strong> Теряется при перезагрузке страницы</p><h4>Сравнительная таблица:</h4><table><tr><th>Технология</th><th>Размер</th><th>Асинхронность</th><th>Сложность</th></tr><tr><td>localStorage</td><td>~5MB</td><td>❌</td><td>⭐</td></tr><tr><td>IndexedDB</td><td>Большой</td><td>✅</td><td>⭐⭐⭐⭐</td></tr><tr><td>Cache API</td><td>Большой</td><td>✅</td><td>⭐⭐⭐</td></tr><tr><td>Cookies</td><td>4KB</td><td>❌</td><td>⭐⭐</td></tr></table><p><em>Выбор зависит:</em> от размера данных, нужны ли они серверу, требуется ли офлайн доступ.</p>",
    difficulty: 'middle',
    tags: ['Web Storage', 'альтернативы', 'IndexedDB', 'Cache API']
  },
  {
    id: 116,
    question: "Как безопасно хранить токены аутентификации?",
    answer: "<p>Хранение токенов — критический вопрос безопасности приложения:</p><h4>Варианты хранения:</h4><p><strong>1. HttpOnly Cookies (РЕКОМЕНДУЕТСЯ):</strong></p><p>✅ Преимущества:</p><ul><li>Недоступны для JavaScript (защита от XSS)</li><li>Автоматически отправляются на сервер</li><li>Secure флаг для HTTPS only</li><li>SameSite защита от CSRF</li></ul><p>❌ Недостатки: Нужна настройка на сервере</p><p><strong>2. localStorage (НЕ РЕКОМЕНДУЕТСЯ):</strong></p><p>❌ Проблемы:</p><ul><li>Доступен любому JavaScript (уязвим к XSS)</li><li>Нет защиты от кражи токена</li><li>Постоянное хранение</li></ul><p>✅ Когда можно: SPA без серверного рендеринга, краткосрочные токены</p><p><strong>3. sessionStorage (КОМПРОМИСС):</strong></p><p>Чуть безопаснее localStorage, так как удаляется при закрытии вкладки, но все еще уязвим к XSS.</p><p><strong>4. Memory (в переменной):</strong></p><p>✅ Самое безопасное для клиента</p><p>❌ Теряется при перезагрузке страницы</p><h4>Best practices:</h4><p><code>// ❌ ПЛОХО - токен в localStorage</code><br><code>localStorage.setItem('token', token);</code></p><p><code>// ✅ ЛУЧШЕ - HttpOnly cookie (настраивается на сервере)</code><br><code>// Set-Cookie: token=xxx; HttpOnly; Secure; SameSite=Strict</code></p><p><code>// ✅ КОМПРОМИСС - короткоживущие токены</code><br><code>sessionStorage.setItem('token', token);</code><br><code>// + Refresh token в HttpOnly cookie</code></p><h4>Дополнительные меры безопасности:</h4><ul><li>Используйте короткие сроки жизни токенов</li><li>Implement token rotation</li><li>Проверяйте fingerprint браузера</li><li>Логируйте подозрительную активность</li><li>CSP заголовки для защиты от XSS</li></ul><p><em>Золотое правило:</em> Если возможно - используйте HttpOnly cookies. Если нет - sessionStorage с короткими токенами и refresh механизмом.</p>",
    difficulty: 'senior',
    tags: ['безопасность', 'токены', 'аутентификация', 'XSS']
  },
  {
    id: 117,
    question: "Как реализовать версионирование данных в Storage?",
    answer: "<p>Версионирование помогает избежать проблем при изменении структуры данных:</p><h4>Базовая схема версионирования:</h4><p><code>const STORAGE_VERSION = 2;</code></p><p><code>function saveData(key, data) {</code><br><code>&nbsp;&nbsp;const versioned = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;version: STORAGE_VERSION,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data: data</code><br><code>&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(versioned));</code><br><code>}</code></p><p><code>function loadData(key) {</code><br><code>&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const parsed = JSON.parse(item);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Проверка версии</code><br><code>&nbsp;&nbsp;if (parsed.version !== STORAGE_VERSION) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return migrateData(parsed, key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return parsed.data;</code><br><code>}</code></p><h4>Миграция между версиями:</h4><p><code>function migrateData(oldData, key) {</code><br><code>&nbsp;&nbsp;const version = oldData.version || 1;</code><br><code>&nbsp;&nbsp;let data = oldData.data;</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Миграция с версии 1 на 2</code><br><code>&nbsp;&nbsp;if (version === 1) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;data = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...data,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newField: 'defaultValue'</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;// Сохраняем обновленные данные</code><br><code>&nbsp;&nbsp;saveData(key, data);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;return data;</code><br><code>}</code></p><h4>Класс с автомиграцией:</h4><p><code>class VersionedStorage {</code><br><code>&nbsp;&nbsp;constructor(version, migrations = {}) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.version = version;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.migrations = migrations;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version: this.version,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;};</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(item));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;let parsed = JSON.parse(item);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const itemVersion = parsed.version || 1;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Применяем все необходимые миграции</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;for (let v = itemVersion; v < this.version; v++) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const migration = this.migrations[v];</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (migration) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsed.data = migration(parsed.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сохраняем мигрированные данные</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (itemVersion < this.version) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.set(key, parsed.data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return parsed.data;</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Использование:</h4><p><code>const storage = new VersionedStorage(3, {</code><br><code>&nbsp;&nbsp;1: (data) => ({ ...data, newField: 'default' }),</code><br><code>&nbsp;&nbsp;2: (data) => ({ ...data, renamedField: data.oldField })</code><br><code>});</code></p><p><code>storage.set('userData', { name: 'John' });</code><br><code>const data = storage.get('userData'); // Автоматическая миграция</code></p><p><em>Best practice:</em> Всегда тестируйте миграции и сохраняйте backup перед применением.</p>",
    difficulty: 'senior',
    tags: ['версионирование', 'миграция', 'данные', 'архитектура']
  },
  {
    id: 118,
    question: "Как отладить проблемы с Web Storage в DevTools?",
    answer: "<p>Chrome DevTools предоставляют мощные инструменты для работы с Storage:</p><h4>Application Tab → Storage:</h4><p><strong>Просмотр данных:</strong></p><ul><li>Application → Local Storage / Session Storage</li><li>Видны все ключи и значения</li><li>Можно редактировать значения напрямую</li><li>Показывает размер каждого элемента</li></ul><p><strong>Очистка данных:</strong></p><ul><li>ПКМ на домене → Clear</li><li>Или кнопка «Clear All» для всего Storage</li></ul><h4>Console методы:</h4><p><code>// Просмотр всех ключей</code><br><code>console.table(localStorage);</code></p><p><code>// Размер Storage</code><br><code>let size = 0;</code><br><code>for (let key in localStorage) {</code><br><code>&nbsp;&nbsp;size += localStorage[key].length + key.length;</code><br><code>}</code><br><code>console.log(size / 1024 + ' KB');</code></p><p><code>// Поиск по ключам</code><br><code>Object.keys(localStorage).filter(key => key.includes('user'));</code></p><h4>Мониторинг изменений:</h4><p><code>// Перехват setItem</code><br><code>const originalSetItem = localStorage.setItem;</code><br><code>localStorage.setItem = function(key, value) {</code><br><code>&nbsp;&nbsp;console.log('Storage set:', key, value);</code><br><code>&nbsp;&nbsp;originalSetItem.apply(this, arguments);</code><br><code>};</code></p><h4>Breakpoints на Storage:</h4><ul><li>Sources → Event Listener Breakpoints</li><li>Выбрать «storage» для отслеживания изменений</li></ul><h4>Network Tab:</h4><p>Проверяйте размер cookies в заголовках запросов - иногда проблемы с Storage связаны с переполнением cookies.</p><h4>Частые проблемы и решения:</h4><p><strong>1. QuotaExceededError:</strong> Проверьте размер данных, очистите старые</p><p><strong>2. Данные не сохраняются:</strong> Проверьте режим инкогнито, настройки браузера</p><p><strong>3. Данные пропадают:</strong> Проверьте sessionStorage vs localStorage</p><p><strong>4. JSON.parse ошибка:</strong> Валидация данных перед парсингом</p><p><em>Совет:</em> Используйте console.table() для удобного просмотра всех данных Storage.</p>",
    difficulty: 'middle',
    tags: ['отладка', 'DevTools', 'Chrome', 'debugging']
  },
  {
    id: 119,
    question: "Как реализовать Storage с сжатием данных?",
    answer: "<p>Сжатие позволяет обойти ограничение размера Storage:</p><h4>Использование LZ-based алгоритмов:</h4><p><code>// Используем библиотеку lz-string</code><br><code>import LZString from 'lz-string';</code></p><p><code>const CompressedStorage = {</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, compressed);</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!compressed) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = LZString.decompress(compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(json);</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Класс с автоматическим сжатием:</h4><p><code>class SmartStorage {</code><br><code>&nbsp;&nbsp;constructor(compressionThreshold = 1024) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.threshold = compressionThreshold;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;set(key, data) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Сжимаем только если больше порога</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (json.length > this.threshold) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, 'compressed:' + compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} else {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;const item = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (!item) return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;// Проверяем префикс сжатия</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;if (item.startsWith('compressed:')) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const compressed = item.slice(11);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const json = LZString.decompress(compressed);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(json);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return JSON.parse(item);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Статистика сжатия:</h4><p><code>function compressionStats(data) {</code><br><code>&nbsp;&nbsp;const json = JSON.stringify(data);</code><br><code>&nbsp;&nbsp;const compressed = LZString.compress(json);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;const original = json.length;</code><br><code>&nbsp;&nbsp;const compressed = compressed.length;</code><br><code>&nbsp;&nbsp;const ratio = ((1 - compressed / original) * 100).toFixed(2);</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;console.log(\`Original: \${original} bytes\`);</code><br><code>&nbsp;&nbsp;console.log(\`Compressed: \${compressed} bytes\`);</code><br><code>&nbsp;&nbsp;console.log(\`Saved: \${ratio}%\`);</code><br><code>}</code></p><h4>Преимущества:</h4><ul><li>Можно сохранить в 2-10 раз больше данных</li><li>Особенно эффективно для текста и JSON</li><li>Прозрачно для остального кода</li></ul><h4>Недостатки:</h4><ul><li>Дополнительное время на сжатие/распаковку</li><li>Нужна внешняя библиотека</li><li>Не все данные хорошо сжимаются</li></ul><p><em>Best practice:</em> Сжимайте только большие объекты (>1KB) для оптимального баланса производительности.</p>",
    difficulty: 'senior',
    tags: ['сжатие', 'оптимизация', 'производительность', 'размер']
  },
  {
    id: 120,
    question: "Как имитировать асинхронный API для Storage?",
    answer: "<p>Web Storage синхронен, но иногда нужен асинхронный API для консистентности с другими Storage API:</p><h4>Promise-based обертка:</h4><p><code>const AsyncStorage = {</code><br><code>&nbsp;&nbsp;async getItem(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const value = localStorage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(value ? JSON.parse(value) : null);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async setItem(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve, reject) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem(key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(e);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;},</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async removeItem(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise((resolve) => {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage.removeItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve();</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;});</code><br><code>&nbsp;&nbsp;}</code><br><code>};</code></p><h4>Использование:</h4><p><code>// Асинхронный стиль</code><br><code>await AsyncStorage.setItem('user', { name: 'John' });</code><br><code>const user = await AsyncStorage.getItem('user');</code></p><h4>Универсальный адаптер:</h4><p><code>class StorageAdapter {</code><br><code>&nbsp;&nbsp;constructor(storage = localStorage) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage = storage;</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async get(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;try {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const item = this.storage.getItem(key);</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item ? JSON.parse(item) : null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async set(key, value) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.setItem(key, JSON.stringify(value));</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async delete(key) {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.removeItem(key);</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async clear() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;this.storage.clear();</code><br><code>&nbsp;&nbsp;}</code><br><code>&nbsp;&nbsp;</code><br><code>&nbsp;&nbsp;async keys() {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;return Object.keys(this.storage);</code><br><code>&nbsp;&nbsp;}</code><br><code>}</code></p><h4>Зачем нужен асинхронный API:</h4><ul><li>Консистентность с IndexedDB и Cache API</li><li>Возможность будущей замены на асинхронное хранилище</li><li>Упрощение тестирования с моками</li><li>Единообразный код</li></ul><h4>Полифилл для React Native AsyncStorage:</h4><p><code>const AsyncStorage = {</code><br><code>&nbsp;&nbsp;getItem: (key) => Promise.resolve(localStorage.getItem(key)),</code><br><code>&nbsp;&nbsp;setItem: (key, value) => Promise.resolve(localStorage.setItem(key, value)),</code><br><code>&nbsp;&nbsp;removeItem: (key) => Promise.resolve(localStorage.removeItem(key)),</code><br><code>&nbsp;&nbsp;clear: () => Promise.resolve(localStorage.clear())</code><br><code>};</code></p><p><em>Применение:</em> Облегчает миграцию кода между web и React Native, создает единый API.</p>",
    difficulty: 'middle',
    tags: ['асинхронность', 'Promise', 'адаптер', 'API']
  },
];
