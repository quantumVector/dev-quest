export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const cssInterviewQuestions: InterviewQuestion[] = [
  // Специфичность селекторов
  {
    id: 1,
    question: "Что такое специфичность в CSS и как она работает?",
    answer: "<p><strong>Специфичность</strong> — это система приоритетов в CSS, которая определяет, какие стили будут применены к элементу, когда на него действует несколько правил.</p><p>Специфичность рассчитывается по четырем категориям:</p><ul><li><strong>Inline стили</strong> (атрибут style) — 1000 единиц</li><li><strong>ID селекторы</strong> (#id) — 100 единиц</li><li><strong>Классы, атрибуты и псевдоклассы</strong> (.class, [attr], :hover) — 10 единиц</li><li><strong>Элементы и псевдоэлементы</strong> (div, ::before) — 1 единица</li></ul><p>Браузер сравнивает специфичность селекторов слева направо и применяет стили с наибольшей специфичностью. Если специфичность одинаковая, то действует правило каскада — применяется стиль, который объявлен позже в коде.</p>",
    difficulty: 'junior',
    tags: ['специфичность', 'селекторы', 'каскад']
  },
  {
    id: 2,
    question: "Как правильно рассчитать специфичность сложного селектора?",
    answer: "<p>Для расчета специфичности сложного селектора нужно <strong>подсчитать количество каждого типа селектора</strong> и сложить их по весам:</p><p>Возьмем пример селектора: <code>body div.container #main ul li.active:hover</code></p><ul><li>ID селекторы: 1 (#main) = 100</li><li>Классы и псевдоклассы: 2 (.container, .active, :hover) = 30</li><li>Элементы: 4 (body, div, ul, li) = 4</li><li>Итого: 134</li></ul><p>При расчете важно помнить, что специфичность не работает в десятичной системе — 11 классов не перебьют 1 ID. Каждая категория имеет свой приоритет, и более высокая категория всегда выигрывает.</p><p>Также стоит избегать чрезмерно специфичных селекторов, так как это усложняет переопределение стилей и поддержку кода.</p>",
    difficulty: 'middle',
    tags: ['специфичность', 'селекторы', 'расчет']
  },
  {
    id: 3,
    question: "Что такое !important и когда его следует использовать?",
    answer: "<p><strong>!important</strong> — это декларация в CSS, которая повышает приоритет правила до максимального уровня, заставляя браузер применить именно это правило независимо от специфичности селектора.</p><p>Использование !important следует <strong>минимизировать</strong> и применять только в исключительных случаях:</p><ul><li>Переопределение стилей сторонних библиотек, которые нельзя изменить</li><li>Utility-классы, которые должны всегда применяться</li><li>Временные решения для быстрого исправления в продакшене</li></ul><p>Проблемы с !important:</p><ul><li>Нарушает естественный каскад CSS</li><li>Усложняет дальнейшее переопределение стилей</li><li>Может привести к войне !important в коде</li><li>Затрудняет отладку и поддержку</li></ul><p>Лучше решать проблемы специфичности за счет рефакторинга селекторов, а не использования !important.</p>",
    difficulty: 'middle',
    tags: ['специфичность', '!important', 'каскад']
  },
  {
    id: 4,
    question: "Как работает наследование в CSS и как оно взаимодействует со специфичностью?",
    answer: "<p><strong>Наследование</strong> — это механизм, при котором некоторые CSS свойства автоматически передаются от родительских элементов к дочерним.</p><p>Наследуемые свойства имеют специфичность <strong>0</strong>, что означает, что любое прямое правило, даже с минимальной специфичностью, переопределит наследуемое значение.</p><p>Основные наследуемые свойства: font-family, font-size, color, text-align, line-height, visibility и другие типографические свойства.</p><p>Ненаследуемые свойства: margin, padding, border, background, position, display и большинство layout-свойств.</p><p>Для управления наследованием используются ключевые слова:</p><ul><li><strong>inherit</strong> — принудительно наследует значение от родителя</li><li><strong>initial</strong> — сбрасывает к начальному значению свойства</li><li><strong>unset</strong> — inherit для наследуемых свойств, initial для неинаследуемых</li><li><strong>revert</strong> — возвращает к значению по умолчанию браузера</li></ul>",
    difficulty: 'middle',
    tags: ['специфичность', 'наследование', 'каскад']
  },
  {
    id: 5,
    question: "Какие селекторы имеют одинаковую специфичность и как браузер выбирает между ними?",
    answer: "<p>Селекторы с одинаковой специфичностью встречаются довольно часто. Например:</p><ul><li>Все селекторы по классу: <code>.header</code>, <code>.footer</code>, <code>.sidebar</code> — специфичность 10</li><li>Все селекторы по элементу: <code>div</code>, <code>p</code>, <code>span</code> — специфичность 1</li><li>Комбинированные селекторы: <code>div p</code>, <code>ul li</code> — специфичность 2</li></ul><p>Когда специфичность одинаковая, браузер применяет правило <strong>каскада</strong>:</p><ul><li>Побеждает стиль, который объявлен <strong>последним</strong> в коде</li><li>Порядок подключения файлов CSS тоже важен</li><li>Inline стили в HTML всегда имеют приоритет</li></ul><p>Это основная причина, почему важен порядок подключения CSS файлов и порядок объявления правил в коде. Многие проблемы с применением стилей возникают именно из-за неправильного понимания этого принципа.</p>",
    difficulty: 'junior',
    tags: ['специфичность', 'каскад', 'порядок']
  },
  {
    id: 6,
    question: "Как псевдокласс :not() влияет на специфичность селектора?",
    answer: "<p>Псевдокласс <code>:not()</code> имеет особенность в расчете специфичности — <strong>сам :not() не добавляет специфичности</strong>, но селектор внутри него учитывается полностью.</p><p>Примеры расчета:</p><ul><li><code>div:not(.hidden)</code> — специфичность 11 (div=1 + .hidden=10)</li><li><code>:not(#main)</code> — специфичность 100 (только #main)</li><li><code>p:not(.active):not(.disabled)</code> — специфичность 21 (p=1 + .active=10 + .disabled=10)</li></ul><p>Это означает, что селектор <code>:not(#id)</code> имеет такую же специфичность, как и <code>#id</code>, что может быть неожиданным для разработчиков.</p><p>Важно помнить, что <code>:not()</code> может принимать только простые селекторы (элемент, класс, ID, атрибут), но не комбинаторы или сложные селекторы.</p><p>Это делает :not() мощным инструментом для исключения элементов без потери контроля над специфичностью.</p>",
    difficulty: 'middle',
    tags: ['специфичность', 'псевдоклассы', ':not()']
  },
  {
    id: 7,
    question: "Чем отличается специфичность универсального селектора (*) от других селекторов?",
    answer: "<p><strong>Универсальный селектор</strong> <code>*</code> имеет специфичность <strong>0</strong>, что делает его особенным среди всех селекторов.</p><p>Особенности универсального селектора:</p><ul><li>Специфичность 0 — меньше даже чем у селекторов элементов</li><li>Не влияет на специфичность комбинированных селекторов: <code>* div</code> = 1, <code>div *</code> = 1</li><li>Легко переопределяется любым другим селектором</li><li>Часто используется для CSS-сброса стилей</li></ul><p>Примеры:</p><ul><li><code>*</code> — специфичность 0</li><li><code>*.class</code> — специфичность 10 (только класс учитывается)</li><li><code>div > *</code> — специфичность 1 (только div учитывается)</li></ul><p>Это делает универсальный селектор идеальным для задания базовых стилей, которые должны легко переопределяться более специфичными правилами. Однако стоит быть осторожным с производительностью при использовании * на больших документах.</p>",
    difficulty: 'middle',
    tags: ['специфичность', 'универсальный селектор', 'производительность']
  },
  {
    id: 8,
    question: "Как работает специфичность в CSS-in-JS библиотеках?",
    answer: "<p>CSS-in-JS библиотеки используют различные подходы к управлению специфичностью:</p><p><strong>Styled-components, Emotion:</strong></p><ul><li>Генерируют уникальные классы для каждого компонента</li><li>Специфичность остается низкой (обычно 10 — один класс)</li><li>Конфликты решаются порядком внедрения стилей</li><li>Поддерживают && для повышения специфичности</li></ul><p><strong>JSS, Fela:</strong></p><ul><li>Также генерируют уникальные классы</li><li>Используют автоматическое управление порядком стилей</li><li>Могут настраивать специфичность через конфигурацию</li></ul><p><strong>Проблемы и решения:</strong></p><ul><li>Переопределение стилей сторонних библиотек может требовать повышения специфичности</li><li>Многие библиотеки предоставляют API для управления порядком стилей</li><li>Некоторые используют CSS custom properties для динамических значений</li></ul><p>Главное преимущество — изоляция стилей компонентов и предсказуемость специфичности.</p>",
    difficulty: 'senior',
    tags: ['специфичность', 'CSS-in-JS', 'компоненты']
  },
  {
    id: 9,
    question: "Какие стратегии помогают избежать проблем со специфичностью в больших проектах?",
    answer: "<p>Для управления специфичностью в больших проектах используются следующие стратегии:</p><p><strong>Методологии именования:</strong></p><ul><li><strong>BEM</strong> — низкая специфичность, избегание вложенности</li><li><strong>SMACSS</strong> — разделение на категории стилей</li><li><strong>ITCSS</strong> — управление специфичностью через слои</li></ul><p><strong>Архитектурные подходы:</strong></p><ul><li>Использование только классов, избегание ID в CSS</li><li>Ограничение глубины вложенности селекторов (не более 3-4 уровней)</li><li>Atomic CSS — максимально простые, переиспользуемые классы</li><li>Utility-first подход (Tailwind CSS)</li></ul><p><strong>Технические решения:</strong></p><ul><li>CSS Modules — автоматическая изоляция стилей</li><li>Shadow DOM — полная изоляция стилей</li><li>PostCSS плагины для контроля специфичности</li><li>Линтеры для отслеживания чрезмерной специфичности</li></ul><p>Главное правило — поддерживать специфичность на минимальном уровне и использовать консистентный подход во всем проекте.</p>",
    difficulty: 'senior',
    tags: ['специфичность', 'архитектура', 'методологии']
  },
  {
    id: 10,
    question: "Как debug и решать проблемы со специфичностью в DevTools?",
    answer: "<p>Браузерные DevTools предоставляют мощные инструменты для отладки проблем со специфичностью:</p><p><strong>Chrome DevTools:</strong></p><ul><li>Панель <strong>Computed</strong> показывает итоговые значения свойств</li><li>Панель <strong>Styles</strong> показывает все применяемые правила в порядке специфичности</li><li>Перечеркнутые правила показывают переопределенные стили</li><li>Hover на селекторе показывает его специфичность</li></ul><p><strong>Firefox DevTools:</strong></p><ul><li>Аналогичная функциональность в панели Inspector</li><li>Дополнительная информация о специфичности в tooltip</li><li>Возможность временного изменения специфичности</li></ul><p><strong>Стратегии отладки:</strong></p><ul><li>Начинать с панели Computed для понимания итогового значения</li><li>Проверять порядок правил в панели Styles</li><li>Использовать временные !important для проверки гипотез</li><li>Анализировать селекторы на предмет чрезмерной специфичности</li></ul><p>Полезные расширения: CSS Specificity Visualizer, Specificity Calculator.</p>",
    difficulty: 'middle',
    tags: ['специфичность', 'отладка', 'DevTools']
  },

  // Изоляция стилей
  {
    id: 11,
    question: "Какие проблемы решает изоляция стилей в CSS?",
    answer: "<p>Изоляция стилей решает несколько <strong>ключевых проблем</strong> современной веб-разработки:</p><ul><li><strong>Глобальное загрязнение</strong> — предотвращает непреднамеренное влияние стилей одного компонента на другие</li><li><strong>Конфликты имен</strong> — исключает пересечения классов с одинаковыми именами в разных частях приложения</li><li><strong>Неконтролируемый каскад</strong> — ограничивает область действия стилей определенным компонентом</li><li><strong>Сложность поддержки</strong> — облегчает понимание того, где и как применяются стили</li></ul><p>Также изоляция помогает в <strong>командной разработке</strong>, когда несколько разработчиков работают над разными частями проекта. Каждый может быть уверен, что его стили не повлияют на работу коллег.</p><p>Это особенно важно в больших проектах и при использовании компонентного подхода, где каждый компонент должен быть независимым и переиспользуемым.</p>",
    difficulty: 'junior',
    tags: ['изоляция', 'архитектура', 'компоненты']
  },
  {
    id: 12,
    question: "Перечислите основные методы изоляции стилей в CSS.",
    answer: "<p>Существует несколько <strong>основных методов</strong> изоляции стилей:</p><p><strong>1. Методологии именования:</strong></p><ul><li>BEM (Block Element Modifier) — структурированное именование классов</li><li>OOCSS (Object-Oriented CSS) — объектно-ориентированный подход</li><li>SMACSS — масштабируемая и модульная архитектура</li></ul><p><strong>2. Технологические решения:</strong></p><ul><li>CSS Modules — автоматическая генерация уникальных имен классов</li><li>CSS-in-JS — написание стилей внутри JavaScript</li><li>Styled Components — компонентный подход к стилизации</li></ul><p><strong>3. Современные веб-стандарты:</strong></p><ul><li>Shadow DOM — изоляция на уровне браузера</li><li>CSS @layer — управление каскадом через слои</li><li>CSS Container Queries — контекстные запросы</li></ul><p>Каждый метод имеет свои преимущества и подходит для разных сценариев использования.</p>",
    difficulty: 'middle',
    tags: ['изоляция', 'методологии', 'технологии']
  },
  {
    id: 13,
    question: "Объясните принцип работы CSS Modules.",
    answer: "<p><strong>CSS Modules</strong> — это подход к изоляции стилей, который автоматически генерирует уникальные имена классов на этапе сборки проекта.</p><p><strong>Принцип работы:</strong></p><ol><li>Вы пишете обычный CSS с понятными именами классов</li><li>Сборщик (webpack, Vite) преобразует имена в уникальные хеши</li><li>В JavaScript вы импортируете объект с мапингом оригинальных имен на хеши</li><li>Используете эти хеши в своих компонентах</li></ol><p><strong>Преимущества:</strong></p><ul><li>Полная изоляция — классы не пересекаются между модулями</li><li>Привычный синтаксис CSS</li><li>Возможность использовать композицию</li><li>Статический анализ — неиспользуемые классы легко найти</li></ul><p><strong>Недостатки:</strong></p><ul><li>Требует настройки сборщика</li><li>Усложняет отладку в DevTools</li><li>Затрудняет динамическое изменение классов</li></ul><p>CSS Modules отлично подходят для больших проектов с компонентной архитектурой.</p>",
    difficulty: 'middle',
    tags: ['CSS Modules', 'изоляция', 'сборка']
  },
  {
    id: 14,
    question: "Как работает Shadow DOM для изоляции стилей?",
    answer: "<p><strong>Shadow DOM</strong> — это веб-стандарт, который создает изолированное поддерево DOM с собственной областью видимости для стилей.</p><p><strong>Механизм работы:</strong></p><ul><li>Создается теневое дерево (shadow tree), которое прикрепляется к элементу</li><li>Стили внутри Shadow DOM не влияют на основной документ</li><li>Стили из основного документа не проникают в Shadow DOM</li><li>Это обеспечивает полную изоляцию на уровне браузера</li></ul><p><strong>Преимущества:</strong></p><ul><li>Нативная изоляция без дополнительных инструментов</li><li>Высокая производительность</li><li>Идеально подходит для Web Components</li><li>Невозможность случайного вмешательства в стили</li></ul><p><strong>Ограничения:</strong></p><ul><li>Ограниченная поддержка в старых браузерах</li><li>Сложности с глобальными стилями (темы, шрифты)</li><li>Более сложная отладка</li><li>Ограниченная гибкость кастомизации</li></ul><p>Shadow DOM лучше всего подходит для создания переиспользуемых компонентов и виджетов.</p>",
    difficulty: 'senior',
    tags: ['Shadow DOM', 'Web Components', 'изоляция']
  },
  {
    id: 15,
    question: "В чем разница между CSS-in-JS и CSS Modules с точки зрения изоляции стилей?",
    answer: "<p><strong>CSS-in-JS и CSS Modules</strong> — два разных подхода к изоляции стилей с различными принципами работы:</p><p><strong>CSS-in-JS:</strong></p><ul><li>Стили создаются и управляются в JavaScript коде</li><li>Полная интеграция с компонентной логикой</li><li>Динамическое создание стилей во время выполнения</li><li>Легкое использование переменных и состояния компонента</li><li>Автоматическое удаление неиспользуемых стилей</li></ul><p><strong>CSS Modules:</strong></p><ul><li>Обычный CSS с автоматической генерацией уникальных имен классов</li><li>Статическая обработка на этапе сборки</li><li>Сохранение привычного синтаксиса CSS</li><li>Меньшее влияние на bundle size</li><li>Лучшая производительность без runtime обработки</li></ul><p><strong>Выбор зависит от:</strong></p><ul><li>Требований к динамическим стилям</li><li>Размера проекта и команды</li><li>Производительности и размера bundle</li><li>Предпочтений в архитектуре</li></ul>",
    difficulty: 'middle',
    tags: ['изоляция', 'CSS-in-JS', 'CSS Modules', 'сравнение']
  },
  {
    id: 16,
    question: "Что такое CSS Custom Properties (CSS переменные) и как они помогают в изоляции стилей?",
    answer: "<p><strong>CSS Custom Properties</strong> — это нативные CSS переменные, которые помогают создавать изолированные и переиспользуемые стили:</p><p><strong>Преимущества для изоляции:</strong></p><ul><li>Локальная область видимости — переменные действуют только в рамках элемента</li><li>Каскадирование — можно переопределять значения для конкретных компонентов</li><li>Инкапсуляция — создание изолированных тем и вариантов компонентов</li><li>Отсутствие конфликтов — уникальные имена переменных исключают пересечения</li></ul><p><strong>Применение в изоляции:</strong></p><ul><li>Создание компонентных тем через локальные переменные</li><li>Изоляция цветовых схем и размеров</li><li>Контекстные стили для разных состояний</li><li>Переиспользование значений без глобального влияния</li></ul><p><strong>Ограничения:</strong></p><ul><li>Не решают проблему конфликтов имен классов</li><li>Ограниченная поддержка в старых браузерах</li><li>Требуют дополнительной организации кода</li></ul>",
    difficulty: 'middle',
    tags: ['изоляция', 'CSS переменные', 'custom properties', 'инкапсуляция']
  },
  {
    id: 17,
    question: "Как работает CSS @layer и как это влияет на изоляцию стилей?",
    answer: "<p><strong>CSS @layer</strong> — это современный способ управления каскадом, который создает явные слои для организации стилей:</p><p><strong>Принцип работы:</strong></p><ul><li>Стили группируются в именованные слои</li><li>Приоритет определяется порядком объявления слоев</li><li>Внутри слоя действуют обычные правила специфичности</li><li>Слои имеют приоритет над обычными стилями</li></ul><p><strong>Влияние на изоляцию:</strong></p><ul><li>Контролируемый каскад — четкое разделение ответственности</li><li>Предсказуемость — явное управление приоритетами</li><li>Изоляция библиотек — каждая библиотека может использовать свой слой</li><li>Решение конфликтов — структурированный подход к разрешению пересечений</li></ul><p><strong>Практические применения:</strong></p><ul><li>Разделение reset, base, components, utilities стилей</li><li>Изоляция стилей третьих библиотек</li><li>Создание тематических слоев</li><li>Постепенная миграция legacy кода</li></ul>",
    difficulty: 'senior',
    tags: ['изоляция', '@layer', 'каскад', 'современный CSS']
  },
  {
    id: 18,
    question: "Какие проблемы может создать неправильная изоляция стилей и как их избежать?",
    answer: "<p><strong>Основные проблемы неправильной изоляции:</strong></p><p><strong>1. Утечки стилей:</strong></p><ul><li>Глобальные селекторы влияют на неожиданные элементы</li><li>Каскадные эффекты распространяются за пределы компонента</li><li>Переопределение стилей в неконтролируемых местах</li></ul><p><strong>2. Конфликты имен:</strong></p><ul><li>Пересечения классов с одинаковыми именами</li><li>Непреднамеренное переопределение существующих стилей</li><li>Проблемы интеграции с внешними библиотеками</li></ul><p><strong>3. Сложность поддержки:</strong></p><ul><li>Невозможность понять источник стилей</li><li>Боязнь изменений из-за непредсказуемых эффектов</li><li>Дублирование кода и раздувание CSS</li></ul><p><strong>Способы предотвращения:</strong></p><ul><li>Использование строгих методологий именования</li><li>Применение автоматизированных решений изоляции</li><li>Регулярные аудиты и рефакторинг кода</li><li>Документирование архитектурных решений</li><li>Использование линтеров и статического анализа</li></ul>",
    difficulty: 'middle',
    tags: ['изоляция', 'проблемы', 'отладка', 'поддержка']
  },
  {
    id: 19,
    question: "Как BEM методология обеспечивает изоляцию стилей и какие у неё ограничения?",
    answer: "<p><strong>BEM (Block Element Modifier)</strong> — методология именования, которая создает изоляцию через структурированные имена классов:</p><p><strong>Принципы изоляции в BEM:</strong></p><ul><li>Уникальность имен — каждый блок имеет уникальное имя</li><li>Отсутствие каскада — стили не зависят от структуры HTML</li><li>Независимость блоков — каждый блок самодостаточен</li><li>Предсказуемость — четкая связь между именем класса и его назначением</li></ul><p><strong>Преимущества:</strong></p><ul><li>Простота понимания и внедрения</li><li>Не требует дополнительных инструментов</li><li>Хорошая читаемость кода</li><li>Легкая интеграция с существующими проектами</li></ul><p><strong>Ограничения:</strong></p><ul><li>Длинные имена классов увеличивают размер HTML и CSS</li><li>Требует дисциплины от всей команды</li><li>Не защищает от человеческих ошибок</li><li>Может создавать избыточность в простых случаях</li><li>Сложность работы с динамическими стилями</li></ul><p><strong>Подходит для:</strong> средних и больших проектов с командной разработкой, где важна читаемость и поддержка кода.</p>",
    difficulty: 'junior',
    tags: ['BEM', 'изоляция', 'методология', 'именование']
  },
  {
    id: 20,
    question: "Как изоляция стилей решается в современных фреймворках (Vue, Angular, React)?",
    answer: "<p><strong>Каждый фреймворк предлагает свои решения для изоляции стилей:</strong></p><p><strong>Vue.js:</strong></p><ul><li>Scoped CSS — автоматическое добавление уникальных атрибутов</li><li>CSS Modules — интеграция через vue-loader</li><li>Поддержка препроцессоров с изоляцией</li><li>Глобальные стили через ::v-deep</li></ul><p><strong>Angular:</strong></p><ul><li>ViewEncapsulation.Emulated — эмуляция Shadow DOM</li><li>ViewEncapsulation.ShadowDom — нативный Shadow DOM</li><li>CSS изоляция по умолчанию для каждого компонента</li><li>Глобальные стили через :host и ::ng-deep</li></ul><p><strong>React:</strong></p><ul><li>CSS-in-JS библиотеки (Styled Components, Emotion)</li><li>CSS Modules через настройки сборщика</li><li>Inline styles для простых случаев</li><li>Библиотеки вроде JSS, Stitches</li></ul><p><strong>Общие принципы:</strong></p><ul><li>Компонентная изоляция по умолчанию</li><li>Возможность глобальных стилей при необходимости</li><li>Интеграция с инструментами сборки</li><li>TypeScript поддержка для типизации стилей</li></ul>",
    difficulty: 'middle',
    tags: ['изоляция', 'фреймворки', 'Vue', 'Angular', 'React']
  },
  {
    id: 21,
    question: "Что такое CSS-in-JS и какие преимущества и недостатки у этого подхода для изоляции стилей?",
    answer: "<p><strong>CSS-in-JS</strong> — подход к написанию стилей непосредственно в JavaScript коде, обеспечивающий полную изоляцию на уровне компонентов:</p><p><strong>Преимущества:</strong></p><ul><li>Полная изоляция — стили существуют только в рамках компонента</li><li>Динамические стили — легкое использование переменных и состояния</li><li>Автоматическое удаление неиспользуемых стилей</li><li>TypeScript поддержка и автодополнение</li><li>Темизация и условные стили из коробки</li><li>Отсутствие конфликтов имен классов</li></ul><p><strong>Недостатки:</strong></p><ul><li>Увеличение размера JavaScript bundle</li><li>Runtime обработка может влиять на производительность</li><li>Сложность отладки в DevTools</li><li>Потеря возможности кеширования CSS</li><li>Необходимость изучения новых API</li><li>Сложность интеграции с дизайн-системами</li></ul><p><strong>Популярные решения:</strong></p><ul><li>Styled Components — template literals подход</li><li>Emotion — универсальная библиотека</li><li>JSS — объектный синтаксис</li><li>Stitches — производительный CSS-in-JS</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'изоляция', 'динамические стили', 'производительность']
  },
  {
    id: 22,
    question: "Как работает :host селектор в Web Components и Shadow DOM для изоляции стилей?",
    answer: "<p><strong>:host селектор</strong> — специальный CSS селектор для стилизации хост-элемента в Shadow DOM, обеспечивающий изоляцию на уровне браузера:</p><p><strong>Особенности работы:</strong></p><ul><li>Применяется только к корневому элементу компонента</li><li>Стили изолированы внутри Shadow DOM</li><li>Не влияют на элементы вне компонента</li><li>Могут быть переопределены внешними стилями</li></ul><p><strong>Варианты использования:</strong></p><ul><li>:host — базовые стили хост-элемента</li><li>:host(.class) — стили для определенного класса</li><li>:host([attribute]) — стили для определенного атрибута</li><li>:host-context(.class) — стили на основе внешнего контекста</li></ul><p><strong>Преимущества:</strong></p><ul><li>Полная изоляция стилей на уровне браузера</li><li>Возможность создания настоящих переиспользуемых компонентов</li><li>Защита от внешних CSS конфликтов</li><li>Стандартизированный подход</li></ul><p><strong>Ограничения:</strong></p><ul><li>Поддержка только в современных браузерах</li><li>Сложность кастомизации извне</li><li>Необходимость использования Custom Elements</li><li>Ограниченная гибкость в сравнении с CSS-in-JS</li></ul>",
    difficulty: 'senior',
    tags: ['Web Components', 'Shadow DOM', ':host', 'нативная изоляция']
  },
  {
    id: 23,
    question: "Какие стратегии именования классов помогают в изоляции стилей без использования дополнительных инструментов?",
    answer: "<p><strong>Стратегии именования классов</strong> для изоляции стилей основаны на создании уникальных и предсказуемых имен:</p><p><strong>1. Префиксы компонентов:</strong></p><ul><li>Каждый компонент имеет уникальный префикс</li><li>Все классы начинаются с префикса компонента</li><li>Исключает конфликты между компонентами</li><li>Легко определить принадлежность стилей</li></ul><p><strong>2. Пространства имен:</strong></p><ul><li>Организация классов по модулям или страницам</li><li>Использование составных имен для группировки</li><li>Создание иерархии через имена классов</li></ul><p><strong>3. Функциональное именование:</strong></p><ul><li>Имена отражают назначение, а не внешний вид</li><li>Упрощение рефакторинга и изменений</li><li>Лучшая читаемость и понимание кода</li></ul><p><strong>4. Версионирование классов:</strong></p><ul><li>Добавление версий к именам классов</li><li>Постепенная миграция без конфликтов</li><li>Поддержка legacy кода</li></ul><p><strong>5. Контекстные модификаторы:</strong></p><ul><li>Использование контекста для уточнения стилей</li><li>Создание вариантов без дублирования</li><li>Гибкость в адаптации под разные сценарии</li></ul>",
    difficulty: 'junior',
    tags: ['именование', 'изоляция', 'стратегии', 'префиксы']
  },
  {
    id: 24,
    question: "Как тестировать изоляцию стилей и обеспечивать качество CSS архитектуры?",
    answer: "<p><strong>Тестирование изоляции стилей</strong> включает различные подходы для проверки корректности архитектуры:</p><p><strong>1. Статический анализ:</strong></p><ul><li>CSS линтеры для проверки соблюдения правил</li><li>Анализ специфичности и конфликтов</li><li>Проверка использования глобальных селекторов</li><li>Выявление неиспользуемых стилей</li></ul><p><strong>2. Визуальное тестирование:</strong></p><ul><li>Снепшот тестирование компонентов</li><li>Проверка изоляции через скриншоты</li><li>Регрессионное тестирование стилей</li><li>Тестирование в разных браузерах</li></ul><p><strong>3. Юнит тестирование стилей:</strong></p><ul><li>Проверка генерации уникальных классов</li><li>Тестирование CSS-in-JS функций</li><li>Валидация применения стилей</li></ul><p><strong>4. Интеграционное тестирование:</strong></p><ul><li>Проверка взаимодействия компонентов</li><li>Тестирование наследования стилей</li><li>Проверка работы в составе приложения</li></ul><p><strong>5. Мониторинг качества:</strong></p><ul><li>Метрики размера CSS</li><li>Анализ дублирования стилей</li><li>Отслеживание сложности селекторов</li><li>Аудит производительности</li></ul>",
    difficulty: 'senior',
    tags: ['тестирование', 'изоляция', 'качество', 'архитектура']
  },
  {
    id: 25,
    question: "Как работают селекторы с областью видимости (scoped selectors) в различных технологиях?",
    answer: "<p><strong>Селекторы с областью видимости</strong> ограничивают действие стилей определенными элементами или компонентами:</p><p><strong>1. Встроенные браузерные механизмы:</strong></p><ul><li>Shadow DOM — создает изолированную область видимости</li><li>CSS @scope — новый стандарт для ограничения селекторов</li><li>CSS @layer — управление приоритетом через слои</li></ul><p><strong>2. Фреймворковые решения:</strong></p><ul><li>Vue Scoped CSS — добавляет уникальные атрибуты к элементам</li><li>Angular ViewEncapsulation — эмулирует Shadow DOM</li><li>Svelte — автоматическая изоляция стилей компонентов</li></ul><p><strong>3. Инструменты сборки:</strong></p><ul><li>CSS Modules — генерация уникальных имен классов</li><li>PostCSS plugins — обработка scoped селекторов</li><li>Webpack style-loader — динамическая изоляция</li></ul><p><strong>Преимущества:</strong></p><ul><li>Автоматическая изоляция без изменения архитектуры</li><li>Сохранение привычного CSS синтаксиса</li><li>Предотвращение конфликтов стилей</li><li>Упрощение отладки и поддержки</li></ul><p><strong>Ограничения:</strong></p><ul><li>Сложность работы с глобальными стилями</li><li>Возможные проблемы с производительностью</li><li>Зависимость от инструментов сборки</li></ul>",
    difficulty: 'middle',
    tags: ['scoped selectors', 'изоляция', 'области видимости', 'фреймворки']
  },
  {
    id: 26,
    question: "Как влияет изоляция стилей на производительность и сопровождаемость кода?",
    answer: "<p><strong>Влияние изоляции стилей на производительность и сопровождаемость</strong> имеет как положительные, так и отрицательные аспекты:</p><p><strong>Положительное влияние на сопровождаемость:</strong></p><ul><li>Предсказуемость — легче понять, где и как применяются стили</li><li>Модульность — изменения в одном компоненте не влияют на другие</li><li>Отладка — быстрее найти источник проблем со стилями</li><li>Рефакторинг — безопасное изменение стилей без страха поломать другие части</li><li>Командная работа — разработчики могут работать независимо</li></ul><p><strong>Влияние на производительность:</strong></p><ul><li>CSS-in-JS может увеличивать время выполнения JS</li><li>Дублирование стилей может увеличить размер bundle</li><li>Автоматическая генерация классов может создавать избыточность</li><li>Лучшее tree-shaking неиспользуемых стилей</li><li>Возможность критических CSS путей для компонентов</li></ul><p><strong>Оптимизация:</strong></p><ul><li>Статическая обработка предпочтительнее runtime</li><li>Переиспользование общих стилей через композицию</li><li>Минимизация и сжатие изолированных стилей</li><li>Ленивая загрузка стилей для компонентов</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Выбирать подход исходя из размера проекта</li><li>Измерять влияние на производительность</li><li>Балансировать между изоляцией и эффективностью</li></ul>",
    difficulty: 'senior',
    tags: ['производительность', 'сопровождаемость', 'изоляция', 'оптимизация']
  },

  // Относительные единицы измерения
  {
    id: 27,
    question: "Зачем нужны относительные единицы измерения в CSS?",
    answer: "<p><strong>Относительные единицы</strong> обеспечивают <strong>гибкость и адаптивность</strong> веб-интерфейсов, позволяя элементам масштабироваться в зависимости от контекста.</p><p><strong>Основные преимущества:</strong></p><ul><li><strong>Адаптивность</strong> — элементы автоматически подстраиваются под размер экрана</li><li><strong>Доступность</strong> — уважают пользовательские настройки размера шрифта</li><li><strong>Консистентность</strong> — поддерживают пропорции между элементами</li><li><strong>Масштабируемость</strong> — упрощают создание компонентов разных размеров</li></ul><p><strong>Типичные случаи использования:</strong></p><ul><li>em и rem для размеров шрифтов и отступов</li><li>% для ширины и высоты элементов</li><li>vw/vh для полноэкранных элементов</li><li>fr для гибких сеток в Grid</li></ul><p>Относительные единицы особенно важны в эпоху множества устройств с разными размерами экранов и разрешениями.</p>",
    difficulty: 'junior',
    tags: ['единицы измерения', 'адаптивность', 'доступность']
  },
  {
    id: 28,
    question: "В чем разница между em и rem? Когда использовать каждую из них?",
    answer: "<p><strong>em</strong> и <strong>rem</strong> — это относительные единицы, но они имеют разные точки отсчета:</p><p><strong>em</strong> — относится к размеру шрифта родительского элемента:</p><ul><li>Наследуется по цепочке родителей</li><li>Может создавать каскадное увеличение размеров</li><li>Хорошо для компонентов, которые должны масштабироваться вместе</li></ul><p><strong>rem</strong> — относится к размеру шрифта корневого элемента (html):</p><ul><li>Всегда имеет одну точку отсчета</li><li>Более предсказуемый в использовании</li><li>Упрощает расчеты и поддержку</li></ul><p><strong>Когда использовать:</strong></p><ul><li><strong>em</strong> — для отступов и размеров внутри компонентов, которые должны масштабироваться пропорционально тексту</li><li><strong>rem</strong> — для основных размеров, отступов между секциями, размеров шрифтов</li></ul><p>Многие команды предпочитают rem для большинства случаев из-за его предсказуемости.</p>",
    difficulty: 'junior',
    tags: ['em', 'rem', 'единицы измерения']
  },
  {
    id: 29,
    question: "Объясните viewport единицы (vw, vh, vmin, vmax) и их применение.",
    answer: "<p><strong>Viewport единицы</strong> — это единицы измерения, которые основываются на размерах видимой области браузера:</p><ul><li><strong>vw</strong> (viewport width) — 1% от ширины viewport</li><li><strong>vh</strong> (viewport height) — 1% от высоты viewport</li><li><strong>vmin</strong> — 1% от наименьшего размера viewport</li><li><strong>vmax</strong> — 1% от наибольшего размера viewport</li></ul><p><strong>Практическое применение:</strong></p><ul><li><strong>100vh</strong> — для создания полноэкранных секций</li><li><strong>100vw</strong> — для элементов на всю ширину экрана</li><li><strong>vmin</strong> — для квадратных элементов, которые должны помещаться на экран</li><li><strong>vmax</strong> — для адаптивной типографики</li></ul><p><strong>Особенности и проблемы:</strong></p><ul><li>Проблема с мобильными браузерами и динамическими панелями</li><li>Необходимость учитывать полосы прокрутки</li><li>Возможные проблемы с accessibility при использовании для шрифтов</li></ul><p>Viewport единицы особенно полезны для создания адаптивных макетов без медиа-запросов.</p>",
    difficulty: 'middle',
    tags: ['viewport', 'единицы измерения', 'адаптивность']
  },
  {
    id: 30,
    question: "Как работают проценты (%) в CSS? В каких случаях они высчитываются от разных родительских свойств?",
    answer: "<p><strong>Проценты в CSS</strong> всегда вычисляются относительно родительского элемента, но базовое свойство зависит от контекста:</p><p><strong>Для разных свойств:</strong></p><ul><li><strong>width, left, right</strong> — от ширины родителя</li><li><strong>height, top, bottom</strong> — от высоты родителя</li><li><strong>margin, padding</strong> — всегда от ширины родителя (даже для вертикальных отступов)</li><li><strong>font-size</strong> — от размера шрифта родителя</li><li><strong>line-height</strong> — от размера шрифта текущего элемента</li></ul><p><strong>Особенности:</strong></p><ul><li>Если высота родителя не задана явно, то height: 100% может не работать</li><li>Проценты для margin и padding могут создавать квадратные пропорции</li><li>При абсолютном позиционировании проценты считаются от ближайшего позиционированного предка</li></ul><p>Понимание этих нюансов критически важно для создания предсказуемых макетов.</p>",
    difficulty: 'middle',
    tags: ['проценты', 'единицы измерения', 'родительские элементы']
  },
  {
    id: 31,
    question: "Что такое единицы ch и ex? Когда их стоит использовать?",
    answer: "<p><strong>ch</strong> и <strong>ex</strong> — это типографические единицы, привязанные к характеристикам шрифта:</p><p><strong>ch (character)</strong> — ширина символа '0' в текущем шрифте:</p><ul><li>Полезна для ограничения ширины текста по количеству символов</li><li>Идеальна для создания читабельных колонок текста</li><li>Используется для моноширинных шрифтов</li></ul><p><strong>ex (x-height)</strong> — высота строчной буквы 'x' в текущем шрифте:</p><ul><li>Редко используется на практике</li><li>Может быть полезна для вертикального выравнивания декоративных элементов</li><li>Зависит от конкретного шрифта и может сильно варьироваться</li></ul><p><strong>Практические применения:</strong></p><ul><li><strong>max-width: 60ch</strong> — для ограничения ширины абзацев</li><li><strong>width: 20ch</strong> — для полей ввода с ограничением символов</li><li>Создание адаптивных интерфейсов на основе размера шрифта</li></ul><p>Эти единицы особенно полезны для типографики и создания интерфейсов, ориентированных на текст.</p>",
    difficulty: 'middle',
    tags: ['ch', 'ex', 'типографика', 'единицы измерения']
  },
  {
    id: 32,
    question: "Как работает единица fr в CSS Grid? Чем она отличается от других единиц?",
    answer: "<p><strong>fr (fractional unit)</strong> — это единица измерения, предназначенная специально для CSS Grid, которая представляет долю доступного пространства:</p><p><strong>Принцип работы:</strong></p><ul><li>Распределяет свободное пространство пропорционально между треками</li><li>Вычисляется после размещения элементов с фиксированными размерами</li><li>1fr означает одну долю от оставшегося пространства</li></ul><p><strong>Отличия от других единиц:</strong></p><ul><li><strong>От %</strong> — fr учитывает только свободное пространство, % от общего размера</li><li><strong>От auto</strong> — fr принудительно распределяет пространство, auto подстраивается под контент</li><li><strong>От px</strong> — fr адаптивная, px фиксированная</li></ul><p><strong>Преимущества:</strong></p><ul><li>Автоматическое распределение пространства</li><li>Легкость создания равных колонок</li><li>Возможность комбинирования с другими единицами</li><li>Интуитивно понятный синтаксис</li></ul><p>fr делает CSS Grid мощным инструментом для создания гибких и адаптивных макетов.</p>",
    difficulty: 'middle',
    tags: ['fr', 'CSS Grid', 'единицы измерения']
  },
  {
    id: 33,
    question: "Какие проблемы могут возникнуть при использовании относительных единиц и как их решать?",
    answer: "<p><strong>Основные проблемы с относительными единицами:</strong></p><p><strong>1. Каскадное наследование em:</strong></p><ul><li>Вложенные элементы могут неожиданно увеличиваться</li><li>Сложность в расчетах и отладке</li><li><strong>Решение:</strong> использовать rem или сбрасывать значения на определенных уровнях</li></ul><p><strong>2. Проблемы с viewport единицами на мобильных:</strong></p><ul><li>Динамические панели браузера влияют на размеры</li><li>100vh может не соответствовать видимой области</li><li><strong>Решение:</strong> использовать новые единицы dvh, lvh, svh или JavaScript</li></ul><p><strong>3. Неопределенность процентов:</strong></p><ul><li>Зависимость от размеров родителя</li><li>Цикличные зависимости</li><li><strong>Решение:</strong> четко определять размеры родительских элементов</li></ul><p><strong>4. Проблемы с accessibility:</strong></p><ul><li>Слишком маленький или большой размер шрифта</li><li><strong>Решение:</strong> использовать clamp() для ограничения размеров</li></ul><p>Понимание этих проблем помогает создавать более надежные и предсказуемые интерфейсы.</p>",
    difficulty: 'senior',
    tags: ['проблемы', 'отладка', 'accessibility', 'единицы измерения']
  },
  {
    id: 34,
    question: "Как правильно комбинировать относительные единицы для создания масштабируемых компонентов?",
    answer: "<p><strong>Стратегии комбинирования относительных единиц:</strong></p><p><strong>1. Иерархический подход:</strong></p><ul><li><strong>rem</strong> — для основных размеров и отступов между компонентами</li><li><strong>em</strong> — для внутренних отступов и размеров, связанных с текстом</li><li><strong>%</strong> — для ширины и пропорций</li></ul><p><strong>2. Использование CSS-переменных:</strong></p><ul><li>Определение базовых размеров через переменные</li><li>Создание масштабируемых систем размеров</li><li>Легкое изменение размеров компонентов</li></ul><p><strong>3. Комбинирование с clamp():</strong></p><ul><li>Создание адаптивных размеров с минимальными и максимальными значениями</li><li>Плавное масштабирование между брейкпоинтами</li><li>Контроль над экстремальными размерами</li></ul><p><strong>4. Контекстные единицы:</strong></p><ul><li>ch для компонентов, связанных с текстом</li><li>fr для гибких сеток</li><li>viewport единицы для полноэкранных элементов</li></ul><p><strong>Принципы:</strong></p><ul><li>Консистентность в выборе единиц</li><li>Документирование решений</li><li>Тестирование на разных размерах экранов</li></ul>",
    difficulty: 'senior',
    tags: ['масштабируемость', 'компоненты', 'архитектура', 'единицы измерения']
  },
  {
    id: 35,
    question: "Что такое новые viewport единицы (dvh, lvh, svh) и зачем они нужны?",
    answer: "<p><strong>Новые viewport единицы</strong> решают проблемы с динамическими панелями мобильных браузеров:</p><p><strong>Типы viewport единиц:</strong></p><ul><li><strong>Large Viewport (lv*)</strong> — размер при скрытых динамических панелях</li><li><strong>Small Viewport (sv*)</strong> — размер при видимых динамических панелях</li><li><strong>Dynamic Viewport (dv*)</strong> — автоматически адаптируется к текущему состоянию</li></ul><p><strong>Конкретные единицы:</strong></p><ul><li><strong>dvh, dvw</strong> — динамические высота и ширина</li><li><strong>lvh, lvw</strong> — 'большие' высота и ширина</li><li><strong>svh, svw</strong> — 'малые' высота и ширина</li></ul><p><strong>Проблемы, которые решают:</strong></p><ul><li>Элементы с 100vh на мобильных часто выходят за пределы экрана</li><li>Динамические панели браузера (адресная строка, навигация) влияют на размеры</li><li>Неконсистентное поведение между браузерами</li></ul><p><strong>Применение:</strong></p><ul><li>Полноэкранные секции на мобильных устройствах</li><li>Модальные окна и оверлеи</li><li>Адаптивная типографика</li></ul><p>Поддержка пока ограничена, но это будущее viewport единиц.</p>",
    difficulty: 'senior',
    tags: ['viewport', 'мобильные устройства', 'новые единицы', 'dvh']
  },
  {
    id: 36,
    question: "Как относительные единицы влияют на производительность? Есть ли единицы, которые работают быстрее других?",
    answer: "<p><strong>Влияние относительных единиц на производительность:</strong></p><p><strong>Наиболее производительные:</strong></p><ul><li><strong>px</strong> — не требуют вычислений, прямое значение</li><li><strong>rem</strong> — вычисляются один раз относительно корневого элемента</li><li><strong>%</strong> — простые математические операции</li></ul><p><strong>Менее производительные:</strong></p><ul><li><strong>em</strong> — требуют обхода DOM для поиска родительского размера шрифта</li><li><strong>viewport единицы</strong> — пересчитываются при изменении размеров окна</li><li><strong>ch, ex</strong> — зависят от метрик шрифта</li></ul><p><strong>Факторы, влияющие на производительность:</strong></p><ul><li>Глубина вложенности (для em)</li><li>Частота изменения размеров viewport</li><li>Количество элементов, использующих единицы</li><li>Сложность вычислений (calc(), clamp())</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Использовать px для небольших, фиксированных значений</li><li>Предпочитать rem вместо em для большинства случаев</li><li>Ограничивать использование viewport единиц критическими случаями</li><li>Избегать чрезмерного вложения em</li></ul><p>В современных браузерах различия минимальны, но стоит учитывать при создании высоконагруженных интерфейсов.</p>",
    difficulty: 'senior',
    tags: ['производительность', 'оптимизация', 'единицы измерения']
  },
  {
    id: 37,
    question: "Как использовать функцию clamp() с относительными единицами для создания адаптивных размеров?",
    answer: "<p><strong>Функция clamp()</strong> позволяет создавать адаптивные размеры с минимальными и максимальными ограничениями:</p><p><strong>Синтаксис:</strong></p><ul><li>clamp(минимум, предпочтительное значение, максимум)</li><li>Браузер выберет значение между минимумом и максимумом</li><li>Если предпочтительное значение в диапазоне — используется оно</li></ul><p><strong>Применение с относительными единицами:</strong></p><ul><li><strong>Адаптивная типографика:</strong> размер шрифта изменяется плавно</li><li><strong>Отступы и поля:</strong> масштабируются в зависимости от экрана</li><li><strong>Размеры элементов:</strong> адаптация без медиа-запросов</li></ul><p><strong>Преимущества:</strong></p><ul><li>Отсутствие резких переходов между размерами</li><li>Меньше медиа-запросов</li><li>Автоматическая адаптация к пользовательским настройкам</li><li>Лучшая accessibility</li></ul><p><strong>Практические советы:</strong></p><ul><li>Использовать rem для предсказуемости</li><li>Комбинировать с viewport единицами для отзывчивости</li><li>Тестировать на разных размерах экранов</li><li>Учитывать пользовательские настройки размера шрифта</li></ul><p>clamp() — мощный инструмент для создания действительно адаптивных интерфейсов.</p>",
    difficulty: 'middle',
    tags: ['clamp', 'адаптивность', 'функции CSS', 'единицы измерения']
  },

  // Flexbox vs Grid
  {
    id: 38,
    question: "В каких случаях лучше использовать Flexbox, а в каких — Grid?",
    answer: "<p><strong>Flexbox</strong> лучше использовать для:</p><ul><li><strong>Одномерных раскладок</strong> — когда элементы выстраиваются в ряд или колонку</li><li><strong>Выравнивания элементов</strong> — центрирование, распределение пространства</li><li><strong>Гибких компонентов</strong> — кнопки, навигация, карточки</li><li><strong>Неизвестного количества элементов</strong> — когда контент добавляется динамически</li></ul><p><strong>Grid</strong> лучше использовать для:</p><ul><li><strong>Двумерных раскладок</strong> — когда нужно контролировать и строки, и колонки</li><li><strong>Сложных макетов</strong> — header, sidebar, main, footer</li><li><strong>Точного позиционирования</strong> — когда элементы должны быть в определенных ячейках</li><li><strong>Перекрывающихся элементов</strong> — когда элементы могут занимать одну ячейку</li></ul><p><strong>Можно комбинировать:</strong> Grid для общего макета страницы, Flexbox для компонентов внутри ячеек Grid.</p><p>Основное правило: Flexbox для компонентов, Grid для макетов.</p>",
    difficulty: 'middle',
    tags: ['Flexbox', 'Grid', 'макеты']
  },
  {
    id: 39,
    question: "Опишите основные свойства Flexbox и их назначение.",
    answer: "<p><strong>Flexbox</strong> имеет свойства для <strong>контейнера</strong> (flex container) и <strong>элементов</strong> (flex items):</p><p><strong>Свойства контейнера:</strong></p><ul><li><strong>display: flex</strong> — превращает элемент в flex-контейнер</li><li><strong>flex-direction</strong> — направление основной оси (row, column)</li><li><strong>justify-content</strong> — выравнивание по главной оси</li><li><strong>align-items</strong> — выравнивание по поперечной оси</li><li><strong>flex-wrap</strong> — перенос элементов на новую строку</li><li><strong>gap</strong> — расстояние между элементами</li></ul><p><strong>Свойства элементов:</strong></p><ul><li><strong>flex-grow</strong> — как элемент растет при наличии свободного места</li><li><strong>flex-shrink</strong> — как элемент сжимается при нехватке места</li><li><strong>flex-basis</strong> — начальный размер элемента</li><li><strong>align-self</strong> — индивидуальное выравнивание элемента</li><li><strong>order</strong> — порядок отображения элемента</li></ul><p>Эти свойства позволяют создавать гибкие и адаптивные раскладки с минимальным количеством кода.</p>",
    difficulty: 'middle',
    tags: ['Flexbox', 'свойства', 'раскладка']
  },
  {
    id: 40,
    question: "Как работает Grid Layout и его ключевые концепции?",
    answer: "<p><strong>CSS Grid</strong> — это двумерная система раскладки, основанная на концепции <strong>сетки</strong> из строк и столбцов.</p><p><strong>Ключевые концепции:</strong></p><ul><li><strong>Grid Container</strong> — родительский элемент с display: grid</li><li><strong>Grid Items</strong> — дочерние элементы, размещаемые в сетке</li><li><strong>Grid Lines</strong> — линии, разделяющие сетку</li><li><strong>Grid Tracks</strong> — пространство между двумя соседними линиями</li><li><strong>Grid Areas</strong> — области, состоящие из одной или нескольких ячеек</li></ul><p><strong>Основные свойства:</strong></p><ul><li><strong>grid-template-columns/rows</strong> — определение размеров колонок и строк</li><li><strong>grid-gap</strong> — расстояние между ячейками</li><li><strong>grid-template-areas</strong> — именованные области</li><li><strong>grid-column/row</strong> — размещение элементов в определенных ячейках</li></ul><p><strong>Преимущества:</strong></p><ul><li>Простота создания сложных макетов</li><li>Встроенная поддержка выравнивания</li><li>Возможность создания адаптивных сеток без медиа-запросов</li></ul>",
    difficulty: 'middle',
    tags: ['Grid', 'концепции', 'раскладка']
  },
  {
    id: 41,
    question: "Как центрировать элемент с помощью Flexbox и Grid? Какой способ лучше?",
    answer: "<p><strong>Flexbox центрирование:</strong></p><ul><li>justify-content: center — по горизонтали</li><li>align-items: center — по вертикали</li><li>Или place-items: center для обеих осей</li></ul><p><strong>Grid центрирование:</strong></p><ul><li>place-items: center — центрирует содержимое в ячейке</li><li>justify-self: center и align-self: center — для отдельного элемента</li></ul><p><strong>Выбор метода:</strong></p><ul><li><strong>Flexbox</strong> — лучше для центрирования в одномерном контексте</li><li><strong>Grid</strong> — удобнее когда нужно центрировать в двумерной раскладке</li><li>Для простого центрирования одного элемента подойдут оба метода</li></ul><p>Grid имеет преимущество в том, что place-items: center работает сразу для обеих осей.</p>",
    difficulty: 'middle',
    tags: ['Flexbox', 'Grid', 'центрирование']
  },
  {
    id: 42,
    question: "Что такое fr единица в Grid и есть ли аналог в Flexbox?",
    answer: "<p><strong>fr (fractional unit)</strong> — единица измерения в Grid, которая представляет долю доступного пространства.</p><p><strong>Как работает fr:</strong></p><ul><li>1fr = одна доля от свободного пространства</li><li>2fr = две доли (в два раза больше места)</li><li>Вычисляется после фиксированных размеров</li></ul><p><strong>Аналог в Flexbox:</strong></p><ul><li><strong>flex-grow</strong> — работает похоже на fr</li><li>flex: 1 ≈ 1fr (растет пропорционально)</li><li>flex: 2 ≈ 2fr (получает в два раза больше места)</li></ul><p><strong>Отличия:</strong></p><ul><li>fr работает для определения размеров треков в Grid</li><li>flex-grow работает для распределения свободного места между элементами</li><li>fr более явная и предсказуемая единица</li></ul>",
    difficulty: 'middle',
    tags: ['Grid', 'fr', 'Flexbox', 'единицы']
  },
  {
    id: 43,
    question: "Как решить проблему равных высот колонок в Flexbox и Grid?",
    answer: "<p><strong>В Flexbox:</strong></p><ul><li>По умолчанию все элементы имеют одинаковую высоту (align-items: stretch)</li><li>Flex-элементы растягиваются до высоты самого высокого элемента</li><li>Работает автоматически без дополнительных настроек</li></ul><p><strong>В Grid:</strong></p><ul><li>Элементы в одной строке автоматически имеют одинаковую высоту</li><li>Высота строки определяется самым высоким элементом</li><li>Можно использовать align-items: stretch для явного растягивания</li></ul><p><strong>Исторический контекст:</strong></p><ul><li>До Flexbox/Grid использовались хаки с table-cell, float + negative margins</li><li>JavaScript для вычисления максимальной высоты</li><li>Flexbox решил эту проблему элегантно</li></ul><p>Оба метода решают проблему равных высот, Flexbox даже проще в использовании.</p>",
    difficulty: 'middle',
    tags: ['Flexbox', 'Grid', 'равные высоты']
  },
  {
    id: 44,
    question: "Когда следует использовать auto-fit и auto-fill в Grid?",
    answer: "<p><strong>auto-fit</strong> и <strong>auto-fill</strong> — функции для создания адаптивных сеток с minmax().</p><p><strong>auto-fill:</strong></p><ul><li>Создает столько колонок, сколько поместится</li><li>Пустые колонки остаются и занимают место</li><li>Элементы не растягиваются на всю ширину</li></ul><p><strong>auto-fit:</strong></p><ul><li>Создает столько колонок, сколько нужно для элементов</li><li>Пустые колонки схлопываются</li><li>Элементы растягиваются на всю доступную ширину</li></ul><p><strong>Применение:</strong></p><ul><li><strong>auto-fill</strong> — когда нужно сохранить постоянную ширину элементов</li><li><strong>auto-fit</strong> — когда элементы должны заполнить всю ширину контейнера</li></ul><p><strong>Аналог в Flexbox:</strong></p><ul><li>flex-wrap: wrap с flex-basis создает похожий эффект</li><li>Но нет такого точного контроля над количеством колонок</li></ul>",
    difficulty: 'senior',
    tags: ['Grid', 'auto-fit', 'auto-fill', 'адаптивность']
  },
  {
    id: 45,
    question: "Как создать липкий footer с помощью Flexbox и Grid?",
    answer: "<p><strong>Flexbox подход:</strong></p><ul><li>Контейнер: display: flex, flex-direction: column, min-height: 100vh</li><li>Main контент: flex: 1 (растет и занимает свободное место)</li><li>Footer остается внизу независимо от количества контента</li></ul><p><strong>Grid подход:</strong></p><ul><li>Контейнер: display: grid, grid-template-rows: auto 1fr auto, min-height: 100vh</li><li>Header: занимает первую строку (auto)</li><li>Main: занимает вторую строку (1fr — все свободное место)</li><li>Footer: занимает третью строку (auto)</li></ul><p><strong>Сравнение:</strong></p><ul><li><strong>Flexbox</strong> — проще для понимания, меньше кода</li><li><strong>Grid</strong> — более декларативный, явно определяет структуру</li><li>Оба решения работают одинаково хорошо</li></ul><p>Выбор зависит от остального макета: если используется Grid для страницы, логично продолжить с Grid.</p>",
    difficulty: 'middle',
    tags: ['Flexbox', 'Grid', 'липкий footer', 'макет']
  },
  {
    id: 46,
    question: "Что такое subgrid и как он соотносится с Flexbox?",
    answer: "<p><strong>Subgrid</strong> — возможность вложенного Grid-элемента наследовать сетку родителя.</p><p><strong>Как работает subgrid:</strong></p><ul><li>Дочерний grid наследует треки родительского grid</li><li>Позволяет выравнивать элементы через несколько уровней вложенности</li><li>Решает проблему выравнивания в карточках и сложных макетах</li></ul><p><strong>Поддержка браузеров:</strong></p><ul><li>Firefox поддерживает полностью</li><li>Chrome/Safari — частичная поддержка</li><li>Новая технология, постепенно внедряется</li></ul><p><strong>Аналог в Flexbox:</strong></p><ul><li>Нет прямого аналога subgrid</li><li>Вложенные flex-контейнеры работают независимо</li><li>Сложнее выравнивать элементы через несколько уровней</li></ul><p><strong>Применение:</strong></p><ul><li>Карточки с выравниванием заголовков и кнопок</li><li>Сложные формы с выравниванием полей</li><li>Таблицы с вложенными элементами</li></ul>",
    difficulty: 'senior',
    tags: ['Grid', 'subgrid', 'Flexbox', 'вложенность']
  },
  {
    id: 47,
    question: "Как обрабатывать переполнение контента в Flexbox и Grid?",
    answer: "<p><strong>В Flexbox:</strong></p><ul><li><strong>flex-shrink</strong> — контролирует сжатие элементов</li><li><strong>flex-wrap: wrap</strong> — перенос на новую строку</li><li><strong>overflow: hidden/scroll</strong> — обрезка или прокрутка</li><li><strong>min-width: 0</strong> — позволяет элементам сжиматься меньше контента</li></ul><p><strong>В Grid:</strong></p><ul><li><strong>minmax(0, 1fr)</strong> — позволяет ячейкам сжиматься</li><li><strong>auto-fit/auto-fill</strong> — автоматический перенос</li><li><strong>grid-auto-flow: dense</strong> — плотная упаковка</li><li><strong>overflow: auto</strong> на отдельных ячейках</li></ul><p><strong>Общие проблемы:</strong></p><ul><li>Flexbox по умолчанию не сжимает элементы меньше их контента</li><li>Grid может создавать неожиданные переполнения</li><li>Длинные слова без пробелов вызывают переполнение</li></ul><p><strong>Решения:</strong></p><ul><li>word-break: break-word для текста</li><li>overflow-wrap: break-word</li><li>Комбинация min-width: 0 и overflow</li></ul>",
    difficulty: 'senior',
    tags: ['Flexbox', 'Grid', 'переполнение', 'overflow']
  },
  {
    id: 48,
    question: "Как создать адаптивную раскладку без медиа-запросов в Flexbox и Grid?",
    answer: "<p><strong>Flexbox подходы:</strong></p><ul><li><strong>flex-wrap: wrap</strong> — автоматический перенос</li><li><strong>flex-basis</strong> с процентами или calc()</li><li><strong>flex-grow/flex-shrink</strong> для адаптивности</li><li>Комбинация flex: 1 1 300px (растет, сжимается, минимум 300px)</li></ul><p><strong>Grid подходы:</strong></p><ul><li><strong>auto-fit/auto-fill</strong> с minmax()</li><li><strong>repeat(auto-fit, minmax(250px, 1fr))</strong></li><li><strong>fr единицы</strong> для пропорциональности</li><li><strong>Именованные области</strong> с grid-template-areas</li></ul><p><strong>Современные техники:</strong></p><ul><li>Container queries (новая возможность)</li><li>clamp() для адаптивных размеров</li><li>Комбинация vw/vh единиц</li></ul><p><strong>Преимущества:</strong></p><ul><li>Меньше кода для поддержки</li><li>Естественная адаптивность</li><li>Меньше точек переключения</li></ul><p>Grid обычно предоставляет больше возможностей для адаптивности без медиа-запросов.</p>",
    difficulty: 'senior',
    tags: ['Flexbox', 'Grid', 'адаптивность', 'медиа-запросы']
  },
  {
    id: 49,
    question: "Какие проблемы производительности могут возникнуть с Flexbox и Grid?",
    answer: "<p><strong>Проблемы с Flexbox:</strong></p><ul><li><strong>Глубокая вложенность</strong> — множество вложенных flex-контейнеров</li><li><strong>Частые пересчеты</strong> — изменение flex-grow/shrink</li><li><strong>Большое количество элементов</strong> — сложные вычисления для каждого</li><li><strong>Автоматические размеры</strong> — браузер должен измерить каждый элемент</li></ul><p><strong>Проблемы с Grid:</strong></p><ul><li><strong>Сложные сетки</strong> — много строк и колонок</li><li><strong>Частые изменения grid-template</strong></li><li><strong>Overlap элементов</strong> — дополнительные вычисления</li><li><strong>Implicit grid</strong> — неявные треки создаются динамически</li></ul><p><strong>Оптимизация:</strong></p><ul><li>Избегать излишней вложенности</li><li>Использовать фиксированные размеры где возможно</li><li>Минимизировать изменения layout во время анимаций</li><li>Использовать will-change для сложных трансформаций</li></ul><p><strong>Сравнение:</strong></p><ul><li>Grid обычно быстрее для сложных макетов</li><li>Flexbox может быть медленнее при большом количестве элементов</li></ul>",
    difficulty: 'senior',
    tags: ['Flexbox', 'Grid', 'производительность', 'оптимизация']
  },
  {
    id: 50,
    question: "Как решить проблему z-index в контексте Flexbox и Grid?",
    answer: "<p><strong>Особенности stacking context:</strong></p><ul><li>Flexbox и Grid создают новый stacking context</li><li>z-index работает только внутри одного stacking context</li><li>Элементы сравниваются по z-index их контейнеров</li></ul><p><strong>Проблемы в Flexbox:</strong></p><ul><li>Flex-элементы могут создавать собственные stacking contexts</li><li>order влияет на порядок отрисовки</li><li>Элементы с transform создают новый context</li></ul><p><strong>Проблемы в Grid:</strong></p><ul><li>Grid-элементы могут перекрываться в одной ячейке</li><li>Порядок в DOM влияет на отрисовку</li><li>Негативные z-index могут работать неожиданно</li></ul><p><strong>Решения:</strong></p><ul><li>Использовать z-index на уровне контейнера</li><li>Понимать иерархию stacking contexts</li><li>Использовать isolation: isolate для создания нового контекста</li><li>Планировать структуру с учетом наложений</li></ul><p><strong>Отладка:</strong></p><ul><li>Инспектор браузера показывает stacking contexts</li><li>Временно добавить outline для визуализации</li></ul>",
    difficulty: 'senior',
    tags: ['Flexbox', 'Grid', 'z-index', 'stacking context']
  },
  {
    id: 51,
    question: "Как Flexbox и Grid ведут себя с direction: rtl?",
    answer: "<p><strong>Flexbox с RTL:</strong></p><ul><li><strong>flex-direction: row</strong> — элементы идут справа налево</li><li><strong>justify-content: flex-start</strong> — выравнивание к правому краю</li><li><strong>margin-left: auto</strong> — становится margin-right: auto</li><li>Логические свойства работают правильно</li></ul><p><strong>Grid с RTL:</strong></p><ul><li><strong>grid-template-columns</strong> — колонки нумеруются справа налево</li><li><strong>grid-column: 1</strong> — первая колонка справа</li><li><strong>justify-items: start</strong> — выравнивание к правому краю</li><li>Именованные области отражаются зеркально</li></ul><p><strong>Лучшие практики:</strong></p><ul><li>Использовать <strong>логические свойства</strong>: margin-inline-start вместо margin-left</li><li>justify-content: start вместо flex-start</li><li>Тестировать интерфейс в RTL режиме</li><li>Использовать CSS Logical Properties</li></ul><p><strong>Проблемы:</strong></p><ul><li>Иконки и изображения могут требовать отдельной обработки</li><li>Анимации могут работать неожиданно</li><li>Некоторые браузеры имеют баги с RTL</li></ul>",
    difficulty: 'senior',
    tags: ['Flexbox', 'Grid', 'RTL', 'интернационализация']
  },
  {
    id: 52,
    question: "Как выбрать между Flexbox и Grid для мобильных устройств?",
    answer: "<p><strong>Соображения для мобильных:</strong></p><ul><li><strong>Производительность</strong> — Grid может быть быстрее для сложных макетов</li><li><strong>Размер экрана</strong> — чаще используются одномерные раскладки</li><li><strong>Touch интерфейс</strong> — важна простота взаимодействия</li><li><strong>Контент-ориентированность</strong> — мобильные макеты часто вертикальные</li></ul><p><strong>Flexbox преимущества:</strong></p><ul><li>Отлично для вертикальных списков</li><li>Простое выравнивание элементов</li><li>Естественная адаптивность</li><li>Меньше кода для простых раскладок</li></ul><p><strong>Grid преимущества:</strong></p><ul><li>Лучше для сложных карточных интерфейсов</li><li>Точный контроль над размещением</li><li>Меньше вложенности</li><li>Лучше для landscape ориентации</li></ul><p><strong>Рекомендации:</strong></p><ul><li><strong>Flexbox</strong> — для навигации, списков, простых компонентов</li><li><strong>Grid</strong> — для макетов страниц, сложных интерфейсов</li><li>Комбинировать оба подхода</li><li>Тестировать на реальных устройствах</li></ul>",
    difficulty: 'middle',
    tags: ['Flexbox', 'Grid', 'мобильные', 'производительность']
  },

  // Трансформации и анимации
  {
    id: 53,
    question: "Какие виды трансформаций доступны в CSS?",
    answer: "<p><strong>CSS трансформации</strong> позволяют изменять положение, размер и форму элементов без влияния на поток документа.</p><p><strong>Основные виды трансформаций:</strong></p><ul><li><strong>translate()</strong> — перемещение элемента по осям X и Y</li><li><strong>scale()</strong> — масштабирование элемента</li><li><strong>rotate()</strong> — поворот элемента на заданный угол</li><li><strong>skew()</strong> — искажение элемента по осям</li></ul><p><strong>3D трансформации:</strong></p><ul><li><strong>translateZ()</strong> — перемещение по оси Z</li><li><strong>rotateX(), rotateY(), rotateZ()</strong> — поворот в 3D пространстве</li><li><strong>scaleZ()</strong> — масштабирование по оси Z</li></ul><p><strong>Комбинированные функции:</strong></p><ul><li><strong>translate3d()</strong> — перемещение в 3D</li><li><strong>matrix()</strong> — комплексные трансформации через матрицу</li></ul><p>Трансформации часто используются для создания анимаций, интерактивных эффектов и адаптивных интерфейсов.</p>",
    difficulty: 'junior',
    tags: ['трансформации', 'анимации', 'effects']
  },
  {
    id: 54,
    question: "Какие CSS-свойства можно эффективно анимировать?",
    answer: "<p>Для <strong>плавных анимаций</strong> важно понимать, какие свойства можно анимировать без потери производительности:</p><p><strong>Наиболее эффективные (не вызывают reflow/repaint):</strong></p><ul><li><strong>transform</strong> — все виды трансформаций</li><li><strong>opacity</strong> — прозрачность элемента</li><li><strong>filter</strong> — фильтры (blur, brightness и т.д.)</li></ul><p><strong>Менее эффективные (вызывают repaint):</strong></p><ul><li><strong>color, background-color</strong> — цвета</li><li><strong>border-color</strong> — цвет границ</li><li><strong>box-shadow</strong> — тени</li></ul><p><strong>Неэффективные (вызывают reflow):</strong></p><ul><li><strong>width, height</strong> — размеры</li><li><strong>margin, padding</strong> — отступы</li><li><strong>top, left, right, bottom</strong> — позиционирование</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Используйте transform вместо изменения позиции</li><li>Применяйте will-change для подготовки к анимации</li><li>Тестируйте производительность на слабых устройствах</li></ul>",
    difficulty: 'middle',
    tags: ['анимации', 'производительность', 'оптимизация']
  },
  {
    id: 55,
    question: "Как работает аппаратное ускорение в CSS анимациях?",
    answer: "<p><strong>Аппаратное ускорение</strong> — это использование GPU для обработки визуальных эффектов вместо CPU, что значительно повышает производительность анимаций.</p><p><strong>Как активировать:</strong></p><ul><li><strong>transform: translateZ(0)</strong> — создание композитного слоя</li><li><strong>will-change</strong> — указание браузеру на предстоящие изменения</li><li><strong>3D трансформации</strong> — любые 3D функции автоматически активируют GPU</li><li><strong>opacity</strong> — изменение прозрачности использует GPU</li></ul><p><strong>Преимущества:</strong></p><ul><li>Плавные анимации с частотой 60 FPS</li><li>Освобождение CPU для других задач</li><li>Лучшая производительность на мобильных устройствах</li></ul><p><strong>Возможные проблемы:</strong></p><ul><li>Увеличение потребления памяти</li><li>Возможные артефакты рендеринга</li><li>Не все устройства имеют мощный GPU</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Использовать аппаратное ускорение для критичных анимаций</li><li>Удалять will-change после завершения анимации</li><li>Тестировать на разных устройствах</li></ul>",
    difficulty: 'senior',
    tags: ['аппаратное ускорение', 'GPU', 'производительность']
  },
  {
    id: 56,
    question: "Чем отличается transform от изменения позиции через top/left?",
    answer: "<p><strong>Transform</strong> и <strong>позиционирование</strong> через top/left принципиально по-разному влияют на рендеринг:</p><p><strong>Transform:</strong></p><ul><li>Не влияет на поток документа</li><li>Создает новый контекст наложения</li><li>Использует аппаратное ускорение</li><li>Не вызывает reflow/repaint соседних элементов</li><li>Работает быстрее для анимаций</li></ul><p><strong>Top/Left:</strong></p><ul><li>Изменяет позицию в потоке документа</li><li>Может вызывать reflow всей страницы</li><li>Влияет на расположение соседних элементов</li><li>Менее производительно для анимаций</li><li>Работает только с positioned элементами</li></ul><p><strong>Когда использовать transform:</strong></p><ul><li>Для анимаций и интерактивных эффектов</li><li>Когда нужна высокая производительность</li><li>Для временных изменений позиции</li></ul><p><strong>Когда использовать top/left:</strong></p><ul><li>Для статичного позиционирования</li><li>Когда нужно влиять на поток документа</li><li>Для точного позиционирования элементов</li></ul>",
    difficulty: 'middle',
    tags: ['трансформации', 'позиционирование', 'производительность']
  },
  {
    id: 57,
    question: "Как работает CSS-свойство will-change и зачем оно нужно?",
    answer: "<p><strong>Will-change</strong> — это CSS-свойство, которое информирует браузер о предстоящих изменениях элемента, позволяя ему подготовиться к оптимизации.</p><p><strong>Принцип работы:</strong></p><ul><li>Создает композитный слой заранее</li><li>Активирует аппаратное ускорение</li><li>Оптимизирует память и рендеринг</li><li>Предотвращает дорогие операции во время анимации</li></ul><p><strong>Основные значения:</strong></p><ul><li><strong>auto</strong> — браузер сам решает</li><li><strong>scroll-position</strong> — для скроллинга</li><li><strong>contents</strong> — для изменения содержимого</li><li><strong>transform</strong> — для трансформаций</li><li><strong>opacity</strong> — для изменения прозрачности</li></ul><p><strong>Правила использования:</strong></p><ul><li>Применять перед началом анимации</li><li>Удалять после завершения анимации</li><li>Не использовать постоянно на всех элементах</li><li>Тестировать влияние на производительность</li></ul><p><strong>Побочные эффекты:</strong></p><ul><li>Увеличение потребления памяти</li><li>Возможные проблемы с z-index</li><li>Влияние на текстовый рендеринг</li></ul>",
    difficulty: 'middle',
    tags: ['оптимизация', 'аппаратное ускорение', 'производительность']
  },
  {
    id: 58,
    question: "Что такое композитные слои и как они влияют на производительность?",
    answer: "<p><strong>Композитные слои</strong> — это отдельные слои рендеринга, которые обрабатываются GPU независимо от основного потока браузера.</p><p><strong>Как создаются:</strong></p><ul><li>3D трансформации (translateZ, rotateX и т.д.)</li><li>Элементы с opacity < 1 и трансформациями</li><li>Элементы с will-change</li><li>Видео с аппаратным декодированием</li><li>Canvas с 3D контекстом</li></ul><p><strong>Преимущества:</strong></p><ul><li>Независимая обработка GPU</li><li>Не блокируют основной поток</li><li>Плавные анимации 60 FPS</li><li>Изоляция от других элементов</li></ul><p><strong>Недостатки:</strong></p><ul><li>Увеличение потребления памяти</li><li>Дополнительные затраты на создание</li><li>Возможные проблемы с отрисовкой текста</li><li>Сложность отладки</li></ul><p><strong>Как контролировать:</strong></p><ul><li>Использовать DevTools для мониторинга слоев</li><li>Применять will-change осознанно</li><li>Удалять свойства после анимации</li><li>Тестировать на слабых устройствах</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Не создавать слои без необходимости</li><li>Группировать анимированные элементы</li><li>Использовать transform3d(0,0,0) для принудительного создания слоя</li></ul>",
    difficulty: 'senior',
    tags: ['композитные слои', 'GPU', 'производительность']
  },
  {
    id: 59,
    question: "Какие есть техники для создания плавных анимаций?",
    answer: "<p>Для создания <strong>плавных анимаций</strong> важно учитывать множество факторов от выбора свойств до оптимизации производительности.</p><p><strong>Выбор правильных свойств:</strong></p><ul><li>Анимировать только transform и opacity</li><li>Избегать анимации layout-свойств</li><li>Использовать translate вместо left/top</li><li>Применять scale вместо width/height</li></ul><p><strong>Оптимизация производительности:</strong></p><ul><li>Включать аппаратное ускорение</li><li>Использовать will-change перед анимацией</li><li>Применять transform3d для создания слоев</li><li>Удалять will-change после анимации</li></ul><p><strong>Настройка timing-функций:</strong></p><ul><li>Использовать ease-out для входящих элементов</li><li>Применять ease-in для исходящих элементов</li><li>Создавать кастомные cubic-bezier кривые</li><li>Избегать linear для естественности</li></ul><p><strong>Работа с FPS:</strong></p><ul><li>Стремиться к 60 FPS</li><li>Тестировать на слабых устройствах</li><li>Использовать DevTools для мониторинга</li><li>Оптимизировать длительность анимаций</li></ul><p><strong>Дополнительные техники:</strong></p><ul><li>Использовать requestAnimationFrame для JS-анимаций</li><li>Применять contain для изоляции</li><li>Группировать анимации по времени</li></ul>",
    difficulty: 'middle',
    tags: ['анимации', 'производительность', 'оптимизация']
  },
  {
    id: 60,
    question: "Как работает CSS-свойство transform-origin и зачем оно нужно?",
    answer: "<p><strong>Transform-origin</strong> определяет точку, относительно которой применяются трансформации элемента.</p><p><strong>Синтаксис:</strong></p><ul><li>Два значения: X и Y координаты</li><li>Три значения: X, Y и Z координаты</li><li>Может быть в пикселях, процентах или ключевых словах</li></ul><p><strong>Ключевые слова:</strong></p><ul><li><strong>center</strong> — центр элемента (по умолчанию)</li><li><strong>top, bottom</strong> — верх/низ элемента</li><li><strong>left, right</strong> — лево/право элемента</li><li><strong>top left, bottom right</strong> — комбинации</li></ul><p><strong>Влияние на трансформации:</strong></p><ul><li><strong>rotate()</strong> — точка вращения</li><li><strong>scale()</strong> — точка масштабирования</li><li><strong>skew()</strong> — точка искажения</li><li>Не влияет на translate()</li></ul><p><strong>Практические применения:</strong></p><ul><li>Вращение элементов вокруг угла</li><li>Масштабирование от определенной точки</li><li>Создание эффектов раскрытия</li><li>Анимации появления/исчезания</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Использовать проценты для адаптивности</li><li>Учитывать влияние на дочерние элементы</li><li>Тестировать на разных размерах экрана</li></ul>",
    difficulty: 'junior',
    tags: ['трансформации', 'transform-origin', 'анимации']
  },
  {
    id: 61,
    question: "Какие проблемы могут возникнуть при использовании трансформаций?",
    answer: "<p>При работе с <strong>трансформациями</strong> могут возникать различные проблемы, которые важно знать и уметь решать.</p><p><strong>Проблемы с отрисовкой:</strong></p><ul><li><strong>Размытый текст</strong> — из-за субпиксельных значений</li><li><strong>Артефакты рендеринга</strong> — неточности GPU</li><li><strong>Проблемы с границами</strong> — искажения border</li><li><strong>Некорректные тени</strong> — смещение box-shadow</li></ul><p><strong>Проблемы с производительностью:</strong></p><ul><li><strong>Избыточное потребление памяти</strong> — множество композитных слоев</li><li><strong>Медленная работа на слабых устройствах</strong></li><li><strong>Блокировка основного потока</strong> — неэффективные анимации</li></ul><p><strong>Проблемы с поведением:</strong></p><ul><li><strong>Нарушение z-index</strong> — создание новых контекстов</li><li><strong>Неработающие события</strong> — смещение областей клика</li><li><strong>Проблемы с доступностью</strong> — анимации для людей с ограничениями</li></ul><p><strong>Решения:</strong></p><ul><li>Использовать backface-visibility: hidden</li><li>Применять transform3d(0,0,0) для четкости</li><li>Добавлять prefers-reduced-motion медиа-запросы</li><li>Тестировать на разных устройствах</li><li>Мониторить производительность через DevTools</li></ul>",
    difficulty: 'senior',
    tags: ['трансформации', 'проблемы', 'отладка']
  },
  {
    id: 62,
    question: "Как правильно использовать 3D трансформации в CSS?",
    answer: "<p><strong>3D трансформации</strong> позволяют создавать объемные эффекты и сложные анимации в браузере.</p><p><strong>Основные 3D функции:</strong></p><ul><li><strong>translateZ()</strong> — перемещение по оси Z</li><li><strong>rotateX(), rotateY(), rotateZ()</strong> — вращение в 3D</li><li><strong>scaleZ()</strong> — масштабирование по глубине</li><li><strong>perspective()</strong> — задание перспективы</li></ul><p><strong>Настройка 3D контекста:</strong></p><ul><li><strong>transform-style: preserve-3d</strong> — сохранение 3D для дочерних элементов</li><li><strong>perspective</strong> — расстояние до точки наблюдения</li><li><strong>perspective-origin</strong> — точка наблюдения</li><li><strong>backface-visibility</strong> — видимость обратной стороны</li></ul><p><strong>Рекомендации по использованию:</strong></p><ul><li>Устанавливать perspective на родительском элементе</li><li>Использовать preserve-3d для вложенных 3D элементов</li><li>Применять backface-visibility: hidden для оптимизации</li><li>Тестировать на мобильных устройствах</li></ul><p><strong>Типичные применения:</strong></p><ul><li>Карточки с переворотом</li><li>3D карусели и галереи</li><li>Эффекты параллакса</li><li>Интерактивные 3D объекты</li></ul><p><strong>Ограничения:</strong></p><ul><li>Высокое потребление ресурсов</li><li>Не все браузеры поддерживают одинаково</li><li>Сложность отладки</li></ul>",
    difficulty: 'middle',
    tags: ['3D трансформации', 'perspective', 'анимации']
  },
  {
    id: 63,
    question: "Что такое reflow и repaint, и как трансформации их избегают?",
    answer: "<p><strong>Reflow</strong> и <strong>repaint</strong> — это дорогие операции браузера, которые влияют на производительность отрисовки страницы.</p><p><strong>Reflow (Layout):</strong></p><ul><li>Пересчет геометрии элементов</li><li>Происходит при изменении размеров, позиции</li><li>Затрагивает соседние элементы</li><li>Самая дорогая операция</li></ul><p><strong>Repaint:</strong></p><ul><li>Перерисовка элементов без изменения геометрии</li><li>Происходит при изменении цвета, фона</li><li>Менее дорогая операция</li><li>Не влияет на соседние элементы</li></ul><p><strong>Как трансформации избегают reflow/repaint:</strong></p><ul><li>Создают композитный слой</li><li>Обрабатываются GPU отдельно</li><li>Не влияют на поток документа</li><li>Изменения происходят на уровне композитинга</li></ul><p><strong>Свойства вызывающие reflow:</strong></p><ul><li>width, height, margin, padding</li><li>top, left, right, bottom</li><li>border, display, position</li></ul><p><strong>Свойства вызывающие только repaint:</strong></p><ul><li>color, background-color</li><li>border-color, outline</li><li>box-shadow, border-radius</li></ul><p><strong>Оптимальные свойства для анимаций:</strong></p><ul><li>transform — создает композитный слой</li><li>opacity — обрабатывается GPU</li><li>filter — использует аппаратное ускорение</li></ul>",
    difficulty: 'senior',
    tags: ['reflow', 'repaint', 'производительность']
  },
  {
    id: 64,
    question: "Как использовать CSS-переменные в трансформациях и анимациях?",
    answer: "<p><strong>CSS-переменные</strong> (кастомные свойства) значительно упрощают создание и управление трансформациями и анимациями.</p><p><strong>Преимущества использования:</strong></p><ul><li>Централизованное управление значениями</li><li>Возможность изменения через JavaScript</li><li>Упрощение сложных анимаций</li><li>Лучшая читаемость кода</li><li>Возможность создания тем</li></ul><p><strong>Применение в трансформациях:</strong></p><ul><li>Создание переменных для углов поворота</li><li>Использование переменных для масштабирования</li><li>Управление перемещением элементов</li><li>Динамическое изменение transform-origin</li></ul><p><strong>Применение в анимациях:</strong></p><ul><li>Управление длительностью анимаций</li><li>Создание переменных для timing-функций</li><li>Централизованное управление задержками</li><li>Создание адаптивных анимаций</li></ul><p><strong>Интерактивность через JavaScript:</strong></p><ul><li>Изменение переменных в реальном времени</li><li>Создание анимаций на основе пользовательского ввода</li><li>Управление анимациями через события</li><li>Адаптация под размер экрана</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Использовать осмысленные имена переменных</li><li>Группировать связанные переменные</li><li>Устанавливать значения по умолчанию</li><li>Тестировать поддержку в браузерах</li></ul>",
    difficulty: 'middle',
    tags: ['CSS переменные', 'трансформации', 'анимации']
  },
  {
    id: 65,
    question: "Как тестировать и отлаживать производительность анимаций?",
    answer: "<p>Тестирование и отладка производительности анимаций — критически важный процесс для создания качественных веб-интерфейсов.</p><p><strong>Инструменты браузера:</strong></p><ul><li><strong>DevTools Performance tab</strong> — анализ производительности</li><li><strong>Rendering tab</strong> — визуализация слоев и FPS</li><li><strong>Layers panel</strong> — просмотр композитных слоев</li><li><strong>Paint flashing</strong> — подсветка перерисовываемых областей</li></ul><p><strong>Ключевые метрики:</strong></p><ul><li><strong>FPS (Frames Per Second)</strong> — частота кадров</li><li><strong>Frame time</strong> — время на отрисовку кадра</li><li><strong>CPU usage</strong> — загрузка процессора</li><li><strong>Memory usage</strong> — потребление памяти</li></ul><p><strong>Методы тестирования:</strong></p><ul><li>Тестирование на разных устройствах</li><li>Проверка в режиме замедления CPU</li><li>Тестирование с ограниченной пропускной способностью</li><li>Проверка на мобильных устройствах</li></ul><p><strong>Признаки проблем:</strong></p><ul><li>FPS ниже 60 кадров в секунду</li><li>Длительные фреймы (>16.67ms)</li><li>Высокое потребление CPU/GPU</li><li>Рывки и подтормаживания</li></ul><p><strong>Способы оптимизации:</strong></p><ul><li>Использование will-change перед анимацией</li><li>Минимизация количества анимируемых элементов</li><li>Применение transform вместо изменения layout</li><li>Группировка анимаций по времени</li></ul>",
    difficulty: 'senior',
    tags: ['тестирование', 'отладка', 'производительность']
  },
  {
    id: 66,
    question: "Как создавать адаптивные анимации для разных устройств?",
    answer: "<p>Создание <strong>адаптивных анимаций</strong> требует учета различий в производительности устройств и предпочтений пользователей.</p><p><strong>Медиа-запросы для анимаций:</strong></p><ul><li><strong>prefers-reduced-motion</strong> — уважение к предпочтениям пользователя</li><li><strong>hover</strong> — проверка поддержки наведения</li><li><strong>pointer</strong> — определение типа указателя</li><li><strong>resolution</strong> — адаптация под плотность пикселей</li></ul><p><strong>Оптимизация для мобильных:</strong></p><ul><li>Упрощение сложных анимаций</li><li>Сокращение длительности анимаций</li><li>Использование менее ресурсоемких эффектов</li><li>Тестирование на реальных устройствах</li></ul><p><strong>Адаптивные значения:</strong></p><ul><li>Использование vw/vh для масштабирования</li><li>Применение CSS-переменных для разных брейкпоинтов</li><li>Создание пропорциональных анимаций</li><li>Учет размера экрана при расчете перемещений</li></ul><p><strong>Производительность по устройствам:</strong></p><ul><li>Детекция слабых устройств</li><li>Постепенная деградация анимаций</li><li>Отключение анимаций при низкой производительности</li><li>Использование matchMedia для динамической адаптации</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Всегда предусматривать fallback без анимаций</li><li>Тестировать на устройствах разной мощности</li><li>Использовать прогрессивные улучшения</li><li>Мониторить производительность через аналитику</li></ul>",
    difficulty: 'middle',
    tags: ['адаптивность', 'мобильные устройства', 'анимации']
  },
  {
    id: 67,
    question: "Какие есть альтернативы CSS-анимациям для сложных эффектов?",
    answer: "<p>Для создания сложных анимаций иногда CSS может быть недостаточно, и стоит рассмотреть альтернативные подходы.</p><p><strong>JavaScript-анимации:</strong></p><ul><li><strong>Web Animations API</strong> — нативный API для анимаций</li><li><strong>requestAnimationFrame</strong> — создание кастомных анимаций</li><li><strong>GSAP (GreenSock)</strong> — мощная библиотека анимаций</li><li><strong>Framer Motion</strong> — для React-приложений</li></ul><p><strong>Когда использовать JS-анимации:</strong></p><ul><li>Сложная логика анимаций</li><li>Интерактивные анимации с пользовательским вводом</li><li>Анимации на основе данных</li><li>Точный контроль над таймингом</li></ul><p><strong>Canvas и WebGL:</strong></p><ul><li><strong>Canvas 2D</strong> — для сложной графики</li><li><strong>WebGL</strong> — для 3D анимаций</li><li><strong>Three.js</strong> — библиотека для 3D</li><li><strong>PixiJS</strong> — для 2D анимаций</li></ul><p><strong>SVG анимации:</strong></p><ul><li>Анимация векторной графики</li><li>Morphing между формами</li><li>Анимация путей и stroke</li><li>Интерактивные иллюстрации</li></ul><p><strong>Выбор подходящего решения:</strong></p><ul><li>CSS — для простых переходов и базовых анимаций</li><li>JavaScript — для сложной логики и интерактивности</li><li>Canvas/WebGL — для игр и тяжелой графики</li><li>SVG — для анимированных иллюстраций</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Начинать с CSS, переходить к JS при необходимости</li><li>Учитывать производительность каждого подхода</li><li>Тестировать на целевых устройствах</li></ul>",
    difficulty: 'senior',
    tags: ['альтернативы', 'JavaScript анимации', 'Canvas']
  },

  // CSS-in-JS
  {
    id: 68,
    question: "Что такое CSS-in-JS и какие проблемы он решает?",
    answer: "<p><strong>CSS-in-JS</strong> — это подход к написанию стилей, при котором CSS описывается внутри JavaScript кода, часто прямо в компонентах.</p><p><strong>Основные проблемы, которые решает:</strong></p><ul><li><strong>Изоляция стилей</strong> — каждый компонент имеет собственные стили</li><li><strong>Динамические стили</strong> — возможность изменять стили на основе состояния</li><li><strong>Удаление неиспользуемого кода</strong> — стили связаны с компонентами</li><li><strong>Тематизация</strong> — легкая поддержка тем и переменных</li><li><strong>Типизация</strong> — поддержка TypeScript для стилей</li></ul><p><strong>Преимущества:</strong></p><ul><li>Все в одном месте — логика и стили компонента</li><li>Условные стили на основе props</li><li>Автоматическая оптимизация</li><li>Лучший developer experience</li></ul><p><strong>Недостатки:</strong></p><ul><li>Увеличение размера JavaScript бандла</li><li>Потенциальное снижение производительности</li><li>Необходимость изучения нового API</li><li>Сложности с серверным рендерингом</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'компоненты', 'React']
  },
  {
    id: 69,
    question: "Сравните runtime и compile-time подходы в CSS-in-JS.",
    answer: "<p><strong>Runtime CSS-in-JS</strong> генерирует и внедряет стили во время выполнения в браузере:</p><p><strong>Примеры:</strong> Styled Components, Emotion, JSS</p><p><strong>Преимущества:</strong></p><ul><li>Полная динамичность — стили могут изменяться в реальном времени</li><li>Простота настройки</li><li>Богатые возможности для тематизации</li><li>Условные стили на основе любых данных</li></ul><p><strong>Недостатки:</strong></p><ul><li>Overhead во время выполнения</li><li>Возможные проблемы с производительностью</li><li>Сложности с SSR</li><li>Увеличение размера бандла</li></ul><p><strong>Compile-time CSS-in-JS</strong> обрабатывает стили на этапе сборки:</p><p><strong>Примеры:</strong> Linaria, Compiled, Vanilla Extract</p><p><strong>Преимущества:</strong></p><ul><li>Нет overhead во время выполнения</li><li>Меньший размер бандла</li><li>Лучшая производительность</li><li>Обычный CSS на выходе</li></ul><p><strong>Недостатки:</strong></p><ul><li>Ограниченная динамичность</li><li>Более сложная настройка</li><li>Возможные ограничения в возможностях</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'runtime', 'compile-time']
  },
  {
    id: 70,
    question: "В каких случаях CSS-in-JS является лучшим выбором по сравнению с обычным CSS?",
    answer: "<p><strong>CSS-in-JS лучше выбирать в следующих случаях:</strong></p><p><strong>Компонентная архитектура:</strong></p><ul><li>Когда нужна полная инкапсуляция стилей в компонентах</li><li>При создании библиотек компонентов</li><li>Когда стили тесно связаны с логикой компонента</li></ul><p><strong>Динамические стили:</strong></p><ul><li>Частые изменения стилей на основе состояния</li><li>Сложная логика условных стилей</li><li>Анимации, зависящие от данных</li></ul><p><strong>Тематизация:</strong></p><ul><li>Множественные темы с глубокой кастомизацией</li><li>Динамическое переключение тем</li><li>Персонализация интерфейса</li></ul><p><strong>Командная работа:</strong></p><ul><li>Когда разработчики работают только с JavaScript</li><li>Нужен строгий контроль над стилями</li><li>Важна типизация стилей</li></ul><p><strong>Не стоит использовать:</strong></p><ul><li>Статичные лендинги</li><li>Простые сайты без сложной логики</li><li>Когда производительность критична</li><li>Небольшие проекты</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'архитектура', 'выбор-технологий']
  },
  {
    id: 71,
    question: "Объясните различия в подходах к созданию стилей в styled-components и Emotion.",
    answer: "<p><strong>Styled Components:</strong></p><p><strong>Подход:</strong> Создание styled компонентов через template literals</p><p><strong>Синтаксис:</strong></p><ul><li>const Button = styled.button`color: blue;`</li><li>Использование props через функции</li><li>Наследование стилей через styled(Component)</li></ul><p><strong>Особенности:</strong></p><ul><li>Автоматическое создание классов</li><li>Встроенная поддержка тем</li><li>Расширение существующих компонентов</li></ul><p><strong>Emotion:</strong></p><p><strong>Подход:</strong> Более гибкий API с несколькими способами написания</p><p><strong>Варианты синтаксиса:</strong></p><ul><li>css prop: <div css={css`color: blue;`} /></li><li>styled API: const Button = styled.button`color: blue;`</li><li>Object styles: css({ color: 'blue' })</li></ul><p><strong>Особенности:</strong></p><ul><li>Меньший размер бандла</li><li>Лучшая производительность</li><li>Больше вариантов API</li><li>Поддержка обычных объектов CSS</li></ul><p><strong>Выбор зависит от:</strong></p><ul><li>Предпочтений в синтаксисе</li><li>Требований к производительности</li><li>Размера проекта</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'styled-components', 'Emotion']
  },
  {
    id: 72,
    question: "Как выбрать между различными CSS-in-JS библиотеками? От чего отталкиваться?",
    answer: "<p><strong>Критерии выбора CSS-in-JS библиотеки:</strong></p><p><strong>1. Производительность:</strong></p><ul><li>Runtime vs compile-time обработка</li><li>Размер бандла</li><li>Скорость рендеринга</li><li>Overhead во время выполнения</li></ul><p><strong>2. API и удобство:</strong></p><ul><li>Простота изучения и использования</li><li>Качество документации</li><li>Поддержка TypeScript</li><li>Совместимость с инструментами разработки</li></ul><p><strong>3. Функциональность:</strong></p><ul><li>Динамические стили</li><li>Поддержка тем</li><li>SSR совместимость</li><li>Анимации и переходы</li></ul><p><strong>4. Экосистема:</strong></p><ul><li>Размер сообщества</li><li>Активность разработки</li><li>Количество плагинов</li><li>Интеграция с фреймворками</li></ul><p><strong>5. Требования проекта:</strong></p><ul><li>Сложность интерфейса</li><li>Требования к производительности</li><li>Размер команды</li><li>Долгосрочная поддержка</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Для простых проектов: Styled Components</li><li>Для производительности: Emotion или compile-time решения</li><li>Для больших проектов: Stitches или Vanilla Extract</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'выбор-технологий', 'архитектура']
  },
  {
    id: 73,
    question: "Какие проблемы производительности могут возникнуть с CSS-in-JS и как их решать?",
    answer: "<p><strong>Основные проблемы производительности:</strong></p><p><strong>1. Runtime overhead:</strong></p><ul><li>Генерация стилей во время выполнения</li><li>Постоянное пересоздание стилей</li><li>Парсинг CSS в браузере</li></ul><p><strong>2. Повторные вычисления:</strong></p><ul><li>Пересчет стилей при каждом рендере</li><li>Создание новых функций стилей</li><li>Ненужные re-renders</li></ul><p><strong>3. Размер бандла:</strong></p><ul><li>Дополнительный JavaScript код</li><li>Дублирование стилей</li><li>Неиспользуемые стили</li></ul><p><strong>Способы решения:</strong></p><p><strong>Оптимизация кода:</strong></p><ul><li>Мемоизация стилей с useMemo</li><li>Вынос статичных стилей за пределы компонента</li><li>Использование CSS переменных для динамики</li></ul><p><strong>Выбор подходящих инструментов:</strong></p><ul><li>Compile-time библиотеки (Linaria, Vanilla Extract)</li><li>Оптимизированные runtime решения (Emotion)</li><li>Гибридные подходы (Stitches)</li></ul><p><strong>Архитектурные решения:</strong></p><ul><li>Разделение статичных и динамических стилей</li><li>Использование CSS-переменных</li><li>Ленивая загрузка стилей</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'производительность', 'оптимизация']
  },
  {
    id: 74,
    question: "Объясните разницу между compile-time и runtime CSS-in-JS подходами на практических примерах.",
    answer: "<p><strong>Runtime CSS-in-JS:</strong></p><p><strong>Как работает:</strong></p><ul><li>Стили генерируются во время выполнения в браузере</li><li>JavaScript создает CSS и вставляет в DOM</li><li>Полная динамичность стилей</li></ul><p><strong>Практический пример (Styled Components):</strong></p><ul><li>Компонент получает props</li><li>Функция стиля выполняется с этими props</li><li>Генерируется CSS класс</li><li>Класс применяется к элементу</li></ul><p><strong>Преимущества:</strong></p><ul><li>Стили могут зависеть от любых данных</li><li>Полная гибкость</li><li>Простота использования</li></ul><p><strong>Compile-time CSS-in-JS:</strong></p><p><strong>Как работает:</strong></p><ul><li>Стили обрабатываются на этапе сборки</li><li>Генерируется обычный CSS файл</li><li>Остаются только CSS классы</li></ul><p><strong>Практический пример (Vanilla Extract):</strong></p><ul><li>Стили описываются в .css.ts файлах</li><li>Babel/webpack преобразует в CSS</li><li>Получаем статичные CSS классы</li><li>Динамика через CSS переменные</li></ul><p><strong>Преимущества:</strong></p><ul><li>Нет overhead во время выполнения</li><li>Меньший размер JavaScript бандла</li><li>Лучшая производительность</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Runtime: когда нужна полная динамичность</li><li>Compile-time: когда важна производительность</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'runtime', 'compile-time', 'производительность']
  },
  {
    id: 75,
    question: "Как решать проблемы с серверным рендерингом (SSR) в CSS-in-JS?",
    answer: "<p><strong>Основные проблемы SSR с CSS-in-JS:</strong></p><p><strong>1. Hydration mismatch:</strong></p><ul><li>Разные стили на сервере и клиенте</li><li>Классы генерируются в разном порядке</li><li>Отсутствие стилей при первой загрузке</li></ul><p><strong>2. Performance issues:</strong></p><ul><li>Медленная генерация стилей на сервере</li><li>Блокировка рендеринга</li><li>Увеличение времени TTFB</li></ul><p><strong>Решения:</strong></p><p><strong>1. Правильная настройка SSR:</strong></p><ul><li>Использование ServerStyleSheet (styled-components)</li><li>Настройка babel для статичного анализа</li><li>Синхронизация генерации классов</li></ul><p><strong>2. Стратегии оптимизации:</strong></p><ul><li>Критический CSS inline</li><li>Ленивая загрузка некритичных стилей</li><li>Кэширование сгенерированных стилей</li></ul><p><strong>3. Альтернативные подходы:</strong></p><ul><li>Compile-time решения (zero-runtime)</li><li>Гибридные подходы</li><li>CSS переменные для динамики</li></ul><p><strong>4. Инструменты:</strong></p><ul><li>Next.js с встроенной поддержкой</li><li>Gatsby плагины</li><li>Custom SSR setup</li></ul><p><strong>Best practices:</strong></p><ul><li>Минимизация динамических стилей</li><li>Использование статичных стилей где возможно</li><li>Правильная настройка bundler</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'SSR', 'hydration', 'производительность']
  },
  {
    id: 76,
    question: "Какие есть альтернативы CSS-in-JS и когда их стоит рассматривать?",
    answer: "<p><strong>Основные альтернативы CSS-in-JS:</strong></p><p><strong>1. CSS Modules:</strong></p><ul><li>Локальная область видимости классов</li><li>Компиляция в обычный CSS</li><li>Хорошая производительность</li><li>Подходит для статичных стилей</li></ul><p><strong>2. Utility-first CSS (Tailwind):</strong></p><ul><li>Готовые утилитарные классы</li><li>Быстрая разработка</li><li>Минимальный CSS в продакшене</li><li>Подходит для прототипирования</li></ul><p><strong>3. PostCSS с плагинами:</strong></p><ul><li>Расширение возможностей CSS</li><li>Автопрефиксы и оптимизации</li><li>Поддержка современного CSS</li><li>Гибкость в настройке</li></ul><p><strong>4. Sass/SCSS:</strong></p><ul><li>Переменные и миксины</li><li>Вложенность и функции</li><li>Большая экосистема</li><li>Знакомый синтаксис</li></ul><p><strong>Когда рассматривать альтернативы:</strong></p><p><strong>CSS Modules:</strong></p><ul><li>Когда нужна изоляция без JavaScript overhead</li><li>Статичные стили с редкими изменениями</li><li>Важна производительность</li></ul><p><strong>Tailwind CSS:</strong></p><ul><li>Быстрое прототипирование</li><li>Команда с разными уровнями CSS знаний</li><li>Консистентный дизайн</li></ul><p><strong>Обычный CSS:</strong></p><ul><li>Простые проекты</li><li>Статичные сайты</li><li>Максимальная производительность</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'альтернативы', 'CSS-modules', 'Tailwind']
  },
  {
    id: 77,
    question: "Как правильно организовать тематизацию в CSS-in-JS приложениях?",
    answer: "<p><strong>Подходы к тематизации в CSS-in-JS:</strong></p><p><strong>1. ThemeProvider паттерн:</strong></p><ul><li>Контекст для передачи темы</li><li>Доступ к теме в любом компоненте</li><li>Централизованное управление</li></ul><p><strong>2. Структура темы:</strong></p><ul><li>Цветовые палитры (primary, secondary, text)</li><li>Типографика (размеры, веса, семейства)</li><li>Отступы и размеры</li><li>Тени и границы</li><li>Переходы и анимации</li></ul><p><strong>3. Динамическое переключение:</strong></p><ul><li>Хуки для смены темы</li><li>Сохранение выбора пользователя</li><li>Плавные переходы между темами</li></ul><p><strong>4. Типизация тем:</strong></p><ul><li>TypeScript интерфейсы для тем</li><li>Автодополнение свойств</li><li>Проверка типов</li></ul><p><strong>Best practices:</strong></p><p><strong>Организация:</strong></p><ul><li>Разделение на логические группы</li><li>Использование семантических имен</li><li>Избегание глубокой вложенности</li></ul><p><strong>Производительность:</strong></p><ul><li>Мемоизация контекста темы</li><li>Ленивая загрузка тем</li><li>Минимизация пересчетов</li></ul><p><strong>Доступность:</strong></p><ul><li>Поддержка системных настроек</li><li>Достаточный контраст</li><li>Респект к prefers-color-scheme</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'тематизация', 'ThemeProvider', 'типизация']
  },
  {
    id: 78,
    question: "Объясните концепцию atomic CSS и как она соотносится с CSS-in-JS.",
    answer: "<p><strong>Atomic CSS:</strong></p><p><strong>Концепция:</strong></p><ul><li>Каждый CSS класс выполняет одну функцию</li><li>Классы соответствуют отдельным CSS свойствам</li><li>Композиция стилей через комбинацию классов</li></ul><p><strong>Примеры:</strong></p><ul><li>.p-4 { padding: 1rem; }</li><li>.text-blue { color: blue; }</li><li>.flex { display: flex; }</li></ul><p><strong>Связь с CSS-in-JS:</strong></p><p><strong>1. Похожие принципы:</strong></p><ul><li>Композиция вместо наследования</li><li>Переиспользование стилей</li><li>Предсказуемость</li></ul><p><strong>2. Гибридные подходы:</strong></p><ul><li>Stitches - atomic CSS + CSS-in-JS</li><li>Styled-system - utility props</li><li>Theme-ui - constraint-based design</li></ul><p><strong>3. Различия:</strong></p><ul><li>Atomic CSS: статичные классы</li><li>CSS-in-JS: динамические стили</li><li>Atomic CSS: HTML разметка</li><li>CSS-in-JS: JavaScript код</li></ul><p><strong>Преимущества комбинации:</strong></p><ul><li>Лучшая производительность</li><li>Меньший размер CSS</li><li>Консистентный дизайн</li><li>Гибкость CSS-in-JS</li></ul><p><strong>Недостатки:</strong></p><ul><li>Сложность изучения</li><li>Многословность в разметке</li><li>Ограничения кастомизации</li></ul><p><strong>Когда использовать:</strong></p><ul><li>Дизайн-системы</li><li>Быстрая разработка UI</li><li>Команды с разным уровнем CSS</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'atomic-CSS', 'Stitches', 'архитектура']
  },
  {
    id: 79,
    question: "Какие инструменты разработки и отладки доступны для CSS-in-JS?",
    answer: "<p><strong>Инструменты разработки для CSS-in-JS:</strong></p><p><strong>1. Browser DevTools:</strong></p><p><strong>Особенности:</strong></p><ul><li>Автоматически генерируемые имена классов</li><li>Сложности с отладкой</li><li>Нужны дополнительные расширения</li></ul><p><strong>Улучшения:</strong></p><ul><li>Styled-components DevTools</li><li>Emotion DevTools</li><li>React DevTools интеграция</li></ul><p><strong>2. IDE поддержка:</strong></p><ul><li>Подсветка синтаксиса в template literals</li><li>Автодополнение CSS свойств</li><li>Линтинг стилей</li><li>Рефакторинг поддержка</li></ul><p><strong>3. Линтеры и анализаторы:</strong></p><ul><li>Stylelint для CSS-in-JS</li><li>ESLint правила для styled-components</li><li>Проверка производительности</li></ul><p><strong>4. Тестирование:</strong></p><ul><li>Jest styled-components</li><li>Snapshot тестирование стилей</li><li>Visual regression testing</li></ul><p><strong>5. Оптимизация и профилирование:</strong></p><ul><li>Bundle analyzer для CSS</li><li>Performance profiling</li><li>Dead code elimination</li></ul><p><strong>Best practices для отладки:</strong></p><ul><li>Использование displayName для компонентов</li><li>Семантичные имена для styled компонентов</li><li>Добавление комментариев к сложным стилям</li><li>Использование CSS переменных для отладки</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'DevTools', 'отладка', 'тестирование']
  },
  {
    id: 80,
    question: "Как миграция с обычного CSS на CSS-in-JS влияет на архитектуру приложения?",
    answer: "<p><strong>Влияние миграции на архитектуру:</strong></p><p><strong>1. Структура файлов:</strong></p><p><strong>До:</strong></p><ul><li>Отдельные CSS файлы</li><li>Глобальные стили</li><li>Возможные конфликты имен</li></ul><p><strong>После:</strong></p><ul><li>Стили внутри компонентов</li><li>Локальная область видимости</li><li>Компонентно-ориентированная структура</li></ul><p><strong>2. Компонентная архитектура:</strong></p><ul><li>Более сильная связь между логикой и стилями</li><li>Переиспользуемые styled компоненты</li><li>Инкапсуляция стилей</li></ul><p><strong>3. Стратегии миграции:</strong></p><p><strong>Постепенная миграция:</strong></p><ul><li>Начать с новых компонентов</li><li>Постепенно мигрировать существующие</li><li>Сохранить критичные глобальные стили</li></ul><p><strong>Полная миграция:</strong></p><ul><li>Переписать всю стилизацию</li><li>Больше контроля</li><li>Больше времени на разработку</li></ul><p><strong>4. Архитектурные изменения:</strong></p><ul><li>Новые паттерны организации кода</li><li>Тематизация через контекст</li><li>Условная стилизация</li></ul><p><strong>5. Влияние на команду:</strong></p><ul><li>Необходимость изучения новых инструментов</li><li>Изменение процесса разработки</li><li>Новые подходы к дизайн-системам</li></ul><p><strong>Рекомендации:</strong></p><ul><li>Планировать миграцию поэтапно</li><li>Обучать команду заранее</li><li>Установить новые соглашения</li><li>Подготовить инструменты разработки</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'миграция', 'архитектура', 'рефакторинг']
  },
  {
    id: 81,
    question: "Объясните, как работает изоляция стилей в CSS-in-JS и какие проблемы она решает.",
    answer: "<p><strong>Изоляция стилей в CSS-in-JS:</strong></p><p><strong>Как работает:</strong></p><ul><li>Автоматическая генерация уникальных имен классов</li><li>Хэширование стилей</li><li>Привязка стилей к конкретным компонентам</li></ul><p><strong>Механизмы изоляции:</strong></p><p><strong>1. Generated class names:</strong></p><ul><li>Классы типа 'sc-abc123' или 'css-xyz789'</li><li>Невозможность случайного пересечения</li><li>Автоматическое управление</li></ul><p><strong>2. Scoped styles:</strong></p><ul><li>Стили применяются только к целевому компоненту</li><li>Нет влияния на другие части приложения</li><li>Предсказуемое поведение</li></ul><p><strong>Проблемы, которые решает:</strong></p><p><strong>1. Конфликты имен:</strong></p><ul><li>Нет глобальных CSS селекторов</li><li>Исключены случайные пересечения</li><li>Безопасное переименование</li></ul><p><strong>2. Каскадность CSS:</strong></p><ul><li>Предсказуемая специфичность</li><li>Нет неожиданных наследований</li><li>Контролируемое применение стилей</li></ul><p><strong>3. Мертвый код:</strong></p><ul><li>Стили удаляются вместе с компонентами</li><li>Нет неиспользуемых CSS правил</li><li>Автоматическая очистка</li></ul><p><strong>4. Порядок загрузки:</strong></p><ul><li>Стили загружаются с компонентами</li><li>Нет зависимости от порядка CSS файлов</li><li>Устойчивость к изменениям</li></ul><p><strong>Ограничения изоляции:</strong></p><ul><li>Сложности с глобальными стилями</li><li>Проблемы с third-party компонентами</li><li>Необходимость специальных решений для body, html</li></ul>",
    difficulty: 'middle',
    tags: ['CSS-in-JS', 'изоляция', 'scoped-styles', 'архитектура']
  },
  {
    id: 82,
    question: "Какие есть подходы к организации CSS-in-JS кода в больших проектах?",
    answer: "<p><strong>Организация CSS-in-JS в больших проектах:</strong></p><p><strong>1. Структура папок:</strong></p><p><strong>Коллокация:</strong></p><ul><li>Стили рядом с компонентами</li><li>Легко найти и изменить</li><li>Хорошо для небольших команд</li></ul><p><strong>Разделение:</strong></p><ul><li>Отдельные папки для стилей</li><li>Централизованное управление</li><li>Подходит для больших команд</li></ul><p><strong>2. Паттерны организации:</strong></p><p><strong>Styled Components:</strong></p><ul><li>Отдельные файлы для styled компонентов</li><li>Переиспользуемые стилизованные элементы</li><li>Композиция через наследование</li></ul><p><strong>Style Objects:</strong></p><ul><li>Объекты стилей в отдельных файлах</li><li>Легко тестировать</li><li>Хорошо для TypeScript</li></ul><p><strong>3. Дизайн-система:</strong></p><ul><li>Централизованные токены дизайна</li><li>Общие компоненты и стили</li><li>Консистентность интерфейса</li></ul><p><strong>4. Код-стандарты:</strong></p><ul><li>Соглашения об именовании</li><li>Структура файлов</li><li>Паттерны для условных стилей</li></ul><p><strong>5. Оптимизация:</strong></p><ul><li>Ленивая загрузка стилей</li><li>Разделение критичных стилей</li><li>Минимизация пересчетов</li></ul><p><strong>Best practices:</strong></p><ul><li>Использование линтеров</li><li>Автоматическое форматирование</li><li>Документирование стилей</li><li>Ревью кода для стилей</li><li>Тестирование визуального регресса</li></ul>",
    difficulty: 'senior',
    tags: ['CSS-in-JS', 'архитектура', 'большие-проекты', 'организация-кода']
  }
  ];
