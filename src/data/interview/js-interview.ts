export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const jsInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое функция в JavaScript и для чего она используется?",
    answer: "<p><strong>Функция</strong> — это блок кода, который можно многократно вызывать для выполнения определенной задачи. Функции являются основным строительным блоком JavaScript-программ.</p><p><strong>Основные назначения функций:</strong></p><ul><li><strong>Переиспользование кода:</strong> Один раз написанный код можно вызывать множество раз</li><li><strong>Модульность:</strong> Разбиение сложной задачи на более простые подзадачи</li><li><strong>Абстракция:</strong> Скрытие деталей реализации за простым интерфейсом</li><li><strong>Область видимости:</strong> Создание изолированного пространства для переменных</li></ul><p>Функции в JavaScript являются <em>объектами первого класса</em>, что означает, что их можно присваивать переменным, передавать как аргументы и возвращать из других функций.</p><p>Пример простой функции, которая складывает два числа и возвращает результат.</p>",
    difficulty: 'junior',
    tags: ['основы', 'функции', 'концепции']
  },
  {
    id: 2,
    question: "Какие способы объявления функций существуют в JavaScript?",
    answer: "<p>В JavaScript существует несколько способов создания функций:</p><h4>1. Function Declaration (Объявление функции):</h4><p>Классический способ объявления функции с ключевым словом <code>function</code>. Такие функции поднимаются (hoisting) и доступны во всей области видимости.</p><h4>2. Function Expression (Функциональное выражение):</h4><p>Функция создается как выражение и присваивается переменной. Не поднимается, доступна только после объявления.</p><h4>3. Arrow Function (Стрелочная функция):</h4><p>Краткий синтаксис ES6 для создания функций. Не имеет собственного контекста <code>this</code>.</p><h4>4. Function Constructor:</h4><p>Создание функции через конструктор <code>Function()</code>. Редко используется в практике.</p><h4>5. Method Definition:</h4><p>Краткий синтаксис для определения методов в объектах.</p><p>Каждый способ имеет свои особенности поведения, особенно касательно <strong>hoisting, this и arguments</strong>.</p>",
    difficulty: 'junior',
    tags: ['объявление функций', 'синтаксис', 'ES6']
  },
  {
    id: 3,
    question: "В чем разница между Function Declaration и Function Expression?",
    answer: "<p>Основные различия между Function Declaration и Function Expression:</p><h4>Function Declaration:</h4><ul><li><strong>Hoisting:</strong> Поднимается полностью, можно вызывать до объявления</li><li><strong>Синтаксис:</strong> Начинается с ключевого слова <code>function</code></li><li><strong>Имя:</strong> Обязательно должна иметь имя</li><li><strong>Область видимости:</strong> Доступна во всей области видимости, где объявлена</li></ul><h4>Function Expression:</h4><ul><li><strong>Hoisting:</strong> Переменная поднимается, но не значение. Нельзя вызвать до присваивания</li><li><strong>Синтаксис:</strong> Функция присваивается переменной</li><li><strong>Имя:</strong> Может быть анонимной или именованной</li><li><strong>Условное создание:</strong> Может создаваться условно внутри блоков</li></ul><h4>Практическое применение:</h4><p><strong>Function Declaration</strong> используется для основных функций программы, которые должны быть доступны везде.</p><p><strong>Function Expression</strong> используется для условного создания функций, callback'ов и когда функция нужна как значение.</p>",
    difficulty: 'junior',
    tags: ['function declaration', 'function expression', 'hoisting', 'различия']
  },
  {
    id: 4,
    question: "Что такое стрелочные функции и чем они отличаются от обычных?",
    answer: "<p><strong>Стрелочные функции</strong> — это краткий синтаксис ES6 для создания функций, введенный для упрощения написания кода.</p><h4>Основные отличия от обычных функций:</h4><h4>1. Контекст this:</h4><p><strong>Обычные функции:</strong> Имеют собственный контекст <code>this</code>, который определяется способом вызова.</p><p><strong>Стрелочные функции:</strong> Наследуют <code>this</code> из внешней области видимости, не создают собственный контекст.</p><h4>2. Объект arguments:</h4><p>Стрелочные функции не имеют собственного объекта <code>arguments</code>. Для доступа к параметрам используйте rest parameters.</p><h4>3. Hoisting:</h4><p>Стрелочные функции не поднимаются, так как являются выражениями.</p><h4>4. Конструктор:</h4><p>Стрелочные функции нельзя использовать как конструкторы с оператором <code>new</code>.</p><h4>5. Синтаксис:</h4><p>Более краткий синтаксис, особенно для простых функций. Неявный возврат для выражений.</p><p><em>Стрелочные функции идеальны для callback'ов и функций, где не нужен собственный контекст.</em></p>",
    difficulty: 'middle',
    tags: ['arrow functions', 'ES6', 'this', 'различия']
  },
  {
    id: 5,
    question: "Что такое hoisting в контексте функций?",
    answer: "<p><strong>Hoisting</strong> — это механизм JavaScript, при котором объявления переменных и функций \"поднимаются\" в начало их области видимости во время компиляции.</p><h4>Поведение разных типов функций:</h4><h4>Function Declaration:</h4><p><strong>Полное поднятие:</strong> И объявление, и определение поднимаются. Функцию можно вызвать до её объявления в коде.</p><h4>Function Expression:</h4><p><strong>Частичное поднятие:</strong> Поднимается только объявление переменной (как <code>undefined</code>), но не присваивание функции.</p><h4>Arrow Functions:</h4><p>Ведут себя как Function Expression — поднимается только переменная.</p><h4>Переменные let/const:</h4><p>Функции, объявленные через <code>let</code> или <code>const</code>, находятся в \"temporal dead zone\" до момента объявления.</p><h4>Практическое значение:</h4><p>Понимание hoisting помогает избежать ошибок и писать более предсказуемый код. <em>Рекомендуется объявлять функции до их использования</em> для лучшей читаемости.</p>",
    difficulty: 'middle',
    tags: ['hoisting', 'область видимости', 'temporal dead zone']
  },
  {
    id: 6,
    question: "Что такое замыкания (closures) и как они работают с функциями?",
    answer: "<p><strong>Замыкание (closure)</strong> — это комбинация функции и лексического окружения, в котором эта функция была определена. Замыкание дает функции доступ к переменным внешней области видимости даже после завершения выполнения внешней функции.</p><h4>Как работают замыкания:</h4><p><strong>Лексическая область видимости:</strong> JavaScript использует лексическую область видимости, что означает, что функции имеют доступ к переменным, определенным в области, где они были созданы.</p><p><strong>Сохранение контекста:</strong> Когда функция возвращается из другой функции, она \"запоминает\" переменные из внешней области.</p><h4>Практические применения:</h4><ul><li><strong>Приватные переменные:</strong> Создание переменных, недоступных извне</li><li><strong>Фабрики функций:</strong> Создание специализированных функций</li><li><strong>Модули:</strong> Создание модульной структуры кода</li><li><strong>Callback функции:</strong> Сохранение состояния в асинхронных операциях</li></ul><p><em>Замыкания — это мощный механизм, который делает JavaScript функциональным языком программирования.</em></p>",
    difficulty: 'middle',
    tags: ['замыкания', 'лексическая область', 'приватные переменные']
  },
  {
    id: 7,
    question: "Что такое функции высшего порядка (Higher-Order Functions)?",
    answer: "<p><strong>Функции высшего порядка</strong> — это функции, которые принимают другие функции в качестве аргументов или возвращают функции как результат.</p><h4>Два типа функций высшего порядка:</h4><h4>1. Принимают функции как аргументы:</h4><p>Такие функции позволяют передавать поведение как параметр, делая код более гибким и переиспользуемым.</p><h4>2. Возвращают функции:</h4><p>Эти функции создают и возвращают новые функции, часто с использованием замыканий.</p><h4>Встроенные функции высшего порядка:</h4><ul><li><strong>Array.map():</strong> Применяет функцию к каждому элементу массива</li><li><strong>Array.filter():</strong> Фильтрует элементы на основе условия</li><li><strong>Array.reduce():</strong> Сворачивает массив к одному значению</li><li><strong>setTimeout/setInterval:</strong> Принимают функции для отложенного выполнения</li></ul><h4>Преимущества:</h4><ul><li>Более абстрактный и выразительный код</li><li>Лучшая переиспользуемость</li><li>Функциональный стиль программирования</li><li>Композиция функций</li></ul><p><em>Функции высшего порядка — основа функционального программирования в JavaScript.</em></p>",
    difficulty: 'middle',
    tags: ['высшего порядка', 'функциональное программирование', 'callback']
  },
  {
    id: 8,
    question: "Что такое IIFE (Immediately Invoked Function Expression)?",
    answer: "<p><strong>IIFE</strong> — это функция, которая выполняется сразу же после её создания. Это паттерн, позволяющий создать изолированную область видимости.</p><h4>Синтаксис IIFE:</h4><p>Существует два основных способа записи: с круглыми скобками вокруг всего выражения или только вокруг функции.</p><h4>Зачем используется IIFE:</h4><h4>1. Изоляция области видимости:</h4><p>Предотвращает загрязнение глобального пространства имен.</p><h4>2. Создание модулей:</h4><p>До появления ES6 модулей IIFE был основным способом создания модульной структуры.</p><h4>3. Инициализация:</h4><p>Выполнение кода инициализации, который должен запуститься только один раз.</p><h4>4. Приватность:</h4><p>Создание приватных переменных и методов.</p><h4>Варианты записи:</h4><p>Стрелочные функции также могут быть IIFE, хотя синтаксис менее читаемый.</p><p><strong>Современное применение:</strong> С появлением ES6 модулей и блочной области видимости <code>let/const</code> IIFE используется реже, но остается полезным для совместимости и специфических случаев.</p>",
    difficulty: 'middle',
    tags: ['IIFE', 'область видимости', 'модули', 'паттерны']
  },
  {
    id: 9,
    question: "Объясните разницу между параметрами и аргументами функции",
    answer: "<p>Часто эти термины используются взаимозаменяемо, но у них есть четкое различие:</p><h4>Параметры (Parameters):</h4><ul><li><strong>Определение:</strong> Переменные, указанные в объявлении функции</li><li><strong>Местоположение:</strong> Находятся в круглых скобках при объявлении функции</li><li><strong>Назначение:</strong> Определяют, какие значения функция ожидает получить</li><li><strong>Время существования:</strong> Существуют только внутри функции</li></ul><h4>Аргументы (Arguments):</h4><ul><li><strong>Определение:</strong> Фактические значения, передаваемые функции при вызове</li><li><strong>Местоположение:</strong> Передаются в круглых скобках при вызове функции</li><li><strong>Назначение:</strong> Конкретные данные для обработки функцией</li><li><strong>Типы:</strong> Могут быть любого типа данных</li></ul><h4>Особенности JavaScript:</h4><p><strong>Гибкость:</strong> Количество аргументов может не совпадать с количеством параметров.</p><p><strong>Объект arguments:</strong> В обычных функциях доступен объект <code>arguments</code> со всеми переданными аргументами.</p><p><strong>Значения по умолчанию:</strong> Параметры могут иметь значения по умолчанию (ES6).</p>",
    difficulty: 'junior',
    tags: ['параметры', 'аргументы', 'синтаксис', 'основы']
  },
  {
    id: 10,
    question: "Что такое rest параметры и spread оператор в функциях?",
    answer: "<p><strong>Rest параметры</strong> и <strong>spread оператор</strong> используют одинаковый синтаксис (<code>...</code>), но в разных контекстах:</p><h4>Rest параметры (...):</h4><p><strong>Назначение:</strong> Собирает несколько аргументов в массив внутри функции.</p><p><strong>Использование:</strong> Только в объявлении функции, только как последний параметр.</p><p><strong>Преимущества:</strong> Заменяет объект <code>arguments</code>, работает со стрелочными функциями, возвращает настоящий массив.</p><h4>Spread оператор (...):</h4><p><strong>Назначение:</strong> Разворачивает массив или итерируемый объект в отдельные элементы.</p><p><strong>Использование:</strong> При вызове функции, в массивах, объектах.</p><p><strong>Применение:</strong> Передача элементов массива как отдельных аргументов.</p><h4>Различия:</h4><ul><li><strong>Rest:</strong> Собирает много в одно (массив)</li><li><strong>Spread:</strong> Разбирает одно на много (элементы)</li></ul><p><em>Оба оператора делают работу с переменным количеством параметров более удобной и читаемой.</em></p>",
    difficulty: 'middle',
    tags: ['rest параметры', 'spread оператор', 'ES6', 'аргументы']
  },
  {
    id: 11,
    question: "Что такое bind, call и apply? В чем их различия?",
    answer: "<p>Это методы для управления контекстом <code>this</code> при вызове функций:</p><h4>call():</h4><p><strong>Назначение:</strong> Вызывает функцию с заданным контекстом <code>this</code> и аргументами.</p><p><strong>Синтаксис:</strong> Аргументы передаются через запятую.</p><p><strong>Выполнение:</strong> Функция выполняется немедленно.</p><h4>apply():</h4><p><strong>Назначение:</strong> То же, что и <code>call</code>, но аргументы передаются массивом.</p><p><strong>Синтаксис:</strong> Второй параметр — массив аргументов.</p><p><strong>Использование:</strong> Удобно, когда аргументы уже в виде массива.</p><h4>bind():</h4><p><strong>Назначение:</strong> Создает новую функцию с привязанным контекстом <code>this</code>.</p><p><strong>Выполнение:</strong> Возвращает новую функцию, не выполняя исходную.</p><p><strong>Частичное применение:</strong> Может частично применять аргументы.</p><h4>Основные различия:</h4><ul><li><strong>call/apply:</strong> Выполняют функцию сразу</li><li><strong>bind:</strong> Возвращает новую функцию для последующего вызова</li><li><strong>call:</strong> Аргументы через запятую</li><li><strong>apply:</strong> Аргументы массивом</li></ul>",
    difficulty: 'middle',
    tags: ['bind', 'call', 'apply', 'this', 'контекст']
  },
  {
    id: 12,
    question: "Что такое currying (каррирование) функций?",
    answer: "<p><strong>Каррирование</strong> — это техника преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.</p><h4>Принцип работы:</h4><p>Функция, принимающая несколько аргументов, преобразуется в функцию, которая принимает первый аргумент и возвращает функцию для следующего аргумента, и так далее.</p><h4>Преимущества каррирования:</h4><h4>1. Частичное применение:</h4><p>Можно создавать специализированные функции, зафиксировав некоторые аргументы.</p><h4>2. Переиспользование:</h4><p>Создание функций с предустановленными параметрами.</p><h4>3. Композиция:</p><p>Легче комбинировать каррированные функции.</p><h4>4. Читаемость:</h4><p>Более декларативный стиль программирования.</p><h4>Реализация:</h4><p>Можно реализовать вручную через замыкания или использовать библиотеки типа Lodash.</p><h4>Применение:</h4><p>Особенно полезно в функциональном программировании, при создании конфигурируемых функций и в библиотеках вроде Redux.</p><p><em>Каррирование — мощная техника для создания более гибких и переиспользуемых функций.</em></p>",
    difficulty: 'senior',
    tags: ['каррирование', 'функциональное программирование', 'замыкания']
  },
  {
    id: 13,
    question: "Что такое чистые функции (pure functions) и побочные эффекты?",
    answer: "<p><strong>Чистая функция</strong> — это функция, которая всегда возвращает одинаковый результат для одинаковых входных данных и не производит побочных эффектов.</p><h4>Критерии чистой функции:</h4><h4>1. Детерминированность:</h4><p>Одинаковый входной параметр всегда дает одинаковый результат.</p><h4>2. Отсутствие побочных эффектов:</h4><p>Функция не изменяет внешнее состояние программы.</p><h4>Побочные эффекты:</h4><ul><li>Изменение глобальных переменных</li><li>Изменение переданных объектов/массивов</li><li>Обращение к DOM</li><li>HTTP-запросы</li><li>Вывод в консоль</li><li>Генерация случайных чисел</li><li>Получение текущего времени</li></ul><h4>Преимущества чистых функций:</h4><ul><li><strong>Предсказуемость:</strong> Легко понять, что делает функция</li><li><strong>Тестируемость:</strong> Проще написать тесты</li><li><strong>Отладка:</strong> Легче найти и исправить ошибки</li><li><strong>Кэширование:</strong> Можно кэшировать результаты (memoization)</li><li><strong>Параллелизм:</strong> Безопасны для параллельного выполнения</li></ul><p><em>Стремитесь к написанию чистых функций, когда это возможно — это основа надежного кода.</em></p>",
    difficulty: 'senior',
    tags: ['чистые функции', 'побочные эффекты', 'функциональное программирование']
  },
  {
    id: 14,
    question: "Что такое мемоизация (memoization) и как её реализовать?",
    answer: "<p><strong>Мемоизация</strong> — это техника оптимизации, при которой результаты выполнения функции кэшируются, чтобы избежать повторных вычислений для одинаковых входных данных.</p><h4>Принцип работы:</h4><ol><li>При первом вызове функции с определенными аргументами результат вычисляется и сохраняется</li><li>При последующих вызовах с теми же аргументами возвращается сохраненный результат</li><li>Время выполнения уменьшается с O(n) до O(1) для повторных вызовов</li></ol><h4>Когда применять:</h4><ul><li><strong>Дорогие вычисления:</strong> Функции с высокой вычислительной сложностью</li><li><strong>Рекурсивные функции:</strong> Например, вычисление чисел Фибоначчи</li><li><strong>Частые повторные вызовы:</strong> С одинаковыми параметрами</li><li><strong>Чистые функции:</strong> Результат зависит только от входных параметров</li></ul><h4>Ограничения:</h4><ul><li>Использует дополнительную память для хранения кэша</li><li>Подходит только для чистых функций</li><li>Может быть неэффективна для функций с большим количеством уникальных аргументов</li></ul><p><em>Мемоизация — мощный инструмент оптимизации, но используйте её осознанно, учитывая баланс между скоростью и памятью.</em></p>",
    difficulty: 'senior',
    tags: ['мемоизация', 'оптимизация', 'кэширование', 'производительность']
  },
  {
    id: 15,
    question: "Как работает контекст выполнения функций и call stack?",
    answer: "<p><strong>Контекст выполнения</strong> — это абстрактная концепция, описывающая среду, в которой выполняется JavaScript код.</p><h4>Типы контекстов выполнения:</h4><h4>1. Глобальный контекст:</h4><p>Создается при загрузке скрипта, существует один на всю программу.</p><h4>2. Контекст функции:</h4><p>Создается при каждом вызове функции.</p><h4>3. Eval контекст:</h4><p>Создается при выполнении кода в <code>eval()</code>.</p><h4>Фазы создания контекста:</h4><h4>1. Creation Phase (Фаза создания):</h4><ul><li>Создание лексического окружения</li><li>Создание переменного окружения</li><li>Определение значения <code>this</code></li><li>Hoisting переменных и функций</li></ul><h4>2. Execution Phase (Фаза выполнения):</h4><ul><li>Выполнение кода построчно</li><li>Присваивание значений переменным</li></ul><h4>Call Stack (Стек вызовов):</h4><p><strong>Принцип работы:</strong> LIFO (Last In, First Out) — последний зашедший, первый вышедший.</p><p><strong>Процесс:</strong> При вызове функции её контекст добавляется в стек, при завершении — удаляется.</p><p><em>Понимание контекста выполнения помогает разобраться в hoisting, замыканиях и области видимости.</em></p>",
    difficulty: 'senior',
    tags: ['контекст выполнения', 'call stack', 'лексическое окружение', 'hoisting']
  },
  {
    id: 16,
    question: "Что такое замыкание?",
    answer: "<p><strong>Замыкание (closure)</strong> — это способность функции получать доступ к переменным из внешней (объемлющей) области видимости даже после того, как внешняя функция завершила своё выполнение.</p><h4>Простое объяснение:</h4><p>Когда функция создается внутри другой функции, она \"запоминает\" переменные родительской функции и может использовать их позже, даже когда родительская функция уже не выполняется.</p><h4>Три ключевых компонента замыкания:</h4><ul><li><strong>Внешняя функция</strong> с локальными переменными</li><li><strong>Внутренняя функция</strong>, которая использует эти переменные</li><li><strong>Возврат</strong> внутренней функции из внешней</li></ul><h4>Зачем нужны замыкания:</h4><ul><li><strong>Сохранение состояния:</strong> Переменные остаются \"живыми\" между вызовами</li><li><strong>Приватность данных:</strong> Переменные недоступны извне</li><li><strong>Создание функций-фабрик:</strong> Генерация специализированных функций</li></ul><p>Замыкания работают благодаря тому, что JavaScript сохраняет ссылку на лексическое окружение функции при её создании.</p><p><em>Замыкания — это фундаментальная концепция JavaScript, которая делает язык мощным и гибким.</em></p>",
    difficulty: 'junior',
    tags: ['замыкания', 'основы', 'концепции', 'область видимости']
  },
  {
    id: 17,
    question: "Что такое лексическое окружение (Lexical Environment) в JavaScript?",
    answer: "<p><strong>Лексическое окружение</strong> — это структура данных, которая содержит привязки идентификаторов к значениям и ссылку на внешнее лексическое окружение.</p><h4>Состав лексического окружения:</h4><h4>1. Environment Record (Запись окружения):</h4><p>Хранит все локальные привязки (переменные, функции, параметры) в данной области видимости.</p><h4>2. Outer Environment Reference:</h4><p>Ссылка на внешнее лексическое окружение, образующая цепочку областей видимости.</p><h4>Типы записей окружения:</h4><ul><li><strong>Declarative Environment Record:</strong> Для функций, блоков, модулей</li><li><strong>Object Environment Record:</strong> Для глобального объекта и with-блоков</li><li><strong>Function Environment Record:</strong> Специально для функций (содержит this, arguments)</li><li><strong>Module Environment Record:</strong> Для ES6 модулей</li></ul><h4>Создание лексического окружения:</h4><p>Лексическое окружение создается <strong>в момент создания контекста выполнения</strong>, а не во время выполнения кода. Это происходит в фазе создания (Creation Phase).</p><p><em>Лексическое окружение — основа для понимания области видимости и замыканий в JavaScript.</em></p>",
    difficulty: 'senior',
    tags: ['лексическое окружение', 'область видимости', 'замыкания', 'контекст выполнения']
  },
  {
    id: 18,
    question: "В какой момент создается лексическое окружение функции?",
    answer: "<p>Лексическое окружение функции создается <strong>в момент создания контекста выполнения функции</strong>, а не в момент её объявления или определения.</p><h4>Временная последовательность:</h4><h4>1. Объявление функции:</h4><p>При объявлении функция запоминает лексическое окружение, в котором была создана (через внутренний слот [[Environment]]).</p><h4>2. Вызов функции:</h4><p>При вызове создается новый контекст выполнения и новое лексическое окружение для этого вызова.</p><h4>3. Фаза создания контекста:</h4><ul><li>Создается Function Environment Record</li><li>Устанавливается ссылка на внешнее окружение</li><li>Происходит привязка параметров и локальных переменных</li><li>Определяется значение <code>this</code></li></ul><h4>4. Фаза выполнения:</h4><p>Переменные получают свои значения, код выполняется строка за строкой.</p><h4>Важные моменты:</h4><p><strong>Каждый вызов</strong> функции создает уникальное лексическое окружение, даже для одной и той же функции.</p><p><strong>Замыкания</strong> формируются благодаря тому, что функция сохраняет ссылку на лексическое окружение своего создания.</p>",
    difficulty: 'senior',
    tags: ['лексическое окружение', 'контекст выполнения', 'замыкания', 'жизненный цикл']
  },
  {
    id: 19,
    question: "Как работает цепочка областей видимости (Scope Chain)?",
    answer: "<p><strong>Цепочка областей видимости</strong> — это механизм поиска переменных через связанные лексические окружения от внутреннего к внешнему.</p><h4>Принцип работы:</h4><h4>1. Поиск переменной:</h4><p>JavaScript начинает поиск переменной в текущем лексическом окружении.</p><h4>2. Поиск во внешних окружениях:</h4><p>Если переменная не найдена, поиск продолжается в родительском окружении по ссылке Outer Environment Reference.</p><h4>3. Завершение поиска:</h4><p>Поиск продолжается до глобального окружения. Если переменная не найдена — <code>ReferenceError</code>.</p><h4>Формирование цепочки:</h4><p>Цепочка определяется <strong>местом объявления функции</strong> в коде (лексически), а не местом её вызова.</p><h4>Особенности:</h4><ul><li><strong>Статическая природа:</strong> Цепочка определяется во время написания кода</li><li><strong>Однонаправленность:</strong> Поиск идет только наружу, никогда внутрь</li><li><strong>Первое найденное:</strong> Используется первое найденное значение (shadowing)</li></ul><h4>Производительность:</h4><p>Поиск переменных в длинной цепочке может влиять на производительность, поэтому локальные переменные быстрее глобальных.</p>",
    difficulty: 'middle',
    tags: ['scope chain', 'область видимости', 'лексическое окружение', 'поиск переменных']
  },
  {
    id: 20,
    question: "Объясните разницу между статической и динамической областью видимости",
    answer: "<p>JavaScript использует <strong>статическую (лексическую)</strong> область видимости, но важно понимать различия с динамической.</p><h4>Статическая (Лексическая) область видимости:</h4><p><strong>Принцип:</strong> Область видимости определяется местом объявления функции в исходном коде.</p><p><strong>Время определения:</strong> Во время написания кода (compile time).</p><p><strong>Предсказуемость:</strong> Можно определить область видимости, просто прочитав код.</p><h4>Динамическая область видимости:</h4><p><strong>Принцип:</strong> Область видимости определяется местом вызова функции.</p><p><strong>Время определения:</strong> Во время выполнения (runtime).</p><p><strong>Непредсказуемость:</strong> Область видимости зависит от стека вызовов.</p><h4>Преимущества статической области:</h4><ul><li><strong>Предсказуемость:</strong> Код ведет себя одинаково независимо от места вызова</li><li><strong>Оптимизация:</strong> Движки могут лучше оптимизировать код</li><li><strong>Отладка:</strong> Легче найти источник переменной</li><li><strong>Замыкания:</strong> Возможность создания замыканий</li></ul><p><em>Статическая область видимости — одна из причин, почему JavaScript предсказуем и подходит для создания сложных приложений.</em></p>",
    difficulty: 'senior',
    tags: ['статическая область', 'динамическая область', 'лексическая область', 'область видимости']
  },
  {
    id: 21,
    question: "Что происходит с замыканием в памяти и как избежать утечек?",
    answer: "<p>Замыкания могут приводить к утечкам памяти, если не управлять ими правильно.</p><h4>Как замыкания влияют на память:</h4><h4>1. Сохранение ссылок:</h4><p>Замыкание сохраняет ссылки на все переменные внешней области видимости, предотвращая их сборку мусора.</p><h4>2. Жизненный цикл:</h4><p>Переменные остаются в памяти до тех пор, пока существует ссылка на функцию-замыкание.</p><h4>3. Неочевидные ссылки:</p><p>Все функции, созданные в одной области видимости, разделяют одно лексическое окружение.</p><h4>Потенциальные проблемы:</h4><ul><li><strong>Циклические ссылки:</strong> Особенно с DOM-элементами</li><li><strong>Большие объекты:</strong> Сохранение больших данных через замыкания</li><li><strong>Таймеры и обработчики:</strong> Забытые setInterval или event listeners</li></ul><h4>Способы избежать утечек:</h4><ul><li><strong>Обнуление ссылок:</strong> Присваивайте <code>null</code> неиспользуемым переменным</li><li><strong>Очистка обработчиков:</strong> Удаляйте event listeners и таймеры</li><li><strong>WeakMap/WeakSet:</strong> Используйте слабые ссылки где возможно</li><li><strong>Минимизация области:</strong> Создавайте замыкания с минимальной областью видимости</li></ul><p><em>Правильное управление памятью критично для производительных приложений.</em></p>",
    difficulty: 'senior',
    tags: ['замыкания', 'управление памятью', 'утечки памяти', 'оптимизация']
  },
  {
    id: 22,
    question: "Как создать приватные переменные с помощью замыканий?",
    answer: "<p>Замыкания позволяют создавать <strong>приватные переменные</strong> в JavaScript, который изначально не имеет встроенной поддержки приватности.</p><h4>Основные паттерны:</h4><h4>1. Модульный паттерн (Module Pattern):</h4><p>Использует IIFE для создания приватной области видимости и возвращает объект с публичными методами.</p><h4>2. Фабричная функция:</h4><p>Функция, создающая объекты с приватными переменными через замыкания.</p><h4>3. Паттерн \"Revealing Module\":</h4><p>Все функции объявляются как приватные, а публичные возвращаются в объекте.</p><h4>Преимущества приватных переменных:</h4><ul><li><strong>Инкапсуляция:</strong> Скрытие внутренней реализации</li><li><strong>Контроль доступа:</strong> Данные изменяются только через публичные методы</li><li><strong>Предотвращение конфликтов:</strong> Избежание случайного изменения данных</li><li><strong>Валидация:</strong> Контроль за корректностью данных</li></ul><h4>Современные альтернативы:</h4><p>С ES2022 появились <strong>приватные поля классов</strong> с синтаксисом <code>#privateField</code>, но замыкания остаются актуальными для функционального стиля программирования.</p><p><em>Приватные переменные через замыкания — классический способ инкапсуляции в JavaScript.</em></p>",
    difficulty: 'middle',
    tags: ['приватные переменные', 'замыкания', 'инкапсуляция', 'модульный паттерн']
  },
  {
    id: 23,
    question: "Что такое модульный паттерн и как он использует замыкания?",
    answer: "<p><strong>Модульный паттерн</strong> — это паттерн проектирования, использующий замыкания для создания модулей с приватными и публичными методами.</p><h4>Основные компоненты паттерна:</h4><h4>1. IIFE (Immediately Invoked Function Expression):</h4><p>Создает изолированную область видимости для модуля.</p><h4>2. Приватные переменные и функции:</h4><p>Объявляются внутри IIFE и недоступны извне.</p><h4>3. Публичный API:</h4><p>Возвращается объект с методами, имеющими доступ к приватным данным через замыкание.</p><h4>Вариации паттерна:</h4><h4>1. Классический модульный паттерн:</h4><p>Возвращает объект с публичными методами.</p><h4>2. Revealing Module Pattern:</h4><p>Все функции объявляются приватными, публичные возвращаются в конце.</p><h4>3. Модуль-синглтон:</h4><p>Создается один экземпляр модуля.</p><h4>4. Модуль с параметрами:</h4><p>Принимает параметры для конфигурации.</p><h4>Преимущества:</h4><ul><li>Инкапсуляция данных</li><li>Избежание загрязнения глобальной области</li><li>Организация кода</li><li>Переиспользование</li></ul><p><em>До появления ES6 модулей это был основной способ модульной организации JavaScript кода.</em></p>",
    difficulty: 'middle',
    tags: ['модульный паттерн', 'замыкания', 'IIFE', 'архитектура', 'паттерны']
  },
  {
    id: 24,
    question: "Как замыкания работают в циклах? Классическая проблема с setTimeout",
    answer: "<p>Одна из самых частых проблем с замыканиями — неправильное поведение в циклах, особенно с асинхронными функциями.</p><h4>Классическая проблема:</h4><p>При использовании <code>var</code> в цикле с <code>setTimeout</code> все колбэки получают доступ к одной и той же переменной, которая к моменту выполнения имеет финальное значение.</p><h4>Причина проблемы:</h4><ul><li><strong>Область видимости var:</strong> <code>var</code> имеет функциональную область видимости</li><li><strong>Общая переменная:</strong> Все итерации разделяют одну переменную <code>i</code></li><li><strong>Асинхронность:</strong> <code>setTimeout</code> выполняется после завершения цикла</li></ul><h4>Способы решения:</h4><h4>1. Использование let (ES6):</h4><p>Блочная область видимости создает новую переменную на каждой итерации.</p><h4>2. IIFE (Immediately Invoked Function Expression):</h4><p>Создает новую область видимости для каждой итерации.</p><h4>3. Bind метод:</h4><p>Привязывает значение к функции.</p><h4>4. forEach:</h4><p>Каждая итерация создает новую область видимости.</p><p><em>Понимание этой проблемы критически важно для работы с асинхронным кодом и замыканиями.</em></p>",
    difficulty: 'middle',
    tags: ['замыкания', 'циклы', 'setTimeout', 'var vs let', 'асинхронность']
  },
  {
    id: 25,
    question: "Что такое частичное применение функций и как оно связано с замыканиями?",
    answer: "<p><strong>Частичное применение</strong> — это техника создания новой функции путем фиксации некоторых аргументов исходной функции.</p><h4>Принцип работы:</h4><p>Создается новая функция, которая \"запоминает\" некоторые аргументы через замыкание и ожидает получения оставшихся аргументов при вызове.</p><h4>Связь с замыканиями:</h4><p>Замыкания позволяют новой функции сохранять доступ к зафиксированным аргументам даже после завершения выполнения функции-создателя.</p><h4>Отличия от каррирования:</h4><ul><li><strong>Каррирование:</strong> Преобразует функцию N аргументов в цепочку из N функций по одному аргументу</li><li><strong>Частичное применение:</strong> Фиксирует произвольное количество аргументов, создавая функцию с меньшим количеством параметров</li></ul><h4>Практические применения:</h4><ul><li><strong>Конфигурация:</strong> Создание предварительно настроенных функций</li><li><strong>Обработчики событий:</strong> Передача дополнительных данных в callback</li><li><strong>Валидация:</strong> Создание специализированных валидаторов</li><li><strong>API вызовы:</strong> Предварительная настройка базовых параметров</li></ul><p><em>Частичное применение делает функции более гибкими и переиспользуемыми.</em></p>",
    difficulty: 'senior',
    tags: ['частичное применение', 'замыкания', 'функциональное программирование', 'каррирование']
  },
  {
    id: 26,
    question: "Как замыкания влияют на производительность и когда их следует избегать?",
    answer: "<p>Замыкания имеют влияние на производительность, которое нужно учитывать при разработке.</p><h4>Влияние на производительность:</h4><h4>1. Потребление памяти:</h4><p>Замыкания сохраняют ссылки на внешние переменные, предотвращая их сборку мусора.</p><h4>2. Время доступа к переменным:</h4><p>Поиск переменных по цепочке областей видимости медленнее доступа к локальным переменным.</p><h4>3. Создание функций:</h4><p>Создание функций-замыканий в циклах может быть дорогостоящим.</p><h4>Когда избегать замыканий:</h4><ul><li><strong>Горячие циклы:</strong> В критически важных для производительности участках</li><li><strong>Большие объемы данных:</strong> Когда замыкание захватывает большие объекты</li><li><strong>Частое создание функций:</strong> В часто вызываемых функциях</li><li><strong>Мобильные устройства:</strong> На устройствах с ограниченной памятью</li></ul><h4>Оптимизация замыканий:</h4><ul><li><strong>Минимизация области:</strong> Захватывайте только необходимые переменные</li><li><strong>Переиспользование функций:</strong> Создавайте функции-замыкания вне циклов</li><li><strong>Освобождение ссылок:</strong> Обнуляйте неиспользуемые переменные</li><li><strong>Профилирование:</strong> Измеряйте реальное влияние на производительность</li></ul><p><em>В большинстве случаев удобство использования замыканий перевешивает небольшое снижение производительности.</em></p>",
    difficulty: 'senior',
    tags: ['замыкания', 'производительность', 'оптимизация', 'память', 'best practices']
  },
  {
    id: 27,
    question: "Объясните, как работают замыкания в стрелочных функциях",
    answer: "<p>Стрелочные функции создают замыкания так же, как обычные функции, но с некоторыми важными особенностями.</p><h4>Общие принципы замыканий:</h4><p>Стрелочные функции, как и обычные, сохраняют доступ к переменным внешней области видимости через механизм замыкания.</p><h4>Особенности стрелочных функций:</h4><h4>1. Лексический this:</h4><p>Стрелочные функции не создают собственный контекст <code>this</code>, а наследуют его из окружающей области.</p><h4>2. Отсутствие arguments:</h4><p>У стрелочных функций нет объекта <code>arguments</code>, но есть доступ к <code>arguments</code> внешней функции через замыкание.</p><h4>3. Нельзя использовать как конструктор:</h4><p>Невозможность использования с <code>new</code> влияет на некоторые паттерны с замыканиями.</p><h4>Практические различия:</h4><p>В большинстве случаев замыкания в стрелочных функциях работают идентично обычным функциям, основное различие — в поведении <code>this</code>.</p><h4>Типичные сценарии использования:</h4><ul><li><strong>Callback функции:</strong> Удобны для обработчиков событий</li><li><strong>Array методы:</strong> map, filter, reduce</li><li><strong>Асинхронный код:</strong> Промисы и async/await</li></ul><p><em>Лексический this делает стрелочные функции особенно удобными для работы с замыканиями в контексте объектов.</em></p>",
    difficulty: 'middle',
    tags: ['стрелочные функции', 'замыкания', 'лексический this', 'ES6']
  },
  {
    id: 28,
    question: "Что такое декораторы и как они используют замыкания?",
    answer: "<p><strong>Декораторы</strong> — это функции высшего порядка, которые принимают другую функцию и возвращают её модифицированную версию, используя замыкания для сохранения дополнительной логики.</p><h4>Принцип работы декораторов:</h4><h4>1. Принимают исходную функцию:</h4><p>Декоратор получает функцию как аргумент.</p><h4>2. Создают обертку:</h4><p>Возвращают новую функцию, которая имеет доступ к исходной через замыкание.</p><h4>3. Расширяют функциональность:</h4><p>Добавляют дополнительную логику до, после или вместо вызова исходной функции.</p><h4>Типы декораторов:</h4><ul><li><strong>Логирующие:</strong> Записывают информацию о вызовах функции</li><li><strong>Кэширующие:</strong> Сохраняют результаты для оптимизации</li><li><strong>Валидирующие:</strong> Проверяют аргументы перед выполнением</li><li><strong>Измеряющие время:</strong> Замеряют производительность</li><li><strong>Авторизующие:</strong> Проверяют права доступа</li></ul><h4>Композиция декораторов:</h4><p>Несколько декораторов можно комбинировать, создавая цепочки обработки.</p><h4>Использование замыканий:</h4><p>Замыкания позволяют декораторам сохранять состояние, доступ к исходной функции и дополнительным данным между вызовами.</p><p><em>Декораторы — мощный паттерн для разделения ответственности и переиспользования логики.</em></p>",
    difficulty: 'senior',
    tags: ['декораторы', 'замыкания', 'функции высшего порядка', 'паттерны проектирования']
  },
  {
    id: 29,
    question: "Как работают замыкания в асинхронном коде (Promise, async/await)?",
    answer: "<p>Замыкания играют ключевую роль в асинхронном JavaScript, сохраняя доступ к переменным между различными фазами выполнения.</p><h4>Замыкания в Promises:</h4><h4>1. Сохранение контекста:</h4><p>Callback функции в <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code> сохраняют доступ к переменным через замыкания.</p><h4>2. Цепочки промисов:</h4><p>Каждый элемент цепочки может использовать переменные из предыдущих шагов.</p><h4>Замыкания в async/await:</h4><p>Async функции также создают замыкания, позволяя await выражениям получать доступ к переменным внешней области.</p><h4>Типичные проблемы:</h4><h4>1. Изменение переменных:</h4><p>Переменные могут изменяться между созданием промиса и его выполнением.</p><h4>2. Циклы с асинхронными операциями:</h4><p>Классическая проблема с <code>var</code> в циклах усугубляется при асинхронности.</p><h4>Практические применения:</h4><ul><li><strong>Обработка ошибок:</strong> Сохранение контекста для логирования</li><li><strong>Конфигурация запросов:</strong> Использование настроек из внешней области</li><li><strong>Состояние компонентов:</strong> В React и других фреймворках</li><li><strong>Middleware:</strong> Сохранение состояния между вызовами</li></ul><p><em>Понимание замыканий критично для правильной работы с асинхронным JavaScript.</em></p>",
    difficulty: 'senior',
    tags: ['замыкания', 'асинхронный код', 'Promise', 'async/await', 'контекст']
  },
  {
    id: 30,
    question: "Что такое фабричные функции и как они используют замыкания?",
    answer: "<p><strong>Фабричные функции</strong> — это функции, которые создают и возвращают объекты, используя замыкания для инкапсуляции данных и поведения.</p><h4>Принцип работы:</h4><h4>1. Создание локального состояния:</h4><p>Переменные объявляются внутри фабричной функции.</p><h4>2. Возврат объекта с методами:</h4><p>Методы имеют доступ к локальным переменным через замыкания.</p><h4>3. Инкапсуляция:</h4><p>Приватные данные недоступны извне, только через публичные методы.</p><h4>Преимущества фабричных функций:</h4><ul><li><strong>Гибкость:</strong> Не требуют <code>new</code>, возвращают любые объекты</li><li><strong>Приватность:</strong> Естественная инкапсуляция через замыкания</li><li><strong>Композиция:</strong> Легко комбинировать с другими функциями</li><li><strong>Отсутствие проблем с this:</strong> Нет привязки к контексту</li></ul><h4>Сравнение с классами:</h4><p><strong>Фабричные функции:</strong> Используют замыкания, более функциональный подход.</p><p><strong>Классы:</strong> Используют прототипы, более ООП подход.</p><h4>Использование с модулями:</h4><p>Фабричные функции отлично сочетаются с модульным паттерном для создания переиспользуемых компонентов.</p><p><em>Фабричные функции — отличная альтернатива классам для создания объектов с приватным состоянием.</em></p>",
    difficulty: 'middle',
    tags: ['фабричные функции', 'замыкания', 'инкапсуляция', 'объекты', 'альтернатива классам']
  },
  {
    id: 31,
    question: "Как отладить проблемы, связанные с замыканиями?",
    answer: "<p>Отладка замыканий может быть сложной из-за их невидимой природы, но существуют эффективные техники и инструменты.</p><h4>Инструменты браузера:</h4><h4>1. Chrome DevTools:</h4><ul><li><strong>Scope панель:</strong> Показывает все доступные области видимости</li><li><strong>Closure раздел:</strong> Отображает переменные, захваченные замыканием</li><li><strong>Call Stack:</strong> Помогает понять контекст выполнения</li></ul><h4>2. Точки останова (Breakpoints):</h4><p>Устанавливайте breakpoint'ы внутри функций-замыканий для исследования состояния.</p><h4>Техники отладки:</h4><h4>1. Console.log стратегия:</h4><p>Логируйте переменные в разных точках для отслеживания изменений.</p><h4>2. Именование функций:</h4><p>Давайте имена анонимным функциям для лучшей читаемости стека вызовов.</p><h4>3. Проверка типов и значений:</h4><p>Используйте <code>typeof</code> и <code>console.dir</code> для детального анализа объектов.</p><h4>Распространенные проблемы:</h4><ul><li><strong>Неожиданные значения:</strong> Переменные изменились к моменту выполнения замыкания</li><li><strong>Утечки памяти:</strong> Замыкание держит большие объекты</li><li><strong>Performance проблемы:</strong> Слишком глубокая цепочка областей видимости</li></ul><h4>Best practices для отладки:</h4><ul><li>Используйте строгий режим (<code>'use strict'</code>)</li><li>Применяйте линтеры (ESLint) для раннего обнаружения проблем</li><li>Пишите тесты для функций с замыканиями</li><li>Документируйте сложные замыкания</li></ul><p><em>Хорошее понимание инструментов разработчика критично для эффективной отладки замыканий.</em></p>",
    difficulty: 'middle',
    tags: ['отладка', 'замыкания', 'DevTools', 'troubleshooting', 'инструменты']
  },
  {
    id: 32,
    question: "Что такое hoisting в JavaScript?",
    answer: "<p><strong>Hoisting (всплытие)</strong> — это механизм JavaScript, при котором объявления переменных и функций \"поднимаются\" в начало их области видимости во время фазы компиляции.</p><h4>Что происходит при hoisting:</h4><p>JavaScript движок перед выполнением кода сканирует его и \"поднимает\" все объявления в начало их области видимости. Это означает, что вы можете использовать переменные и функции до их фактического объявления в коде.</p><h4>Что всплывает:</h4><ul><li><strong>var переменные:</strong> Объявление всплывает, инициализация остается на месте</li><li><strong>Function declarations:</strong> Полностью всплывают (объявление + определение)</li><li><strong>let/const:</strong> Всплывают, но находятся в temporal dead zone</li></ul><h4>Что НЕ всплывает:</h4><ul><li>Function expressions</li><li>Arrow functions</li><li>Инициализация переменных</li></ul><p>Важно понимать, что всплывает только <em>объявление</em>, а не <em>инициализация</em> переменных.</p><p><em>Hoisting помогает понять порядок выполнения JavaScript кода и избежать неожиданных ошибок.</em></p>",
    difficulty: 'junior',
    tags: ['hoisting', 'основы', 'переменные', 'функции']
  },
  {
    id: 33,
    question: "Можем ли мы обращаться к переменной var до её определения в коде?",
    answer: "<p>Да, к переменной <code>var</code> можно обращаться до её определения в коде, но результат может быть неожиданным.</p><h4>Что происходит с var:</h4><p><strong>Объявление всплывает:</strong> Переменная <code>var</code> объявляется в начале области видимости и инициализируется значением <code>undefined</code>.</p><p><strong>Инициализация остается на месте:</strong> Присваивание значения происходит только в том месте, где написано в коде.</p><h4>Практический пример:</h4><p>Код ведет себя так, как если бы переменная была объявлена в начале функции со значением <code>undefined</code>.</p><h4>Особенности поведения:</h4><ul><li><strong>Доступ до объявления:</strong> Возвращает <code>undefined</code>, не выбрасывает ошибку</li><li><strong>Функциональная область видимости:</strong> <code>var</code> всплывает до начала функции или глобальной области</li><li><strong>Переопределение:</strong> Можно объявлять <code>var</code> с одинаковым именем несколько раз</li></ul><p><strong>Рекомендация:</strong> Всегда объявляйте переменные до их использования для лучшей читаемости кода.</p><p><em>Хотя это технически возможно, лучше избегать обращения к переменным до их объявления.</em></p>",
    difficulty: 'junior',
    tags: ['var', 'hoisting', 'undefined', 'область видимости']
  },
  {
    id: 34,
    question: "Можем ли мы обращаться к переменным let и const до их определения?",
    answer: "<p>Нет, обращение к переменным <code>let</code> и <code>const</code> до их определения приведет к <code>ReferenceError</code>.</p><h4>Temporal Dead Zone (TDZ):</h4><p><strong>Определение:</strong> Временная мертвая зона — это период между всплытием переменной и её инициализацией, когда переменная недоступна.</p><p><strong>Поведение:</strong> Переменные <code>let</code> и <code>const</code> всплывают, но остаются неинициализированными до строки объявления.</p><h4>Различия с var:</h4><ul><li><strong>var:</strong> Инициализируется как <code>undefined</code> при всплытии</li><li><strong>let/const:</strong> Остаются неинициализированными в TDZ</li></ul><h4>Типы ошибок:</h4><p><strong>ReferenceError:</strong> При обращении к <code>let/const</code> в TDZ.</p><p><strong>SyntaxError:</strong> При попытке объявить <code>const</code> без инициализации.</p><h4>Блочная область видимости:</h4><p><code>let</code> и <code>const</code> всплывают только до начала блока, а не функции.</p><p><strong>Преимущество TDZ:</strong> Помогает выявлять ошибки на раннем этапе и делает код более предсказуемым.</p><p><em>TDZ — это защитный механизм, предотвращающий использование переменных до их правильной инициализации.</em></p>",
    difficulty: 'junior',
    tags: ['let', 'const', 'temporal dead zone', 'ReferenceError', 'блочная область']
  },
  {
    id: 35,
    question: "Как ведут себя function declarations при hoisting?",
    answer: "<p><strong>Function declarations</strong> всплывают полностью — и объявление, и определение функции поднимаются в начало области видимости.</p><h4>Особенности поведения:</h4><p><strong>Полное всплытие:</strong> Функцию можно вызвать в любом месте её области видимости, даже до объявления в коде.</p><p><strong>Приоритет:</strong> Function declarations имеют приоритет над переменными с тем же именем.</p><h4>Область видимости:</h4><ul><li><strong>Глобальная область:</strong> Функция доступна везде</li><li><strong>Функциональная область:</strong> Всплывает до начала содержащей функции</li><li><strong>Блочная область (строгий режим):</strong> Всплывает только в пределах блока</li></ul><h4>Взаимодействие с переменными:</h4><p>Если есть переменная и функция с одинаковым именем, функция \"побеждает\" при hoisting.</p><h4>Strict mode особенности:</h4><p>В строгом режиме function declarations внутри блоков ведут себя как block-scoped.</p><h4>Best practices:</h4><ul><li>Объявляйте функции в начале области видимости</li><li>Используйте function expressions для условного создания функций</li><li>В блоках предпочитайте function expressions</li></ul><p><em>Function declarations — самый \"всплывающий\" тип объявлений в JavaScript.</em></p>",
    difficulty: 'junior',
    tags: ['function declaration', 'hoisting', 'область видимости', 'strict mode']
  },
  {
    id: 36,
    question: "Чем отличается hoisting function expressions от function declarations?",
    answer: "<p><strong>Function expressions</strong> ведут себя при hoisting совершенно по-разному по сравнению с function declarations.</p><h4>Function Declaration:</h4><ul><li><strong>Полное всплытие:</strong> И объявление, и определение всплывают</li><li><strong>Доступность:</strong> Можно вызвать до объявления в коде</li><li><strong>Синтаксис:</strong> Начинается с ключевого слова <code>function</code></li></ul><h4>Function Expression:</h4><ul><li><strong>Частичное всплытие:</strong> Всплывает только переменная, не функция</li><li><strong>Временная недоступность:</strong> До присваивания переменная равна <code>undefined</code></li><li><strong>Синтаксис:</strong> Функция присваивается переменной</li></ul><h4>Практическое различие:</h4><p>При попытке вызвать function expression до её объявления получаем <code>TypeError</code>, так как пытаемся вызвать <code>undefined</code> как функцию.</p><h4>Поведение с разными типами переменных:</h4><ul><li><strong>var expression:</strong> Переменная всплывает как <code>undefined</code></li><li><strong>let/const expression:</strong> Переменная в temporal dead zone</li></ul><h4>Рекомендации:</h4><p>Используйте function expressions для условного создания функций и когда порядок определения важен.</p><p><em>Понимание этого различия критично для избежания ошибок TypeError в коде.</em></p>",
    difficulty: 'junior',
    tags: ['function expression', 'function declaration', 'hoisting', 'TypeError']
  },
  {
    id: 37,
    question: "Что происходит при hoisting в блочной области видимости?",
    answer: "<p>В блочной области видимости hoisting работает по-разному для различных типов объявлений.</p><h4>Переменные let и const:</h4><p><strong>Блочное всплытие:</strong> Всплывают только до начала блока, не до начала функции.</p><p><strong>Temporal Dead Zone:</strong> Находятся в TDZ от начала блока до строки объявления.</p><h4>Переменные var:</h4><p><strong>Игнорирование блоков:</strong> <code>var</code> всплывает до начала функции, игнорируя блоки.</p><p><strong>Функциональная область:</strong> Ведет себя так, как если бы блоков не было.</p><h4>Function declarations в блоках:</h4><h4>Нестрогий режим:</h4><p>Функции всплывают до начала функции (как <code>var</code>).</p><h4>Строгий режим:</h4><p>Функции ведут себя как block-scoped (всплывают только в пределах блока).</p><h4>Практические примеры:</h4><p>В циклах <code>let</code> создает новую переменную на каждой итерации, <code>var</code> — одну на весь цикл.</p><h4>Best practices:</h4><ul><li>Используйте <code>let/const</code> вместо <code>var</code></li><li>Объявляйте переменные в начале блока</li><li>Включайте строгий режим</li></ul><p><em>Блочная область видимости делает hoisting более предсказуемым и безопасным.</em></p>",
    difficulty: 'middle',
    tags: ['блочная область', 'let', 'const', 'var', 'strict mode', 'temporal dead zone']
  },
  {
    id: 38,
    question: "Как hoisting работает с классами в JavaScript?",
    answer: "<p><strong>Классы в JavaScript</strong> ведут себя при hoisting аналогично <code>let</code> и <code>const</code> — они всплывают, но находятся в temporal dead zone.</p><h4>Class declarations:</h4><p><strong>Всплытие без инициализации:</strong> Класс всплывает, но остается неинициализированным до строки объявления.</p><p><strong>ReferenceError:</strong> Обращение к классу до объявления вызывает ошибку.</p><h4>Class expressions:</h4><p>Ведут себя как function expressions — всплывает переменная, но не значение класса.</p><h4>Особенности поведения:</h4><ul><li><strong>Temporal Dead Zone:</strong> Классы находятся в TDZ как <code>let/const</code></li><li><strong>Блочная область:</strong> Классы имеют block scope</li><li><strong>Строгий режим:</strong> Классы автоматически выполняются в строгом режиме</li></ul><h4>Методы класса:</h4><p>Методы класса не всплывают отдельно — они становятся доступными только после инициализации класса.</p><h4>Сравнение с функциями:</h4><ul><li><strong>Function declaration:</strong> Полностью всплывает</li><li><strong>Class declaration:</strong> Всплывает в TDZ</li></ul><h4>Наследование:</h4><p>При наследовании важен порядок объявления классов — родительский класс должен быть объявлен до дочернего.</p><p><em>Классы следуют современной семантике hoisting, предотвращая использование до инициализации.</em></p>",
    difficulty: 'middle',
    tags: ['классы', 'class declarations', 'temporal dead zone', 'блочная область']
  },
  {
    id: 39,
    question: "Объясните порядок приоритета при hoisting разных конструкций",
    answer: "<p>При hoisting в JavaScript существует определенный <strong>порядок приоритета</strong> между различными типами объявлений.</p><h4>Порядок приоритета (от высшего к низшему):</h4><h4>1. Function declarations:</h4><p><strong>Самый высокий приоритет:</strong> Функции всплывают первыми и полностью.</p><p><strong>Перезапись переменных:</strong> Могут \"перезаписать\" переменные с тем же именем.</p><h4>2. var переменные:</h4><p><strong>Второй приоритет:</strong> Всплывают после функций, инициализируются как <code>undefined</code>.</p><p><strong>Игнорируются при конфликте:</strong> Если есть функция с тем же именем, переменная игнорируется.</p><h4>3. let/const переменные:</h4><p><strong>Блочная область:</strong> Всплывают в пределах блока, находятся в TDZ.</p><p><strong>Ошибки при конфликте:</strong> Нельзя объявлять с тем же именем в одной области.</p><h4>Конфликты имен:</h4><p>При одинаковых именах function declaration \"побеждает\" var, но последующее присваивание var может перезаписать функцию.</p><h4>Современные best practices:</h4><ul><li>Избегайте конфликтов имен</li><li>Используйте <code>let/const</code> вместо <code>var</code></li><li>Объявляйте переменные и функции в начале области видимости</li><li>Используйте разные имена для переменных и функций</li></ul><p><em>Понимание приоритетов помогает избежать неожиданного поведения при конфликтах имен.</em></p>",
    difficulty: 'middle',
    tags: ['приоритет hoisting', 'конфликты имен', 'function declaration', 'var', 'let/const']
  },
  {
    id: 40,
    question: "Как hoisting ведет себя в разных контекстах выполнения?",
    answer: "<p>Hoisting ведет себя по-разному в зависимости от <strong>контекста выполнения</strong> — глобального, функционального или блочного.</p><h4>Глобальный контекст:</h4><ul><li><strong>var и function declarations:</strong> Становятся свойствами глобального объекта</li><li><strong>let/const:</strong> Не становятся свойствами глобального объекта</li><li><strong>Область видимости:</strong> Вся программа</li></ul><h4>Контекст функции:</h4><ul><li><strong>var:</strong> Всплывает до начала функции</li><li><strong>function declarations:</strong> Доступны во всей функции</li><li><strong>let/const:</strong> Блочная область видимости внутри функции</li><li><strong>Параметры:</strong> Создаются в начале выполнения функции</li></ul><h4>Блочный контекст:</h4><ul><li><strong>let/const:</strong> Всплывают только в пределах блока</li><li><strong>var:</strong> Игнорирует границы блока</li><li><strong>function declarations (strict):</strong> Блочная область видимости</li></ul><h4>Модульный контекст (ES6):</h4><ul><li><strong>Модульная область видимости:</strong> Переменные и функции ограничены модулем</li><li><strong>Строгий режим:</strong> Автоматически включен</li><li><strong>Экспорты:</strong> Имеют особую семантику hoisting</li></ul><h4>Eval контекст:</h4><p>Код в <code>eval()</code> создает собственную область видимости с особенностями hoisting.</p><p><em>Каждый контекст выполнения имеет свои правила hoisting и области видимости.</em></p>",
    difficulty: 'middle',
    tags: ['контекст выполнения', 'глобальная область', 'функциональная область', 'блочная область', 'модули']
  },
  {
    id: 41,
    question: "Что такое temporal dead zone и как она связана с hoisting?",
    answer: "<p><strong>Temporal Dead Zone (TDZ)</strong> — это период времени между всплытием переменной и её инициализацией, когда переменная недоступна для использования.</p><h4>Принцип работы TDZ:</h4><h4>1. Фаза всплытия:</h4><p>Переменные <code>let</code>, <code>const</code> и <code>class</code> всплывают в начало блока.</p><h4>2. Неинициализированное состояние:</h4><p>Переменные остаются в специальном неинициализированном состоянии.</p><h4>3. Инициализация:</h4><p>При достижении строки объявления переменная инициализируется и становится доступной.</p><h4>Конструкции в TDZ:</h4><ul><li><strong>let переменные:</strong> До строки объявления</li><li><strong>const переменные:</strong> До строки объявления с инициализацией</li><li><strong>class declarations:</strong> До строки объявления класса</li><li><strong>default параметры:</strong> При ссылке на следующие параметры</li></ul><h4>Типы ошибок в TDZ:</h4><p><strong>ReferenceError:</strong> При попытке доступа к переменной в TDZ.</p><p><strong>TypeError:</strong> При попытке присвоения const в TDZ.</p><h4>Преимущества TDZ:</h4><ul><li>Раннее обнаружение ошибок</li><li>Предотвращение использования неинициализированных переменных</li><li>Более предсказуемое поведение кода</li><li>Лучшая отладка</li></ul><p><em>TDZ — это защитный механизм, делающий JavaScript более безопасным и предсказуемым.</em></p>",
    difficulty: 'middle',
    tags: ['temporal dead zone', 'let', 'const', 'class', 'ReferenceError', 'безопасность']
  },
  {
    id: 42,
    question: "Как hoisting влияет на производительность JavaScript?",
    answer: "<p>Hoisting оказывает влияние на производительность JavaScript на нескольких уровнях — от парсинга до выполнения кода.</p><h4>Влияние на парсинг:</h4><h4>1. Фаза сканирования:</h4><p>JavaScript движок должен просканировать весь код перед выполнением для обнаружения всех объявлений.</p><h4>2. Создание лексического окружения:</h4><p>Дополнительные операции по созданию структур данных для hoisting.</p><h4>Влияние на выполнение:</h4><h4>1. Доступ к переменным:</h4><ul><li><strong>var переменные:</strong> Быстрый доступ, так как всегда инициализированы</li><li><strong>let/const:</strong> Дополнительные проверки TDZ</li></ul><h4>2. Поиск в областях видимости:</h4><p>Hoisting может создавать более глубокие цепочки областей видимости.</p><h4>Оптимизации движков:</h4><ul><li><strong>V8 оптимизации:</strong> Современные движки оптимизируют hoisting</li><li><strong>Inline caching:</strong> Кэширование доступа к переменным</li><li><strong>Hidden classes:</strong> Оптимизация структур объектов</li></ul><h4>Best practices для производительности:</h4><ul><li>Объявляйте переменные в начале области видимости</li><li>Используйте <code>const</code> где возможно (лучше оптимизируется)</li><li>Избегайте глубоких цепочек областей видимости</li><li>Минимизируйте количество переменных в замыканиях</li></ul><p><em>В современных движках влияние hoisting на производительность минимально благодаря оптимизациям.</em></p>",
    difficulty: 'senior',
    tags: ['производительность', 'оптимизация', 'V8', 'парсинг', 'лексическое окружение']
  },
  {
    id: 43,
    question: "Объясните особенности hoisting в модулях ES6",
    answer: "<p>В <strong>ES6 модулях</strong> hoisting имеет особенности, связанные с import/export декларациями и строгим режимом.</p><h4>Import hoisting:</h4><p><strong>Полное всплытие:</strong> Import декларации всплывают в самое начало модуля, до всех остальных инструкций.</p><p><strong>Статическая природа:</strong> Импорты обрабатываются во время парсинга, не во время выполнения.</p><h4>Export hoisting:</h4><ul><li><strong>Named exports:</strong> Всплывают аналогично обычным объявлениям</li><li><strong>Default exports:</strong> Зависят от типа экспортируемого значения</li><li><strong>Re-exports:</strong> Обрабатываются статически</li></ul><h4>Особенности модульной области:</h4><ul><li><strong>Строгий режим:</strong> Автоматически включен во всех модулях</li><li><strong>Изолированная область:</strong> Переменные не становятся глобальными</li><li><strong>TDZ семантика:</strong> let/const ведут себя как в блоках</li></ul><h4>Циркулярные зависимости:</h4><p>Hoisting позволяет модулям ссылаться друг на друга, но могут возникать проблемы с TDZ.</p><h4>Сравнение с CommonJS:</h4><ul><li><strong>ES6 модули:</strong> Статический анализ, hoisting импортов</li><li><strong>CommonJS:</strong> Динамическая загрузка, никакого hoisting</li></ul><h4>Best practices:</h4><ul><li>Размещайте импорты в начале файла</li><li>Избегайте циркулярных зависимостей</li><li>Используйте статический анализ (ESLint)</li></ul><p><em>Hoisting в модулях обеспечивает статический анализ и лучшую оптимизацию bundler'ами.</em></p>",
    difficulty: 'senior',
    tags: ['ES6 модули', 'import/export', 'статический анализ', 'циркулярные зависимости']
  },
  {
    id: 44,
    question: "Как работает hoisting при деструктуризации?",
    answer: "<p><strong>Деструктуризация</strong> в JavaScript подчиняется тем же правилам hoisting, что и обычные объявления переменных, но с некоторыми нюансами.</p><h4>Деструктуризация с var:</h4><p><strong>Всплытие объявлений:</strong> Все переменные из деструктуризации всплывают как обычные <code>var</code> переменные.</p><p><strong>Инициализация на месте:</strong> Значения присваиваются только при выполнении строки деструктуризации.</p><h4>Деструктуризация с let/const:</h4><p><strong>TDZ поведение:</strong> Все переменные находятся в temporal dead zone до строки объявления.</p><p><strong>Атомарность:</strong> Если деструктуризация не удалась, переменные остаются неинициализированными.</p><h4>Параметры функций:</h4><p>Деструктуризация параметров создает переменные в области видимости функции с особой семантикой.</p><h4>Вложенная деструктуризация:</h4><p>При глубокой деструктуризации все переменные всех уровней всплывают согласно своему типу объявления.</p><h4>Значения по умолчанию:</h4><p>Default значения в деструктуризации вычисляются только при выполнении, не при hoisting.</p><h4>Практические особенности:</h4><ul><li><strong>Rest параметры:</strong> Всплывают как обычные переменные</li><li><strong>Переименование:</strong> Новые имена всплывают</li><li><strong>Computed properties:</strong> Вычисляются при выполнении</li></ul><p><em>Деструктуризация не изменяет базовые правила hoisting, но добавляет сложности в понимание.</em></p>",
    difficulty: 'senior',
    tags: ['деструктуризация', 'var', 'let/const', 'параметры функций', 'temporal dead zone']
  },
  {
    id: 45,
    question: "Объясните hoisting в контексте async/await и generators",
    answer: "<p><strong>Async/await</strong> и <strong>generators</strong> создают специальные контексты выполнения с особенностями hoisting.</p><h4>Async функции:</h4><p><strong>Объявления async функций:</strong> Всплывают полностью, как обычные function declarations.</p><p><strong>Внутренняя область видимости:</strong> Hoisting внутри async функций работает стандартно.</p><p><strong>Await выражения:</strong> Не влияют на hoisting, но создают точки приостановки выполнения.</p><h4>Generator функции:</h4><p><strong>Function* declarations:</strong> Всплывают полностью, возвращают generator объект.</p><p><strong>Yield выражения:</strong> Не влияют на hoisting, но создают точки паузы.</p><p><strong>Локальные переменные:</strong> Сохраняют состояние между вызовами next().</p><h4>Особенности выполнения:</h4><h4>1. Состояние переменных:</h4><p>В generators переменные сохраняют состояние между паузами благодаря замыканиям.</p><h4>2. Область видимости:</h4><p>Каждый вызов generator.next() продолжает выполнение в том же лексическом окружении.</p><h4>3. Async итераторы:</h4><p>Комбинация async/await и generators создает сложные сценарии hoisting.</p><h4>Практические аспекты:</h4><ul><li>Hoisting работает при создании функции, не при её выполнении</li><li>Переменные в generators \"живут\" между вызовами</li><li>TDZ действует как в обычных функциях</li></ul><p><em>Async/await и generators не изменяют базовые правила hoisting, но создают сложные сценарии выполнения.</em></p>",
    difficulty: 'senior',
    tags: ['async/await', 'generators', 'асинхронность', 'состояние переменных', 'лексическое окружение']
  },
  {
    id: 46,
    question: "Как оптимизировать код с учетом особенностей hoisting?",
    answer: "<p>Понимание hoisting позволяет писать более <strong>оптимизированный и предсказуемый код</strong> с лучшей производительностью.</p><h4>Стратегии оптимизации:</h4><h4>1. Выбор типа переменных:</h4><ul><li><strong>const:</strong> Используйте где возможно — лучше оптимизируется движками</li><li><strong>let:</strong> Для изменяемых переменных с блочной областью видимости</li><li><strong>Избегайте var:</strong> Функциональная область видимости менее предсказуема</li></ul><h4>2. Объявление в начале области:</h4><p><strong>Читаемость:</strong> Объявляйте переменные и функции в начале их области видимости.</p><p><strong>Производительность:</strong> Минимизирует работу парсера и улучшает inline optimization.</p><h4>3. Минимизация областей видимости:</h4><ul><li>Используйте блочную область видимости для ограничения жизни переменных</li><li>Избегайте глубоких цепочек замыканий</li><li>Создавайте локальные переменные вместо глобальных</li></ul><h4>4. Оптимизация функций:</h4><ul><li><strong>Function declarations:</strong> Для основных функций программы</li><li><strong>Function expressions:</strong> Для условного создания и callback'ов</li><li><strong>Arrow functions:</strong> Для простых операций без собственного this</li></ul><h4>Инструменты и техники:</h4><ul><li><strong>ESLint правила:</strong> no-use-before-define, prefer-const</li><li><strong>TypeScript:</strong> Статическая типизация выявляет проблемы hoisting</li><li><strong>Bundler optimization:</strong> Webpack и другие используют hoisting для tree shaking</li></ul><p><em>Правильное использование hoisting улучшает как читаемость, так и производительность кода.</em></p>",
    difficulty: 'senior',
    tags: ['оптимизация', 'производительность', 'best practices', 'ESLint', 'читаемость кода']
  },
  {
    id: 47,
    question: "Какие проблемы может создать неправильное понимание hoisting и как их избежать?",
    answer: "<p>Неправильное понимание hoisting может привести к <strong>серьезным ошибкам</strong> и неожиданному поведению программы.</p><h4>Типичные проблемы:</h4><h4>1. Использование переменных до объявления:</h4><p><strong>Проблема:</strong> Обращение к <code>var</code> переменным до их инициализации возвращает <code>undefined</code>.</p><p><strong>Решение:</strong> Всегда объявляйте переменные перед использованием, используйте <code>let/const</code>.</p><h4>2. Конфликты имен:</h4><p><strong>Проблема:</strong> Function declarations могут неожиданно \"перезаписать\" переменные.</p><p><strong>Решение:</strong> Используйте уникальные имена, следуйте naming conventions.</p><h4>3. Циклы с замыканиями:</h4><p><strong>Проблема:</strong> <code>var</code> в циклах создает общую переменную для всех итераций.</p><p><strong>Решение:</strong> Используйте <code>let</code> в циклах или IIFE.</p><h4>4. Temporal Dead Zone ошибки:</h4><p><strong>Проблема:</strong> ReferenceError при обращении к <code>let/const</code> до объявления.</p><p><strong>Решение:</strong> Объявляйте переменные перед использованием.</p><h4>Превентивные меры:</h4><ul><li><strong>Strict mode:</strong> Включайте 'use strict' для раннего обнаружения ошибок</li><li><strong>Линтеры:</strong> Используйте ESLint с правилами для hoisting</li><li><strong>TypeScript:</strong> Статическая типизация предотвращает многие проблемы</li><li><strong>Code review:</strong> Проверяйте код на правильное использование hoisting</li><li><strong>Тестирование:</strong> Пишите тесты для критических участков кода</li></ul><h4>Best practices:</h4><ul><li>Предпочитайте <code>const</code> → <code>let</code> → избегайте <code>var</code></li><li>Объявляйте переменные в начале области видимости</li><li>Используйте функциональные выражения для условного создания</li><li>Документируйте сложные случаи hoisting</li></ul><p><em>Профилактика проблем hoisting — ключ к написанию надежного JavaScript кода.</em></p>",
    difficulty: 'senior',
    tags: ['проблемы hoisting', 'отладка', 'ошибки', 'best practices', 'профилактика', 'ESLint']
  },
  // Добавить эти вопросы к существующему массиву jsInterviewQuestions:

  {
    id: 48,
    question: "Для чего нам нужна асинхронность в JavaScript?",
    answer: "<p><strong>Асинхронность</strong> — это возможность выполнения операций без блокировки основного потока выполнения программы.</p><h4>Зачем нужна асинхронность:</h4><h4>1. Неблокирующий пользовательский интерфейс:</h4><p>Позволяет интерфейсу оставаться отзывчивым во время выполнения длительных операций.</p><h4>2. Обработка сетевых запросов:</h4><p>HTTP-запросы, загрузка файлов, обращения к API выполняются асинхронно.</p><h4>3. Работа с файловой системой:</h4><p>Чтение и запись файлов без блокировки программы.</p><h4>4. Таймеры и отложенное выполнение:</h4><p>setTimeout, setInterval позволяют планировать выполнение кода.</p><h4>Проблемы синхронного подхода:</h4><ul><li><strong>Блокировка потока:</strong> Длительные операции замораживают интерфейс</li><li><strong>Плохой UX:</strong> Пользователь не может взаимодействовать с приложением</li><li><strong>Неэффективность:</strong> Простой ресурсов во время ожидания</li></ul><h4>Примеры асинхронных операций:</h4><ul><li>Запросы к серверу (fetch, XMLHttpRequest)</li><li>Работа с базами данных</li><li>Анимации и переходы</li><li>Обработка пользовательских событий</li></ul><p><em>Асинхронность — основа современных веб-приложений и пользовательского опыта.</em></p>",
    difficulty: 'junior',
    tags: ['асинхронность', 'основы', 'пользовательский интерфейс', 'производительность']
  },
  {
    id: 49,
    question: "Что такое callback функции и какие у них проблемы?",
    answer: "<p><strong>Callback функции</strong> — это функции, которые передаются как аргументы другим функциям и вызываются после завершения асинхронной операции.</p><h4>Принцип работы callback:</h4><p>Функция принимает callback как параметр и вызывает его при завершении операции, передавая результат или ошибку.</p><h4>Проблемы callback функций:</h4><h4>1. Callback Hell (Пирамида Doom):</h4><p>Вложенные callback'и создают трудночитаемый код с глубокой вложенностью.</p><h4>2. Обработка ошибок:</h4><p>Сложно обрабатывать ошибки в цепочке callback'ов, нет единого механизма.</p><h4>3. Потеря контроля:</h4><p>Передавая callback третьей стороне, мы теряем контроль над его выполнением.</p><h4>4. Отсутствие композиции:</h4><p>Сложно комбинировать и переиспользовать асинхронные операции.</p><h4>Паттерны с callback:</h4><ul><li><strong>Error-first callback:</strong> Первый параметр — ошибка, второй — результат</li><li><strong>Node.js style:</strong> callback(error, result)</li></ul><p>До появления промисов callback'и были основным способом работы с асинхронностью в JavaScript.</p><p><em>Callback функции заложили основу асинхронного программирования, но имеют серьезные ограничения.</em></p>",
    difficulty: 'junior',
    tags: ['callback', 'асинхронность', 'callback hell', 'обработка ошибок']
  },
  {
    id: 50,
    question: "Что такое Promise и какие состояния у него есть?",
    answer: "<p><strong>Promise</strong> — это объект, представляющий результат асинхронной операции, который может быть доступен сейчас, в будущем или никогда.</p><h4>Три состояния Promise:</h4><h4>1. Pending (Ожидание):</h4><p><strong>Начальное состояние:</strong> Операция еще не завершена, результат неизвестен.</p><p><strong>Переходы:</strong> Может перейти в fulfilled или rejected.</p><h4>2. Fulfilled (Выполнено):</h4><p><strong>Успешное завершение:</strong> Операция завершилась успешно, есть результат.</p><p><strong>Финальное состояние:</strong> Нельзя изменить состояние или значение.</p><h4>3. Rejected (Отклонено):</h4><p><strong>Неудачное завершение:</strong> Операция завершилась с ошибкой.</p><p><strong>Финальное состояние:</strong> Содержит причину отклонения (ошибку).</p><h4>Важные особенности:</h4><ul><li><strong>Immutable:</strong> После перехода в финальное состояние Promise нельзя изменить</li><li><strong>Thenable:</strong> Можно присоединить обработчики через .then()</li><li><strong>Chainable:</strong> Поддерживает цепочки вызовов</li></ul><h4>Преимущества перед callback:</h4><ul><li>Лучшая обработка ошибок</li><li>Избежание callback hell</li><li>Композиция операций</li><li>Стандартизированный API</li></ul><p><em>Promise решает основные проблемы callback'ов и становится стандартом асинхронного программирования.</em></p>",
    difficulty: 'junior',
    tags: ['Promise', 'состояния', 'pending', 'fulfilled', 'rejected']
  },
  {
    id: 51,
    question: "Как создать и использовать Promise?",
    answer: "<p>Promise создается с помощью конструктора, принимающего <strong>executor функцию</strong> с параметрами resolve и reject.</p><h4>Создание Promise:</h4><p><strong>Executor функция:</strong> Выполняется немедленно при создании Promise и получает две функции — resolve и reject.</p><h4>Основные методы Promise:</h4><h4>1. .then(onFulfilled, onRejected):</h4><p>Обрабатывает успешное выполнение и ошибки, возвращает новый Promise.</p><h4>2. .catch(onRejected):</h4><p>Обрабатывает только ошибки, эквивалент .then(null, onRejected).</p><h4>3. .finally(onFinally):</h4><p>Выполняется независимо от результата Promise.</p><h4>Цепочки Promise:</h4><p>Каждый .then() возвращает новый Promise, что позволяет создавать цепочки асинхронных операций.</p><h4>Обработка ошибок:</h4><p>Ошибки \"всплывают\" по цепочке до ближайшего .catch() обработчика.</p><h4>Возврат значений:</h4><ul><li><strong>Обычное значение:</strong> Автоматически оборачивается в resolved Promise</li><li><strong>Promise:</strong> Возвращается как есть</li><li><strong>Thenable объект:</strong> Преобразуется в Promise</li></ul><p><em>Promise предоставляет элегантный API для работы с асинхронными операциями.</em></p>",
    difficulty: 'junior',
    tags: ['Promise', 'создание', 'then', 'catch', 'finally', 'цепочки']
  },
  {
    id: 52,
    question: "Что такое async/await и как они работают?",
    answer: "<p><strong>Async/await</strong> — это синтаксический сахар над Promise, делающий асинхронный код похожим на синхронный.</p><h4>Async функции:</h4><p><strong>Объявление:</strong> Функция с ключевым словом <code>async</code> всегда возвращает Promise.</p><p><strong>Автоматическое оборачивание:</strong> Возвращаемое значение автоматически оборачивается в resolved Promise.</p><h4>Await выражения:</h4><p><strong>Ожидание Promise:</strong> <code>await</code> приостанавливает выполнение функции до разрешения Promise.</p><p><strong>Только в async функциях:</strong> <code>await</code> можно использовать только внутри async функций.</p><h4>Преимущества async/await:</h4><ul><li><strong>Читаемость:</strong> Код выглядит как синхронный</li><li><strong>Отладка:</strong> Проще ставить breakpoint'ы и отслеживать выполнение</li><li><strong>Обработка ошибок:</strong> Можно использовать try/catch</li><li><strong>Условная логика:</strong> Легче писать условия и циклы</li></ul><h4>Обработка ошибок:</h4><p>Используйте try/catch блоки для обработки rejected Promise.</p><h4>Parallel выполнение:</h4><p>Для параллельного выполнения используйте Promise.all() с await.</p><p><em>Async/await — современный стандарт для написания асинхронного JavaScript кода.</em></p>",
    difficulty: 'junior',
    tags: ['async/await', 'синтаксический сахар', 'Promise', 'читаемость', 'обработка ошибок']
  },
  {
    id: 53,
    question: "Что такое Event Loop и как он работает?",
    answer: "<p><strong>Event Loop</strong> — это механизм, который позволяет JavaScript выполнять асинхронные операции в однопоточной среде.</p><h4>Компоненты Event Loop:</h4><h4>1. Call Stack (Стек вызовов):</h4><p>Хранит текущие выполняющиеся функции в порядке LIFO.</p><h4>2. Web APIs:</h4><p>Браузерные API (setTimeout, DOM events, HTTP requests), которые работают вне основного потока.</p><h4>3. Callback Queue (Очередь колбэков):</h4><p>Очередь функций, готовых к выполнению после завершения асинхронных операций.</p><h4>4. Microtask Queue:</h4><p>Приоритетная очередь для Promise callbacks и queueMicrotask.</p><h4>Алгоритм работы:</h4><ol><li>Выполняется код из Call Stack</li><li>Асинхронные операции передаются в Web APIs</li><li>По завершении callback'и попадают в соответствующие очереди</li><li>Event Loop проверяет пустой ли Call Stack</li><li>Сначала обрабатываются все microtask'и</li><li>Затем один callback из Callback Queue</li></ol><h4>Приоритеты:</h4><p><strong>Microtasks</strong> (Promise, queueMicrotask) имеют приоритет над <strong>macrotasks</strong> (setTimeout, setInterval).</p><p><em>Event Loop — сердце асинхронности в JavaScript, обеспечивающее неблокирующее выполнение.</em></p>",
    difficulty: 'middle',
    tags: ['Event Loop', 'Call Stack', 'очереди', 'microtasks', 'macrotasks']
  },
  {
    id: 54,
    question: "В чем разница между microtasks и macrotasks?",
    answer: "<p><strong>Microtasks</strong> и <strong>macrotasks</strong> — это разные типы асинхронных задач с различными приоритетами выполнения.</p><h4>Microtasks (Микрозадачи):</h4><p><strong>Высокий приоритет:</strong> Выполняются перед любыми macrotask'ами.</p><p><strong>Примеры:</strong></p><ul><li>Promise callbacks (.then, .catch, .finally)</li><li>queueMicrotask()</li><li>async/await</li><li>MutationObserver callbacks</li></ul><h4>Macrotasks (Макрозадачи):</h4><p><strong>Обычный приоритет:</strong> Выполняются после всех microtask'ов.</p><p><strong>Примеры:</strong></p><ul><li>setTimeout/setInterval</li><li>setImmediate (Node.js)</li><li>DOM events</li><li>HTTP requests callbacks</li><li>I/O operations</li></ul><h4>Порядок выполнения:</h4><ol><li>Выполняется текущий синхронный код</li><li>Обрабатываются ВСЕ microtask'и в очереди</li><li>Выполняется ОДИН macrotask</li><li>Снова обрабатываются ВСЕ microtask'и</li><li>Повторяется цикл</li></ol><h4>Практические последствия:</h4><p><strong>Starving macrotasks:</strong> Большое количество microtask'ов может заблокировать выполнение macrotask'ов.</p><p><em>Понимание различий критично для предсказуемого асинхронного кода.</em></p>",
    difficulty: 'middle',
    tags: ['microtasks', 'macrotasks', 'приоритеты', 'Event Loop', 'порядок выполнения']
  },
  {
    id: 55,
    question: "Как работает Promise.all() и когда его использовать?",
    answer: "<p><strong>Promise.all()</strong> — это метод для параллельного выполнения нескольких Promise и ожидания завершения всех операций.</p><h4>Принцип работы:</h4><p><strong>Вход:</strong> Принимает итерируемую коллекцию (обычно массив) Promise'ов.</p><p><strong>Выход:</strong> Возвращает Promise, который разрешается массивом результатов в том же порядке.</p><h4>Поведение при ошибках:</h4><p><strong>Fail-fast:</strong> Если хотя бы один Promise отклоняется, Promise.all немедленно отклоняется с этой ошибкой.</p><p><strong>Остальные операции:</strong> Продолжают выполняться, но их результаты игнорируются.</p><h4>Когда использовать:</h4><ul><li><strong>Независимые операции:</strong> Когда операции не зависят друг от друга</li><li><strong>Все результаты нужны:</strong> Когда требуются результаты всех операций</li><li><strong>Производительность:</strong> Для ускорения выполнения через параллелизм</li><li><strong>Атомарность:</strong> Когда нужно \"все или ничего\"</li></ul><h4>Практические примеры:</h4><ul><li>Загрузка данных из нескольких API</li><li>Параллельная обработка файлов</li><li>Валидация нескольких полей формы</li><li>Инициализация компонентов приложения</li></ul><h4>Альтернативы:</h4><p>Для других сценариев рассмотрите Promise.allSettled(), Promise.race(), или Promise.any().</p><p><em>Promise.all() — основной инструмент для параллельного выполнения асинхронных операций.</em></p>",
    difficulty: 'middle',
    tags: ['Promise.all', 'параллельное выполнение', 'fail-fast', 'производительность']
  },
  {
    id: 56,
    question: "Объясните различия между Promise.race(), Promise.any(), Promise.allSettled()",
    answer: "<p>Эти методы предоставляют разные стратегии для работы с коллекциями Promise'ов.</p><h4>Promise.race():</h4><p><strong>\"Первый финиширует\":</strong> Возвращает результат первого завершившегося Promise (успешно или с ошибкой).</p><p><strong>Использование:</strong> Timeouts, выбор самого быстрого сервера, гонка между операциями.</p><h4>Promise.any():</h4><p><strong>\"Первый успешный\":</strong> Возвращает результат первого успешно разрешенного Promise.</p><p><strong>Ошибка:</strong> Отклоняется только если ВСЕ Promise отклонены (AggregateError).</p><p><strong>Использование:</strong> Fallback стратегии, попытки подключения к нескольким серверам.</p><h4>Promise.allSettled():</h4><p><strong>\"Ждет всех\":</strong> Ждет завершения всех Promise независимо от результата.</p><p><strong>Результат:</strong> Массив объектов с status ('fulfilled'/'rejected') и value/reason.</p><p><strong>Использование:</strong> Когда нужна информация о всех операциях, независимо от успеха.</p><h4>Сравнительная таблица:</h4><ul><li><strong>Promise.all:</strong> Все успешны ИЛИ первая ошибка</li><li><strong>Promise.race:</strong> Первый завершенный (любой результат)</li><li><strong>Promise.any:</strong> Первый успешный ИЛИ все ошибки</li><li><strong>Promise.allSettled:</strong> Все завершены (все результаты)</li></ul><p><em>Выбор метода зависит от требуемой стратегии обработки результатов.</em></p>",
    difficulty: 'middle',
    tags: ['Promise.race', 'Promise.any', 'Promise.allSettled', 'стратегии', 'сравнение']
  },
  {
    id: 57,
    question: "Как обрабатывать ошибки в асинхронном коде?",
    answer: "<p>Правильная <strong>обработка ошибок</strong> в асинхронном коде критична для стабильности приложения.</p><h4>Обработка в Promise:</h4><h4>1. .catch() метод:</h4><p>Перехватывает ошибки в цепочке Promise'ов.</p><h4>2. .then() с onRejected:</h4><p>Второй параметр .then() обрабатывает ошибки текущего Promise.</p><h4>3. .finally():</h4><p>Выполняется независимо от результата для cleanup операций.</p><h4>Обработка в async/await:</h4><h4>1. try/catch блоки:</h4><p>Стандартный способ обработки ошибок в async функциях.</p><h4>2. Обработка на уровне вызова:</h4><p>Можно обрабатывать ошибки при вызове async функции.</p><h4>Паттерны обработки ошибок:</h4><ul><li><strong>Global error handlers:</strong> window.onunhandledrejection</li><li><strong>Error boundaries:</strong> В React для компонентов</li><li><strong>Centralized logging:</strong> Логирование всех ошибок в одном месте</li><li><strong>Graceful degradation:</strong> Fallback при ошибках</li></ul><h4>Best practices:</h4><ul><li>Всегда обрабатывайте rejected Promise'ы</li><li>Используйте специфичные типы ошибок</li><li>Логируйте ошибки для отладки</li><li>Предоставляйте fallback значения</li><li>Показывайте понятные сообщения пользователю</li></ul><p><em>Хорошая обработка ошибок — залог надежного асинхронного кода.</em></p>",
    difficulty: 'middle',
    tags: ['обработка ошибок', 'try/catch', 'catch', 'async/await', 'best practices']
  },
  {
    id: 58,
    question: "Что такое неблокирующий I/O и как он реализован в JavaScript?",
    answer: "<p><strong>Неблокирующий I/O</strong> — это способ выполнения операций ввода-вывода без остановки выполнения основного потока программы.</p><h4>Принцип неблокирующего I/O:</h4><p><strong>Асинхронность:</strong> Операции запускаются и возвращают управление немедленно, не дожидаясь завершения.</p><p><strong>Callback/Promise:</strong> Результат обрабатывается через колбэки или Promise'ы.</p><h4>Реализация в JavaScript:</h4><h4>1. Browser APIs:</h4><ul><li><strong>XMLHttpRequest/fetch:</strong> HTTP запросы</li><li><strong>File API:</strong> Работа с файлами</li><li><strong>IndexedDB:</strong> Работа с базой данных браузера</li><li><strong>Web Workers:</strong> Вычисления в фоновом потоке</li></ul><h4>2. Node.js APIs:</h4><ul><li><strong>fs module:</strong> Файловая система</li><li><strong>http module:</strong> HTTP сервер/клиент</li><li><strong>streams:</strong> Потоковая обработка данных</li><li><strong>child_process:</strong> Запуск внешних процессов</li></ul><h4>Преимущества:</h4><ul><li><strong>Отзывчивость:</strong> UI остается интерактивным</li><li><strong>Производительность:</strong> Эффективное использование ресурсов</li><li><strong>Масштабируемость:</strong> Обработка множества операций одновременно</li></ul><h4>Реализация на уровне ОС:</h4><p>JavaScript движки используют системные механизмы (epoll, kqueue, IOCP) для неблокирующих операций.</p><p><em>Неблокирующий I/O — основа высокопроизводительных JavaScript приложений.</em></p>",
    difficulty: 'senior',
    tags: ['неблокирующий I/O', 'производительность', 'Node.js', 'Browser APIs', 'масштабируемость']
  },
  {
    id: 59,
    question: "Как работают генераторы с асинхронным кодом?",
    answer: "<p><strong>Генераторы</strong> могут эффективно использоваться для работы с асинхронным кодом, создавая мощные паттерны управления потоком выполнения.</p><h4>Async генераторы:</h4><p><strong>async function*:</strong> Комбинируют возможности генераторов и async/await.</p><p><strong>yield await:</strong> Могут приостанавливаться на асинхронных операциях.</p><h4>Паттерны использования:</h4><h4>1. Async итерация:</h4><p>Обработка потоков данных с использованием for await...of.</p><h4>2. Корутины:</h4><p>Функции, которые могут приостанавливаться и возобновляться.</p><h4>3. Управление состоянием:</h4><p>Создание state машин с асинхронными переходами.</p><h4>Преимущества:</h4><ul><li><strong>Ленивая загрузка:</strong> Данные загружаются по мере необходимости</li><li><strong>Управление памятью:</strong> Обработка больших наборов данных по частям</li><li><strong>Отмена операций:</strong> Возможность прервать выполнение</li><li><strong>Backpressure:</strong> Контроль скорости обработки</li></ul><h4>Практические применения:</h4><ul><li>Обработка больших файлов</li><li>Пагинация API запросов</li><li>Потоковая обработка данных</li><li>Реализация async итераторов</li></ul><h4>Сравнение с обычными Promise:</h4><p>Генераторы предоставляют больше контроля над выполнением, но требуют больше кода для обработки.</p><p><em>Async генераторы — мощный инструмент для сложных сценариев асинхронной обработки.</em></p>",
    difficulty: 'senior',
    tags: ['генераторы', 'async generators', 'итерация', 'потоки данных', 'корутины']
  },
  {
    id: 60,
    question: "Что такое AbortController и как управлять отменой асинхронных операций?",
    answer: "<p><strong>AbortController</strong> — это Web API для отмены асинхронных операций, предоставляющий стандартизированный способ прерывания выполнения.</p><h4>Основные компоненты:</h4><h4>1. AbortController:</h4><p>Контроллер, который может послать сигнал отмены.</p><h4>2. AbortSignal:</h4><p>Сигнал, который передается в асинхронные операции для отслеживания отмены.</p><h4>Использование с fetch:</h4><p>Передача signal в опциях fetch позволяет отменить HTTP запрос.</p><h4>Использование с Promise:</h4><p>Создание отменяемых Promise'ов через проверку signal.aborted.</p><h4>Обработка отмены:</h4><p><strong>AbortError:</strong> При отмене генерируется специальная ошибка 'AbortError'.</p><p><strong>Event listener:</strong> Можно подписаться на событие 'abort'.</p><h4>Практические применения:</h4><ul><li><strong>HTTP запросы:</strong> Отмена запросов при смене страницы</li><li><strong>Timeout:</strong> Автоматическая отмена по таймауту</li><li><strong>User interaction:</strong> Отмена по действию пользователя</li><li><strong>Cleanup:</strong> Освобождение ресурсов при размонтировании компонентов</li></ul><h4>Best practices:</h4><ul><li>Всегда обрабатывайте AbortError</li><li>Передавайте signal через всю цепочку операций</li><li>Комбинируйте с timeout'ами</li><li>Используйте в React useEffect cleanup</li></ul><p><em>AbortController — современный стандарт для управления жизненным циклом асинхронных операций.</em></p>",
    difficulty: 'senior',
    tags: ['AbortController', 'отмена операций', 'fetch', 'timeout', 'управление ресурсами']
  },
  {
    id: 61,
    question: "Как оптимизировать производительность асинхронного кода?",
    answer: "<p>Оптимизация асинхронного кода включает множество стратегий для улучшения <strong>производительности</strong> и <strong>пользовательского опыта</strong>.</p><h4>Стратегии параллелизации:</h4><h4>1. Promise.all() для независимых операций:</h4><p>Выполнение независимых операций параллельно вместо последовательно.</p><h4>2. Batch операции:</h4><p>Группировка множественных запросов в один batch.</p><h4>Кэширование:</h4><ul><li><strong>Мемоизация:</strong> Кэширование результатов дорогих асинхронных операций</li><li><strong>HTTP кэширование:</strong> Использование заголовков кэширования</li><li><strong>Service Workers:</strong> Кэширование на уровне браузера</li></ul><h4>Оптимизация сетевых запросов:</h4><ul><li><strong>Connection pooling:</strong> Переиспользование HTTP соединений</li><li><strong>Request deduplication:</strong> Избежание дублирующихся запросов</li><li><strong>Compression:</strong> Сжатие данных (gzip, brotli)</li><li><strong>CDN:</strong> Использование географически распределенных серверов</li></ul><h4>Управление ресурсами:</h4><ul><li><strong>Lazy loading:</strong> Загрузка данных по мере необходимости</li><li><strong>Pagination:</strong> Разбиение больших наборов данных</li><li><strong>Throttling/Debouncing:</strong> Ограничение частоты запросов</li><li><strong>AbortController:</strong> Отмена ненужных операций</li></ul><h4>Мониторинг и профилирование:</h4><ul><li>Performance API для измерения времени</li><li>DevTools для анализа network activity</li><li>Метрики пользовательского опыта (LCP, FID, CLS)</li></ul><p><em>Комплексный подход к оптимизации обеспечивает максимальную производительность асинхронных операций.</em></p>",
    difficulty: 'senior',
    tags: ['оптимизация', 'производительность', 'кэширование', 'параллелизация', 'сетевые запросы']
  },
  {
    id: 62,
    question: "Объясните сложные паттерны асинхронного программирования (Saga, Worker pools, Streaming)",
    answer: "<p>Сложные паттерны асинхронного программирования решают специфические задачи в enterprise приложениях и высоконагруженных системах.</p><h4>Saga Pattern:</h4><p><strong>Назначение:</strong> Управление длительными бизнес-процессами и обеспечение консистентности данных в распределенных системах.</p><p><strong>Принцип:</strong> Последовательность шагов с возможностью компенсации (rollback) при ошибках.</p><p><strong>Реализация:</strong> Generator функции для описания пошагового выполнения операций.</p><p><strong>Применение:</strong> Redux-Saga, оркестрация микросервисов, сложные формы с валидацией.</p><h4>Worker Pools:</h4><p><strong>Назначение:</strong> Параллельная обработка задач с ограничением количества одновременных операций.</p><p><strong>Принцип:</strong> Очередь задач обрабатывается ограниченным числом worker'ов.</p><p><strong>Преимущества:</strong> Контроль нагрузки, предотвращение перегрузки системы, управление ресурсами.</p><p><strong>Применение:</strong> Обработка изображений, массовые API запросы, файловые операции.</p><h4>Streaming:</h4><p><strong>Назначение:</strong> Обработка больших объемов данных по частям без загрузки всего набора в память.</p><p><strong>Типы:</strong> Readable, Writable, Transform, Duplex streams.</p><p><strong>Backpressure:</strong> Механизм контроля скорости обработки для предотвращения переполнения буферов.</p><p><strong>Применение:</strong> Обработка больших файлов, real-time данные, потоковое видео/аудио.</p><h4>Reactive Programming:</h4><ul><li><strong>Observables:</strong> Потоки данных с операторами для трансформации</li><li><strong>RxJS:</strong> Библиотека для реактивного программирования</li><li><strong>Event sourcing:</strong> Хранение изменений как последовательности событий</li></ul><p><em>Эти паттерны обеспечивают масштабируемость и надежность в сложных асинхронных системах.</em></p>",
    difficulty: 'senior',
    tags: ['Saga pattern', 'Worker pools', 'Streaming', 'reactive programming', 'архитектурные паттерны']
  },
  // Добавить эти вопросы к существующему массиву jsInterviewQuestions:

  {
    id: 63,
    question: "Что такое Event Loop и зачем он нужен в JavaScript?",
    answer: "<p><strong>Event Loop</strong> — это механизм, который позволяет JavaScript выполнять асинхронные операции в однопоточной среде выполнения.</p><h4>Зачем нужен Event Loop:</h4><h4>1. Однопоточность JavaScript:</h4><p>JavaScript выполняется в одном основном потоке, но Event Loop позволяет не блокировать выполнение при асинхронных операциях.</p><h4>2. Неблокирующий I/O:</h4><p>Позволяет выполнять операции ввода-вывода (сетевые запросы, чтение файлов) без остановки основного потока.</p><h4>3. Отзывчивость интерфейса:</h4><p>Обеспечивает возможность обновления UI и обработки пользовательских событий даже во время выполнения длительных операций.</p><h4>Основная проблема без Event Loop:</h4><p>Без асинхронности любая операция, требующая времени (например, HTTP запрос), полностью заблокировала бы выполнение программы.</p><h4>Простая аналогия:</h4><p>Event Loop работает как официант в ресторане: принимает заказы (ставит задачи в очередь), передает их на кухню (внешние API), и приносит готовые блюда (выполняет колбэки) когда они готовы, при этом продолжая обслуживать других клиентов.</p><p><em>Event Loop — это сердце асинхронности в JavaScript, делающее возможными современные веб-приложения.</em></p>",
    difficulty: 'junior',
    tags: ['Event Loop', 'основы', 'асинхронность', 'однопоточность']
  },
  {
    id: 64,
    question: "Из каких основных компонентов состоит Event Loop?",
    answer: "<p>Event Loop состоит из нескольких ключевых компонентов, которые работают вместе для обеспечения асинхронного выполнения.</p><h4>Основные компоненты:</h4><h4>1. Call Stack (Стек вызовов):</h4><p><strong>Назначение:</strong> Хранит информацию о выполняющихся функциях в порядке LIFO (последний зашел — первый вышел).</p><p><strong>Принцип:</strong> Когда функция вызывается, она попадает на вершину стека, когда завершается — удаляется.</p><h4>2. Heap (Куча):</h4><p><strong>Назначение:</strong> Область памяти для хранения объектов и переменных.</p><p><strong>Особенность:</strong> Неструктурированная область памяти.</p><h4>3. Web APIs / Browser APIs:</h4><p><strong>Назначение:</strong> Предоставляют асинхронные возможности (setTimeout, DOM events, HTTP requests).</p><p><strong>Выполнение:</strong> Работают вне основного потока JavaScript.</p><h4>4. Callback Queue (Task Queue):</h4><p><strong>Назначение:</strong> Очередь функций, готовых к выполнению после завершения асинхронных операций.</p><p><strong>Порядок:</strong> FIFO (первый зашел — первый вышел).</p><h4>5. Event Loop:</h4><p><strong>Назначение:</strong> Мониторит Call Stack и очереди, перемещает задачи из очередей в стек когда он пуст.</p><p><em>Все компоненты работают синхронно для создания иллюзии многопоточности в однопоточном JavaScript.</em></p>",
    difficulty: 'junior',
    tags: ['Event Loop', 'Call Stack', 'Web APIs', 'Callback Queue', 'компоненты']
  },
  {
    id: 65,
    question: "Как работает Call Stack в Event Loop?",
    answer: "<p><strong>Call Stack</strong> — это структура данных, которая отслеживает выполнение функций в JavaScript по принципу LIFO.</p><h4>Принцип работы:</h4><h4>1. Добавление функций:</h4><p>Когда функция вызывается, она добавляется на вершину стека.</p><h4>2. Выполнение:</h4><p>JavaScript выполняет функцию с вершины стека.</p><h4>3. Удаление:</h4><p>После завершения функция удаляется со стека.</p><h4>4. Вложенные вызовы:</h4><p>При вызове функции из другой функции, новая функция добавляется поверх текущей.</p><h4>Особенности Call Stack:</h4><ul><li><strong>Синхронное выполнение:</strong> Функции выполняются строго по одной</li><li><strong>Блокирующий характер:</strong> Пока функция не завершится, другие не могут выполняться</li><li><strong>Отслеживание контекста:</strong> Хранит информацию о текущем контексте выполнения</li><li><strong>Stack overflow:</strong> При слишком глубокой рекурсии возможно переполнение стека</li></ul><h4>Взаимодействие с Event Loop:</h4><p>Event Loop постоянно проверяет: если Call Stack пуст, он берет первую задачу из очереди и помещает её в стек.</p><h4>Отладка:</h4><p>В DevTools можно увидеть состояние Call Stack при остановке на breakpoint.</p><p><em>Call Stack — основа синхронного выполнения кода в асинхронной среде JavaScript.</em></p>",
    difficulty: 'junior',
    tags: ['Call Stack', 'LIFO', 'выполнение функций', 'синхронность']
  },
  {
    id: 66,
    question: "Что такое Task Queue (Macrotask Queue) и какие задачи туда попадают?",
    answer: "<p><strong>Task Queue (Macrotask Queue)</strong> — это очередь задач, которые ожидают выполнения после освобождения Call Stack.</p><h4>Какие задачи попадают в Task Queue:</h4><h4>1. Таймеры:</h4><ul><li><strong>setTimeout:</strong> Выполнение функции через заданное время</li><li><strong>setInterval:</strong> Повторяющееся выполнение функции</li></ul><h4>2. DOM события:</h4><ul><li><strong>click, scroll, resize:</strong> Пользовательские взаимодействия</li><li><strong>load, DOMContentLoaded:</strong> События загрузки страницы</li></ul><h4>3. I/O операции:</h4><ul><li><strong>HTTP requests:</strong> XMLHttpRequest callbacks (не fetch!)</li><li><strong>File operations:</strong> Чтение файлов в Node.js</li></ul><h4>4. Другие макрозадачи:</h4><ul><li><strong>setImmediate</strong> (Node.js)</li><li><strong>MessageChannel</strong> postMessage</li></ul><h4>Принцип работы:</h4><p><strong>FIFO порядок:</strong> Задачи выполняются в порядке поступления.</p><p><strong>Выполнение:</strong> Event Loop берет одну задачу из очереди только когда Call Stack пуст.</p><h4>Особенности:</h4><ul><li>После выполнения одной macrotask Event Loop обрабатывает все microtask'и</li><li>Браузер может обновить рендеринг между macrotask'ами</li><li>Длительные macrotask'и могут блокировать UI</li></ul><p><em>Task Queue обеспечивает упорядоченное выполнение асинхронных операций.</em></p>",
    difficulty: 'junior',
    tags: ['Task Queue', 'macrotasks', 'setTimeout', 'DOM события', 'FIFO']
  },
  {
    id: 67,
    question: "Что такое Microtask Queue и чем она отличается от Task Queue?",
    answer: "<p><strong>Microtask Queue</strong> — это приоритетная очередь для задач, которые должны выполняться раньше обычных macrotask'ов.</p><h4>Какие задачи попадают в Microtask Queue:</h4><h4>1. Promise callbacks:</h4><ul><li><strong>.then(), .catch(), .finally():</strong> Обработчики промисов</li><li><strong>async/await:</strong> Результаты await выражений</li></ul><h4>2. queueMicrotask():</h4><p>Явное добавление функции в очередь микрозадач.</p><h4>3. MutationObserver:</h4><p>Callbacks для отслеживания изменений DOM.</p><h4>Ключевые отличия от Task Queue:</h4><h4>1. Приоритет выполнения:</h4><p><strong>Microtasks:</strong> Выполняются ВСЕ перед любой macrotask.</p><p><strong>Macrotasks:</strong> Выполняется только ОДНА, затем снова все microtask'и.</p><h4>2. Момент выполнения:</h4><p><strong>Microtasks:</strong> После каждой macrotask и перед рендерингом.</p><p><strong>Macrotasks:</strong> По одной между обработкой microtask'ов.</p><h4>3. Влияние на производительность:</h4><p><strong>Опасность:</strong> Бесконечные microtask'и могут заблокировать macrotask'и и рендеринг.</p><h4>Алгоритм Event Loop:</h4><ol><li>Выполнить одну macrotask</li><li>Выполнить ВСЕ microtask'и</li><li>Обновить рендеринг (если нужно)</li><li>Повторить</li></ol><p><em>Microtask Queue обеспечивает более высокий приоритет для критически важных операций.</em></p>",
    difficulty: 'middle',
    tags: ['Microtask Queue', 'Promise', 'queueMicrotask', 'приоритет', 'производительность']
  },
  {
    id: 68,
    question: "Где в Event Loop выполняется requestAnimationFrame?",
    answer: "<p><strong>requestAnimationFrame</strong> выполняется в специальной фазе Event Loop, связанной с обновлением рендеринга браузера.</p><h4>Место в Event Loop:</h4><p><strong>Rendering phase:</strong> requestAnimationFrame callbacks выполняются перед перерисовкой страницы, но после обработки всех microtask'ов.</p><h4>Детальный порядок выполнения:</h4><ol><li>Выполнить одну macrotask из Task Queue</li><li>Выполнить ВСЕ microtask'и из Microtask Queue</li><li><strong>Выполнить requestAnimationFrame callbacks</strong></li><li>Обновить DOM рендеринг</li><li>Повторить цикл</li></ol><h4>Особенности requestAnimationFrame:</h4><h4>1. Синхронизация с частотой обновления:</h4><p>Выполняется с частотой дисплея (обычно 60 FPS = каждые 16.67ms).</p><h4>2. Оптимизация производительности:</h4><p>Браузер может пропускать вызовы для скрытых вкладок или минимизированных окон.</p><h4>3. Точное время выполнения:</h4><p>Callback получает timestamp с точным временем начала кадра.</p><h4>Сравнение с другими методами:</h4><ul><li><strong>setTimeout(fn, 16):</strong> Не гарантирует синхронизацию с рендерингом</li><li><strong>requestAnimationFrame:</strong> Идеально синхронизирован с дисплеем</li></ul><h4>Применение:</h4><p>Идеален для плавных анимаций, обновления canvas, и любых визуальных изменений.</p><p><em>requestAnimationFrame обеспечивает оптимальную производительность анимаций благодаря интеграции с циклом рендеринга.</em></p>",
    difficulty: 'middle',
    tags: ['requestAnimationFrame', 'рендеринг', 'анимации', 'производительность', 'FPS']
  },
  {
    id: 69,
    question: "Объясните полный алгоритм работы Event Loop шаг за шагом",
    answer: "<p>Event Loop работает по строго определенному алгоритму, обеспечивающему правильный порядок выполнения всех типов задач.</p><h4>Полный алгоритм Event Loop:</h4><h4>1. Проверка Call Stack:</h4><p>Если Call Stack не пуст, продолжить выполнение синхронного кода.</p><h4>2. Обработка одной Macrotask:</h4><p>Если Call Stack пуст, взять первую задачу из Task Queue (macrotask) и выполнить её.</p><h4>3. Обработка всех Microtask'ов:</h4><p>Выполнить ВСЕ задачи из Microtask Queue до полного опустошения очереди.</p><p><strong>Важно:</strong> Если во время выполнения microtask'а добавляются новые microtask'и, они тоже выполняются в той же фазе.</p><h4>4. Проверка необходимости рендеринга:</h4><p>Браузер решает, нужно ли обновить рендеринг (обычно 60 FPS).</p><h4>5. Rendering phase (если нужно):</h4><ul><li>Выполнить requestAnimationFrame callbacks</li><li>Обновить стили (recalculate styles)</li><li>Обновить layout (reflow)</li><li>Перерисовать элементы (repaint)</li><li>Composite layers</li></ul><h4>6. Проверка на Idle:</h4><p>Выполнить requestIdleCallback'и если есть свободное время до следующего кадра.</p><h4>7. Повтор цикла:</h4><p>Вернуться к шагу 1 и повторить весь процесс.</p><h4>Критические моменты:</h4><ul><li>Microtask'и имеют приоритет над macrotask'ами</li><li>Рендеринг происходит только между циклами</li><li>Длительные задачи блокируют весь цикл</li></ul><p><em>Понимание полного алгоритма критично для написания производительного асинхронного кода.</em></p>",
    difficulty: 'middle',
    tags: ['алгоритм Event Loop', 'macrotasks', 'microtasks', 'рендеринг', 'производительность']
  },
  {
    id: 70,
    question: "Как Event Loop обрабатывает Promise'ы и async/await?",
    answer: "<p>Promise'ы и async/await тесно интегрированы с Event Loop через систему microtask'ов.</p><h4>Обработка Promise'ов:</h4><h4>1. Создание Promise:</h4><p>Executor функция выполняется синхронно в момент создания Promise.</p><h4>2. .then(), .catch(), .finally():</h4><p>Callbacks попадают в Microtask Queue после разрешения Promise.</p><h4>3. Цепочки Promise:</h4><p>Каждый .then() создает новый Promise, чьи callbacks также попадают в Microtask Queue.</p><h4>Обработка async/await:</h4><h4>1. Async функции:</h4><p>Возвращают Promise, выполняются синхронно до первого await.</p><h4>2. Await выражения:</h4><p>Приостанавливают выполнение функции, продолжение попадает в Microtask Queue.</p><h4>3. Цепочка await'ов:</h4><p>Каждый await создает новую microtask для продолжения выполнения.</p><h4>Примеры поведения:</h4><p><strong>Promise.resolve().then():</strong> Callback выполнится в следующей microtask фазе.</p><p><strong>await Promise.resolve():</strong> Продолжение функции выполнится в следующей microtask фазе.</p><h4>Особенности:</h4><ul><li><strong>Приоритет:</strong> Promise callbacks выполняются раньше setTimeout</li><li><strong>Батчинг:</strong> Все Promise callbacks в одной фазе выполняются подряд</li><li><strong>Ошибки:</strong> Unhandled Promise rejection обрабатывается в конце microtask фазы</li></ul><h4>Оптимизации браузеров:</h4><p>Современные браузеры оптимизируют выполнение Promise'ов для лучшей производительности.</p><p><em>Promise'ы обеспечивают предсказуемый порядок выполнения асинхронного кода через microtask'и.</em></p>",
    difficulty: 'middle',
    tags: ['Promise', 'async/await', 'microtasks', 'цепочки', 'приоритет']
  },
  {
    id: 71,
    question: "Что такое requestIdleCallback и как он вписывается в Event Loop?",
    answer: "<p><strong>requestIdleCallback</strong> — это API для выполнения задач в свободное время между кадрами рендеринга.</p><h4>Место в Event Loop:</h4><p><strong>Idle period:</strong> Выполняется в конце цикла Event Loop, когда есть свободное время до следующего кадра рендеринга.</p><h4>Детальный порядок:</h4><ol><li>Обработать macrotask</li><li>Обработать все microtask'и</li><li>Выполнить рендеринг (если нужно)</li><li><strong>Если остается время до следующего кадра — выполнить idle callbacks</strong></li><li>Повторить цикл</li></ol><h4>Особенности requestIdleCallback:</h4><h4>1. Deadline объект:</h4><p>Callback получает объект с информацией о доступном времени.</p><h4>2. timeRemaining():</h4><p>Метод показывает, сколько миллисекунд осталось до следующего кадра.</p><h4>3. didTimeout:</h4><p>Флаг указывает, был ли вызов отложен из-за таймаута.</p><h4>4. Timeout опция:</h4><p>Можно установить максимальное время ожидания.</p><h4>Применение:</h4><ul><li><strong>Аналитика:</strong> Отправка метрик в фоновом режиме</li><li><strong>Предзагрузка:</strong> Загрузка ресурсов с низким приоритетом</li><li><strong>Очистка:</strong> Garbage collection или cleanup операции</li><li><strong>Обработка данных:</strong> Неблокирующая обработка больших массивов</li></ul><h4>Ограничения:</h4><ul><li>Не гарантирует выполнение в каждом кадре</li><li>Может не вызываться на медленных устройствах</li><li>Ограниченная поддержка браузерами</li></ul><p><em>requestIdleCallback позволяет выполнять задачи без влияния на производительность анимаций.</em></p>",
    difficulty: 'middle',
    tags: ['requestIdleCallback', 'idle time', 'производительность', 'фоновые задачи', 'оптимизация']
  },
  {
    id: 72,
    question: "Как Event Loop работает в Node.js и чем отличается от браузера?",
    answer: "<p>Event Loop в Node.js имеет более сложную структуру с несколькими фазами, отличаясь от браузерной реализации.</p><h4>Фазы Event Loop в Node.js:</h4><h4>1. Timer phase:</h4><p>Выполнение setTimeout() и setInterval() callbacks.</p><h4>2. Pending callbacks phase:</h4><p>Выполнение I/O callbacks, отложенных с предыдущего цикла.</p><h4>3. Idle, prepare phase:</h4><p>Внутренние операции Node.js.</p><h4>4. Poll phase:</h4><p><strong>Основная фаза:</strong> Получение новых I/O событий, выполнение I/O callbacks.</p><p><strong>Блокировка:</strong> Может блокироваться в ожидании событий.</p><h4>5. Check phase:</h4><p>Выполнение setImmediate() callbacks.</p><h4>6. Close callbacks phase:</h4><p>Выполнение close событий (socket.on('close', ...)).</p><h4>Особенности Node.js:</h4><h4>1. process.nextTick():</h4><p><strong>Наивысший приоритет:</strong> Выполняется перед любой фазой и microtask'ами.</p><h4>2. setImmediate vs setTimeout:</h4><p>В I/O контексте setImmediate выполняется раньше setTimeout(0).</p><h4>3. Libuv integration:</h4><p>Использует libuv для кроссплатформенного асинхронного I/O.</p><h4>Отличия от браузера:</h4><ul><li><strong>Больше фаз:</strong> 6 фаз против простого цикла браузера</li><li><strong>I/O фокус:</strong> Оптимизирован для серверных задач</li><li><strong>process.nextTick:</strong> Уникальный для Node.js приоритет</li><li><strong>Нет рендеринга:</strong> Отсутствуют фазы рендеринга и RAF</li></ul><p><em>Node.js Event Loop оптимизирован для высокопроизводительных серверных приложений.</em></p>",
    difficulty: 'senior',
    tags: ['Node.js', 'Event Loop фазы', 'process.nextTick', 'setImmediate', 'I/O', 'libuv']
  },
  {
    id: 73,
    question: "Как диагностировать и решать проблемы с производительностью Event Loop?",
    answer: "<p>Проблемы с производительностью Event Loop могут серьезно влиять на отзывчивость приложения. Важно уметь их выявлять и решать.</p><h4>Основные проблемы Event Loop:</h4><h4>1. Блокировка основного потока:</h4><p><strong>Причина:</strong> Длительные синхронные операции в Call Stack.</p><p><strong>Симптомы:</strong> Зависание UI, пропуск кадров анимации.</p><h4>2. Microtask'и блокируют macrotask'и:</h4><p><strong>Причина:</strong> Бесконечные или слишком частые Promise chains.</p><p><strong>Симптомы:</strong> setTimeout'ы не выполняются, DOM события не обрабатываются.</p><h4>3. Memory leaks в асинхронном коде:</h4><p><strong>Причина:</strong> Незавершенные Promise'ы, неотмененные таймеры.</p><h4>Инструменты диагностики:</h4><h4>1. Performance API:</h4><p>performance.mark() и performance.measure() для измерения времени выполнения.</p><h4>2. Chrome DevTools:</h4><ul><li><strong>Performance tab:</strong> Flame graphs, Main thread activity</li><li><strong>Task Manager:</strong> Использование CPU и памяти</li><li><strong>Coverage tab:</strong> Неиспользуемый код</li></ul><h4>3. Long Task API:</h4><p>PerformanceObserver для отслеживания задач дольше 50ms.</p><h4>Стратегии решения:</h4><ul><li><strong>Time slicing:</strong> Разбиение больших задач на части</li><li><strong>Web Workers:</strong> Вынос тяжелых вычислений в фоновые потоки</li><li><strong>requestIdleCallback:</strong> Выполнение неприоритетных задач</li><li><strong>Debouncing/Throttling:</strong> Ограничение частоты выполнения</li><li><strong>Code splitting:</strong> Ленивая загрузка кода</li></ul><h4>Мониторинг в production:</h4><ul><li>Web Vitals (FID, INP) для пользовательского опыта</li><li>Error tracking для unhandled Promise rejections</li><li>Performance budgets для контроля производительности</li></ul><p><em>Регулярный мониторинг и оптимизация Event Loop критичны для производительных приложений.</em></p>",
    difficulty: 'senior',
    tags: ['диагностика', 'производительность', 'оптимизация', 'DevTools', 'Long Task API', 'Web Workers']
  },
  {
    id: 74,
    question: "Что такое задачи с приоритетом (Scheduler API) и как они взаимодействуют с Event Loop?",
    answer: "<p><strong>Scheduler API</strong> — это экспериментальное API для управления приоритетами задач в Event Loop, позволяющее более тонко контролировать порядок выполнения.</p><h4>Основные концепции:</h4><h4>1. scheduler.postTask():</h4><p>Позволяет добавлять задачи с указанным приоритетом в специальную очередь.</p><h4>2. Уровни приоритета:</h4><ul><li><strong>'user-blocking':</strong> Критичные для пользователя задачи (клики, ввод текста)</li><li><strong>'user-visible':</strong> Видимые пользователю задачи (анимации, обновления UI)</li><li><strong>'background':</strong> Фоновые задачи (аналитика, предзагрузка)</li></ul><h4>3. TaskController:</h4><p>Позволяет отменять запланированные задачи через AbortController паттерн.</p><h4>Взаимодействие с Event Loop:</h4><p><strong>Отдельная очередь:</strong> Scheduler задачи имеют свою очередь с приоритетом между microtask'ами и обычными macrotask'ами.</p><h4>Порядок выполнения с Scheduler:</h4><ol><li>Обработать macrotask</li><li>Обработать все microtask'и</li><li><strong>Обработать priority task'и в порядке приоритета</strong></li><li>Продолжить с обычными macrotask'ами</li><li>Рендеринг (если нужно)</li></ol><h4>Преимущества:</h4><ul><li><strong>Контроль приоритетов:</strong> Важные задачи выполняются раньше</li><li><strong>Отзывчивость:</strong> UI задачи не блокируются фоновыми</li><li><strong>Отмена задач:</strong> Возможность отменить неактуальные задачи</li></ul><h4>Состояние стандартизации:</h4><p><strong>Экспериментальное API:</strong> Доступно в некоторых браузерах под флагом, активно развивается.</p><p><strong>Polyfill'ы:</strong> Существуют polyfill'ы для браузеров без нативной поддержки.</p><p><em>Scheduler API представляет будущее управления задачами в веб-платформе.</em></p>",
    difficulty: 'senior',
    tags: ['Scheduler API', 'приоритеты задач', 'postTask', 'TaskController', 'экспериментальное API']
  },
  {
    id: 75,
    question: "Как работают Web Workers в контексте Event Loop?",
    answer: "<p><strong>Web Workers</strong> позволяют выполнять JavaScript код в отдельных потоках, каждый из которых имеет собственный Event Loop.</p><h4>Архитектура с Web Workers:</h4><h4>1. Основной поток (Main Thread):</h4><p>Имеет свой Event Loop для UI и основной логики приложения.</p><h4>2. Worker потоки:</h4><p>Каждый Worker имеет независимый Event Loop без доступа к DOM.</p><h4>3. Коммуникация:</h4><p>Общение между потоками происходит через message passing (postMessage/onmessage).</p><h4>Event Loop в Worker:</h4><p><strong>Упрощенная структура:</strong> Нет фаз рендеринга, requestAnimationFrame, DOM событий.</p><p><strong>Компоненты Worker Event Loop:</strong></p><ul><li>Call Stack</li><li>Task Queue (setTimeout, setInterval, message events)</li><li>Microtask Queue (Promise, queueMicrotask)</li></ul><h4>Взаимодействие потоков:</h4><h4>1. postMessage():</h4><p>Отправка данных между main thread и worker добавляет задачу в Task Queue получателя.</p><h4>2. Serialization:</h4><p>Данные клонируются (structured clone) при передаче между потоками.</p><h4>3. Transferable Objects:</h4><p>Некоторые объекты (ArrayBuffer) могут передаваться без копирования.</p><h4>Практические применения:</h4><ul><li><strong>Тяжелые вычисления:</strong> Математические операции, обработка изображений</li><li><strong>Data processing:</strong> Парсинг больших JSON, CSV файлов</li><li><strong>Background tasks:</strong> Синхронизация данных, кэширование</li><li><strong>Real-time processing:</strong> Обработка audio/video потоков</li></ul><h4>Ограничения:</h4><ul><li>Нет доступа к DOM</li><li>Ограниченный доступ к Web APIs</li><li>Overhead создания и коммуникации</li></ul><p><em>Web Workers позволяют истинную многопоточность в JavaScript, не блокируя основной Event Loop.</em></p>",
    difficulty: 'senior',
    tags: ['Web Workers', 'многопоточность', 'postMessage', 'отдельный Event Loop', 'производительность']
  },
  {
    id: 76,
    question: "Объясните продвинутые техники оптимизации Event Loop (Time slicing, Concurrent features)",
    answer: "<p>Продвинутые техники оптимизации Event Loop направлены на поддержание отзывчивости приложения при выполнении тяжелых задач.</p><h4>Time Slicing (Разделение времени):</h4><h4>1. Принцип:</h4><p>Разбиение больших синхронных задач на маленькие части с паузами между ними.</p><h4>2. Реализация:</h4><p>Использование setTimeout(0) или MessageChannel для передачи управления Event Loop'у.</p><h4>3. Scheduler.postTask():</h4><p>Современный способ планирования задач с контролем приоритета.</p><h4>React Concurrent Features:</h4><h4>1. Time Slicing в React:</h4><p>React 18+ автоматически разбивает рендеринг на небольшие части.</p><h4>2. Interruptible Rendering:</h4><p>Возможность прерывать рендеринг для обработки более приоритетных задач.</p><h4>3. Suspense и Transitions:</h4><p>Управление приоритетами обновлений UI.</p><h4>Продвинутые паттерны:</h4><h4>1. Cooperative Scheduling:</h4><p>Задачи добровольно передают управление через yield points.</p><h4>2. Priority Queues:</h4><p>Несколько очередей с разными приоритетами для задач.</p><h4>3. Adaptive Time Slicing:</p><p>Динамическое изменение размера slice'ов в зависимости от производительности устройства.</p><h4>4. Background Scheduling:</h4><p>Использование requestIdleCallback для фоновых задач.</p><h4>Мониторинг и метрики:</h4><ul><li><strong>Long Task API:</strong> Отслеживание задач > 50ms</li><li><strong>Performance Observer:</strong> Мониторинг производительности</li><li><strong>First Input Delay (FID):</strong> Измерение отзывчивости</li><li><strong>Interaction to Next Paint (INP):</strong> Новая метрика отзывчивости</li></ul><h4>Инструменты и библиотеки:</h4><ul><li><strong>React Scheduler:</strong> Встроенный планировщик React</li><li><strong>scheduler/tracing:</strong> Профилирование React приложений</li><li><strong>Workbox:</strong> Оптимизация Service Worker задач</li></ul><p><em>Современные техники оптимизации обеспечивают плавный пользовательский опыт даже при сложных вычислениях.</em></p>",
    difficulty: 'senior',
    tags: ['Time slicing', 'React Concurrent', 'оптимизация', 'Cooperative Scheduling', 'производительность']
  },
  {
    id: 77,
    question: "Как Event Loop эволюционирует в современных браузерах и какие новые API влияют на его работу?",
    answer: "<p>Event Loop продолжает эволюционировать с появлением новых Web APIs и требований к производительности современных веб-приложений.</p><h4>Современные улучшения Event Loop:</h4><h4>1. Origin Private File System API:</h4><p>Асинхронная работа с файлами без блокировки основного потока.</p><h4>2. WebCodecs API:</h4><p>Низкоуровневая обработка аудио/видео с интеграцией в Event Loop.</p><h4>3. WebAssembly Integration:</h4><p>Оптимизированное выполнение WASM кода в рамках Event Loop.</p><h4>4. Shared Array Buffer и Atomics:</h4><p>Синхронизация между Worker'ами без блокировки main thread.</p><h4>Планируемые улучшения:</h4><h4>1. Main Thread Scheduling API:</h4><p>Более точный контроль над планированием задач в основном потоке.</p><h4>2. Task Attribution API:</h4><p>Лучшее отслеживание источников долгих задач для отладки.</p><h4>3. Background Fetch:</h4><p>Продолжение загрузки данных даже при закрытой вкладке.</p><h4>Влияние новых паттернов:</h4><h4>1. Islands Architecture:</h4><p>Изолированные интерактивные компоненты с независимыми Event Loop'ами.</p><h4>2. Streaming SSR:</h4><p>Потоковая серверная отрисовка с оптимизированной гидратацией.</p><h4>3. Edge Computing:</h4><p>Выполнение кода ближе к пользователю с адаптированными Event Loop'ами.</p><h4>Браузерные оптимизации:</h4><ul><li><strong>V8 Optimizations:</strong> Улучшенная обработка Promise'ов и async/await</li><li><strong>Composite Threading:</strong> Вынос композитинга в отдельные потоки</li><li><strong>OffscreenCanvas:</strong> Рендеринг в Worker'ах без блокировки UI</li></ul><h4>Вызовы и решения:</h4><ul><li><strong>Battery Life:</strong> Оптимизация для мобильных устройств</li><li><strong>Memory Pressure:</strong> Лучшее управление памятью в асинхронном коде</li><li><strong>Security:</strong> Изоляция контекстов выполнения для безопасности</li></ul><h4>Будущие направления:</h4><p>Развитие Event Loop направлено на еще большую отзывчивость, безопасность и энергоэффективность веб-платформы.</p><p><em>Event Loop остается центральным элементом веб-платформы, продолжая адаптироваться к новым требованиям и возможностям.</em></p>",
    difficulty: 'senior',
    tags: ['эволюция Event Loop', 'новые Web APIs', 'WebAssembly', 'Islands Architecture', 'будущее веб-платформы']
  },
  // Добавить эти вопросы к существующему массиву jsInterviewQuestions:

  {
    id: 78,
    question: "Что такое контекст выполнения в JavaScript?",
    answer: "<p><strong>Контекст выполнения</strong> — это среда, в которой выполняется JavaScript код, определяющая доступные переменные, функции и значение <code>this</code>.</p><h4>Что включает контекст выполнения:</h4><h4>1. Лексическое окружение:</h4><p>Содержит локальные переменные, параметры функции и ссылки на внешние области видимости.</p><h4>2. Переменное окружение:</h4><p>Хранит привязки переменных, созданных через <code>var</code> и function declarations.</p><h4>3. Значение this:</h4><p>Ссылка на объект, в контексте которого выполняется код.</p><h4>Типы контекстов выполнения:</h4><ul><li><strong>Глобальный контекст:</strong> Основной контекст программы</li><li><strong>Функциональный контекст:</strong> Создается при вызове функции</li><li><strong>Eval контекст:</strong> Создается при выполнении eval()</li></ul><h4>Создание контекста:</h4><p>Новый контекст создается каждый раз при вызове функции и помещается в стек вызовов (Call Stack).</p><h4>Фазы создания контекста:</h4><ol><li><strong>Creation Phase:</strong> Создание лексического окружения, hoisting</li><li><strong>Execution Phase:</strong> Пошаговое выполнение кода</li></ol><p><em>Контекст выполнения — основа понимания того, как работают переменные, функции и this в JavaScript.</em></p>",
    difficulty: 'junior',
    tags: ['контекст выполнения', 'лексическое окружение', 'this', 'Call Stack', 'основы']
  },
  {
    id: 79,
    question: "Что такое ключевое слово this и от чего зависит его значение?",
    answer: "<p><strong>This</strong> — это ключевое слово, которое ссылается на объект, в контексте которого выполняется текущая функция.</p><h4>От чего зависит значение this:</h4><h4>1. Способ вызова функции:</h4><p>Основной фактор, определяющий значение <code>this</code> — как именно вызывается функция.</p><h4>2. Режим выполнения:</h4><p>В строгом режиме (<code>'use strict'</code>) поведение <code>this</code> отличается от нестрогого.</p><h4>Правила определения this:</h4><h4>1. Вызов как метод объекта:</h4><p><code>obj.method()</code> — <code>this</code> указывает на <code>obj</code>.</p><h4>2. Обычный вызов функции:</h4><p><code>func()</code> — <code>this</code> указывает на глобальный объект (window) или <code>undefined</code> в строгом режиме.</p><h4>3. Конструктор:</h4><p><code>new Func()</code> — <code>this</code> указывает на создаваемый объект.</p><h4>4. Явная привязка:</h4><p><code>func.call(obj)</code> — <code>this</code> указывает на переданный объект.</p><h4>Особенности:</h4><ul><li><strong>Динамическая привязка:</strong> Значение определяется во время выполнения</li><li><strong>Потеря контекста:</strong> При передаче метода как callback</li><li><strong>Стрелочные функции:</strong> Не имеют собственного <code>this</code></li></ul><p><em>Понимание this — ключ к работе с объектами и методами в JavaScript.</em></p>",
    difficulty: 'junior',
    tags: ['this', 'контекст', 'вызов функций', 'методы объектов', 'основы']
  },
  {
    id: 80,
    question: "Как this ведет себя в разных способах вызова функций?",
    answer: "<p>Значение <code>this</code> в JavaScript зависит от того, <strong>как</strong> вызывается функция, а не где она объявлена.</p><h4>1. Вызов как метод объекта:</h4><p><strong>Синтаксис:</strong> <code>obj.method()</code></p><p><strong>This:</strong> Указывает на объект перед точкой (obj).</p><h4>2. Обычный вызов функции:</h4><p><strong>Синтаксис:</strong> <code>func()</code></p><p><strong>Нестрогий режим:</strong> <code>this</code> указывает на глобальный объект (window в браузере).</p><p><strong>Строгий режим:</strong> <code>this</code> равен <code>undefined</code>.</p><h4>3. Вызов через call/apply:</h4><p><strong>Синтаксис:</strong> <code>func.call(thisArg)</code></p><p><strong>This:</strong> Указывает на переданный первый аргумент.</p><h4>4. Вызов с new (конструктор):</h4><p><strong>Синтаксис:</strong> <code>new Func()</code></p><p><strong>This:</strong> Указывает на новый создаваемый объект.</p><h4>5. Стрелочные функции:</h4><p><strong>Особенность:</strong> Наследуют <code>this</code> из внешней области видимости, игнорируют способ вызова.</p><h4>6. Event handlers:</h4><p><strong>DOM события:</strong> <code>this</code> указывает на элемент, на котором произошло событие.</p><h4>Приоритет правил:</h4><ol><li>new binding</li><li>Explicit binding (call/apply/bind)</li><li>Implicit binding (метод объекта)</li><li>Default binding (обычный вызов)</li></ol><p><em>Запомните: \"Кто вызывает функцию, тот и становится this\" (кроме стрелочных функций).</em></p>",
    difficulty: 'junior',
    tags: ['this', 'способы вызова', 'методы', 'конструкторы', 'стрелочные функции']
  },
  {
    id: 81,
    question: "В чем разница между call, apply и bind?",
    answer: "<p>Методы <strong>call</strong>, <strong>apply</strong> и <strong>bind</strong> позволяют явно устанавливать значение <code>this</code> при вызове функции.</p><h4>Function.prototype.call():</h4><p><strong>Назначение:</strong> Вызывает функцию с заданным <code>this</code> и аргументами.</p><p><strong>Синтаксис:</strong> <code>func.call(thisArg, arg1, arg2, ...)</code></p><p><strong>Аргументы:</strong> Передаются через запятую.</p><p><strong>Выполнение:</strong> Функция вызывается немедленно.</p><h4>Function.prototype.apply():</h4><p><strong>Назначение:</strong> То же, что call, но аргументы передаются массивом.</p><p><strong>Синтаксис:</strong> <code>func.apply(thisArg, [arg1, arg2, ...])</code></p><p><strong>Аргументы:</strong> Передаются как массив или array-like объект.</p><p><strong>Выполнение:</strong> Функция вызывается немедленно.</p><h4>Function.prototype.bind():</h4><p><strong>Назначение:</strong> Создает новую функцию с привязанным <code>this</code>.</p><p><strong>Синтаксис:</strong> <code>func.bind(thisArg, arg1, arg2, ...)</code></p><p><strong>Выполнение:</strong> Возвращает новую функцию, исходная не вызывается.</p><p><strong>Частичное применение:</strong> Может зафиксировать некоторые аргументы.</p><h4>Когда использовать:</h4><ul><li><strong>call:</strong> Когда аргументы известны заранее</li><li><strong>apply:</strong> Когда аргументы в массиве или их количество динамическое</li><li><strong>bind:</strong> Для создания функций с постоянным контекстом</li></ul><p><em>Все три метода решают проблему потери контекста, но разными способами.</em></p>",
    difficulty: 'junior',
    tags: ['call', 'apply', 'bind', 'привязка контекста', 'this']
  },
  {
    id: 82,
    question: "Как работает потеря контекста и как её избежать?",
    answer: "<p><strong>Потеря контекста</strong> происходит, когда метод объекта вызывается не как метод, а как обычная функция, что изменяет значение <code>this</code>.</p><h4>Когда происходит потеря контекста:</h4><h4>1. Передача метода как callback:</h4><p>При передаче метода в setTimeout, addEventListener или другие функции высшего порядка.</p><h4>2. Присваивание метода переменной:</h4><p>Когда метод сохраняется в переменной и вызывается через неё.</p><h4>3. Деструктуризация методов:</h4><p>При извлечении метода из объекта через деструктуризацию.</p><h4>Способы избежать потери контекста:</h4><h4>1. Стрелочные функции:</h4><p>Создание обертки в виде стрелочной функции, которая сохраняет внешний контекст.</p><h4>2. Метод bind():</h4><p>Привязка контекста к методу заранее.</p><h4>3. Сохранение this в переменной:</h4><p>Классический подход с сохранением <code>this</code> в переменной типа <code>self</code> или <code>that</code>.</p><h4>4. Использование call/apply:</h4><p>Явный вызов метода с нужным контекстом.</p><h4>5. Методы в классах как стрелочные функции:</h4><p>Объявление методов классов как стрелочных функций (class fields).</p><h4>Лучшие практики:</h4><ul><li>Используйте стрелочные функции для event handlers</li><li>Применяйте bind() при передаче методов как callbacks</li><li>В React компонентах используйте стрелочные методы или bind в конструкторе</li></ul><p><em>Понимание потери контекста критично для корректной работы с объектами и событиями.</em></p>",
    difficulty: 'middle',
    tags: ['потеря контекста', 'callback', 'bind', 'стрелочные функции', 'this']
  },
  {
    id: 83,
    question: "Как работает частичное применение с помощью bind?",
    answer: "<p><strong>Частичное применение</strong> с помощью <code>bind</code> позволяет создавать новые функции с предустановленными аргументами.</p><h4>Принцип работы:</h4><p><code>bind</code> может принимать не только контекст (<code>this</code>), но и дополнительные аргументы, которые будут \"зашиты\" в новую функцию.</p><p><strong>Синтаксис:</strong> <code>func.bind(thisArg, arg1, arg2, ...)</code></p><h4>Создание функций с дефолтными аргументами:</h4><p>Можно зафиксировать первые аргументы функции, создав специализированную версию.</p><h4>Порядок аргументов:</h4><p>При вызове новой функции, переданные аргументы добавляются <strong>после</strong> зафиксированных через <code>bind</code>.</p><h4>Практические применения:</h4><h4>1. Создание специализированных функций:</h4><p>Например, функция логирования с предустановленным уровнем.</p><h4>2. Конфигурирование API функций:</h4><p>Создание функций с предустановленными параметрами для HTTP запросов.</p><h4>3. Математические операции:</h4><p>Создание функций с зафиксированными операндами.</p><h4>4. Валидация:</h4><p>Создание специализированных валидаторов на основе общей функции.</p><h4>Преимущества:</h4><ul><li><strong>Переиспользование:</strong> Создание специализированных функций</li><li><strong>Читаемость:</strong> Более понятные имена функций</li><li><strong>Конфигурация:</strong> Предустановка часто используемых параметров</li></ul><h4>Сравнение с каррированием:</h4><p>Bind создает функцию с частично примененными аргументами, каррирование — цепочку функций по одному аргументу.</p><p><em>Частичное применение через bind — мощный инструмент функционального программирования.</em></p>",
    difficulty: 'middle',
    tags: ['частичное применение', 'bind', 'дефолтные аргументы', 'специализированные функции']
  },
  {
    id: 84,
    question: "Как this работает в стрелочных функциях?",
    answer: "<p><strong>Стрелочные функции</strong> имеют принципиально иное поведение <code>this</code> по сравнению с обычными функциями.</p><h4>Лексический this:</h4><p><strong>Наследование:</strong> Стрелочные функции наследуют значение <code>this</code> из внешней области видимости в момент создания.</p><p><strong>Неизменность:</strong> Значение <code>this</code> в стрелочной функции нельзя изменить никакими способами.</p><h4>Отличия от обычных функций:</h4><h4>1. Игнорирование способа вызова:</h4><p>Неважно, как вызывается стрелочная функция — <code>this</code> остается тем же.</p><h4>2. Неэффективность call/apply/bind:</h4><p>Методы <code>call</code>, <code>apply</code> и <code>bind</code> не могут изменить <code>this</code> в стрелочных функциях.</p><h4>3. Нельзя использовать как конструктор:</h4><p>Стрелочные функции нельзя вызывать с оператором <code>new</code>.</p><h4>4. Нет собственного arguments:</h4><p>Доступ к <code>arguments</code> внешней функции или использование rest параметров.</p><h4>Практические применения:</h4><h4>1. Event handlers:</h4><p>Сохранение контекста компонента в обработчиках событий.</p><h4>2. Callbacks:</h4><p>Передача методов объектов без потери контекста.</p><h4>3. Array methods:</h4><p>Использование в <code>map</code>, <code>filter</code>, <code>forEach</code> с доступом к внешнему <code>this</code>.</p><h4>Когда НЕ использовать:</h4><ul><li>Как методы объектов (потеря доступа к объекту)</li><li>В прототипах (та же проблема)</li><li>Когда нужна динамическая привязка <code>this</code></li></ul><p><em>Стрелочные функции решают проблему потери контекста, но создают новые ограничения.</em></p>",
    difficulty: 'middle',
    tags: ['стрелочные функции', 'лексический this', 'наследование контекста', 'ограничения']
  },
  {
    id: 85,
    question: "Как this работает в классах ES6?",
    answer: "<p>В <strong>классах ES6</strong> поведение <code>this</code> имеет свои особенности, связанные с методами, конструкторами и наследованием.</p><h4>This в конструкторе:</h4><p><strong>Создание экземпляра:</strong> В конструкторе <code>this</code> ссылается на создаваемый экземпляр класса.</p><p><strong>Инициализация:</strong> Используется для установки свойств экземпляра.</p><h4>This в методах класса:</h4><p><strong>Обычные методы:</strong> <code>this</code> указывает на экземпляр, если метод вызван как <code>instance.method()</code>.</p><p><strong>Потеря контекста:</strong> При передаче метода как callback контекст может потеряться.</p><h4>Стрелочные методы (Class Fields):</h4><p><strong>Современный синтаксис:</strong> Методы как стрелочные функции автоматически привязывают <code>this</code>.</p><p><strong>Преимущества:</strong> Нет потери контекста при использовании как callbacks.</p><h4>This в статических методах:</h4><p><strong>Контекст:</strong> В статических методах <code>this</code> ссылается на сам класс, а не на экземпляр.</p><h4>Наследование и super:</h4><p><strong>Super calls:</strong> В наследованных классах <code>super()</code> в конструкторе обязателен до использования <code>this</code>.</p><p><strong>Method overriding:</strong> Переопределенные методы сохраняют правильный контекст.</p><h4>Паттерны привязки контекста:</h4><h4>1. Bind в конструкторе:</h4><p>Явная привязка методов в конструкторе.</p><h4>2. Стрелочные методы:</h4><p>Использование class fields для автоматической привязки.</p><h4>3. Обертки в стрелочные функции:</h4><p>При передаче методов как callbacks.</p><p><em>Классы ES6 предоставляют более структурированный подход к работе с this в ООП.</em></p>",
    difficulty: 'middle',
    tags: ['классы ES6', 'конструктор', 'методы классов', 'статические методы', 'наследование']
  },
  {
    id: 86,
    question: "Что такое полифилл для bind и как его реализовать?",
    answer: "<p><strong>Полифилл для bind</strong> — это реализация метода <code>Function.prototype.bind</code> для браузеров, которые его не поддерживают.</p><h4>Принцип работы bind:</h4><p>Метод <code>bind</code> должен создавать новую функцию с привязанным контекстом и частично примененными аргументами.</p><h4>Базовая реализация полифилла:</h4><p>Простая версия, которая привязывает только контекст без поддержки частичного применения аргументов.</p><h4>Полная реализация:</h4><p>Включает поддержку частичного применения аргументов и корректную обработку всех случаев использования.</p><h4>Продвинутая реализация:</h4><p>Учитывает особые случаи, такие как использование с оператором <code>new</code> и сохранение свойств исходной функции.</p><h4>Ключевые особенности полифилла:</h4><h4>1. Сохранение контекста:</h4><p>Новая функция должна выполняться с переданным <code>this</code>.</p><h4>2. Частичное применение:</h4><p>Аргументы, переданные в <code>bind</code>, должны добавляться к аргументам вызова.</p><h4>3. Поддержка new:</h4><p>При использовании с оператором <code>new</code> контекст должен игнорироваться.</p><h4>4. Сохранение прототипа:</h4><p>Связывание прототипа новой функции с исходной.</p><h4>Проверка поддержки:</h4><p>Перед добавлением полифилла нужно проверить, существует ли нативная реализация.</p><h4>Современные альтернативы:</h4><p>В современных проектах обычно используются транспайлеры (Babel) или готовые полифиллы из core-js.</p><p><em>Реализация полифилла bind помогает понять внутреннюю работу привязки контекста.</em></p>",
    difficulty: 'senior',
    tags: ['полифилл', 'bind', 'реализация', 'совместимость', 'частичное применение']
  },
  {
    id: 87,
    question: "Как работает контекст в обработчиках событий?",
    answer: "<p>В <strong>обработчиках событий</strong> поведение <code>this</code> зависит от способа регистрации обработчика и типа функции.</p><h4>addEventListener:</h4><p><strong>Обычные функции:</strong> <code>this</code> ссылается на элемент, на котором зарегистрировано событие.</p><p><strong>Стрелочные функции:</strong> <code>this</code> наследуется из внешней области видимости.</p><h4>Inline обработчики:</h4><p><strong>HTML атрибуты:</strong> В inline обработчиках <code>this</code> ссылается на элемент.</p><p><strong>React синтетические события:</strong> Поведение зависит от типа функции компонента.</p><h4>Способы управления контекстом:</h4><h4>1. Стрелочные функции:</h4><p>Автоматическое сохранение контекста внешней области видимости.</p><h4>2. Bind в конструкторе/setup:</h4><p>Явная привязка контекста при регистрации обработчика.</p><h4>3. Обертка в стрелочную функцию:</h4><p>Создание промежуточной стрелочной функции при регистрации.</p><h4>4. Использование замыканий:</h4><p>Сохранение нужного контекста через замыкание.</p><h4>Практические паттерны:</h4><h4>1. В классовых компонентах:</h4><p>Привязка методов в конструкторе или использование стрелочных методов.</p><h4>2. В функциональных компонентах:</h4><p>Использование useCallback для оптимизации и сохранения контекста.</p><h4>3. Доступ к event.target:</h4><p>Получение элемента, на котором произошло событие, независимо от контекста.</p><h4>Распространенные ошибки:</h4><ul><li>Потеря контекста при передаче методов объектов</li><li>Неправильное использование стрелочных функций в циклах</li><li>Смешивание разных подходов к привязке контекста</li></ul><p><em>Правильное управление контекстом в event handlers критично для работы интерактивных приложений.</em></p>",
    difficulty: 'middle',
    tags: ['обработчики событий', 'addEventListener', 'event handlers', 'this в событиях']
  },
  {
    id: 88,
    question: "Объясните различия в поведении this в строгом и нестрогом режимах",
    answer: "<p>Поведение <code>this</code> существенно отличается в <strong>строгом</strong> (<code>'use strict'</code>) и <strong>нестрогом</strong> режимах JavaScript.</p><h4>Обычный вызов функции:</h4><h4>Нестрогий режим:</h4><p><code>this</code> указывает на глобальный объект (window в браузере, global в Node.js).</p><h4>Строгий режим:</h4><p><code>this</code> остается <code>undefined</code>, что помогает выявлять ошибки раньше.</p><h4>Методы объектов:</h4><p><strong>Оба режима:</strong> Поведение одинаковое — <code>this</code> указывает на объект-владелец метода.</p><h4>Конструкторы:</h4><p><strong>Нестрогий режим:</strong> Забытый <code>new</code> приводит к загрязнению глобального объекта.</p><p><strong>Строгий режим:</strong> Вызов конструктора без <code>new</code> вызывает TypeError.</p><h4>Call, apply, bind с null/undefined:</h4><h4>Нестрогий режим:</h4><p><code>null</code> и <code>undefined</code> заменяются на глобальный объект.</p><h4>Строгий режим:</h4><p><code>null</code> и <code>undefined</code> передаются как есть.</p><h4>Функции как свойства объектов:</h4><p><strong>Оба режима:</strong> Поведение одинаковое при правильном вызове.</p><h4>Преимущества строгого режима:</h4><ul><li><strong>Раннее обнаружение ошибок:</strong> TypeError вместо молчаливых ошибок</li><li><strong>Предсказуемость:</strong> Более последовательное поведение</li><li><strong>Безопасность:</strong> Предотвращение случайного создания глобальных переменных</li><li><strong>Оптимизации:</strong> Движки могут лучше оптимизировать строгий код</li></ul><h4>Лучшие практики:</h4><ul><li>Всегда используйте строгий режим в новом коде</li><li>ES6 модули автоматически выполняются в строгом режиме</li><li>Классы ES6 автоматически находятся в строгом режиме</li></ul><p><em>Строгий режим делает поведение this более предсказуемым и безопасным.</em></p>",
    difficulty: 'middle',
    tags: ['строгий режим', 'use strict', 'нестрогий режим', 'различия поведения', 'безопасность']
  },
  {
    id: 89,
    question: "Как реализовать собственную версию call и apply?",
    answer: "<p>Реализация собственных версий <code>call</code> и <code>apply</code> помогает понять механизм привязки контекста изнутри.</p><h4>Принцип работы call/apply:</h4><p>Основная идея: временно добавить функцию как свойство объекта-контекста, вызвать её, затем удалить.</p><h4>Реализация myCall:</h4><p>Создает временное уникальное свойство объекта, устанавливает функцию как значение, вызывает и удаляет.</p><h4>Реализация myApply:</h4><p>Аналогична myCall, но обрабатывает аргументы как массив и использует spread оператор.</p><h4>Ключевые особенности реализации:</h4><h4>1. Обработка null/undefined контекста:</h4><p>В нестрогом режиме заменяется на глобальный объект, в строгом остается как есть.</p><h4>2. Уникальные имена свойств:</h4><p>Использование Symbol или уникальных строк для избежания конфликтов имен.</p><h4>3. Очистка:</h4><p>Обязательное удаление временного свойства
];
