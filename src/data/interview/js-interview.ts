export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const jsInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое функция в JavaScript и для чего она используется?",
    answer: "<p><strong>Функция</strong> — это блок кода, который можно многократно вызывать для выполнения определенной задачи. Функции являются основным строительным блоком JavaScript-программ.</p><p><strong>Основные назначения функций:</strong></p><ul><li><strong>Переиспользование кода:</strong> Один раз написанный код можно вызывать множество раз</li><li><strong>Модульность:</strong> Разбиение сложной задачи на более простые подзадачи</li><li><strong>Абстракция:</strong> Скрытие деталей реализации за простым интерфейсом</li><li><strong>Область видимости:</strong> Создание изолированного пространства для переменных</li></ul><p>Функции в JavaScript являются <em>объектами первого класса</em>, что означает, что их можно присваивать переменным, передавать как аргументы и возвращать из других функций.</p><p>Пример простой функции, которая складывает два числа и возвращает результат.</p>",
    difficulty: 'junior',
    tags: ['основы', 'функции', 'концепции']
  },
  {
    id: 2,
    question: "Какие способы объявления функций существуют в JavaScript?",
    answer: "<p>В JavaScript существует несколько способов создания функций:</p><h4>1. Function Declaration (Объявление функции):</h4><p>Классический способ объявления функции с ключевым словом <code>function</code>. Такие функции поднимаются (hoisting) и доступны во всей области видимости.</p><h4>2. Function Expression (Функциональное выражение):</h4><p>Функция создается как выражение и присваивается переменной. Не поднимается, доступна только после объявления.</p><h4>3. Arrow Function (Стрелочная функция):</h4><p>Краткий синтаксис ES6 для создания функций. Не имеет собственного контекста <code>this</code>.</p><h4>4. Function Constructor:</h4><p>Создание функции через конструктор <code>Function()</code>. Редко используется в практике.</p><h4>5. Method Definition:</h4><p>Краткий синтаксис для определения методов в объектах.</p><p>Каждый способ имеет свои особенности поведения, особенно касательно <strong>hoisting, this и arguments</strong>.</p>",
    difficulty: 'junior',
    tags: ['объявление функций', 'синтаксис', 'ES6']
  },
  {
    id: 3,
    question: "В чем разница между Function Declaration и Function Expression?",
    answer: "<p>Основные различия между Function Declaration и Function Expression:</p><h4>Function Declaration:</h4><ul><li><strong>Hoisting:</strong> Поднимается полностью, можно вызывать до объявления</li><li><strong>Синтаксис:</strong> Начинается с ключевого слова <code>function</code></li><li><strong>Имя:</strong> Обязательно должна иметь имя</li><li><strong>Область видимости:</strong> Доступна во всей области видимости, где объявлена</li></ul><h4>Function Expression:</h4><ul><li><strong>Hoisting:</strong> Переменная поднимается, но не значение. Нельзя вызвать до присваивания</li><li><strong>Синтаксис:</strong> Функция присваивается переменной</li><li><strong>Имя:</strong> Может быть анонимной или именованной</li><li><strong>Условное создание:</strong> Может создаваться условно внутри блоков</li></ul><h4>Практическое применение:</h4><p><strong>Function Declaration</strong> используется для основных функций программы, которые должны быть доступны везде.</p><p><strong>Function Expression</strong> используется для условного создания функций, callback'ов и когда функция нужна как значение.</p>",
    difficulty: 'junior',
    tags: ['function declaration', 'function expression', 'hoisting', 'различия']
  },
  {
    id: 4,
    question: "Что такое стрелочные функции и чем они отличаются от обычных?",
    answer: "<p><strong>Стрелочные функции</strong> — это краткий синтаксис ES6 для создания функций, введенный для упрощения написания кода.</p><h4>Основные отличия от обычных функций:</h4><h4>1. Контекст this:</h4><p><strong>Обычные функции:</strong> Имеют собственный контекст <code>this</code>, который определяется способом вызова.</p><p><strong>Стрелочные функции:</strong> Наследуют <code>this</code> из внешней области видимости, не создают собственный контекст.</p><h4>2. Объект arguments:</h4><p>Стрелочные функции не имеют собственного объекта <code>arguments</code>. Для доступа к параметрам используйте rest parameters.</p><h4>3. Hoisting:</h4><p>Стрелочные функции не поднимаются, так как являются выражениями.</p><h4>4. Конструктор:</h4><p>Стрелочные функции нельзя использовать как конструкторы с оператором <code>new</code>.</p><h4>5. Синтаксис:</h4><p>Более краткий синтаксис, особенно для простых функций. Неявный возврат для выражений.</p><p><em>Стрелочные функции идеальны для callback'ов и функций, где не нужен собственный контекст.</em></p>",
    difficulty: 'middle',
    tags: ['arrow functions', 'ES6', 'this', 'различия']
  },
  {
    id: 5,
    question: "Что такое hoisting в контексте функций?",
    answer: "<p><strong>Hoisting</strong> — это механизм JavaScript, при котором объявления переменных и функций \"поднимаются\" в начало их области видимости во время компиляции.</p><h4>Поведение разных типов функций:</h4><h4>Function Declaration:</h4><p><strong>Полное поднятие:</strong> И объявление, и определение поднимаются. Функцию можно вызвать до её объявления в коде.</p><h4>Function Expression:</h4><p><strong>Частичное поднятие:</strong> Поднимается только объявление переменной (как <code>undefined</code>), но не присваивание функции.</p><h4>Arrow Functions:</h4><p>Ведут себя как Function Expression — поднимается только переменная.</p><h4>Переменные let/const:</h4><p>Функции, объявленные через <code>let</code> или <code>const</code>, находятся в \"temporal dead zone\" до момента объявления.</p><h4>Практическое значение:</h4><p>Понимание hoisting помогает избежать ошибок и писать более предсказуемый код. <em>Рекомендуется объявлять функции до их использования</em> для лучшей читаемости.</p>",
    difficulty: 'middle',
    tags: ['hoisting', 'область видимости', 'temporal dead zone']
  },
  {
    id: 6,
    question: "Что такое замыкания (closures) и как они работают с функциями?",
    answer: "<p><strong>Замыкание (closure)</strong> — это комбинация функции и лексического окружения, в котором эта функция была определена. Замыкание дает функции доступ к переменным внешней области видимости даже после завершения выполнения внешней функции.</p><h4>Как работают замыкания:</h4><p><strong>Лексическая область видимости:</strong> JavaScript использует лексическую область видимости, что означает, что функции имеют доступ к переменным, определенным в области, где они были созданы.</p><p><strong>Сохранение контекста:</strong> Когда функция возвращается из другой функции, она \"запоминает\" переменные из внешней области.</p><h4>Практические применения:</h4><ul><li><strong>Приватные переменные:</strong> Создание переменных, недоступных извне</li><li><strong>Фабрики функций:</strong> Создание специализированных функций</li><li><strong>Модули:</strong> Создание модульной структуры кода</li><li><strong>Callback функции:</strong> Сохранение состояния в асинхронных операциях</li></ul><p><em>Замыкания — это мощный механизм, который делает JavaScript функциональным языком программирования.</em></p>",
    difficulty: 'middle',
    tags: ['замыкания', 'лексическая область', 'приватные переменные']
  },
  {
    id: 7,
    question: "Что такое функции высшего порядка (Higher-Order Functions)?",
    answer: "<p><strong>Функции высшего порядка</strong> — это функции, которые принимают другие функции в качестве аргументов или возвращают функции как результат.</p><h4>Два типа функций высшего порядка:</h4><h4>1. Принимают функции как аргументы:</h4><p>Такие функции позволяют передавать поведение как параметр, делая код более гибким и переиспользуемым.</p><h4>2. Возвращают функции:</h4><p>Эти функции создают и возвращают новые функции, часто с использованием замыканий.</p><h4>Встроенные функции высшего порядка:</h4><ul><li><strong>Array.map():</strong> Применяет функцию к каждому элементу массива</li><li><strong>Array.filter():</strong> Фильтрует элементы на основе условия</li><li><strong>Array.reduce():</strong> Сворачивает массив к одному значению</li><li><strong>setTimeout/setInterval:</strong> Принимают функции для отложенного выполнения</li></ul><h4>Преимущества:</h4><ul><li>Более абстрактный и выразительный код</li><li>Лучшая переиспользуемость</li><li>Функциональный стиль программирования</li><li>Композиция функций</li></ul><p><em>Функции высшего порядка — основа функционального программирования в JavaScript.</em></p>",
    difficulty: 'middle',
    tags: ['высшего порядка', 'функциональное программирование', 'callback']
  },
  {
    id: 8,
    question: "Что такое IIFE (Immediately Invoked Function Expression)?",
    answer: "<p><strong>IIFE</strong> — это функция, которая выполняется сразу же после её создания. Это паттерн, позволяющий создать изолированную область видимости.</p><h4>Синтаксис IIFE:</h4><p>Существует два основных способа записи: с круглыми скобками вокруг всего выражения или только вокруг функции.</p><h4>Зачем используется IIFE:</h4><h4>1. Изоляция области видимости:</h4><p>Предотвращает загрязнение глобального пространства имен.</p><h4>2. Создание модулей:</h4><p>До появления ES6 модулей IIFE был основным способом создания модульной структуры.</p><h4>3. Инициализация:</h4><p>Выполнение кода инициализации, который должен запуститься только один раз.</p><h4>4. Приватность:</h4><p>Создание приватных переменных и методов.</p><h4>Варианты записи:</h4><p>Стрелочные функции также могут быть IIFE, хотя синтаксис менее читаемый.</p><p><strong>Современное применение:</strong> С появлением ES6 модулей и блочной области видимости <code>let/const</code> IIFE используется реже, но остается полезным для совместимости и специфических случаев.</p>",
    difficulty: 'middle',
    tags: ['IIFE', 'область видимости', 'модули', 'паттерны']
  },
  {
    id: 9,
    question: "Объясните разницу между параметрами и аргументами функции",
    answer: "<p>Часто эти термины используются взаимозаменяемо, но у них есть четкое различие:</p><h4>Параметры (Parameters):</h4><ul><li><strong>Определение:</strong> Переменные, указанные в объявлении функции</li><li><strong>Местоположение:</strong> Находятся в круглых скобках при объявлении функции</li><li><strong>Назначение:</strong> Определяют, какие значения функция ожидает получить</li><li><strong>Время существования:</strong> Существуют только внутри функции</li></ul><h4>Аргументы (Arguments):</h4><ul><li><strong>Определение:</strong> Фактические значения, передаваемые функции при вызове</li><li><strong>Местоположение:</strong> Передаются в круглых скобках при вызове функции</li><li><strong>Назначение:</strong> Конкретные данные для обработки функцией</li><li><strong>Типы:</strong> Могут быть любого типа данных</li></ul><h4>Особенности JavaScript:</h4><p><strong>Гибкость:</strong> Количество аргументов может не совпадать с количеством параметров.</p><p><strong>Объект arguments:</strong> В обычных функциях доступен объект <code>arguments</code> со всеми переданными аргументами.</p><p><strong>Значения по умолчанию:</strong> Параметры могут иметь значения по умолчанию (ES6).</p>",
    difficulty: 'junior',
    tags: ['параметры', 'аргументы', 'синтаксис', 'основы']
  },
  {
    id: 10,
    question: "Что такое rest параметры и spread оператор в функциях?",
    answer: "<p><strong>Rest параметры</strong> и <strong>spread оператор</strong> используют одинаковый синтаксис (<code>...</code>), но в разных контекстах:</p><h4>Rest параметры (...):</h4><p><strong>Назначение:</strong> Собирает несколько аргументов в массив внутри функции.</p><p><strong>Использование:</strong> Только в объявлении функции, только как последний параметр.</p><p><strong>Преимущества:</strong> Заменяет объект <code>arguments</code>, работает со стрелочными функциями, возвращает настоящий массив.</p><h4>Spread оператор (...):</h4><p><strong>Назначение:</strong> Разворачивает массив или итерируемый объект в отдельные элементы.</p><p><strong>Использование:</strong> При вызове функции, в массивах, объектах.</p><p><strong>Применение:</strong> Передача элементов массива как отдельных аргументов.</p><h4>Различия:</h4><ul><li><strong>Rest:</strong> Собирает много в одно (массив)</li><li><strong>Spread:</strong> Разбирает одно на много (элементы)</li></ul><p><em>Оба оператора делают работу с переменным количеством параметров более удобной и читаемой.</em></p>",
    difficulty: 'middle',
    tags: ['rest параметры', 'spread оператор', 'ES6', 'аргументы']
  },
  {
    id: 11,
    question: "Что такое bind, call и apply? В чем их различия?",
    answer: "<p>Это методы для управления контекстом <code>this</code> при вызове функций:</p><h4>call():</h4><p><strong>Назначение:</strong> Вызывает функцию с заданным контекстом <code>this</code> и аргументами.</p><p><strong>Синтаксис:</strong> Аргументы передаются через запятую.</p><p><strong>Выполнение:</strong> Функция выполняется немедленно.</p><h4>apply():</h4><p><strong>Назначение:</strong> То же, что и <code>call</code>, но аргументы передаются массивом.</p><p><strong>Синтаксис:</strong> Второй параметр — массив аргументов.</p><p><strong>Использование:</strong> Удобно, когда аргументы уже в виде массива.</p><h4>bind():</h4><p><strong>Назначение:</strong> Создает новую функцию с привязанным контекстом <code>this</code>.</p><p><strong>Выполнение:</strong> Возвращает новую функцию, не выполняя исходную.</p><p><strong>Частичное применение:</strong> Может частично применять аргументы.</p><h4>Основные различия:</h4><ul><li><strong>call/apply:</strong> Выполняют функцию сразу</li><li><strong>bind:</strong> Возвращает новую функцию для последующего вызова</li><li><strong>call:</strong> Аргументы через запятую</li><li><strong>apply:</strong> Аргументы массивом</li></ul>",
    difficulty: 'middle',
    tags: ['bind', 'call', 'apply', 'this', 'контекст']
  },
  {
    id: 12,
    question: "Что такое currying (каррирование) функций?",
    answer: "<p><strong>Каррирование</strong> — это техника преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.</p><h4>Принцип работы:</h4><p>Функция, принимающая несколько аргументов, преобразуется в функцию, которая принимает первый аргумент и возвращает функцию для следующего аргумента, и так далее.</p><h4>Преимущества каррирования:</h4><h4>1. Частичное применение:</h4><p>Можно создавать специализированные функции, зафиксировав некоторые аргументы.</p><h4>2. Переиспользование:</h4><p>Создание функций с предустановленными параметрами.</p><h4>3. Композиция:</p><p>Легче комбинировать каррированные функции.</p><h4>4. Читаемость:</h4><p>Более декларативный стиль программирования.</p><h4>Реализация:</h4><p>Можно реализовать вручную через замыкания или использовать библиотеки типа Lodash.</p><h4>Применение:</h4><p>Особенно полезно в функциональном программировании, при создании конфигурируемых функций и в библиотеках вроде Redux.</p><p><em>Каррирование — мощная техника для создания более гибких и переиспользуемых функций.</em></p>",
    difficulty: 'senior',
    tags: ['каррирование', 'функциональное программирование', 'замыкания']
  },
  {
    id: 13,
    question: "Что такое чистые функции (pure functions) и побочные эффекты?",
    answer: "<p><strong>Чистая функция</strong> — это функция, которая всегда возвращает одинаковый результат для одинаковых входных данных и не производит побочных эффектов.</p><h4>Критерии чистой функции:</h4><h4>1. Детерминированность:</h4><p>Одинаковый входной параметр всегда дает одинаковый результат.</p><h4>2. Отсутствие побочных эффектов:</h4><p>Функция не изменяет внешнее состояние программы.</p><h4>Побочные эффекты:</h4><ul><li>Изменение глобальных переменных</li><li>Изменение переданных объектов/массивов</li><li>Обращение к DOM</li><li>HTTP-запросы</li><li>Вывод в консоль</li><li>Генерация случайных чисел</li><li>Получение текущего времени</li></ul><h4>Преимущества чистых функций:</h4><ul><li><strong>Предсказуемость:</strong> Легко понять, что делает функция</li><li><strong>Тестируемость:</strong> Проще написать тесты</li><li><strong>Отладка:</strong> Легче найти и исправить ошибки</li><li><strong>Кэширование:</strong> Можно кэшировать результаты (memoization)</li><li><strong>Параллелизм:</strong> Безопасны для параллельного выполнения</li></ul><p><em>Стремитесь к написанию чистых функций, когда это возможно — это основа надежного кода.</em></p>",
    difficulty: 'senior',
    tags: ['чистые функции', 'побочные эффекты', 'функциональное программирование']
  },
  {
    id: 14,
    question: "Что такое мемоизация (memoization) и как её реализовать?",
    answer: "<p><strong>Мемоизация</strong> — это техника оптимизации, при которой результаты выполнения функции кэшируются, чтобы избежать повторных вычислений для одинаковых входных данных.</p><h4>Принцип работы:</h4><ol><li>При первом вызове функции с определенными аргументами результат вычисляется и сохраняется</li><li>При последующих вызовах с теми же аргументами возвращается сохраненный результат</li><li>Время выполнения уменьшается с O(n) до O(1) для повторных вызовов</li></ol><h4>Когда применять:</h4><ul><li><strong>Дорогие вычисления:</strong> Функции с высокой вычислительной сложностью</li><li><strong>Рекурсивные функции:</strong> Например, вычисление чисел Фибоначчи</li><li><strong>Частые повторные вызовы:</strong> С одинаковыми параметрами</li><li><strong>Чистые функции:</strong> Результат зависит только от входных параметров</li></ul><h4>Ограничения:</h4><ul><li>Использует дополнительную память для хранения кэша</li><li>Подходит только для чистых функций</li><li>Может быть неэффективна для функций с большим количеством уникальных аргументов</li></ul><p><em>Мемоизация — мощный инструмент оптимизации, но используйте её осознанно, учитывая баланс между скоростью и памятью.</em></p>",
    difficulty: 'senior',
    tags: ['мемоизация', 'оптимизация', 'кэширование', 'производительность']
  },
  {
    id: 15,
    question: "Как работает контекст выполнения функций и call stack?",
    answer: "<p><strong>Контекст выполнения</strong> — это абстрактная концепция, описывающая среду, в которой выполняется JavaScript код.</p><h4>Типы контекстов выполнения:</h4><h4>1. Глобальный контекст:</h4><p>Создается при загрузке скрипта, существует один на всю программу.</p><h4>2. Контекст функции:</h4><p>Создается при каждом вызове функции.</p><h4>3. Eval контекст:</h4><p>Создается при выполнении кода в <code>eval()</code>.</p><h4>Фазы создания контекста:</h4><h4>1. Creation Phase (Фаза создания):</h4><ul><li>Создание лексического окружения</li><li>Создание переменного окружения</li><li>Определение значения <code>this</code></li><li>Hoisting переменных и функций</li></ul><h4>2. Execution Phase (Фаза выполнения):</h4><ul><li>Выполнение кода построчно</li><li>Присваивание значений переменным</li></ul><h4>Call Stack (Стек вызовов):</h4><p><strong>Принцип работы:</strong> LIFO (Last In, First Out) — последний зашедший, первый вышедший.</p><p><strong>Процесс:</strong> При вызове функции её контекст добавляется в стек, при завершении — удаляется.</p><p><em>Понимание контекста выполнения помогает разобраться в hoisting, замыканиях и области видимости.</em></p>",
    difficulty: 'senior',
    tags: ['контекст выполнения', 'call stack', 'лексическое окружение', 'hoisting']
  },
  {
    id: 16,
    question: "Что такое лексическое окружение (Lexical Environment) в JavaScript?",
    answer: "<p><strong>Лексическое окружение</strong> — это структура данных, которая содержит привязки идентификаторов к значениям и ссылку на внешнее лексическое окружение.</p><h4>Состав лексического окружения:</h4><h4>1. Environment Record (Запись окружения):</h4><p>Хранит все локальные привязки (переменные, функции, параметры) в данной области видимости.</p><h4>2. Outer Environment Reference:</h4><p>Ссылка на внешнее лексическое окружение, образующая цепочку областей видимости.</p><h4>Типы записей окружения:</h4><ul><li><strong>Declarative Environment Record:</strong> Для функций, блоков, модулей</li><li><strong>Object Environment Record:</strong> Для глобального объекта и with-блоков</li><li><strong>Function Environment Record:</strong> Специально для функций (содержит this, arguments)</li><li><strong>Module Environment Record:</strong> Для ES6 модулей</li></ul><h4>Создание лексического окружения:</h4><p>Лексическое окружение создается <strong>в момент создания контекста выполнения</strong>, а не во время выполнения кода. Это происходит в фазе создания (Creation Phase).</p><p><em>Лексическое окружение — основа для понимания области видимости и замыканий в JavaScript.</em></p>",
    difficulty: 'senior',
    tags: ['лексическое окружение', 'область видимости', 'замыкания', 'контекст выполнения']
  },
  {
    id: 17,
    question: "В какой момент создается лексическое окружение функции?",
    answer: "<p>Лексическое окружение функции создается <strong>в момент создания контекста выполнения функции</strong>, а не в момент её объявления или определения.</p><h4>Временная последовательность:</h4><h4>1. Объявление функции:</h4><p>При объявлении функция запоминает лексическое окружение, в котором была создана (через внутренний слот [[Environment]]).</p><h4>2. Вызов функции:</h4><p>При вызове создается новый контекст выполнения и новое лексическое окружение для этого вызова.</p><h4>3. Фаза создания контекста:</h4><ul><li>Создается Function Environment Record</li><li>Устанавливается ссылка на внешнее окружение</li><li>Происходит привязка параметров и локальных переменных</li><li>Определяется значение <code>this</code></li></ul><h4>4. Фаза выполнения:</h4><p>Переменные получают свои значения, код выполняется строка за строкой.</p><h4>Важные моменты:</h4><p><strong>Каждый вызов</strong> функции создает уникальное лексическое окружение, даже для одной и той же функции.</p><p><strong>Замыкания</strong> формируются благодаря тому, что функция сохраняет ссылку на лексическое окружение своего создания.</p>",
    difficulty: 'senior',
    tags: ['лексическое окружение', 'контекст выполнения', 'замыкания', 'жизненный цикл']
  },
  {
    id: 18,
    question: "Как работает цепочка областей видимости (Scope Chain)?",
    answer: "<p><strong>Цепочка областей видимости</strong> — это механизм поиска переменных через связанные лексические окружения от внутреннего к внешнему.</p><h4>Принцип работы:</h4><h4>1. Поиск переменной:</h4><p>JavaScript начинает поиск переменной в текущем лексическом окружении.</p><h4>2. Поиск во внешних окружениях:</h4><p>Если переменная не найдена, поиск продолжается в родительском окружении по ссылке Outer Environment Reference.</p><h4>3. Завершение поиска:</h4><p>Поиск продолжается до глобального окружения. Если переменная не найдена — <code>ReferenceError</code>.</p><h4>Формирование цепочки:</h4><p>Цепочка определяется <strong>местом объявления функции</strong> в коде (лексически), а не местом её вызова.</p><h4>Особенности:</h4><ul><li><strong>Статическая природа:</strong> Цепочка определяется во время написания кода</li><li><strong>Однонаправленность:</strong> Поиск идет только наружу, никогда внутрь</li><li><strong>Первое найденное:</strong> Используется первое найденное значение (shadowing)</li></ul><h4>Производительность:</h4><p>Поиск переменных в длинной цепочке может влиять на производительность, поэтому локальные переменные быстрее глобальных.</p>",
    difficulty: 'middle',
    tags: ['scope chain', 'область видимости', 'лексическое окружение', 'поиск переменных']
  },
  {
    id: 19,
    question: "Объясните разницу между статической и динамической областью видимости",
    answer: "<p>JavaScript использует <strong>статическую (лексическую)</strong> область видимости, но важно понимать различия с динамической.</p><h4>Статическая (Лексическая) область видимости:</h4><p><strong>Принцип:</strong> Область видимости определяется местом объявления функции в исходном коде.</p><p><strong>Время определения:</strong> Во время написания кода (compile time).</p><p><strong>Предсказуемость:</strong> Можно определить область видимости, просто прочитав код.</p><h4>Динамическая область видимости:</h4><p><strong>Принцип:</strong> Область видимости определяется местом вызова функции.</p><p><strong>Время определения:</strong> Во время выполнения (runtime).</p><p><strong>Непредсказуемость:</strong> Область видимости зависит от стека вызовов.</p><h4>Преимущества статической области:</h4><ul><li><strong>Предсказуемость:</strong> Код ведет себя одинаково независимо от места вызова</li><li><strong>Оптимизация:</strong> Движки могут лучше оптимизировать код</li><li><strong>Отладка:</strong> Легче найти источник переменной</li><li><strong>Замыкания:</strong> Возможность создания замыканий</li></ul><p><em>Статическая область видимости — одна из причин, почему JavaScript предсказуем и подходит для создания сложных приложений.</em></p>",
    difficulty: 'senior',
    tags: ['статическая область', 'динамическая область', 'лексическая область', 'область видимости']
  },
  {
    id: 20,
    question: "Что происходит с замыканием в памяти и как избежать утечек?",
    answer: "<p>Замыкания могут приводить к утечкам памяти, если не управлять ими правильно.</p><h4>Как замыкания влияют на память:</h4><h4>1. Сохранение ссылок:</h4><p>Замыкание сохраняет ссылки на все переменные внешней области видимости, предотвращая их сборку мусора.</p><h4>2. Жизненный цикл:</h4><p>Переменные остаются в памяти до тех пор, пока существует ссылка на функцию-замыкание.</p><h4>3. Неочевидные ссылки:</p><p>Все функции, созданные в одной области видимости, разделяют одно лексическое окружение.</p><h4>Потенциальные проблемы:</h4><ul><li><strong>Циклические ссылки:</strong> Особенно с DOM-элементами</li><li><strong>Большие объекты:</strong> Сохранение больших данных через замыкания</li><li><strong>Таймеры и обработчики:</strong> Забытые setInterval или event listeners</li></ul><h4>Способы избежать утечек:</h4><ul><li><strong>Обнуление ссылок:</strong> Присваивайте <code>null</code> неиспользуемым переменным</li><li><strong>Очистка обработчиков:</strong> Удаляйте event listeners и таймеры</li><li><strong>WeakMap/WeakSet:</strong> Используйте слабые ссылки где возможно</li><li><strong>Минимизация области:</strong> Создавайте замыкания с минимальной областью видимости</li></ul><p><em>Правильное управление памятью критично для производительных приложений.</em></p>",
    difficulty: 'senior',
    tags: ['замыкания', 'управление памятью', 'утечки памяти', 'оптимизация']
  },
  {
    id: 21,
    question: "Как создать приватные переменные с помощью замыканий?",
    answer: "<p>Замыкания позволяют создавать <strong>приватные переменные</strong> в JavaScript, который изначально не имеет встроенной поддержки приватности.</p><h4>Основные паттерны:</h4><h4>1. Модульный паттерн (Module Pattern):</h4><p>Использует IIFE для создания приватной области видимости и возвращает объект с публичными методами.</p><h4>2. Фабричная функция:</h4><p>Функция, создающая объекты с приватными переменными через замыкания.</p><h4>3. Паттерн \"Revealing Module\":</h4><p>Все функции объявляются как приватные, а публичные возвращаются в объекте.</p><h4>Преимущества приватных переменных:</h4><ul><li><strong>Инкапсуляция:</strong> Скрытие внутренней реализации</li><li><strong>Контроль доступа:</strong> Данные изменяются только через публичные методы</li><li><strong>Предотвращение конфликтов:</strong> Избежание случайного изменения данных</li><li><strong>Валидация:</strong> Контроль за корректностью данных</li></ul><h4>Современные альтернативы:</h4><p>С ES2022 появились <strong>приватные поля классов</strong> с синтаксисом <code>#privateField</code>, но замыкания остаются актуальными для функционального стиля программирования.</p><p><em>Приватные переменные через замыкания — классический способ инкапсуляции в JavaScript.</em></p>",
    difficulty: 'middle',
    tags: ['приватные переменные', 'замыкания', 'инкапсуляция', 'модульный паттерн']
  },
  {
    id: 22,
    question: "Что такое модульный паттерн и как он использует замыкания?",
    answer: "<p><strong>Модульный паттерн</strong> — это паттерн проектирования, использующий замыкания для создания модулей с приватными и публичными методами.</p><h4>Основные компоненты паттерна:</h4><h4>1. IIFE (Immediately Invoked Function Expression):</h4><p>Создает изолированную область видимости для модуля.</p><h4>2. Приватные переменные и функции:</h4><p>Объявляются внутри IIFE и недоступны извне.</p><h4>3. Публичный API:</h4><p>Возвращается объект с методами, имеющими доступ к приватным данным через замыкание.</p><h4>Вариации паттерна:</h4><h4>1. Классический модульный паттерн:</h4><p>Возвращает объект с публичными методами.</p><h4>2. Revealing Module Pattern:</h4><p>Все функции объявляются приватными, публичные возвращаются в конце.</p><h4>3. Модуль-синглтон:</h4><p>Создается один экземпляр модуля.</p><h4>4. Модуль с параметрами:</h4><p>Принимает параметры для конфигурации.</p><h4>Преимущества:</h4><ul><li>Инкапсуляция данных</li><li>Избежание загрязнения глобальной области</li><li>Организация кода</li><li>Переиспользование</li></ul><p><em>До появления ES6 модулей это был основной способ модульной организации JavaScript кода.</em></p>",
    difficulty: 'middle',
    tags: ['модульный паттерн', 'замыкания', 'IIFE', 'архитектура', 'паттерны']
  },
  {
    id: 23,
    question: "Как замыкания работают в циклах? Классическая проблема с setTimeout",
    answer: "<p>Одна из самых частых проблем с замыканиями — неправильное поведение в циклах, особенно с асинхронными функциями.</p><h4>Классическая проблема:</h4><p>При использовании <code>var</code> в цикле с <code>setTimeout</code> все колбэки получают доступ к одной и той же переменной, которая к моменту выполнения имеет финальное значение.</p><h4>Причина проблемы:</h4><ul><li><strong>Область видимости var:</strong> <code>var</code> имеет функциональную область видимости</li><li><strong>Общая переменная:</strong> Все итерации разделяют одну переменную <code>i</code></li><li><strong>Асинхронность:</strong> <code>setTimeout</code> выполняется после завершения цикла</li></ul><h4>Способы решения:</h4><h4>1. Использование let (ES6):</h4><p>Блочная область видимости создает новую переменную на каждой итерации.</p><h4>2. IIFE (Immediately Invoked Function Expression):</h4><p>Создает новую область видимости для каждой итерации.</p><h4>3. Bind метод:</h4><p>Привязывает значение к функции.</p><h4>4. forEach:</h4><p>Каждая итерация создает новую область видимости.</p><p><em>Понимание этой проблемы критически важно для работы с асинхронным кодом и замыканиями.</em></p>",
    difficulty: 'middle',
    tags: ['замыкания', 'циклы', 'setTimeout', 'var vs let', 'асинхронность']
  },
  {
    id: 24,
    question: "Что такое частичное применение функций и как оно связано с замыканиями?",
    answer: "<p><strong>Частичное применение</strong> — это техника создания новой функции путем фиксации некоторых аргументов исходной функции.</p><h4>Принцип работы:</h4><p>Создается новая функция, которая \"запоминает\" некоторые аргументы через замыкание и ожидает получения оставшихся аргументов при вызове.</p><h4>Связь с замыканиями:</h4><p>Замыкания позволяют новой функции сохранять доступ к зафиксированным аргументам даже после завершения выполнения функции-создателя.</p><h4>Отличия от каррирования:</h4><ul><li><strong>Каррирование:</strong> Преобразует функцию N аргументов в цепочку из N функций по одному аргументу</li><li><strong>Частичное применение:</strong> Фиксирует произвольное количество аргументов, создавая функцию с меньшим количеством параметров</li></ul><h4>Практические применения:</h4><ul><li><strong>Конфигурация:</strong> Создание предварительно настроенных функций</li><li><strong>Обработчики событий:</strong> Передача дополнительных данных в callback</li><li><strong>Валидация:</strong> Создание специализированных валидаторов</li><li><strong>API вызовы:</strong> Предварительная настройка базовых параметров</li></ul><p><em>Частичное применение делает функции более гибкими и переиспользуемыми.</em></p>",
    difficulty: 'senior',
    tags: ['частичное применение', 'замыкания', 'функциональное программирование', 'каррирование']
  },
  {
    id: 25,
    question: "Как замыкания влияют на производительность и когда их следует избегать?",
    answer: "<p>Замыкания имеют влияние на производительность, которое нужно учитывать при разработке.</p><h4>Влияние на производительность:</h4><h4>1. Потребление памяти:</h4><p>Замыкания сохраняют ссылки на внешние переменные, предотвращая их сборку мусора.</p><h4>2. Время доступа к переменным:</h4><p>Поиск переменных по цепочке областей видимости медленнее доступа к локальным переменным.</p><h4>3. Создание функций:</h4><p>Создание функций-замыканий в циклах может быть дорогостоящим.</p><h4>Когда избегать замыканий:</h4><ul><li><strong>Горячие циклы:</strong> В критически важных для производительности участках</li><li><strong>Большие объемы данных:</strong> Когда замыкание захватывает большие объекты</li><li><strong>Частое создание функций:</strong> В часто вызываемых функциях</li><li><strong>Мобильные устройства:</strong> На устройствах с ограниченной памятью</li></ul><h4>Оптимизация замыканий:</h4><ul><li><strong>Минимизация области:</strong> Захватывайте только необходимые переменные</li><li><strong>Переиспользование функций:</strong> Создавайте функции-замыкания вне циклов</li><li><strong>Освобождение ссылок:</strong> Обнуляйте неиспользуемые переменные</li><li><strong>Профилирование:</strong> Измеряйте реальное влияние на производительность</li></ul><p><em>В большинстве случаев удобство использования замыканий перевешивает небольшое снижение производительности.</em></p>",
    difficulty: 'senior',
    tags: ['замыкания', 'производительность', 'оптимизация', 'память', 'best practices']
  },
  {
    id: 26,
    question: "Объясните, как работают замыкания в стрелочных функциях",
    answer: "<p>Стрелочные функции создают замыкания так же, как обычные функции, но с некоторыми важными особенностями.</p><h4>Общие принципы замыканий:</h4><p>Стрелочные функции, как и обычные, сохраняют доступ к переменным внешней области видимости через механизм замыкания.</p><h4>Особенности стрелочных функций:</h4><h4>1. Лексический this:</h4><p>Стрелочные функции не создают собственный контекст <code>this</code>, а наследуют его из окружающей области.</p><h4>2. Отсутствие arguments:</h4><p>У стрелочных функций нет объекта <code>arguments</code>, но есть доступ к <code>arguments</code> внешней функции через замыкание.</p><h4>3. Нельзя использовать как конструктор:</h4><p>Невозможность использования с <code>new</code> влияет на некоторые паттерны с замыканиями.</p><h4>Практические различия:</h4><p>В большинстве случаев замыкания в стрелочных функциях работают идентично обычным функциям, основное различие — в поведении <code>this</code>.</p><h4>Типичные сценарии использования:</h4><ul><li><strong>Callback функции:</strong> Удобны для обработчиков событий</li><li><strong>Array методы:</strong> map, filter, reduce</li><li><strong>Асинхронный код:</strong> Промисы и async/await</li></ul><p><em>Лексический this делает стрелочные функции особенно удобными для работы с замыканиями в контексте объектов.</em></p>",
    difficulty: 'middle',
    tags: ['стрелочные функции', 'замыкания', 'лексический this', 'ES6']
  },
  {
    id: 27,
    question: "Что такое декораторы и как они используют замыкания?",
    answer: "<p><strong>Декораторы</strong> — это функции высшего порядка, которые принимают другую функцию и возвращают её модифицированную версию, используя замыкания для сохранения дополнительной логики.</p><h4>Принцип работы декораторов:</h4><h4>1. Принимают исходную функцию:</h4><p>Декоратор получает функцию как аргумент.</p><h4>2. Создают обертку:</h4><p>Возвращают новую функцию, которая имеет доступ к исходной через замыкание.</p><h4>3. Расширяют функциональность:</h4><p>Добавляют дополнительную логику до, после или вместо вызова исходной функции.</p><h4>Типы декораторов:</h4><ul><li><strong>Логирующие:</strong> Записывают информацию о вызовах функции</li><li><strong>Кэширующие:</strong> Сохраняют результаты для оптимизации</li><li><strong>Валидирующие:</strong> Проверяют аргументы перед выполнением</li><li><strong>Измеряющие время:</strong> Замеряют производительность</li><li><strong>Авторизующие:</strong> Проверяют права доступа</li></ul><h4>Композиция декораторов:</h4><p>Несколько декораторов можно комбинировать, создавая цепочки обработки.</p><h4>Использование замыканий:</h4><p>Замыкания позволяют декораторам сохранять состояние, доступ к исходной функции и дополнительным данным между вызовами.</p><p><em>Декораторы — мощный паттерн для разделения ответственности и переиспользования логики.</em></p>",
    difficulty: 'senior',
    tags: ['декораторы', 'замыкания', 'функции высшего порядка', 'паттерны проектирования']
  },
  {
    id: 28,
    question: "Как работают замыкания в асинхронном коде (Promise, async/await)?",
    answer: "<p>Замыкания играют ключевую роль в асинхронном JavaScript, сохраняя доступ к переменным между различными фазами выполнения.</p><h4>Замыкания в Promises:</h4><h4>1. Сохранение контекста:</h4><p>Callback функции в <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code> сохраняют доступ к переменным через замыкания.</p><h4>2. Цепочки промисов:</h4><p>Каждый элемент цепочки может использовать переменные из предыдущих шагов.</p><h4>Замыкания в async/await:</h4><p>Async функции также создают замыкания, позволяя await выражениям получать доступ к переменным внешней области.</p><h4>Типичные проблемы:</h4><h4>1. Изменение переменных:</h4><p>Переменные могут изменяться между созданием промиса и его выполнением.</p><h4>2. Циклы с асинхронными операциями:</h4><p>Классическая проблема с <code>var</code> в циклах усугубляется при асинхронности.</p><h4>Практические применения:</h4><ul><li><strong>Обработка ошибок:</strong> Сохранение контекста для логирования</li><li><strong>Конфигурация запросов:</strong> Использование настроек из внешней области</li><li><strong>Состояние компонентов:</strong> В React и других фреймворках</li><li><strong>Middleware:</strong> Сохранение состояния между вызовами</li></ul><p><em>Понимание замыканий критично для правильной работы с асинхронным JavaScript.</em></p>",
    difficulty: 'senior',
    tags: ['замыкания', 'асинхронный код', 'Promise', 'async/await', 'контекст']
  },
  {
    id: 29,
    question: "Что такое фабричные функции и как они используют замыкания?",
    answer: "<p><strong>Фабричные функции</strong> — это функции, которые создают и возвращают объекты, используя замыкания для инкапсуляции данных и поведения.</p><h4>Принцип работы:</h4><h4>1. Создание локального состояния:</h4><p>Переменные объявляются внутри фабричной функции.</p><h4>2. Возврат объекта с методами:</h4><p>Методы имеют доступ к локальным переменным через замыкания.</p><h4>3. Инкапсуляция:</h4><p>Приватные данные недоступны извне, только через публичные методы.</p><h4>Преимущества фабричных функций:</h4><ul><li><strong>Гибкость:</strong> Не требуют <code>new</code>, возвращают любые объекты</li><li><strong>Приватность:</strong> Естественная инкапсуляция через замыкания</li><li><strong>Композиция:</strong> Легко комбинировать с другими функциями</li><li><strong>Отсутствие проблем с this:</strong> Нет привязки к контексту</li></ul><h4>Сравнение с классами:</h4><p><strong>Фабричные функции:</strong> Используют замыкания, более функциональный подход.</p><p><strong>Классы:</strong> Используют прототипы, более ООП подход.</p><h4>Использование с модулями:</h4><p>Фабричные функции отлично сочетаются с модульным паттерном для создания переиспользуемых компонентов.</p><p><em>Фабричные функции — отличная альтернатива классам для создания объектов с приватным состоянием.</em></p>",
    difficulty: 'middle',
    tags: ['фабричные функции', 'замыкания', 'инкапсуляция', 'объекты', 'альтернатива классам']
  },
  {
    id: 30,
    question: "Как отладить проблемы, связанные с замыканиями?",
    answer: "<p>Отладка замыканий может быть с
];
