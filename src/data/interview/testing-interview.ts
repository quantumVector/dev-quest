export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const testingInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое тестирование и зачем оно нужно в разработке ПО?",
    answer: "<p><strong>Тестирование</strong> — это процесс проверки программного обеспечения на соответствие требованиям и ожиданиям, а также выявления дефектов до того, как продукт попадет к конечным пользователям.</p><h4>Основные цели тестирования:</h4><ul><li><strong>Обеспечение качества:</strong> Проверка, что приложение работает правильно и соответствует требованиям</li><li><strong>Поиск дефектов:</strong> Раннее обнаружение ошибок снижает стоимость их исправления</li><li><strong>Снижение рисков:</strong> Уменьшение вероятности критических сбоев в продакшене</li><li><strong>Улучшение дизайна:</strong> Тестируемый код обычно лучше структурирован</li><li><strong>Документация:</strong> Тесты служат живой документацией поведения системы</li></ul><p><strong>Стоимость исправления:</strong> Чем позже обнаружена ошибка, тем дороже ее исправить. Баг, найденный на этапе разработки, может стоить 1 условную единицу, на этапе тестирования — 10, а в продакшене — 100 и более.</p><p><em>Вывод:</em> Тестирование — это не роскошь, а необходимость для создания качественного и надежного программного обеспечения.</p>",
    difficulty: 'junior',
    tags: ['основы', 'качество', 'цели тестирования']
  },
  {
    id: 2,
    question: "Какие основные виды тестирования вы знаете?",
    answer: "<p>Существует множество видов тестирования, которые можно классифицировать по разным признакам:</p><h4>По уровню детализации:</h4><ul><li><strong>Unit-тестирование:</strong> Тестирование отдельных модулей, функций, компонентов в изоляции</li><li><strong>Integration-тестирование:</strong> Проверка взаимодействия между компонентами системы</li><li><strong>System-тестирование:</strong> Тестирование системы в целом</li><li><strong>E2E-тестирование:</strong> Проверка полных сценариев работы пользователя</li></ul><h4>По знанию системы:</h4><ul><li><strong>Black-box:</strong> Тестирование без знания внутренней структуры</li><li><strong>White-box:</strong> Тестирование с полным знанием кода</li><li><strong>Gray-box:</strong> Частичное знание внутренней структуры</li></ul><h4>По целям:</h4><ul><li><strong>Функциональное:</strong> Проверка соответствия функциональным требованиям</li><li><strong>Нефункциональное:</strong> Производительность, безопасность, юзабилити</li><li><strong>Регрессионное:</strong> Проверка, что новые изменения не сломали существующий функционал</li></ul><p><em>Важно:</em> Выбор видов тестирования зависит от проекта, требований и доступных ресурсов.</p>",
    difficulty: 'junior',
    tags: ['виды тестирования', 'классификация', 'уровни тестирования']
  },
  {
    id: 3,
    question: "Объясните пирамиду тестирования и почему она важна",
    answer: "<p><strong>Пирамида тестирования</strong> — это концепция, которая показывает оптимальное соотношение различных типов тестов в проекте.</p><h4>Структура пирамиды (снизу вверх):</h4><p><strong>1. Unit-тесты (основание, ~70%):</strong></p><ul><li>Быстрые, дешевые в поддержке</li><li>Изолированное тестирование логики</li><li>Легко локализовать проблемы</li><li>Можно запускать очень часто</li></ul><p><strong>2. Integration-тесты (середина, ~20%):</strong></p><ul><li>Тестируют взаимодействие компонентов</li><li>Медленнее unit-тестов</li><li>Проверяют интеграционные точки</li><li>Важны для API и баз данных</li></ul><p><strong>3. E2E-тесты (вершина, ~10%):</strong></p><ul><li>Самые медленные и хрупкие</li><li>Тестируют критические пользовательские сценарии</li><li>Дорогие в поддержке</li><li>Запускаются реже всех</li></ul><h4>Почему именно пирамида:</h4><p>Чем выше уровень тестирования, тем тесты дороже в создании и поддержке, медленнее выполняются и сложнее в отладке. Поэтому их должно быть меньше.</p><p><em>Антипаттерн:</em> Перевернутая пирамида или «мороженое» — когда много E2E-тестов и мало unit-тестов — приводит к медленной обратной связи и сложностям в поддержке.</p>",
    difficulty: 'middle',
    tags: ['пирамида тестирования', 'стратегия', 'соотношение тестов']
  },
  {
    id: 4,
    question: "В чем разница между unit, integration и E2E тестами на практике?",
    answer: "<p>Рассмотрим на примере интернет-магазина:</p><h4>Unit-тест:</h4><p><strong>Что тестируем:</strong> Функцию расчета общей стоимости корзины</p><p><strong>Как:</strong> Передаем массив товаров с ценами, проверяем, что функция возвращает правильную сумму</p><p><strong>Особенности:</strong> Все зависимости замокированы, тест выполняется за миллисекунды, проверяет только чистую логику</p><h4>Integration-тест:</h4><p><strong>Что тестируем:</strong> API endpoint для добавления товара в корзину</p><p><strong>Как:</strong> Отправляем HTTP-запрос, проверяем, что товар сохранился в базе данных и вернулся правильный ответ</p><p><strong>Особенности:</strong> Работает с реальной БД (тестовой), проверяет взаимодействие нескольких компонентов, выполняется за секунды</p><h4>E2E-тест:</h4><p><strong>Что тестируем:</strong> Полный сценарий покупки</p><p><strong>Как:</strong> Открываем браузер, заходим на сайт, ищем товар, добавляем в корзину, оформляем заказ, проверяем подтверждение</p><p><strong>Особенности:</strong> Тестирует всю систему целиком включая UI, может занимать минуты, проверяет реальный пользовательский опыт</p><p><em>Практический совет:</em> Для одной фичи должно быть много unit-тестов, несколько integration-тестов и 1-2 E2E-теста на критические сценарии.</p>",
    difficulty: 'middle',
    tags: ['unit', 'integration', 'E2E', 'практика', 'примеры']
  },
  {
    id: 5,
    question: "Что такое TDD (Test-Driven Development) и каковы его преимущества?",
    answer: "<p><strong>TDD</strong> — это методология разработки, при которой тесты пишутся до написания продакшен-кода.</p><h4>Цикл TDD (Red-Green-Refactor):</h4><p><strong>1. Red (Красный):</strong></p><ul><li>Пишем тест для новой функциональности</li><li>Запускаем — тест падает (красный), так как код еще не написан</li><li>Это подтверждает, что тест действительно что-то проверяет</li></ul><p><strong>2. Green (Зеленый):</strong></p><ul><li>Пишем минимальный код, чтобы тест прошел</li><li>Фокус на работоспособности, не на красоте кода</li><li>Тест становится зеленым</li></ul><p><strong>3. Refactor (Рефакторинг):</strong></p><ul><li>Улучшаем код, не меняя поведение</li><li>Тесты остаются зелеными и защищают от ошибок</li><li>Улучшаем структуру, читаемость, производительность</li></ul><h4>Преимущества TDD:</h4><ul><li><strong>Лучший дизайн:</strong> Код становится более модульным и тестируемым</li><li><strong>Документация:</strong> Тесты описывают, как должен работать код</li><li><strong>Уверенность в рефакторинге:</strong> Можно смело менять код</li><li><strong>Меньше багов:</strong> Проблемы обнаруживаются на ранней стадии</li><li><strong>Фокус:</strong> Помогает четко определить требования</li></ul><h4>Недостатки:</h4><ul><li>Требует времени на изучение подхода</li><li>Может замедлить разработку на начальном этапе</li><li>Не подходит для исследовательского программирования</li></ul>",
    difficulty: 'middle',
    tags: ['TDD', 'методологии', 'разработка через тестирование']
  },
  {
    id: 6,
    question: "Что такое моки, стабы и шпионы? Когда их использовать?",
    answer: "<p>Это тестовые дублеры (test doubles), которые заменяют реальные зависимости в тестах:</p><h4>Stub (Заглушка):</h4><p><strong>Что делает:</strong> Возвращает заранее определенные данные</p><p><strong>Когда использовать:</strong> Когда нужно контролировать входные данные для тестируемого кода</p><p><strong>Пример:</strong> API всегда возвращает одного и того же пользователя, чтобы протестировать обработку ответа</p><h4>Mock (Мок):</h4><p><strong>Что делает:</strong> Имитирует поведение и проверяет, что методы были вызваны правильно</p><p><strong>Когда использовать:</strong> Когда важно проверить взаимодействие с зависимостью</p><p><strong>Пример:</strong> Проверяем, что метод отправки email был вызван с правильными параметрами</p><h4>Spy (Шпион):</h4><p><strong>Что делает:</strong> Оборачивает реальный объект и записывает информацию о вызовах</p><p><strong>Когда использовать:</strong> Когда нужно использовать реальную реализацию, но отследить вызовы</p><p><strong>Пример:</strong> Используем реальную функцию логирования, но проверяем, что она была вызвана</p><h4>Практические рекомендации:</h4><ul><li>Не мокируйте то, чем не владеете (внешние библиотеки)</li><li>Избегайте чрезмерного моканья — признак плохого дизайна</li><li>Моки делают тесты хрупкими — используйте их осознанно</li><li>Предпочитайте реальные объекты, когда это возможно</li></ul>",
    difficulty: 'middle',
    tags: ['моки', 'стабы', 'шпионы', 'test doubles', 'изоляция']
  },
  {
    id: 7,
    question: "Как писать хорошие unit-тесты? Какие есть best practices?",
    answer: "<p>Хорошие unit-тесты обладают рядом качеств и следуют определенным принципам:</p><h4>F.I.R.S.T принципы:</h4><p><strong>Fast (Быстрые):</strong> Должны выполняться за миллисекунды, чтобы их можно было запускать часто</p><p><strong>Independent (Независимые):</strong> Не должны зависеть друг от друга, можно запускать в любом порядке</p><p><strong>Repeatable (Повторяемые):</strong> Всегда дают одинаковый результат при одинаковых условиях</p><p><strong>Self-validating (Самопроверяющиеся):</strong> Тест либо проходит, либо нет, без ручной проверки</p><p><strong>Timely (Своевременные):</strong> Пишутся до или вместе с продакшен-кодом</p><h4>AAA паттерн (Arrange-Act-Assert):</h4><ul><li><strong>Arrange:</strong> Подготовка данных и настройка окружения</li><li><strong>Act:</strong> Выполнение тестируемого действия</li><li><strong>Assert:</strong> Проверка результата</li></ul><h4>Лучшие практики:</h4><ul><li><strong>Один тест — одна проверка:</strong> Тест должен проверять одно поведение</li><li><strong>Говорящие имена:</strong> Имя теста должно объяснять, что тестируется и ожидается</li><li><strong>DRY с осторожностью:</strong> Дублирование в тестах иногда лучше, чем сложная абстракция</li><li><strong>Избегайте логики в тестах:</strong> Условия и циклы усложняют понимание</li><li><strong>Тестируйте поведение, а не реализацию:</strong> Тесты не должны знать о внутренностях</li></ul><h4>Чего избегать:</h4><ul><li>Тестов, которые проверяют несколько вещей одновременно</li><li>Зависимостей между тестами</li><li>Тестирования приватных методов напрямую</li><li>Хрупких тестов, которые ломаются при малейшем изменении кода</li></ul>",
    difficulty: 'middle',
    tags: ['unit-тесты', 'best practices', 'качество тестов', 'FIRST']
  },
  {
    id: 8,
    question: "Что такое покрытие кода (code coverage) и нужно ли стремиться к 100%?",
    answer: "<p><strong>Code Coverage</strong> — это метрика, показывающая, какой процент кода был выполнен во время тестирования.</p><h4>Виды покрытия:</h4><p><strong>Line Coverage (покрытие строк):</strong> Процент выполненных строк кода</p><p><strong>Branch Coverage (покрытие ветвлений):</strong> Процент проверенных веток условий (if/else)</p><p><strong>Function Coverage (покрытие функций):</strong> Процент вызванных функций</p><p><strong>Statement Coverage (покрытие выражений):</strong> Процент выполненных выражений</p><h4>Нужно ли стремиться к 100%:</h4><p><strong>Аргументы «за»:</strong></p><ul><li>Гарантия, что весь код хоть раз выполнился</li><li>Обнаружение мертвого кода</li><li>Психологическая уверенность</li></ul><p><strong>Аргументы «против»:</strong></p><ul><li>100% покрытие НЕ гарантирует отсутствие багов</li><li>Может привести к бессмысленным тестам ради метрики</li><li>Последние 10-20% очень дороги в достижении</li><li>Фокус смещается с качества на количество</li></ul><h4>Здравый подход:</h4><ul><li>70-80% покрытия — хороший показатель для большинства проектов</li><li>Покрытие — это индикатор, а не цель</li><li>Важнее качество тестов, чем процент покрытия</li><li>Критический код (платежи, безопасность) должен быть покрыт максимально</li><li>Некоторый код (getters/setters, конфиги) можно не покрывать</li></ul><p><em>Цитата:</em> «100% code coverage не означает 100% протестированное приложение. Можно вызвать каждую строку кода и при этом не проверить ни одного edge case.»</p>",
    difficulty: 'middle',
    tags: ['code coverage', 'метрики', 'качество тестов']
  },
  {
    id: 9,
    question: "Как тестировать асинхронный код?",
    answer: "<p>Тестирование асинхронного кода имеет свои особенности в зависимости от используемого подхода:</p><h4>Callbacks:</h4><p><strong>Проблема:</strong> Тест может завершиться до выполнения callback</p><p><strong>Решение:</strong> Использовать done callback, который вызывается после проверок</p><p><strong>Важно:</strong> Обязательно вызвать done() или done(error), иначе тест зависнет</p><h4>Promises:</h4><p><strong>Подход 1:</strong> Вернуть промис из теста — фреймворк дождется его разрешения</p><p><strong>Подход 2:</strong> Использовать async/await для более читаемого кода</p><p><strong>Важно:</strong> Обязательно вернуть промис или использовать await</p><h4>Async/Await (современный подход):</h4><p><strong>Преимущества:</strong></p><ul><li>Самый читаемый синтаксис</li><li>Легко тестировать последовательность асинхронных операций</li><li>Удобная обработка ошибок через try/catch</li></ul><h4>Проблемы и решения:</h4><p><strong>Таймауты:</strong> Увеличивайте таймаут для медленных операций или используйте фейковые таймеры</p><p><strong>Race conditions:</strong> Используйте waitFor или подобные утилиты для ожидания состояний</p><p><strong>Недетерминированность:</strong> Мокируйте время или используйте fake timers (jest.useFakeTimers)</p><h4>Best practices:</h4><ul><li>Используйте async/await — самый чистый подход</li><li>Всегда обрабатывайте rejected промисы</li><li>Используйте fake timers для тестов с setTimeout/setInterval</li><li>Мокируйте HTTP-запросы вместо реальных вызовов</li><li>Используйте утилиты типа waitFor для асинхронных проверок</li></ul>",
    difficulty: 'senior',
    tags: ['асинхронность', 'promises', 'async/await', 'тестирование']
  },
  {
    id: 10,
    question: "Что такое integration-тестирование и как его правильно организовать?",
    answer: "<p><strong>Integration-тестирование</strong> проверяет взаимодействие между различными модулями или компонентами системы.</p><h4>Что тестируем на integration-уровне:</h4><ul><li>Взаимодействие фронтенда с API</li><li>Работу с базой данных</li><li>Интеграцию со сторонними сервисами</li><li>Взаимодействие между модулями приложения</li><li>Правильность передачи данных между слоями</li></ul><h4>Подходы к организации:</h4><p><strong>Bottom-up (снизу вверх):</strong></p><ul><li>Начинаем с низкоуровневых модулей</li><li>Постепенно интегрируем более высокие уровни</li><li>Подходит для систем с четкой архитектурой</li></ul><p><strong>Top-down (сверху вниз):</strong></p><ul><li>Начинаем с высокоуровневых компонентов</li><li>Используем стабы для недостающих модулей</li><li>Хорошо для раннего тестирования основных сценариев</li></ul><p><strong>Big Bang (все сразу):</strong></p><ul><li>Интегрируем все модули одновременно</li><li>Сложно локализовать проблемы</li><li>Подходит только для маленьких систем</li></ul><h4>Best practices:</h4><ul><li><strong>Изоляция тестового окружения:</strong> Используйте отдельные БД/сервисы для тестов</li><li><strong>Setup и Teardown:</strong> Очищайте состояние между тестами</li><li><strong>Фикстуры:</strong> Готовьте тестовые данные заранее</li><li><strong>Контейнеризация:</strong> Docker для единообразного окружения</li><li><strong>Выборочность:</strong> Не тестируйте все комбинации, фокусируйтесь на критических путях</li></ul><h4>Типичные ошибки:</h4><ul><li>Использование продакшн-баз данных</li><li>Зависимость от внешних сервисов без моков</li><li>Слишком много integration-тестов вместо unit</li><li>Тесты, которые падают из-за порядка выполнения</li></ul>",
    difficulty: 'senior',
    tags: ['integration', 'интеграционные тесты', 'архитектура тестов']
  },
  {
    id: 11,
    question: "Как тестировать UI компоненты? Какие существуют подходы?",
    answer: "<p>Тестирование UI компонентов можно проводить на разных уровнях:</p><h4>Unit-тестирование компонентов:</h4><p><strong>Что тестируем:</strong> Логику компонента в изоляции</p><p><strong>Инструменты:</strong> React Testing Library, Jest, Enzyme</p><p><strong>Подход:</strong></p><ul><li>Рендерим компонент</li><li>Имитируем пользовательские действия</li><li>Проверяем результат без реального браузера</li></ul><p><strong>Что проверяем:</strong></p><ul><li>Правильность рендеринга</li><li>Обработку событий</li><li>Условный рендеринг</li><li>Передачу props</li></ul><h4>Snapshot-тестирование:</h4><p><strong>Принцип:</strong> Сохраняем снимок структуры компонента и сравниваем с ним при изменениях</p><p><strong>Плюсы:</strong> Быстро обнаруживает неожиданные изменения</p><p><strong>Минусы:</strong> Легко получить false positives, требует дисциплины в обновлении</p><h4>Visual Regression Testing:</h4><p><strong>Что делает:</strong> Сравнивает скриншоты компонента</p><p><strong>Инструменты:</strong> Percy, Chromatic, BackstopJS</p><p><strong>Применение:</strong> Отлавливает визуальные регрессии (сломанные стили, смещения)</p><h4>E2E для критических UI флоу:</h4><p><strong>Инструменты:</strong> Cypress, Playwright, Selenium</p><p><strong>Когда:</strong> Для проверки полных пользовательских сценариев</p><h4>Best practices:</h4><ul><li><strong>Тестируйте с точки зрения пользователя:</strong> Используйте доступные имена, роли, текст</li><li><strong>Избегайте тестирования реализации:</strong> Не привязывайтесь к структуре компонента</li><li><strong>Accessibility-first:</strong> Если компонент сложно протестировать, возможно, он недоступен</li><li><strong>Изолируйте:</strong> Мокируйте внешние зависимости</li><li><strong>Осторожно со snapshots:</strong> Они дополняют, но не заменяют настоящие тесты</li></ul>",
    difficulty: 'senior',
    tags: ['UI тестирование', 'компоненты', 'React', 'E2E']
  },
  {
    id: 12,
    question: "Что такое E2E тестирование и когда его применять?",
    answer: "<p><strong>E2E (End-to-End) тестирование</strong> — это проверка приложения целиком, от начала до конца, имитируя реальное поведение пользователя.</p><h4>Характеристики E2E тестов:</h4><ul><li>Тестируют всю систему: фронтенд, бэкенд, базу данных, интеграции</li><li>Используют реальный браузер (или headless)</li><li>Проверяют полные пользовательские сценарии</li><li>Самые медленные и дорогие в поддержке</li><li>Наиболее хрупкие — много точек отказа</li></ul><h4>Когда применять E2E:</h4><p><strong>Критические бизнес-процессы:</strong></p><ul><li>Регистрация и авторизация</li><li>Оформление заказа и оплата</li><li>Ключевые пользовательские флоу</li></ul><p><strong>Проверка интеграций:</strong></p><ul><li>Работа со сторонними API</li><li>Платежные системы</li><li>Email/SMS уведомления</li></ul><p><strong>Smoke тесты:</strong></p><ul><li>Быстрая проверка, что приложение работает</li><li>Запуск после деплоя</li></ul><h4>Популярные инструменты:</h4><p><strong>Cypress:</strong></p><ul><li>Быстрый, современный, с отличным DX</li><li>Работает в том же контексте, что и приложение</li><li>Отличная отладка</li></ul><p><strong>Playwright:</strong></p><ul><li>Поддержка всех браузеров</li><li>Параллельное выполнение</li><li>Автоматическое ожидание</li></ul><p><strong>Selenium:</strong></p><ul><li>Старый, проверенный инструмент</li><li>Поддержка многих языков</li><li>Сложнее в настройке</li></ul><h4>Best practices:</h4><ul><li><strong>Минимизируйте количество:</strong> Только критические сценарии</li><li><strong>Делайте стабильными:</strong> Используйте data-testid, избегайте селекторов по классам</li><li><strong>Изолируйте данные:</strong> Каждый тест должен готовить свои данные</li><li><strong>Параллелизация:</strong> Запускайте тесты параллельно для ускорения</li><li><strong>Не дублируйте unit-тесты:</strong> E2E для флоу, unit для логики</li></ul>",
    difficulty: 'senior',
    tags: ['E2E', 'end-to-end', 'Cypress', 'Playwright', 'интеграционные тесты']
  },
  {
    id: 13,
    question: "Как организовать тестирование в CI/CD pipeline?",
    answer: "<p>Интеграция тестирования в CI/CD — критически важная часть современной разработки:</p><h4>Этапы тестирования в pipeline:</h4><p><strong>1. Pre-commit (локально):</strong></p><ul><li>Линтеры и форматтеры (ESLint, Prettier)</li><li>Быстрые unit-тесты на измененные файлы</li><li>Хуки через Husky или lint-staged</li></ul><p><strong>2. Pull Request / Merge Request:</strong></p><ul><li>Полный прогон unit-тестов</li><li>Integration-тесты</li><li>Проверка code coverage</li><li>Статический анализ кода</li></ul><p><strong>3. Main/Master branch:</strong></p><ul><li>Все тесты из PR +</li><li>E2E тесты на staging окружении</li><li>Performance тесты</li><li>Security сканирование</li></ul><p><strong>4. Production deployment:</strong></p><ul><li>Smoke тесты после деплоя</li><li>Мониторинг критических метрик</li><li>Возможность быстрого отката</li></ul><h4>Стратегии оптимизации:</h4><p><strong>Параллелизация:</strong></p><ul><li>Запуск тестов на нескольких машинах</li><li>Разделение по типам (unit, integration, E2E)</li><li>Использование test sharding</li></ul><p><strong>Кэширование:</strong></p><ul><li>Кэш зависимостей (node_modules)</li><li>Кэш результатов тестов</li><li>Incremental testing (только измененное)</li></ul><p><strong>Fail Fast:</strong></p><ul><li>Останавливать pipeline при первом падении</li><li>Запускать быстрые тесты первыми</li><li>Отложенные E2E (не блокируют PR)</li></ul><h4>Инструменты:</h4><ul><li><strong>GitHub Actions:</strong> Нативная интеграция с GitHub</li><li><strong>GitLab CI:</strong> Мощный и гибкий</li><li><strong>Jenkins:</strong> Классика, много плагинов</li><li><strong>CircleCI:</strong> Хорошая производительность</li></ul><h4>Метрики для отслеживания:</h4><ul><li>Время выполнения тестов</li><li>Процент падающих тестов (flaky tests)</li><li>Code coverage динамика</li><li>Среднее время до обнаружения бага</li></ul>",
    difficulty: 'senior',
    tags: ['CI/CD', 'автоматизация', 'DevOps', 'pipeline']
  },
  {
    id: 14,
    question: "Что такое flaky tests и как с ними бороться?",
    answer: "<p><strong>Flaky tests (нестабильные тесты)</strong> — это тесты, которые могут проходить или падать непредсказуемо при одном и том же коде.</p><h4>Основные причины нестабильности:</h4><p><strong>1. Асинхронность:</strong></p><ul><li>Гонки (race conditions)</li><li>Недостаточные таймауты</li><li>Неправильное ожидание асинхронных операций</li></ul><p><strong>2. Зависимости между тестами:</strong></p><ul><li>Общее состояние</li><li>Порядок выполнения имеет значение</li><li>Неочищенные данные после тестов</li></ul><p><strong>3. Внешние зависимости:</strong></p><ul><li>Реальные API вместо моков</li><li>Сетевые проблемы</li><li>Зависимость от текущей даты/времени</li></ul><p><strong>4. Недетерминированность:</strong></p><ul><li>Случайные данные без seed</li><li>Параллельное выполнение с конфликтами</li><li>Проблемы с animations и transitions</li></ul><h4>Методы борьбы:</h4><p><strong>Превентивные меры:</strong></p><ul><li><strong>Изоляция:</strong> Каждый тест независим, очищает за собой</li><li><strong>Детерминированность:</strong> Используйте фиксированные данные и mock времени</li><li><strong>Правильное ожидание:</strong> waitFor вместо фиксированных таймаутов</li><li><strong>Мокирование:</strong> Все внешние зависимости должны быть замокированы</li></ul><p><strong>Диагностика:</strong></p><ul><li>Запускайте тесты многократно для выявления нестабильных</li><li>Используйте инструменты отслеживания (flaky test detection)</li><li>Логируйте состояние при падении</li><li>Сохраняйте скриншоты/видео для E2E</li></ul><p><strong>Управление:</strong></p><ul><li>Помечайте flaky тесты (skip/quarantine)</li><li>Не игнорируйте — исправляйте приоритетно</li><li>Временно отключайте блокирующие тесты, но фиксируйте задачу</li><li>Используйте retry только как временное решение</li></ul><h4>Стратегия в команде:</h4><ul><li>Flaky test = баг высокого приоритета</li><li>Метрика flakiness в dashboard</li><li>Политика zero tolerance для критических тестов</li></ul>",
    difficulty: 'senior',
    tags: ['flaky tests', 'нестабильность', 'качество тестов', 'отладка']
  },
  {
    id: 15,
    question: "Как оценить эффективность тестирования в проекте?",
    answer: "<p>Эффективность тестирования измеряется не только метриками, но и реальным влиянием на качество продукта:</p><h4>Количественные метрики:</h4><p><strong>Code Coverage:</strong></p><ul><li>Процент покрытого кода</li><li>Важно: не цель, а индикатор</li><li>Branch coverage важнее line coverage</li></ul><p><strong>Defect Detection Rate (DDR):</strong></p><ul><li>Сколько багов находят тесты vs находят пользователи</li><li>Идеал: большинство багов находится на этапе тестирования</li></ul><p><strong>Test Execution Time:</strong></p><ul><li>Время прогона всех тестов</li><li>Быстрая обратная связь критична для продуктивности</li></ul><p><strong>Flakiness Rate:</strong></p><ul><li>Процент нестабильных тестов</li><li>Должен стремиться к нулю</li></ul><h4>Качественные показатели:</h4><p><strong>Уверенность в рефакторинге:</strong></p><ul><li>Насколько команда боится менять код?</li><li>Как часто рефакторинг приводит к багам?</li></ul><p><strong>Time to Detection:</strong></p><ul><li>Как быстро обнаруживаются проблемы?</li><li>На каком этапе (dev, CI, staging, prod)?</li></ul><p><strong>Regression Prevention:</strong></p><ul><li>Как часто возвращаются старые баги?</li><li>Эффективность регрессионных тестов</li></ul><h4>Бизнес-метрики:</h4><ul><li><strong>Production Incidents:</strong> Количество и серьезность багов в проде</li><li><strong>Mean Time To Recovery (MTTR):</strong> Скорость исправления проблем</li><li><strong>Customer Satisfaction:</strong> Влияние на пользовательский опыт</li><li><strong>Development Velocity:</strong> Скорость доставки фич</li></ul><h4>Признаки эффективного тестирования:</h4><ul><li>Команда уверенно деплоит в любое время</li><li>Баги обычно находятся до продакшена</li><li>Рефакторинг не пугает</li><li>CI/CD pipeline работает быстро и надежно</li><li>Документация тестов помогает новым разработчикам</li></ul><h4>Red flags:</h4><ul><li>Много времени тратится на поддержку тестов</li><li>Тесты часто падают без причины</li><li>Баги постоянно находят пользователи, а не тесты</li><li>Команда избегает запускать тесты</li><li>Высокий coverage, но низкое доверие к тестам</li></ul><p><em>Главное правило:</em> Тесты должны помогать разработке, а не мешать. Если команда тратит больше времени на тесты, чем экономит — что-то не так.</p>",
    difficulty: 'senior',
    tags: ['метрики', 'эффективность', 'качество', 'оценка тестирования']
  }
]
