export interface InterviewQuestion {
  id: number
  question: string
  answer: string
  difficulty?: 'junior' | 'middle' | 'senior'
  tags?: string[]
}

export const testingInterviewQuestions: InterviewQuestion[] = [
  {
    id: 1,
    question: "Что такое тестирование и зачем оно нужно в разработке ПО?",
    answer: "<p><strong>Тестирование</strong> — это процесс проверки программного обеспечения на соответствие требованиям и ожиданиям, а также выявления дефектов до того, как продукт попадет к конечным пользователям.</p><h4>Основные цели тестирования:</h4><ul><li><strong>Обеспечение качества:</strong> Проверка, что приложение работает правильно и соответствует требованиям</li><li><strong>Поиск дефектов:</strong> Раннее обнаружение ошибок снижает стоимость их исправления</li><li><strong>Снижение рисков:</strong> Уменьшение вероятности критических сбоев в продакшене</li><li><strong>Улучшение дизайна:</strong> Тестируемый код обычно лучше структурирован</li><li><strong>Документация:</strong> Тесты служат живой документацией поведения системы</li></ul><p><strong>Стоимость исправления:</strong> Чем позже обнаружена ошибка, тем дороже ее исправить. Баг, найденный на этапе разработки, может стоить 1 условную единицу, на этапе тестирования — 10, а в продакшене — 100 и более.</p><p><em>Вывод:</em> Тестирование — это не роскошь, а необходимость для создания качественного и надежного программного обеспечения.</p>",
    difficulty: 'junior',
    tags: ['основы', 'качество', 'цели тестирования']
  },
  {
    id: 2,
    question: "Какие основные виды тестирования вы знаете?",
    answer: "<p>Существует множество видов тестирования, которые можно классифицировать по разным признакам:</p><h4>По уровню детализации:</h4><ul><li><strong>Unit-тестирование:</strong> Тестирование отдельных модулей, функций, компонентов в изоляции</li><li><strong>Integration-тестирование:</strong> Проверка взаимодействия между компонентами системы</li><li><strong>System-тестирование:</strong> Тестирование системы в целом</li><li><strong>E2E-тестирование:</strong> Проверка полных сценариев работы пользователя</li></ul><h4>По знанию системы:</h4><ul><li><strong>Black-box:</strong> Тестирование без знания внутренней структуры</li><li><strong>White-box:</strong> Тестирование с полным знанием кода</li><li><strong>Gray-box:</strong> Частичное знание внутренней структуры</li></ul><h4>По целям:</h4><ul><li><strong>Функциональное:</strong> Проверка соответствия функциональным требованиям</li><li><strong>Нефункциональное:</strong> Производительность, безопасность, юзабилити</li><li><strong>Регрессионное:</strong> Проверка, что новые изменения не сломали существующий функционал</li></ul><p><em>Важно:</em> Выбор видов тестирования зависит от проекта, требований и доступных ресурсов.</p>",
    difficulty: 'junior',
    tags: ['виды тестирования', 'классификация', 'уровни тестирования']
  },
  {
    id: 3,
    question: "Объясните пирамиду тестирования и почему она важна",
    answer: "<p><strong>Пирамида тестирования</strong> — это концепция, которая показывает оптимальное соотношение различных типов тестов в проекте.</p><h4>Структура пирамиды (снизу вверх):</h4><p><strong>1. Unit-тесты (основание, ~70%):</strong></p><ul><li>Быстрые, дешевые в поддержке</li><li>Изолированное тестирование логики</li><li>Легко локализовать проблемы</li><li>Можно запускать очень часто</li></ul><p><strong>2. Integration-тесты (середина, ~20%):</strong></p><ul><li>Тестируют взаимодействие компонентов</li><li>Медленнее unit-тестов</li><li>Проверяют интеграционные точки</li><li>Важны для API и баз данных</li></ul><p><strong>3. E2E-тесты (вершина, ~10%):</strong></p><ul><li>Самые медленные и хрупкие</li><li>Тестируют критические пользовательские сценарии</li><li>Дорогие в поддержке</li><li>Запускаются реже всех</li></ul><h4>Почему именно пирамида:</h4><p>Чем выше уровень тестирования, тем тесты дороже в создании и поддержке, медленнее выполняются и сложнее в отладке. Поэтому их должно быть меньше.</p><p><em>Антипаттерн:</em> Перевернутая пирамида или «мороженое» — когда много E2E-тестов и мало unit-тестов — приводит к медленной обратной связи и сложностям в поддержке.</p>",
    difficulty: 'middle',
    tags: ['пирамида тестирования', 'стратегия', 'соотношение тестов']
  },
  {
    id: 4,
    question: "В чем разница между unit, integration и E2E тестами на практике?",
    answer: "<p>Рассмотрим на примере интернет-магазина:</p><h4>Unit-тест:</h4><p><strong>Что тестируем:</strong> Функцию расчета общей стоимости корзины</p><p><strong>Как:</strong> Передаем массив товаров с ценами, проверяем, что функция возвращает правильную сумму</p><p><strong>Особенности:</strong> Все зависимости замокированы, тест выполняется за миллисекунды, проверяет только чистую логику</p><h4>Integration-тест:</h4><p><strong>Что тестируем:</strong> API endpoint для добавления товара в корзину</p><p><strong>Как:</strong> Отправляем HTTP-запрос, проверяем, что товар сохранился в базе данных и вернулся правильный ответ</p><p><strong>Особенности:</strong> Работает с реальной БД (тестовой), проверяет взаимодействие нескольких компонентов, выполняется за секунды</p><h4>E2E-тест:</h4><p><strong>Что тестируем:</strong> Полный сценарий покупки</p><p><strong>Как:</strong> Открываем браузер, заходим на сайт, ищем товар, добавляем в корзину, оформляем заказ, проверяем подтверждение</p><p><strong>Особенности:</strong> Тестирует всю систему целиком включая UI, может занимать минуты, проверяет реальный пользовательский опыт</p><p><em>Практический совет:</em> Для одной фичи должно быть много unit-тестов, несколько integration-тестов и 1-2 E2E-теста на критические сценарии.</p>",
    difficulty: 'middle',
    tags: ['unit', 'integration', 'E2E', 'практика', 'примеры']
  },
  {
    id: 5,
    question: "Что такое TDD (Test-Driven Development) и каковы его преимущества?",
    answer: "<p><strong>TDD</strong> — это методология разработки, при которой тесты пишутся до написания продакшен-кода.</p><h4>Цикл TDD (Red-Green-Refactor):</h4><p><strong>1. Red (Красный):</strong></p><ul><li>Пишем тест для новой функциональности</li><li>Запускаем — тест падает (красный), так как код еще не написан</li><li>Это подтверждает, что тест действительно что-то проверяет</li></ul><p><strong>2. Green (Зеленый):</strong></p><ul><li>Пишем минимальный код, чтобы тест прошел</li><li>Фокус на работоспособности, не на красоте кода</li><li>Тест становится зеленым</li></ul><p><strong>3. Refactor (Рефакторинг):</strong></p><ul><li>Улучшаем код, не меняя поведение</li><li>Тесты остаются зелеными и защищают от ошибок</li><li>Улучшаем структуру, читаемость, производительность</li></ul><h4>Преимущества TDD:</h4><ul><li><strong>Лучший дизайн:</strong> Код становится более модульным и тестируемым</li><li><strong>Документация:</strong> Тесты описывают, как должен работать код</li><li><strong>Уверенность в рефакторинге:</strong> Можно смело менять код</li><li><strong>Меньше багов:</strong> Проблемы обнаруживаются на ранней стадии</li><li><strong>Фокус:</strong> Помогает четко определить требования</li></ul><h4>Недостатки:</h4><ul><li>Требует времени на изучение подхода</li><li>Может замедлить разработку на начальном этапе</li><li>Не подходит для исследовательского программирования</li></ul>",
    difficulty: 'middle',
    tags: ['TDD', 'методологии', 'разработка через тестирование']
  },
  {
    id: 6,
    question: "Что такое моки, стабы и шпионы? Когда их использовать?",
    answer: "<p>Это тестовые дублеры (test doubles), которые заменяют реальные зависимости в тестах:</p><h4>Stub (Заглушка):</h4><p><strong>Что делает:</strong> Возвращает заранее определенные данные</p><p><strong>Когда использовать:</strong> Когда нужно контролировать входные данные для тестируемого кода</p><p><strong>Пример:</strong> API всегда возвращает одного и того же пользователя, чтобы протестировать обработку ответа</p><h4>Mock (Мок):</h4><p><strong>Что делает:</strong> Имитирует поведение и проверяет, что методы были вызваны правильно</p><p><strong>Когда использовать:</strong> Когда важно проверить взаимодействие с зависимостью</p><p><strong>Пример:</strong> Проверяем, что метод отправки email был вызван с правильными параметрами</p><h4>Spy (Шпион):</h4><p><strong>Что делает:</strong> Оборачивает реальный объект и записывает информацию о вызовах</p><p><strong>Когда использовать:</strong> Когда нужно использовать реальную реализацию, но отследить вызовы</p><p><strong>Пример:</strong> Используем реальную функцию логирования, но проверяем, что она была вызвана</p><h4>Практические рекомендации:</h4><ul><li>Не мокируйте то, чем не владеете (внешние библиотеки)</li><li>Избегайте чрезмерного моканья — признак плохого дизайна</li><li>Моки делают тесты хрупкими — используйте их осознанно</li><li>Предпочитайте реальные объекты, когда это возможно</li></ul>",
    difficulty: 'middle',
    tags: ['моки', 'стабы', 'шпионы', 'test doubles', 'изоляция']
  },
  {
    id: 7,
    question: "Как писать хорошие unit-тесты? Какие есть best practices?",
    answer: "<p>Хорошие unit-тесты обладают рядом качеств и следуют определенным принципам:</p><h4>F.I.R.S.T принципы:</h4><p><strong>Fast (Быстрые):</strong> Должны выполняться за миллисекунды, чтобы их можно было запускать часто</p><p><strong>Independent (Независимые):</strong> Не должны зависеть друг от друга, можно запускать в любом порядке</p><p><strong>Repeatable (Повторяемые):</strong> Всегда дают одинаковый результат при одинаковых условиях</p><p><strong>Self-validating (Самопроверяющиеся):</strong> Тест либо проходит, либо нет, без ручной проверки</p><p><strong>Timely (Своевременные):</strong> Пишутся до или вместе с продакшен-кодом</p><h4>AAA паттерн (Arrange-Act-Assert):</h4><ul><li><strong>Arrange:</strong> Подготовка данных и настройка окружения</li><li><strong>Act:</strong> Выполнение тестируемого действия</li><li><strong>Assert:</strong> Проверка результата</li></ul><h4>Лучшие практики:</h4><ul><li><strong>Один тест — одна проверка:</strong> Тест должен проверять одно поведение</li><li><strong>Говорящие имена:</strong> Имя теста должно объяснять, что тестируется и ожидается</li><li><strong>DRY с осторожностью:</strong> Дублирование в тестах иногда лучше, чем сложная абстракция</li><li><strong>Избегайте логики в тестах:</strong> Условия и циклы усложняют понимание</li><li><strong>Тестируйте поведение, а не реализацию:</strong> Тесты не должны знать о внутренностях</li></ul><h4>Чего избегать:</h4><ul><li>Тестов, которые проверяют несколько вещей одновременно</li><li>Зависимостей между тестами</li><li>Тестирования приватных методов напрямую</li><li>Хрупких тестов, которые ломаются при малейшем изменении кода</li></ul>",
    difficulty: 'middle',
    tags: ['unit-тесты', 'best practices', 'качество тестов', 'FIRST']
  },
  {
    id: 8,
    question: "Что такое покрытие кода (code coverage) и нужно ли стремиться к 100%?",
    answer: "<p><strong>Code Coverage</strong> — это метрика, показывающая, какой процент кода был выполнен во время тестирования.</p><h4>Виды покрытия:</h4><p><strong>Line Coverage (покрытие строк):</strong> Процент выполненных строк кода</p><p><strong>Branch Coverage (покрытие ветвлений):</strong> Процент проверенных веток условий (if/else)</p><p><strong>Function Coverage (покрытие функций):</strong> Процент вызванных функций</p><p><strong>Statement Coverage (покрытие выражений):</strong> Процент выполненных выражений</p><h4>Нужно ли стремиться к 100%:</h4><p><strong>Аргументы «за»:</strong></p><ul><li>Гарантия, что весь код хоть раз выполнился</li><li>Обнаружение мертвого кода</li><li>Психологическая уверенность</li></ul><p><strong>Аргументы «против»:</strong></p><ul><li>100% покрытие НЕ гарантирует отсутствие багов</li><li>Может привести к бессмысленным тестам ради метрики</li><li>Последние 10-20% очень дороги в достижении</li><li>Фокус смещается с качества на количество</li></ul><h4>Здравый подход:</h4><ul><li>70-80% покрытия — хороший показатель для большинства проектов</li><li>Покрытие — это индикатор, а не цель</li><li>Важнее качество тестов, чем процент покрытия</li><li>Критический код (платежи, безопасность) должен быть покрыт максимально</li><li>Некоторый код (getters/setters, конфиги) можно не покрывать</li></ul><p><em>Цитата:</em> «100% code coverage не означает 100% протестированное приложение. Можно вызвать каждую строку кода и при этом не проверить ни одного edge case.»</p>",
    difficulty: 'middle',
    tags: ['code coverage', 'метрики', 'качество тестов']
  },
  {
    id: 9,
    question: "Как тестировать асинхронный код?",
    answer: "<p>Тестирование асинхронного кода имеет свои особенности в зависимости от используемого подхода:</p><h4>Callbacks:</h4><p><strong>Проблема:</strong> Тест может завершиться до выполнения callback</p><p><strong>Решение:</strong> Использовать done callback, который вызывается после проверок</p><p><strong>Важно:</strong> Обязательно вызвать done() или done(error), иначе тест зависнет</p><h4>Promises:</h4><p><strong>Подход 1:</strong> Вернуть промис из теста — фреймворк дождется его разрешения</p><p><strong>Подход 2:</strong> Использовать async/await для более читаемого кода</p><p><strong>Важно:</strong> Обязательно вернуть промис или использовать await</p><h4>Async/Await (современный подход):</h4><p><strong>Преимущества:</strong></p><ul><li>Самый читаемый синтаксис</li><li>Легко тестировать последовательность асинхронных операций</li><li>Удобная обработка ошибок через try/catch</li></ul><h4>Проблемы и решения:</h4><p><strong>Таймауты:</strong> Увеличивайте таймаут для медленных операций или используйте фейковые таймеры</p><p><strong>Race conditions:</strong> Используйте waitFor или подобные утилиты для ожидания состояний</p><p><strong>Недетерминированность:</strong> Мокируйте время или используйте fake timers (jest.useFakeTimers)</p><h4>Best practices:</h4><ul><li>Используйте async/await — самый чистый подход</li><li>Всегда обрабатывайте rejected промисы</li><li>Используйте fake timers для тестов с setTimeout/setInterval</li><li>Мокируйте HTTP-запросы вместо реальных вызовов</li><li>Используйте утилиты типа waitFor для асинхронных проверок</li></ul>",
    difficulty: 'senior',
    tags: ['асинхронность', 'promises', 'async/await', 'тестирование']
  },
  {
    id: 10,
    question: "Что такое integration-тестирование и как его правильно организовать?",
    answer: "<p><strong>Integration-тестирование</strong> проверяет взаимодействие между различными модулями или компонентами системы.</p><h4>Что тестируем на integration-уровне:</h4><ul><li>Взаимодействие фронтенда с API</li><li>Работу с базой данных</li><li>Интеграцию со сторонними сервисами</li><li>Взаимодействие между модулями приложения</li><li>Правильность передачи данных между слоями</li></ul><h4>Подходы к организации:</h4><p><strong>Bottom-up (снизу вверх):</strong></p><ul><li>Начинаем с низкоуровневых модулей</li><li>Постепенно интегрируем более высокие уровни</li><li>Подходит для систем с четкой архитектурой</li></ul><p><strong>Top-down (сверху вниз):</strong></p><ul><li>Начинаем с высокоуровневых компонентов</li><li>Используем стабы для недостающих модулей</li><li>Хорошо для раннего тестирования основных сценариев</li></ul><p><strong>Big Bang (все сразу):</strong></p><ul><li>Интегрируем все модули одновременно</li><li>Сложно локализовать проблемы</li><li>Подходит только для маленьких систем</li></ul><h4>Best practices:</h4><ul><li><strong>Изоляция тестового окружения:</strong> Используйте отдельные БД/сервисы для тестов</li><li><strong>Setup и Teardown:</strong> Очищайте состояние между тестами</li><li><strong>Фикстуры:</strong> Готовьте тестовые данные заранее</li><li><strong>Контейнеризация:</strong> Docker для единообразного окружения</li><li><strong>Выборочность:</strong> Не тестируйте все комбинации, фокусируйтесь на критических путях</li></ul><h4>Типичные ошибки:</h4><ul><li>Использование продакшн-баз данных</li><li>Зависимость от внешних сервисов без моков</li><li>Слишком много integration-тестов вместо unit</li><li>Тесты, которые падают из-за порядка выполнения</li></ul>",
    difficulty: 'senior',
    tags: ['integration', 'интеграционные тесты', 'архитектура тестов']
  },
  {
    id: 11,
    question: "Как тестировать UI компоненты? Какие существуют подходы?",
    answer: "<p>Тестирование UI компонентов можно проводить на разных уровнях:</p><h4>Unit-тестирование компонентов:</h4><p><strong>Что тестируем:</strong> Логику компонента в изоляции</p><p><strong>Инструменты:</strong> React Testing Library, Jest, Enzyme</p><p><strong>Подход:</strong></p><ul><li>Рендерим компонент</li><li>Имитируем пользовательские действия</li><li>Проверяем результат без реального браузера</li></ul><p><strong>Что проверяем:</strong></p><ul><li>Правильность рендеринга</li><li>Обработку событий</li><li>Условный рендеринг</li><li>Передачу props</li></ul><h4>Snapshot-тестирование:</h4><p><strong>Принцип:</strong> Сохраняем снимок структуры компонента и сравниваем с ним при изменениях</p><p><strong>Плюсы:</strong> Быстро обнаруживает неожиданные изменения</p><p><strong>Минусы:</strong> Легко получить false positives, требует дисциплины в обновлении</p><h4>Visual Regression Testing:</h4><p><strong>Что делает:</strong> Сравнивает скриншоты компонента</p><p><strong>Инструменты:</strong> Percy, Chromatic, BackstopJS</p><p><strong>Применение:</strong> Отлавливает визуальные регрессии (сломанные стили, смещения)</p><h4>E2E для критических UI флоу:</h4><p><strong>Инструменты:</strong> Cypress, Playwright, Selenium</p><p><strong>Когда:</strong> Для проверки полных пользовательских сценариев</p><h4>Best practices:</h4><ul><li><strong>Тестируйте с точки зрения пользователя:</strong> Используйте доступные имена, роли, текст</li><li><strong>Избегайте тестирования реализации:</strong> Не привязывайтесь к структуре компонента</li><li><strong>Accessibility-first:</strong> Если компонент сложно протестировать, возможно, он недоступен</li><li><strong>Изолируйте:</strong> Мокируйте внешние зависимости</li><li><strong>Осторожно со snapshots:</strong> Они дополняют, но не заменяют настоящие тесты</li></ul>",
    difficulty: 'senior',
    tags: ['UI тестирование', 'компоненты', 'React', 'E2E']
  },
  {
    id: 12,
    question: "Что такое E2E тестирование и когда его применять?",
    answer: "<p><strong>E2E (End-to-End) тестирование</strong> — это проверка приложения целиком, от начала до конца, имитируя реальное поведение пользователя.</p><h4>Характеристики E2E тестов:</h4><ul><li>Тестируют всю систему: фронтенд, бэкенд, базу данных, интеграции</li><li>Используют реальный браузер (или headless)</li><li>Проверяют полные пользовательские сценарии</li><li>Самые медленные и дорогие в поддержке</li><li>Наиболее хрупкие — много точек отказа</li></ul><h4>Когда применять E2E:</h4><p><strong>Критические бизнес-процессы:</strong></p><ul><li>Регистрация и авторизация</li><li>Оформление заказа и оплата</li><li>Ключевые пользовательские флоу</li></ul><p><strong>Проверка интеграций:</strong></p><ul><li>Работа со сторонними API</li><li>Платежные системы</li><li>Email/SMS уведомления</li></ul><p><strong>Smoke тесты:</strong></p><ul><li>Быстрая проверка, что приложение работает</li><li>Запуск после деплоя</li></ul><h4>Популярные инструменты:</h4><p><strong>Cypress:</strong></p><ul><li>Быстрый, современный, с отличным DX</li><li>Работает в том же контексте, что и приложение</li><li>Отличная отладка</li></ul><p><strong>Playwright:</strong></p><ul><li>Поддержка всех браузеров</li><li>Параллельное выполнение</li><li>Автоматическое ожидание</li></ul><p><strong>Selenium:</strong></p><ul><li>Старый, проверенный инструмент</li><li>Поддержка многих языков</li><li>Сложнее в настройке</li></ul><h4>Best practices:</h4><ul><li><strong>Минимизируйте количество:</strong> Только критические сценарии</li><li><strong>Делайте стабильными:</strong> Используйте data-testid, избегайте селекторов по классам</li><li><strong>Изолируйте данные:</strong> Каждый тест должен готовить свои данные</li><li><strong>Параллелизация:</strong> Запускайте тесты параллельно для ускорения</li><li><strong>Не дублируйте unit-тесты:</strong> E2E для флоу, unit для логики</li></ul>",
    difficulty: 'senior',
    tags: ['E2E', 'end-to-end', 'Cypress', 'Playwright', 'интеграционные тесты']
  },
  {
    id: 13,
    question: "Как организовать тестирование в CI/CD pipeline?",
    answer: "<p>Интеграция тестирования в CI/CD — критически важная часть современной разработки:</p><h4>Этапы тестирования в pipeline:</h4><p><strong>1. Pre-commit (локально):</strong></p><ul><li>Линтеры и форматтеры (ESLint, Prettier)</li><li>Быстрые unit-тесты на измененные файлы</li><li>Хуки через Husky или lint-staged</li></ul><p><strong>2. Pull Request / Merge Request:</strong></p><ul><li>Полный прогон unit-тестов</li><li>Integration-тесты</li><li>Проверка code coverage</li><li>Статический анализ кода</li></ul><p><strong>3. Main/Master branch:</strong></p><ul><li>Все тесты из PR +</li><li>E2E тесты на staging окружении</li><li>Performance тесты</li><li>Security сканирование</li></ul><p><strong>4. Production deployment:</strong></p><ul><li>Smoke тесты после деплоя</li><li>Мониторинг критических метрик</li><li>Возможность быстрого отката</li></ul><h4>Стратегии оптимизации:</h4><p><strong>Параллелизация:</strong></p><ul><li>Запуск тестов на нескольких машинах</li><li>Разделение по типам (unit, integration, E2E)</li><li>Использование test sharding</li></ul><p><strong>Кэширование:</strong></p><ul><li>Кэш зависимостей (node_modules)</li><li>Кэш результатов тестов</li><li>Incremental testing (только измененное)</li></ul><p><strong>Fail Fast:</strong></p><ul><li>Останавливать pipeline при первом падении</li><li>Запускать быстрые тесты первыми</li><li>Отложенные E2E (не блокируют PR)</li></ul><h4>Инструменты:</h4><ul><li><strong>GitHub Actions:</strong> Нативная интеграция с GitHub</li><li><strong>GitLab CI:</strong> Мощный и гибкий</li><li><strong>Jenkins:</strong> Классика, много плагинов</li><li><strong>CircleCI:</strong> Хорошая производительность</li></ul><h4>Метрики для отслеживания:</h4><ul><li>Время выполнения тестов</li><li>Процент падающих тестов (flaky tests)</li><li>Code coverage динамика</li><li>Среднее время до обнаружения бага</li></ul>",
    difficulty: 'senior',
    tags: ['CI/CD', 'автоматизация', 'DevOps', 'pipeline']
  },
  {
    id: 14,
    question: "Что такое flaky tests и как с ними бороться?",
    answer: "<p><strong>Flaky tests (нестабильные тесты)</strong> — это тесты, которые могут проходить или падать непредсказуемо при одном и том же коде.</p><h4>Основные причины нестабильности:</h4><p><strong>1. Асинхронность:</strong></p><ul><li>Гонки (race conditions)</li><li>Недостаточные таймауты</li><li>Неправильное ожидание асинхронных операций</li></ul><p><strong>2. Зависимости между тестами:</strong></p><ul><li>Общее состояние</li><li>Порядок выполнения имеет значение</li><li>Неочищенные данные после тестов</li></ul><p><strong>3. Внешние зависимости:</strong></p><ul><li>Реальные API вместо моков</li><li>Сетевые проблемы</li><li>Зависимость от текущей даты/времени</li></ul><p><strong>4. Недетерминированность:</strong></p><ul><li>Случайные данные без seed</li><li>Параллельное выполнение с конфликтами</li><li>Проблемы с animations и transitions</li></ul><h4>Методы борьбы:</h4><p><strong>Превентивные меры:</strong></p><ul><li><strong>Изоляция:</strong> Каждый тест независим, очищает за собой</li><li><strong>Детерминированность:</strong> Используйте фиксированные данные и mock времени</li><li><strong>Правильное ожидание:</strong> waitFor вместо фиксированных таймаутов</li><li><strong>Мокирование:</strong> Все внешние зависимости должны быть замокированы</li></ul><p><strong>Диагностика:</strong></p><ul><li>Запускайте тесты многократно для выявления нестабильных</li><li>Используйте инструменты отслеживания (flaky test detection)</li><li>Логируйте состояние при падении</li><li>Сохраняйте скриншоты/видео для E2E</li></ul><p><strong>Управление:</strong></p><ul><li>Помечайте flaky тесты (skip/quarantine)</li><li>Не игнорируйте — исправляйте приоритетно</li><li>Временно отключайте блокирующие тесты, но фиксируйте задачу</li><li>Используйте retry только как временное решение</li></ul><h4>Стратегия в команде:</h4><ul><li>Flaky test = баг высокого приоритета</li><li>Метрика flakiness в dashboard</li><li>Политика zero tolerance для критических тестов</li></ul>",
    difficulty: 'senior',
    tags: ['flaky tests', 'нестабильность', 'качество тестов', 'отладка']
  },
  {
    id: 15,
    question: "Как оценить эффективность тестирования в проекте?",
    answer: "<p>Эффективность тестирования измеряется не только метриками, но и реальным влиянием на качество продукта:</p><h4>Количественные метрики:</h4><p><strong>Code Coverage:</strong></p><ul><li>Процент покрытого кода</li><li>Важно: не цель, а индикатор</li><li>Branch coverage важнее line coverage</li></ul><p><strong>Defect Detection Rate (DDR):</strong></p><ul><li>Сколько багов находят тесты vs находят пользователи</li><li>Идеал: большинство багов находится на этапе тестирования</li></ul><p><strong>Test Execution Time:</strong></p><ul><li>Время прогона всех тестов</li><li>Быстрая обратная связь критична для продуктивности</li></ul><p><strong>Flakiness Rate:</strong></p><ul><li>Процент нестабильных тестов</li><li>Должен стремиться к нулю</li></ul><h4>Качественные показатели:</h4><p><strong>Уверенность в рефакторинге:</strong></p><ul><li>Насколько команда боится менять код?</li><li>Как часто рефакторинг приводит к багам?</li></ul><p><strong>Time to Detection:</strong></p><ul><li>Как быстро обнаруживаются проблемы?</li><li>На каком этапе (dev, CI, staging, prod)?</li></ul><p><strong>Regression Prevention:</strong></p><ul><li>Как часто возвращаются старые баги?</li><li>Эффективность регрессионных тестов</li></ul><h4>Бизнес-метрики:</h4><ul><li><strong>Production Incidents:</strong> Количество и серьезность багов в проде</li><li><strong>Mean Time To Recovery (MTTR):</strong> Скорость исправления проблем</li><li><strong>Customer Satisfaction:</strong> Влияние на пользовательский опыт</li><li><strong>Development Velocity:</strong> Скорость доставки фич</li></ul><h4>Признаки эффективного тестирования:</h4><ul><li>Команда уверенно деплоит в любое время</li><li>Баги обычно находятся до продакшена</li><li>Рефакторинг не пугает</li><li>CI/CD pipeline работает быстро и надежно</li><li>Документация тестов помогает новым разработчикам</li></ul><h4>Red flags:</h4><ul><li>Много времени тратится на поддержку тестов</li><li>Тесты часто падают без причины</li><li>Баги постоянно находят пользователи, а не тесты</li><li>Команда избегает запускать тесты</li><li>Высокий coverage, но низкое доверие к тестам</li></ul><p><em>Главное правило:</em> Тесты должны помогать разработке, а не мешать. Если команда тратит больше времени на тесты, чем экономит — что-то не так.</p>",
    difficulty: 'senior',
    tags: ['метрики', 'эффективность', 'качество', 'оценка тестирования']
  },
  {
    id: 16,
    question: "Расскажите подробнее о концепции пирамиды тестирования. Почему она имеет форму пирамиды?",
    answer: "<p>Пирамида тестирования — это визуальная метафора, которая показывает, как должны распределяться разные типы тестов в здоровом проекте.</p><h4>Почему именно пирамида:</h4><p>Форма пирамиды отражает два ключевых принципа:</p><ul><li><strong>Количество тестов:</strong> Чем ниже уровень, тем больше тестов должно быть</li><li><strong>Стоимость поддержки:</strong> Чем выше уровень, тем дороже каждый тест</li></ul><h4>Экономика тестирования:</h4><p><strong>Unit-тесты (основание):</strong></p><ul><li>Выполняются за миллисекунды</li><li>Легко писать и поддерживать</li><li>Точно показывают, где проблема</li><li>Можно запускать тысячи раз в день</li><li>Дешевы в создании и поддержке</li></ul><p><strong>E2E-тесты (вершина):</strong></p><ul><li>Выполняются минутами</li><li>Хрупкие — ломаются от малейших изменений UI</li><li>Сложно понять причину падения</li><li>Требуют сложной инфраструктуры</li><li>Дороги в создании и поддержке</li></ul><p><strong>Ключевой инсайт:</strong> Если пытаться покрыть всю логику E2E-тестами, получим медленную обратную связь и огромные затраты на поддержку. Если полагаться только на unit-тесты — пропустим проблемы интеграции. Пирамида дает баланс.</p><p><em>Аналогия:</em> Это как строительство дома — нужен прочный фундамент (unit), стены (integration) и крыша (E2E). Нельзя построить дом только из крыши.</p>",
    difficulty: 'middle',
    tags: ['пирамида тестирования', 'стратегия', 'экономика тестов']
  },
  {
    id: 17,
    question: "Какие антипаттерны существуют в распределении тестов и почему они вредны?",
    answer: "<p>Существует несколько антипаттернов, которые нарушают принципы пирамиды тестирования:</p><h4>1. Ice Cream Cone (Мороженое):</h4><p><strong>Что это:</strong> Много E2E-тестов, мало unit-тестов — перевернутая пирамида</p><p><strong>Проблемы:</strong></p><ul><li>Тесты выполняются часами</li><li>Непонятно, где именно ошибка</li><li>Постоянные flaky tests</li><li>Огромные затраты на поддержку</li><li>Разработчики не хотят запускать тесты</li></ul><p><strong>Почему возникает:</strong> Команда начинает с E2E, потому что «это проверяет реальное поведение», и не инвестирует в unit-тесты</p><h4>2. Hourglass (Песочные часы):</h4><p><strong>Что это:</strong> Много unit и E2E, мало integration</p><p><strong>Проблемы:</strong></p><ul><li>Unit-тесты проверяют изолированную логику</li><li>E2E проверяют UI флоу</li><li>Но никто не проверяет, как модули работают вместе</li><li>Баги в интеграции находятся поздно</li></ul><h4>3. Cupcake (Кексик):</h4><p><strong>Что это:</strong> Нормальное основание, но слишком много integration-тестов</p><p><strong>Проблемы:</strong></p><ul><li>Integration-тесты медленнее unit</li><li>Дублирование проверок</li><li>Сложнее поддерживать окружение</li></ul><h4>Как избежать антипаттернов:</h4><ul><li><strong>Осознанный выбор:</strong> Каждый тест должен быть на правильном уровне</li><li><strong>Code review тестов:</strong> Проверять, не дублируются ли проверки</li><li><strong>Метрики:</strong> Отслеживать время выполнения и соотношение типов</li><li><strong>Принцип:</strong> Тестируй на самом низком возможном уровне</li></ul><p><em>Правило:</em> Если логику можно проверить unit-тестом — пишите unit-тест. E2E только для критических флоу, которые невозможно проверить иначе.</p>",
    difficulty: 'middle',
    tags: ['антипаттерны', 'ice cream cone', 'стратегия тестирования']
  },
  {
    id: 18,
    question: "Как пирамида тестирования помогает ускорить обратную связь для разработчиков?",
    answer: "<p>Скорость обратной связи — один из ключевых факторов продуктивности разработки. Пирамида тестирования напрямую влияет на это.</p><h4>Принцип быстрой обратной связи:</h4><p><strong>Во время разработки (секунды-минуты):</strong></p><ul><li>Разработчик запускает unit-тесты локально</li><li>Тысячи тестов выполняются за секунды</li><li>Мгновенно видит, что сломал</li><li>Может исправить до коммита</li></ul><p><strong>На PR (минуты):</strong></p><ul><li>Запускаются unit + integration</li><li>Обычно 5-15 минут</li><li>Успеваем проверить до code review</li><li>Не блокируем других разработчиков</li></ul><p><strong>На main ветке (десятки минут):</strong></p><ul><li>Добавляются E2E тесты</li><li>20-60 минут</li><li>Проверяем перед деплоем</li><li>Критические флоу защищены</li></ul><h4>Сравнение подходов:</h4><p><strong>С правильной пирамидой:</strong></p><ul><li>Локально: 10 сек unit → быстрый фидбэк</li><li>CI: 5 мин unit+integration → PR не висит долго</li><li>Deploy: 30 мин с E2E → финальная проверка</li><li><strong>Итого:</strong> Разработчик знает о проблеме за секунды-минуты</li></ul><p><strong>С перевернутой пирамидой (ice cream cone):</strong></p><ul><li>Локально: ничего не запускается (слишком медленно)</li><li>CI: 2 часа E2E тестов → PR висит полдня</li><li>Deploy: еще 2 часа → можем деплоить раз в день</li><li><strong>Итого:</strong> Проблема обнаруживается через часы, контекст потерян</li></ul><h4>Психологический эффект:</h4><p>Когда тесты быстрые, разработчики запускают их часто. Когда медленные — избегают и коммитят непроверенный код. Правильная пирамида создает культуру частого тестирования.</p><p><em>Золотое правило:</em> Разработчик должен получить фидбэк о проблеме, пока еще помнит, что делал. Идеально — в пределах 10 минут.</p>",
    difficulty: 'middle',
    tags: ['обратная связь', 'скорость тестов', 'продуктивность', 'CI/CD']
  },
  {
    id: 19,
    question: "Как правильно распределять ответственность тестов по уровням пирамиды?",
    answer: "<p>Ключ к эффективной пирамиде — понимание, что должно тестироваться на каждом уровне.</p><h4>Unit-тесты (70-80%):</h4><p><strong>Что тестируем:</strong></p><ul><li>Чистую бизнес-логику</li><li>Утилитарные функции</li><li>Вычисления и трансформации данных</li><li>Валидацию</li><li>Edge cases и граничные условия</li></ul><p><strong>Что НЕ тестируем:</strong></p><ul><li>Интеграцию с базой данных</li><li>HTTP-запросы к API</li><li>Полный рендеринг компонентов с зависимостями</li></ul><p><strong>Пример:</strong> Функция расчета скидки — проверяем все комбинации параметров, edge cases (отрицательные числа, ноль, максимальные значения)</p><h4>Integration-тесты (15-25%):</h4><p><strong>Что тестируем:</strong></p><ul><li>Взаимодействие модулей</li><li>API endpoints с реальной БД</li><li>Компоненты с их реальными зависимостями</li><li>Работу с файловой системой</li><li>Интеграцию со сторонними сервисами (с моками)</li></ul><p><strong>Что НЕ тестируем:</strong></p><ul><li>Все возможные комбинации параметров (это для unit)</li><li>Полные UI флоу (это для E2E)</li></ul><p><strong>Пример:</strong> POST /api/orders создает заказ в БД, отправляет событие в очередь, возвращает правильный статус</p><h4>E2E-тесты (5-10%):</h4><p><strong>Что тестируем:</strong></p><ul><li>Критические бизнес-сценарии</li><li>Happy path основных флоу</li><li>Регистрация, авторизация, оплата</li><li>Ключевые пользовательские journey</li></ul><p><strong>Что НЕ тестируем:</strong></p><ul><li>Все edge cases (это для unit)</li><li>Каждую комбинацию параметров</li><li>Детальную валидацию форм</li></ul><p><strong>Пример:</strong> Пользователь может найти товар → добавить в корзину → оформить заказ → получить подтверждение</p><h4>Принцип выбора уровня:</h4><p><em>«Тестируй на самом низком уровне, где это возможно»</em></p><p>Если логику можно проверить unit-тестом — не нужен integration. Если флоу можно проверить integration-тестом — не нужен E2E.</p>",
    difficulty: 'senior',
    tags: ['распределение ответственности', 'стратегия', 'уровни тестирования']
  },
  {
    id: 20,
    question: "Как пирамида тестирования интегрируется с CI/CD процессами?",
    answer: "<p>Пирамида тестирования и CI/CD — это две стороны одной медали. Правильная пирамида делает CI/CD быстрым и надежным.</p><h4>Стадии CI/CD pipeline:</h4><p><strong>1. Pre-commit hooks (локально, секунды):</strong></p><ul><li>Линтеры и форматтеры</li><li>Unit-тесты на измененные файлы (git diff)</li><li>Быстрая проверка перед коммитом</li><li><strong>Цель:</strong> Поймать очевидные ошибки до push</li></ul><p><strong>2. Pull Request validation (2-5 минут):</strong></p><ul><li>Все unit-тесты (полный прогон)</li><li>Code coverage проверка</li><li>Статический анализ</li><li><strong>Цель:</strong> Убедиться, что код качественный до ревью</li></ul><p><strong>3. Integration stage (5-15 минут):</strong></p><ul><li>Integration-тесты с тестовой БД</li><li>API тесты</li><li>Тесты компонентов с зависимостями</li><li><strong>Цель:</strong> Проверить взаимодействие модулей</li></ul><p><strong>4. Staging deployment (15-30 минут):</strong></p><ul><li>E2E тесты критических флоу</li><li>Smoke тесты</li><li>Performance тесты</li><li><strong>Цель:</strong> Финальная проверка перед продакшеном</li></ul><p><strong>5. Production deployment (5-10 минут):</strong></p><ul><li>Smoke тесты на проде</li><li>Health checks</li><li>Мониторинг ключевых метрик</li><li><strong>Цель:</strong> Убедиться, что деплой прошел успешно</li></ul><h4>Стратегии оптимизации:</h4><p><strong>Параллелизация по уровням:</strong></p><ul><li>Unit-тесты на 10 машинах → 30 сек вместо 5 мин</li><li>Integration разбиты по доменам → параллельно</li><li>E2E тесты независимы → запускаются одновременно</li></ul><p><strong>Fail-fast подход:</strong></p><ul><li>Запускаем unit первыми (они быстрые)</li><li>Если unit упали — не запускаем integration</li><li>Если integration упали — не запускаем E2E</li><li>Экономим время на явно сломанном коде</li></ul><p><strong>Conditional testing:</strong></p><ul><li>Изменения в frontend → только frontend тесты</li><li>Изменения в API → API + E2E</li><li>Изменения в utils → все unit-тесты</li></ul><h4>Метрики pipeline:</h4><ul><li><strong>Total time:</strong> Не более 15-20 минут для полного цикла</li><li><strong>Success rate:</strong> >95% проходимость (иначе flaky tests)</li><li><strong>Time to feedback:</strong> Разработчик знает о проблеме за <10 минут</li></ul><p><em>Ключевой принцип:</em> Пирамида позволяет делать CI/CD быстрым (много быстрых unit) и надежным (критические E2E как финальная проверка).</p>",
    difficulty: 'senior',
    tags: ['CI/CD', 'pipeline', 'автоматизация', 'DevOps', 'стратегия']
  },
  {
    id: 21,
    question: "Как адаптировать пирамиду тестирования для микросервисной архитектуры?",
    answer: "<p>В микросервисах пирамида тестирования трансформируется, но принципы остаются теми же.</p><h4>Особенности микросервисов:</h4><ul><li>Каждый сервис — отдельное приложение</li><li>Много точек интеграции между сервисами</li><li>Распределенная система со своими проблемами</li><li>Сложнее организовать E2E тестирование</li></ul><h4>Трансформация пирамиды:</h4><p><strong>Unit-тесты (по-прежнему основа ~70%):</strong></p><ul><li>Внутри каждого микросервиса</li><li>Тестируем бизнес-логику сервиса</li><li>Никаких внешних зависимостей</li><li><strong>Без изменений</strong> — работает как обычно</li></ul><p><strong>Integration-тесты (увеличенный слой ~25%):</strong></p><p><em>Contract testing:</em></p><ul><li>Проверяем контракты между сервисами</li><li>Инструменты: Pact, Spring Cloud Contract</li><li>Producer гарантирует API, Consumer проверяет ожидания</li></ul><p><em>Component testing:</em></p><ul><li>Тестируем микросервис как черный ящик</li><li>Все внешние зависимости замокированы</li><li>Проверяем API endpoints с реальной БД сервиса</li></ul><p><em>Integration между сервисами:</em></p><ul><li>Поднимаем несколько связанных сервисов (Docker Compose)</li><li>Проверяем реальное взаимодействие</li><li>Дороже, но критично для важных интеграций</li></ul><p><strong>E2E-тесты (минимизированы ~5%):</strong></p><ul><li>Только критические бизнес-сценарии</li><li>Через UI или API Gateway</li><li>Требуют полной инфраструктуры</li><li>Очень дорогие — используем минимально</li></ul><h4>Дополнительный уровень — Contract Tests:</h4><p>В микросервисах появляется важная прослойка:</p><ul><li><strong>Consumer-driven contracts:</strong> Consumer определяет, что ему нужно</li><li><strong>Provider verification:</strong> Provider проверяет, что может это дать</li><li>Позволяет тестировать интеграции без реального взаимодействия</li><li>Быстрее и стабильнее, чем полные integration-тесты</li></ul><h4>Best practices:</h4><ul><li><strong>Независимость сервисов:</strong> Каждый сервис имеет свою пирамиду</li><li><strong>Contract-first:</strong> Сначала договариваемся о контрактах</li><li><strong>Test in isolation:</strong> Компонентное тестирование с моками</li><li><strong>Strategic E2E:</strong> Только ключевые флоу через всю систему</li><li><strong>Consumer tests в CI:</strong> Ломаем сборку Provider при нарушении контракта</li></ul><p><em>Новая пирамида:</em> Unit (70%) → Component (15%) → Contract (10%) → E2E (5%)</p>",
    difficulty: 'senior',
    tags: ['микросервисы', 'contract testing', 'архитектура', 'распределенные системы']
  },
  {
    id: 22,
    question: "Какие метрики помогают контролировать здоровье пирамиды тестирования?",
    answer: "<p>Пирамида может деградировать со временем. Важно отслеживать метрики, чтобы поддерживать баланс.</p><h4>Базовые метрики распределения:</h4><p><strong>Test Distribution Ratio:</strong></p><ul><li>Считаем количество тестов каждого типа</li><li><strong>Здоровое соотношение:</strong> 70% unit : 20% integration : 10% E2E</li><li><strong>Отклонение:</strong> Если E2E >20% — проблема, ice cream cone</li><li>Простая метрика, легко визуализировать</li></ul><p><strong>Execution Time Ratio:</strong></p><ul><li>Сколько времени занимает каждый уровень</li><li><strong>Здоровое:</strong> Unit 1-2 мин, Integration 3-5 мин, E2E 10-15 мин</li><li><strong>Red flag:</strong> E2E занимает большую часть времени</li></ul><h4>Метрики эффективности:</h4><p><strong>Test Feedback Time:</strong></p><ul><li>Как быстро разработчик узнает о проблеме</li><li><strong>Цель:</strong> Unit <1 мин, Integration <5 мин, E2E <15 мин</li><li>Медленные unit-тесты — признак неправильной архитектуры</li></ul><p><strong>Failure Localization:</strong></p><ul><li>На каком уровне обнаруживаются баги</li><li><strong>Здоровое:</strong> 70% проблем находят unit-тесты</li><li><strong>Проблема:</strong> Если больше 50% багов находит E2E — значит, плохие unit/integration</li></ul><p><strong>Flakiness by Level:</strong></p><ul><li>Процент нестабильных тестов на каждом уровне</li><li><strong>Типично:</strong> Unit 0%, Integration 1-2%, E2E 5-10%</li><li>E2E естественно более хрупкие, но >10% — плохо</li></ul><h4>Метрики поддержки:</h4><p><strong>Maintenance Time:</strong></p><ul><li>Сколько времени тратится на обновление тестов при изменениях</li><li>E2E должны ломаться редко и только при реальных изменениях UX</li><li>Частые обновления E2E — признак хрупких тестов</li></ul><p><strong>Code Coverage per Level:</strong></p><ul><li>Какой coverage дает каждый уровень</li><li><strong>Здоровое:</strong> Unit дают 60-70%, Integration добавляют 10-15%, E2E еще 5-10%</li><li>Если E2E дают много coverage — дублирование с unit</li></ul><h4>Dashboard пример:</h4><pre>\n📊 Test Health Dashboard\n\nDistribution:\n  Unit: 850 tests (73%) ✅\n  Integration: 210 tests (18%) ✅  \n  E2E: 105 tests (9%) ✅\n\nExecution Time:\n  Unit: 1.2 min ✅\n  Integration: 4.5 min ✅\n  E2E: 12 min ✅\n  Total: 17.7 min ✅\n\nFailure Detection:\n  Unit: 68% ✅\n  Integration: 24% ✅\n  E2E: 8% ✅\n\nFlakiness:\n  Unit: 0% ✅\n  Integration: 1.2% ✅\n  E2E: 6.5% ⚠️\n</pre><p><em>Практика:</em> Выводите эти метрики на дашборд команды. Если метрики ухудшаются — выделяйте время на исправление, пока не стало критично.</p>",
    difficulty: 'senior',
    tags: ['метрики', 'мониторинг', 'качество тестов', 'аналитика']
  },
  {
    id: 23,
    question: "Как убедить команду следовать пирамиде тестирования, если сейчас все тесты E2E?",
    answer: "<p>Это частая ситуация — команда имеет legacy подход с перевернутой пирамидой. Нужна стратегия миграции.</p><h4>Диагностика проблемы:</h4><p><strong>Типичные симптомы:</strong></p><ul><li>Тесты выполняются 1-2 часа</li><li>Постоянные flaky tests</li><li>Разработчики боятся запускать тесты</li><li>Непонятно, где именно проблема при падении теста</li><li>Огромные затраты времени на поддержку</li></ul><p><strong>Измеряем боль:</strong></p><ul><li>Сколько времени тратим на ожидание CI</li><li>Сколько времени на исправление flaky tests</li><li>Как часто баги проскальзывают в продакшен</li><li>Насколько медленнее стала разработка</li></ul><h4>Стратегия убеждения:</h4><p><strong>1. Покажите цифры:</strong></p><ul><li>«E2E тесты занимают 80% времени CI, но находят только 20% багов»</li><li>«Мы тратим 10 часов в неделю на flaky E2E тесты»</li><li>«Unit-тест выполняется 0.1 сек, E2E — 2 минуты (в 1200 раз медленнее)»</li></ul><p><strong>2. Пилотный проект:</strong></p><ul><li>Выберите один модуль</li><li>Покройте его unit-тестами</li><li>Удалите дублирующие E2E</li><li>Покажите улучшение: скорость ↑, стабильность ↑, поддержка ↓</li></ul><p><strong>3. Постепенная миграция:</strong></p><ul><li><strong>Не переписывайте всё сразу</strong> — это провалится</li><li>Новый код — только с правильной пирамидой</li><li>Старый код — постепенно рефакторим</li><li>Приоритет: модули с наибольшей болью</li></ul><h4>План действий:</h4><p><strong>Фаза 1 (1-2 месяца): Foundation</strong></p><ul><li>Настроить unit-тестирование (jest/vitest)</li><li>Обучить команду TDD</li><li>Все новые фичи — сначала unit-тесты</li><li>Покрыть 2-3 критических модуля</li></ul><p><strong>Фаза 2 (2-3 месяца): Refactoring</strong></p><ul><li>Анализ текущих E2E: что можно спустить на unit/integration</li><li>Рефакторинг кода для тестируемости</li><li>Добавление integration-тестов для API</li><li>Начать удалять дублирующие E2E</li></ul><p><strong>Фаза 3 (постоянно): Optimization</strong></p><ul><li>E2E только для критических флоу (5-10 сценариев)</li><li>Отслеживание метрик пирамиды</li><li>Continuous improvement</li></ul><h4>Преодоление сопротивления:</h4><p><strong>«E2E проверяют реальное поведение»:</strong></p><ul><li>Да, но unit-тесты проверяют логику полнее</li><li>E2E не могут покрыть все edge cases</li><li>Нужен баланс, а не отказ от E2E</li></ul><p><strong>«У нас нет времени переписывать тесты»:</strong></p><ul><li>Не переписываем — постепенно добавляем unit</li><li>Новый код сразу правильно</li><li>ROI виден через месяц — CI ускоряется</li></ul><p><strong>«Наш код не тестируемый»:</strong></p><ul><li>Это признак проблем с архитектурой</li><li>Unit-тесты помогут улучшить дизайн</li><li>Начнем с рефакторинга небольшого модуля</li></ul><p><em>Ключевое:</em> Не критикуйте текущий подход, а покажите преимущества нового на конкретных примерах и цифрах.</p>",
    difficulty: 'senior',
    tags: ['миграция', 'управление изменениями', 'стратегия', 'legacy']
  },
  {
    id: 24,
    question: "Как пирамида тестирования меняется для разных типов приложений?",
    answer: "<p>Классическая пирамида — это гайдлайн, но для разных типов приложений баланс может смещаться.</p><h4>Веб-приложения (классика):</h4><ul><li>Unit: 70%, Integration: 20%, E2E: 10%</li><li>Много бизнес-логики → много unit</li><li>API endpoints → integration</li><li>Критические флоу → E2E</li><li><strong>Пример:</strong> E-commerce, SaaS</li></ul><h4>API-сервисы (Backend-heavy):</h4><ul><li>Unit: 60%, Integration: 35%, E2E: 5%</li><li>Увеличена доля integration — важны взаимодействия</li><li>Contract testing для внешних API</li><li>E2E минимальны — это не UI</li><li><strong>Пример:</strong> REST API, GraphQL, микросервисы</li></ul><h4>UI-библиотеки и компоненты:</h4><ul><li>Unit: 50%, Integration: 30%, Visual: 20%</li><li>Меньше unit — меньше логики</li><li>Больше integration — проверяем props, events</li><li>Visual regression вместо E2E</li><li><strong>Пример:</strong> UI kit, component library</li></ul><h4>Mobile приложения:</h4><ul><li>Unit: 60%, Integration: 25%, E2E: 15%</li><li>Больше E2E чем в вебе — сложнее мокировать нативные API</li><li>Device-specific тесты важны</li><li>Эмуляторы медленнее браузеров</li><li><strong>Пример:</strong> iOS, Android apps</li></ul><h4>Data-heavy приложения:</h4><ul><li>Unit: 50%, Integration: 40%, E2E: 10%</li><li>Много integration — работа с БД критична</li><li>Тестируем трансформации данных</li><li>Performance testing важен</li><li><strong>Пример:</strong> Analytics, Data Processing</li></ul><h4>Прототипы и MVP:</h4><ul><li>Unit: 30%, Integration: 20%, E2E: 50%</li><li>Временная «перевернутая пирамида»</li><li>Быстрая валидация идеи через E2E</li><li>При переходе в продакшен — нормализуем</li><li><strong>Важно:</strong> Это осознанный технический долг</li></ul><h4>Legacy монолиты:</h4><ul><li>Начинаем с E2E (20%) для защиты</li><li>Постепенно добавляем unit при рефакторинге</li><li>Движемся к классической пирамиде</li><li>Процесс может занять годы</li></ul><h4>Serverless:</h4><ul><li>Unit: 65%, Integration: 30%, E2E: 5%</li><li>Каждая функция изолирована → много unit</li><li>Integration через события и API</li><li>E2E сложнее — распределенная система</li></ul><h4>Принципы адаптации:</h4><ul><li><strong>Анализируйте риски:</strong> Где больше всего багов — там усильте тестирование</li><li><strong>Стоимость vs ценность:</strong> E2E дороги — используйте там, где они незаменимы</li><li><strong>Техдолг:</strong> Временные отклонения ОК, но с планом возврата</li><li><strong>Эволюция:</strong> Пирамида меняется с развитием продукта</li></ul><p><em>Вывод:</em> Пирамида — это принцип, а не жесткое правило. Важно понимать WHY за каждым соотношением и адаптировать под свой контекст.</p>",
    difficulty: 'senior',
    tags: ['типы приложений', 'адаптация', 'контекст', 'стратегия']
  },
  {
    id: 25,
    question: "Расскажите о современных альтернативах и эволюции пирамиды тестирования",
    answer: "<p>Пирамида тестирования — классическая концепция, но индустрия предлагает новые взгляды:</p><h4>Testing Trophy (Кубок тестирования):</h4><p><strong>Автор:</strong> Kent C. Dodds</p><p><strong>Структура (снизу вверх):</strong></p><ul><li><strong>Static (основание):</strong> TypeScript, ESLint, форматтеры</li><li><strong>Unit (узкий слой):</strong> Только чистые функции</li><li><strong>Integration (широкий слой):</strong> Компоненты с зависимостями — основной фокус</li><li><strong>E2E (вершина):</strong> Критические флоу</li></ul><p><strong>Отличие от пирамиды:</strong></p><ul><li>Больший акцент на integration-тестах</li><li>Статический анализ как отдельный слой</li><li>Unit-тестов меньше — только для сложной логики</li><li>Подходит для фронтенд-приложений</li></ul><p><strong>Философия:</strong> Тестируйте так, как пользователь использует приложение</p><h4>Testing Honeycomb (Соты):</h4><p><strong>Для микросервисов и распределенных систем</strong></p><p><strong>Структура:</strong></p><ul><li>Много integration тестов (проверка контрактов)</li><li>Unit и E2E меньше по размеру, но одинаково важны</li><li>Не пирамида, а соты — разные приоритеты для разных систем</li></ul><p><strong>Ключевая идея:</strong> В микросервисах интеграция — главный источник проблем</p><h4>Risk-Based Testing Pyramid:</h4><p><strong>Адаптивная пирамида на основе рисков:</strong></p><ul><li>Анализ: где чаще всего баги</li><li>Больше тестов там, где больше риск</li><li>Критичность функции влияет на coverage</li><li>Динамически меняется со временем</li></ul><p><strong>Пример:</strong> Платежный модуль → 90% coverage всех уровней. Страница «О нас» → минимум тестов</p><h4>Swiss Cheese Model:</h4><p><strong>Комбинированный подход:</strong></p><ul><li>Каждый слой тестирования — это слой сыра с дырками</li><li>Баги проскальзывают через дырки</li><li>Комбинация слоев перекрывает дырки друг друга</li><li>Важен не один тип, а их сочетание</li></ul><h4>Property-Based Testing:</h4><p><strong>Дополнение к пирамиде:</strong></p><ul><li>Генерация случайных входных данных</li><li>Проверка инвариантов, а не конкретных случаев</li><li>Находит edge cases, о которых не подумали</li><li>Инструменты: fast-check, jsverify</li></ul><h4>Современные тренды:</h4><p><strong>1. Shift-Left Testing:</strong></p><ul><li>Тестирование раньше в процессе разработки</li><li>TDD и статический анализ</li><li>Быстрая обратная связь</li></ul><p><strong>2. Chaos Engineering:</strong></p><ul><li>Тестирование отказоустойчивости</li><li>Намеренное создание сбоев</li><li>Важно для распределенных систем</li></ul><p><strong>3. AI-Powered Testing:</strong></p><ul><li>Автоматическая генерация тестов</li><li>Обнаружение аномалий</li><li>Предсказание проблемных мест</li></ul><h4>Как выбрать подход:</h4><ul><li><strong>Монолит + бизнес-логика:</strong> Классическая пирамида</li><li><strong>Фронтенд React:</strong> Testing Trophy (больше integration)</li><li><strong>Микросервисы:</strong> Honeycomb (фокус на contracts)</li><li><strong>Enterprise критичное:</strong> Risk-based (больше на критичных частях)</li></ul><p><em>Главное:</em> Не застревайте в догмах. Пирамида — это модель для мышления, а не закон. Важно понимать принципы и адаптировать под свой контекст.</p>",
    difficulty: 'senior',
    tags: ['современные подходы', 'эволюция', 'testing trophy', 'альтернативы']
  },
  {
    id: 26,
    question: "Какие практические шаги предпринять для построения правильной пирамиды с нуля?",
    answer: "<p>Пошаговый план для новых проектов или полной перестройки тестовой стратегии:</p><h4>Фаза 0: Подготовка (1 неделя)</h4><p><strong>1. Аудит текущего состояния:</strong></p><ul><li>Сколько тестов каждого типа</li><li>Время выполнения по уровням</li><li>Где находятся баги (unit vs E2E)</li><li>Стоимость поддержки тестов</li></ul><p><strong>2. Определение целей:</strong></p><ul><li>Целевая скорость CI (например, <10 мин)</li><li>Целевой coverage (70-80%)</li><li>Допустимый уровень flakiness (<2%)</li><li>Критичные флоу для E2E (5-10 сценариев)</li></ul><p><strong>3. Выбор инструментов:</strong></p><ul><li>Unit: Jest/Vitest</li><li>Integration: Supertest для API, React Testing Library для UI</li><li>E2E: Playwright или Cypress</li><li>Мониторинг: Code coverage инструменты</li></ul><h4>Фаза 1: Основание пирамиды (1-2 месяца)</h4><p><strong>Unit-тесты (достигаем 60% coverage):</strong></p><ul><li><strong>Неделя 1-2:</strong> Настройка инфраструктуры (Jest, pre-commit hooks)</li><li><strong>Неделя 3-4:</strong> Покрытие утилит и чистых функций</li><li><strong>Неделя 5-6:</strong> Бизнес-логика (валидация, вычисления)</li><li><strong>Неделя 7-8:</strong> Сложные алгоритмы и edge cases</li></ul><p><strong>Правила написания:</strong></p><ul><li>TDD для новых фич</li><li>Минимум 3 теста на функцию: happy path, edge case, error case</li><li>AAA pattern (Arrange-Act-Assert)</li><li>Независимость тестов</li></ul><h4>Фаза 2: Середина пирамиды (1 месяц)</h4><p><strong>Integration-тесты (добавляем 15% coverage):</strong></p><ul><li><strong>Неделя 1:</strong> API endpoints с тестовой БД</li><li><strong>Неделя 2:</strong> Компоненты с реальными зависимостями</li><li><strong>Неделя 3:</strong> Взаимодействие между модулями</li><li><strong>Неделя 4:</strong> Интеграция со сторонними сервисами (моки)</li></ul><p><strong>Setup окружения:</strong></p><ul><li>Docker Compose для локальной БД</li><li>Seed данные для тестов</li><li>Автоматическая очистка между тестами</li></ul><h4>Фаза 3: Вершина пирамиды (2-3 недели)</h4><p><strong>E2E-тесты (5-10 критичных сценариев):</strong></p><ul><li><strong>Неделя 1:</strong> Идентификация критических флоу</li><li><strong>Неделя 2:</strong> Написание базовых E2E (регистрация, логин)</li><li><strong>Неделя 3:</strong> Основные бизнес-процессы (покупка, оплата)</li></ul><p><strong>Критерии выбора E2E:</strong></p><ul><li>Критично для бизнеса</li><li>Сложно проверить на нижних уровнях</li><li>Высокий риск при поломке</li><li>Часто используется пользователями</li></ul><h4>Фаза 4: Оптимизация и автоматизация (постоянно)</h4><p><strong>CI/CD интеграция:</strong></p><ul><li>Pre-commit: линтеры + unit на changed files</li><li>PR: все unit + changed integration</li><li>Main: полный прогон + E2E</li><li>Nightly: полный E2E suite</li></ul><p><strong>Метрики и мониторинг:</strong></p><ul><li>Dashboard с соотношением тестов</li><li>Отслеживание времени выполнения</li><li>Flaky tests detection</li><li>Coverage trends</li></ul><p><strong>Процессы команды:</strong></p><ul><li>Code review тестов обязателен</li><li>Новая фича → сначала тесты</li><li>Баг → сначала тест, потом фикс</li><li>Рефакторинг → зеленые тесты как защита</li></ul><h4>Чеклист готовности:</h4><ul><li>✅ Unit-тесты выполняются <2 минут</li><li>✅ Integration-тесты <5 минут</li><li>✅ E2E тесты <15 минут</li><li>✅ Coverage 70-80%</li><li>✅ Flakiness <2%</li><li>✅ Автоматический запуск в CI/CD</li><li>✅ Команда следует TDD</li><li>✅ Метрики на dashboard</li></ul><p><em>Критически важно:</em> Не пытайтесь сделать всё сразу. Инкрементально строим пирамиду, начиная с основания. Каждый этап должен приносить ценность.</p>",
    difficulty: 'senior',
    tags: ['практика', 'план действий', 'внедрение', 'стратегия', 'пошаговый гайд']
  }
]
