import type { Question } from '@/types/question.ts'

export const bffQuestions: Question[] = [
  // Тема 1: Что такое BFF и его роль
  {
    id: 1,
    question: "Что означает аббревиатура BFF в контексте архитектуры веб-приложений?",
    options: [
      "Backend File Format",
      "Backend For Frontend",
      "Best Frontend Framework",
      "Backend Functionality Framework"
    ],
    correctAnswer: 1,
    explanation: "BFF расшифровывается как Backend For Frontend — это архитектурный паттерн, представляющий собой промежуточный слой между фронтенд-приложением и основными бэкенд-сервисами.",
    topic: "Основы BFF"
  },
  {
    id: 2,
    question: "Какую основную роль играет BFF в архитектуре веб-приложений?",
    options: [
      "Замена базы данных",
      "Промежуточный слой для адаптации данных под нужды конкретного фронтенда",
      "Полная замена бэкенда",
      "Кеширование статических файлов"
    ],
    correctAnswer: 1,
    explanation: "BFF служит промежуточным слоем, который адаптирует данные и API основного бэкенда под специфические нужды конкретного фронтенд-приложения (web, mobile, desktop).",
    topic: "Основы BFF"
  },
  {
    id: 3,
    question: "Для чего обычно создаются отдельные BFF для разных типов клиентов (web, mobile)?",
    options: [
      "Для увеличения количества серверов",
      "Чтобы каждый клиент получал оптимизированный под него API и данные",
      "Для усложнения архитектуры",
      "Для разделения команд разработчиков"
    ],
    correctAnswer: 1,
    explanation: "Разные типы клиентов (web-браузеры, мобильные приложения) имеют разные потребности в данных, разную пропускную способность и UX требования. Отдельные BFF позволяют оптимизировать API под каждый тип клиента.",
    topic: "Основы BFF"
  },
  {
    id: 4,
    question: "Что НЕ является задачей BFF?",
    options: [
      "Агрегация данных из нескольких микросервисов",
      "Адаптация формата данных под клиента",
      "Хранение бизнес-логики приложения",
      "Оптимизация количества запросов от клиента"
    ],
    correctAnswer: 2,
    explanation: "BFF не должен содержать бизнес-логику — она остается в основных бэкенд-сервисах. BFF занимается только адаптацией, агрегацией и оптимизацией данных для конкретного клиента.",
    topic: "Основы BFF"
  },
  {
    id: 5,
    question: "Кто обычно разрабатывает и поддерживает BFF?",
    options: [
      "Только backend команда",
      "Только frontend команда",
      "Frontend команда или full-stack разработчики, знающие нужды клиента",
      "DevOps команда"
    ],
    correctAnswer: 2,
    explanation: "BFF часто разрабатывается и поддерживается frontend командой или full-stack разработчиками, так как они лучше понимают специфические потребности клиентского приложения.",
    topic: "Основы BFF"
  },

  // Тема 2: BFF vs традиционный подход
  {
    id: 6,
    question: "В чем основное отличие BFF от традиционного подхода с прямым обращением фронтенда к бэкенду?",
    options: [
      "BFF быстрее обрабатывает запросы",
      "BFF добавляет промежуточный слой адаптации между клиентом и основным бэкендом",
      "BFF заменяет базу данных",
      "BFF работает только с GraphQL"
    ],
    correctAnswer: 1,
    explanation: "При традиционном подходе фронтенд напрямую обращается к единому бэкенд API. BFF добавляет промежуточный слой, который адаптирует и оптимизирует данные под нужды конкретного клиента.",
    topic: "BFF vs традиционный подход"
  },
  {
    id: 7,
    question: "Какую проблему решает BFF, которая часто возникает при традиционном подходе?",
    options: [
      "Медленная работа базы данных",
      "Необходимость делать множество запросов к разным сервисам с клиента",
      "Отсутствие кеширования",
      "Проблемы с авторизацией"
    ],
    correctAnswer: 1,
    explanation: "При традиционном подходе клиент часто вынужден делать множество запросов к разным микросервисам. BFF агрегирует эти запросы на серверной стороне, уменьшая количество round-trips.",
    topic: "BFF vs традиционный подход"
  },
  {
    id: 8,
    question: "Как BFF влияет на связанность (coupling) между фронтендом и бэкендом?",
    options: [
      "Увеличивает связанность",
      "Уменьшает связанность, создавая слой абстракции",
      "Не влияет на связанность",
      "Полностью устраняет связанность"
    ],
    correctAnswer: 1,
    explanation: "BFF уменьшает связанность между фронтендом и основным бэкендом, создавая слой абстракции. Изменения в бэкенд API не обязательно требуют изменений в клиенте, если BFF адаптирует их.",
    topic: "BFF vs традиционный подход"
  },
  {
    id: 9,
    question: "При традиционном подходе клиент получает данные в формате: { user: {...}, posts: {...}, comments: {...} }. Что может сделать BFF?",
    options: [
      "Ничего, должен вернуть данные как есть",
      "Преобразовать в формат, оптимальный для конкретного UI клиента",
      "Удалить все данные",
      "Только добавить кеширование"
    ],
    correctAnswer: 1,
    explanation: "BFF может трансформировать данные в формат, оптимальный для конкретного клиента: изменить структуру, отфильтровать ненужные поля, добавить вычисляемые поля, объединить данные из разных источников.",
    topic: "BFF vs традиционный подход"
  },
  {
    id: 10,
    question: "Что происходит с версионированием API при использовании BFF?",
    options: [
      "Версионирование становится невозможным",
      "BFF может поддерживать разные версии клиентов, преобразуя запросы к актуальной версии бэкенда",
      "Требуется больше версий API",
      "Версионирование не нужно"
    ],
    correctAnswer: 1,
    explanation: "BFF может обрабатывать запросы от разных версий клиентов и преобразовывать их к актуальной версии бэкенд API, упрощая поддержку обратной совместимости.",
    topic: "BFF vs традиционный подход"
  },

  // Тема 3: Преимущества BFF
  {
    id: 11,
    question: "Какое ключевое преимущество BFF для производительности клиента?",
    options: [
      "Уменьшение количества HTTP запросов от клиента",
      "Увеличение скорости работы JavaScript",
      "Автоматическое сжатие изображений",
      "Отключение валидации данных"
    ],
    correctAnswer: 0,
    explanation: "BFF агрегирует данные из нескольких источников на серверной стороне, уменьшая количество HTTP запросов от клиента. Вместо 5 запросов к разным сервисам, клиент делает 1 запрос к BFF.",
    topic: "Преимущества BFF"
  },
  {
    id: 12,
    question: "Как BFF помогает в работе с медленными сетями (например, мобильный интернет)?",
    options: [
      "Ускоряет интернет-соединение",
      "Уменьшает объем передаваемых данных, отправляя только необходимое клиенту",
      "Сжимает все данные в ZIP архив",
      "Отключает передачу данных"
    ],
    correctAnswer: 1,
    explanation: "BFF может фильтровать и оптимизировать данные, отправляя клиенту только то, что действительно нужно для отображения UI, что критично для медленных мобильных сетей.",
    topic: "Преимущества BFF"
  },
  {
    id: 13,
    question: "Какое преимущество BFF в контексте безопасности?",
    options: [
      "Шифрование всех данных",
      "Скрытие деталей реализации бэкенда и микросервисов от клиента",
      "Автоматическое обнаружение хакеров",
      "Отключение всех запросов"
    ],
    correctAnswer: 1,
    explanation: "BFF скрывает внутреннюю архитектуру, структуру микросервисов и детали API от клиента, уменьшая поверхность атаки и не раскрывая внутреннюю реализацию системы.",
    topic: "Преимущества BFF"
  },
  {
    id: 14,
    question: "Как BFF упрощает тестирование фронтенда?",
    options: [
      "Автоматически пишет тесты",
      "Предоставляет стабильный контракт API, независимый от изменений в микросервисах",
      "Отключает необходимость тестирования",
      "Генерирует моки автоматически"
    ],
    correctAnswer: 1,
    explanation: "BFF создает стабильный контракт API для клиента. Даже если внутренние микросервисы меняются, BFF может адаптировать изменения, не ломая клиента, что упрощает тестирование.",
    topic: "Преимущества BFF"
  },
  {
    id: 15,
    question: "Какое преимущество BFF для команд разработки?",
    options: [
      "Увеличивает количество разработчиков",
      "Позволяет frontend и backend командам работать более независимо",
      "Устраняет необходимость в backend разработчиках",
      "Автоматизирует код-ревью"
    ],
    correctAnswer: 1,
    explanation: "BFF позволяет frontend команде управлять своим API слоем и развиваться независимо от backend команды, которая может фокусироваться на бизнес-логике и микросервисах.",
    topic: "Преимущества BFF"
  },
  {
    id: 16,
    question: "Как BFF помогает в работе с легаси системами?",
    options: [
      "Полностью переписывает легаси код",
      "Может адаптировать устаревшие API к современным стандартам",
      "Удаляет легаси системы",
      "Игнорирует легаси системы"
    ],
    correctAnswer: 1,
    explanation: "BFF может служить адаптером между современным фронтендом и устаревшими backend системами, преобразуя старые форматы данных и протоколы в современные REST/GraphQL API.",
    topic: "Преимущества BFF"
  },

  // Тема 4: Over-fetching и Under-fetching
  {
    id: 17,
    question: "Что такое over-fetching в контексте REST API?",
    options: [
      "Слишком много запросов к API",
      "Получение больше данных, чем нужно клиенту",
      "Медленная загрузка данных",
      "Ошибки в запросах"
    ],
    correctAnswer: 1,
    explanation: "Over-fetching — это ситуация, когда API возвращает больше данных, чем нужно клиенту. Например, запрос возвращает весь объект пользователя с 50 полями, когда нужны только имя и email.",
    topic: "Over-fetching и Under-fetching"
  },
  {
    id: 18,
    question: "Что такое under-fetching?",
    options: [
      "Недостаточно быстрая загрузка",
      "Получение меньше данных, чем нужно, требующее дополнительных запросов",
      "Ошибка сервера",
      "Отсутствие данных в базе"
    ],
    correctAnswer: 1,
    explanation: "Under-fetching — это когда один запрос не предоставляет все нужные данные, и клиенту приходится делать дополнительные запросы. Например, получить пользователя, затем его посты, затем комментарии к постам.",
    topic: "Over-fetching и Under-fetching"
  },
  {
    id: 19,
    question: "Как BFF решает проблему over-fetching?",
    options: [
      "Увеличивает размер ответа",
      "Фильтрует и возвращает только те поля, которые нужны конкретному клиенту",
      "Блокирует все запросы",
      "Кеширует все данные"
    ],
    correctAnswer: 1,
    explanation: "BFF может запросить полные данные у backend сервисов, но отфильтровать и вернуть клиенту только необходимые поля, уменьшая объем передаваемых данных и время парсинга на клиенте.",
    topic: "Over-fetching и Under-fetching"
  },
  {
    id: 20,
    question: "Как BFF решает проблему under-fetching?",
    options: [
      "Заставляет клиента делать больше запросов",
      "Агрегирует данные из нескольких источников в один запрос",
      "Удаляет ненужные данные",
      "Кеширует старые запросы"
    ],
    correctAnswer: 1,
    explanation: "BFF может сделать несколько запросов к разным микросервисам на серверной стороне, агрегировать данные и вернуть клиенту все необходимое в одном ответе.",
    topic: "Over-fetching и Under-fetching"
  },
  {
    id: 21,
    question: "Клиенту нужны: имя пользователя, его последние 5 постов и количество подписчиков. Как BFF поможет оптимизировать это?",
    options: [
      "Заставит клиента сделать 3 отдельных запроса",
      "Сделает 3 запроса к микросервисам на сервере, агрегирует и вернет в одном ответе",
      "Вернет все данные всех пользователей",
      "Откажет в доступе"
    ],
    correctAnswer: 1,
    explanation: "BFF может параллельно запросить данные из User Service, Post Service и Follower Service, скомбинировать их и вернуть клиенту одним ответом с точно теми данными, которые нужны.",
    topic: "Over-fetching и Under-fetching"
  },
  {
    id: 22,
    question: "Почему GraphQL часто используется в BFF для решения over-fetching/under-fetching?",
    options: [
      "GraphQL быстрее REST",
      "GraphQL позволяет клиенту запрашивать точно те поля, которые нужны",
      "GraphQL не требует сервера",
      "GraphQL автоматически кеширует данные"
    ],
    correctAnswer: 1,
    explanation: "GraphQL идеально подходит для BFF, так как позволяет клиенту явно указывать, какие поля и связанные данные нужны, решая проблемы over-fetching и under-fetching на уровне запроса.",
    topic: "Over-fetching и Under-fetching"
  },

  // Тема 5: Проблемы BFF и их решение
  {
    id: 23,
    question: "Какая основная проблема может возникнуть при использовании BFF?",
    options: [
      "Невозможность работы с базами данных",
      "Дополнительная сложность и еще один слой для поддержки",
      "Отсутствие безопасности",
      "Невозможность использования JavaScript"
    ],
    correctAnswer: 1,
    explanation: "BFF добавляет дополнительный слой в архитектуру, который нужно разрабатывать, поддерживать, мониторить и масштабировать. Это увеличивает общую сложность системы.",
    topic: "Проблемы BFF"
  },
  {
    id: 24,
    question: "Что может произойти, если в BFF начать добавлять бизнес-логику?",
    options: [
      "Ничего страшного",
      "Размывание ответственности, дублирование логики, сложность поддержки",
      "Увеличение производительности",
      "Автоматическая оптимизация"
    ],
    correctAnswer: 1,
    explanation: "Одна из главных проблем — соблазн добавить бизнес-логику в BFF. Это приводит к дублированию логики, усложнению тестирования и размыванию границ ответственности. BFF должен оставаться тонким слоем адаптации.",
    topic: "Проблемы BFF"
  },
  {
    id: 25,
    question: "Какая проблема производительности может возникнуть с BFF?",
    options: [
      "BFF всегда медленнее любого решения",
      "BFF становится bottleneck, если не оптимизирован или не масштабирован",
      "BFF ускоряет все запросы",
      "BFF не влияет на производительность"
    ],
    correctAnswer: 1,
    explanation: "BFF — это дополнительный network hop между клиентом и данными. Если BFF плохо оптимизирован, не использует параллельные запросы или не масштабирован, он может стать узким местом.",
    topic: "Проблемы BFF"
  },
  {
    id: 26,
    question: "Как избежать дублирования кода между несколькими BFF (web, mobile)?",
    options: [
      "Никак, нужно писать все заново",
      "Выделить общую бизнес-логику в shared библиотеки или переместить в backend сервисы",
      "Использовать только один BFF",
      "Копировать код вручную"
    ],
    correctAnswer: 1,
    explanation: "Общий код (валидация, трансформации, утилиты) можно выделить в shared библиотеки. А если код содержит бизнес-логику — это сигнал, что её место в основных backend сервисах, а не в BFF.",
    topic: "Проблемы BFF"
  },
  {
    id: 27,
    question: "Как решить проблему увеличения latency из-за дополнительного слоя BFF?",
    options: [
      "Удалить BFF",
      "Использовать кеширование, параллельные запросы, оптимизировать сериализацию данных",
      "Игнорировать проблему",
      "Замедлить клиент"
    ],
    correctAnswer: 1,
    explanation: "Latency можно уменьшить через: кеширование частых запросов, параллельное выполнение запросов к микросервисам, использование HTTP/2, оптимизацию сериализации (Protocol Buffers вместо JSON), CDN для статики.",
    topic: "Проблемы BFF"
  },
  {
    id: 28,
    question: "Что делать, если команда BFF становится bottleneck для изменений?",
    options: [
      "Увеличить размер команды в 10 раз",
      "Четко разграничить зоны ответственности, автоматизировать деплой, использовать feature flags",
      "Удалить BFF",
      "Запретить вносить изменения"
    ],
    correctAnswer: 1,
    explanation: "Проблему можно решить через: четкое разделение ответственности между frontend и BFF командами, автоматизацию CI/CD, использование feature flags для независимого выката фич, документирование контрактов API.",
    topic: "Проблемы BFF"
  },
  {
    id: 29,
    question: "Как обеспечить консистентность данных, если BFF кеширует ответы?",
    options: [
      "Отключить кеширование полностью",
      "Использовать правильные стратегии инвалидации кеша и TTL",
      "Игнорировать консистентность",
      "Кешировать все навсегда"
    ],
    correctAnswer: 1,
    explanation: "Нужно продумать стратегии инвалидации кеша: использовать правильные TTL, реагировать на события изменения данных (event-driven invalidation), использовать Cache-Control headers, различать мутабельные и иммутабельные данные.",
    topic: "Проблемы BFF"
  },

  // Тема 6: Взаимодействие и технологии
  {
    id: 30,
    question: "Какие протоколы обычно используются для взаимодействия между клиентом и BFF?",
    options: [
      "Только FTP",
      "HTTP/HTTPS (REST, GraphQL, WebSocket)",
      "Только SMTP",
      "Только TCP сокеты"
    ],
    correctAnswer: 1,
    explanation: "Для взаимодействия клиент-BFF обычно используют: REST API (JSON/XML), GraphQL, WebSocket для real-time коммуникации, HTTP/2 или HTTP/3 для оптимизации.",
    topic: "Взаимодействие и технологии"
  },
  {
    id: 31,
    question: "Какой формат данных чаще всего используется для обмена между клиентом и BFF?",
    options: [
      "CSV",
      "JSON",
      "XML только",
      "Бинарные файлы"
    ],
    correctAnswer: 1,
    explanation: "JSON — наиболее популярный формат для REST и GraphQL API. Также могут использоваться: Protocol Buffers (для оптимизации размера), MessagePack, XML (для легаси систем).",
    topic: "Взаимодействие и технологии"
  },
  {
    id: 32,
    question: "Как BFF обычно взаимодействует с внутренними микросервисами?",
    options: [
      "Напрямую через базу данных",
      "Через HTTP/REST, gRPC, message queues",
      "Только через FTP",
      "Не взаимодействует вообще"
    ],
    correctAnswer: 1,
    explanation: "BFF может взаимодействовать с микросервисами через: HTTP/REST API, gRPC для высокопроизводительной коммуникации, message queues (RabbitMQ, Kafka) для асинхронных операций, service mesh для управления коммуникацией.",
    topic: "Взаимодействие и технологии"
  },
  {
    id: 33,
    question: "Почему gRPC может быть хорошим выбором для коммуникации BFF с микросервисами?",
    options: [
      "gRPC медленнее HTTP",
      "gRPC использует Protocol Buffers, HTTP/2 и предоставляет типизированные контракты",
      "gRPC работает только с JavaScript",
      "gRPC не поддерживает стриминг"
    ],
    correctAnswer: 1,
    explanation: "gRPC использует Protocol Buffers (компактнее JSON), работает по HTTP/2 (multiplexing), предоставляет строго типизированные контракты, поддерживает bi-directional streaming, что делает его эффективным для server-to-server коммуникации.",
    topic: "Взаимодействие и технологии"
  },
  {
    id: 34,
    question: "Какой паттерн можно использовать в BFF для агрегации данных из нескольких источников?",
    options: [
      "Singleton",
      "Параллельные запросы с Promise.all() или аналогичные механизмы",
      "Observer",
      "Factory"
    ],
    correctAnswer: 1,
    explanation: "Для эффективной агрегации данных BFF должен делать параллельные запросы к микросервисам (Promise.all, async/await, concurrent requests), а не последовательные, чтобы минимизировать общее время ответа.",
    topic: "Взаимодействие и технологии"
  },
  {
    id: 35,
    question: "Как BFF может обрабатывать real-time обновления данных?",
    options: [
      "Только через постоянный polling",
      "WebSocket, Server-Sent Events (SSE), или подписки в GraphQL",
      "Real-time невозможен в BFF",
      "Только через email уведомления"
    ],
    correctAnswer: 1,
    explanation: "BFF может использовать: WebSocket для bi-directional real-time коммуникации, Server-Sent Events (SSE) для server-to-client streaming, GraphQL subscriptions, long-polling как fallback.",
    topic: "Взаимодействие и технологии"
  },
  {
    id: 36,
    question: "Что такое API Gateway и чем он отличается от BFF?",
    options: [
      "Это одно и то же",
      "API Gateway — общий маршрутизатор для всех клиентов, BFF — специфичен для одного типа клиента",
      "API Gateway медленнее BFF",
      "API Gateway не поддерживает HTTP"
    ],
    correctAnswer: 1,
    explanation: "API Gateway — это единая точка входа для всех клиентов, предоставляющая маршрутизацию, аутентификацию, rate limiting. BFF — специализированный backend для конкретного типа клиента. Часто используются вместе: Gateway впереди, BFF за ним.",
    topic: "Взаимодействие и технологии"
  },

  // Тема 7: Практические сценарии
  {
    id: 37,
    question: "У вас есть мобильное и веб-приложение с разными требованиями к данным. Какое решение лучше?",
    options: [
      "Один общий BFF для обоих",
      "Отдельные BFF для mobile и web с оптимизациями под каждую платформу",
      "Отказаться от BFF",
      "Использовать только GraphQL без BFF"
    ],
    correctAnswer: 1,
    explanation: "Лучше создать отдельные BFF: mobile-BFF может возвращать более компактные данные для экономии трафика, web-BFF может быть более щедрым на данные, каждый оптимизирован под свой UX.",
    topic: "Практические сценарии"
  },
  {
    id: 38,
    question: "Ваш backend состоит из 15 микросервисов. Страница требует данных из 8 сервисов. Что должен сделать BFF?",
    options: [
      "Заставить клиента сделать 8 запросов",
      "Параллельно запросить 8 сервисов, агрегировать данные, вернуть один ответ",
      "Выбрать случайный сервис",
      "Вернуть ошибку"
    ],
    correctAnswer: 1,
    explanation: "BFF должен параллельно (Promise.all) запросить все 8 микросервисов, дождаться ответов, скомбинировать данные в нужной структуре и вернуть клиенту один ответ, минимизируя latency.",
    topic: "Практические сценарии"
  },
  {
    id: 39,
    question: "У вас легаси SOAP сервис, а фронтенд ожидает современный REST JSON API. Как BFF может помочь?",
    options: [
      "BFF не может работать с SOAP",
      "BFF может вызвать SOAP сервис и преобразовать XML ответ в JSON для клиента",
      "Нужно переписать весь backend",
      "Клиент должен работать с SOAP напрямую"
    ],
    correctAnswer: 1,
    explanation: "BFF может служить адаптером: вызывать легаси SOAP API, парсить XML, трансформировать в современный JSON формат и возвращать клиенту, скрывая сложность легаси системы.",
    topic: "Практические сценарии"
  },
  {
    id: 40,
    question: "Какой паттерн масштабирования подходит для BFF?",
    options: [
      "Только вертикальное масштабирование",
      "Горизонтальное масштабирование (stateless BFF instances за load balancer)",
      "BFF нельзя масштабировать",
      "Только репликация базы данных"
    ],
    correctAnswer: 1,
    explanation: "BFF должен быть stateless (без хранения состояния сессии) и масштабироваться горизонтально: запустить несколько инстансов за load balancer. Состояние должно храниться во внешних сервисах (Redis, БД).",
    topic: "Практические сценарии"
  },
  {
    id: 41,
    question: "Нужно ли в BFF реализовывать собственную авторизацию?",
    options: [
      "Да, всегда писать свою авторизацию",
      "Нет, BFF должен проверять токены и делегировать авторизационные решения специализированному сервису",
      "Авторизация не нужна в BFF",
      "BFF должен хранить пароли"
    ],
    correctAnswer: 1,
    explanation: "BFF должен валидировать JWT токены или session cookies, но авторизационные правила (permissions, roles) должны управляться специализированным Auth Service. BFF может кешировать результаты проверок для производительности.",
    topic: "Практические сценарии"
  },
  {
    id: 42,
    question: "Клиент запрашивает список из 1000 элементов. Что должен сделать BFF?",
    options: [
      "Вернуть все 1000 элементов сразу",
      "Реализовать пагинацию или cursor-based navigation, возвращать порциями",
      "Отказать в запросе",
      "Вернуть случайные 10 элементов"
    ],
    correctAnswer: 1,
    explanation: "BFF должен реализовать пагинацию (offset/limit или cursor-based), возвращая данные порциями. Также может применить фильтрацию и сортировку на стороне сервера, уменьшая нагрузку на клиента.",
    topic: "Практические сценарии"
  },
  {
    id: 43,
    question: "Как BFF может помочь с оптимистичными обновлениями UI?",
    options: [
      "BFF не участвует в UI обновлениях",
      "BFF может быстро подтверждать запросы и асинхронно обрабатывать их в фоне",
      "BFF блокирует все UI обновления",
      "BFF удаляет все данные"
    ],
    correctAnswer: 1,
    explanation: "BFF может сразу вернуть 200 OK после валидации запроса, а фактическую обработку выполнить асинхронно через message queue. Клиент может оптимистично обновить UI, получая реальный результат позже через WebSocket или polling.",
    topic: "Практические сценарии"
  },
  {
    id: 44,
    question: "Стоит ли кешировать данные в BFF?",
    options: [
      "Никогда не кешировать",
      "Да, но с правильными стратегиями инвалидации и TTL",
      "Кешировать всё навсегда",
      "Кешировать только статические файлы"
    ],
    correctAnswer: 1,
    explanation: "BFF может кешировать: часто запрашиваемые данные (с правильным TTL), результаты агрегации (Redis, in-memory cache), идемпотентные запросы. Важно продумать стратегию инвалидации кеша при изменении данных.",
    topic: "Практические сценарии"
  },
  {
    id: 45,
    question: "Как обрабатывать ошибки микросервисов в BFF?",
    options: [
      "Пробросить все ошибки клиенту как есть",
      "Обработать, нормализовать и вернуть клиенту понятные, консистентные сообщения об ошибках",
      "Игнорировать все ошибки",
      "Перезапустить микросервис"
    ],
    correctAnswer: 1,
    explanation: "BFF должен: обрабатывать ошибки микросервисов, нормализовать их в понятные клиенту сообщения, логировать детали для отладки, реализовать retry логику для временных сбоев, возвращать fallback данные если возможно.",
    topic: "Практические сценарии"
  },

  // Дополнительные вопросы
  {
    id: 46,
    question: "Что такое micro-frontend и как BFF связан с ним?",
    options: [
      "Это одно и то же",
      "Micro-frontend — архитектурный подход на фронтенде, BFF может предоставлять API для каждого micro-frontend",
      "BFF заменяет micro-frontend",
      "Они не связаны"
    ],
    correctAnswer: 1,
    explanation: "Micro-frontend — подход к разделению фронтенда на независимые части. Каждый micro-frontend может иметь свой собственный BFF, или несколько micro-frontend могут использовать один BFF с разными endpoints.",
    topic: "Архитектурные паттерны"
  },
  {
    id: 47,
    question: "Можно ли использовать BFF с Server-Side Rendering (SSR)?",
    options: [
      "Нет, это несовместимо",
      "Да, BFF может предоставлять данные для SSR и Client-Side",
      "SSR заменяет BFF",
      "BFF работает только с Client-Side Rendering"
    ],
    correctAnswer: 1,
    explanation: "BFF отлично сочетается с SSR (Next.js, Nuxt.js): серверная часть приложения может запрашивать данные у BFF для рендеринга на сервере, а клиентская часть использует те же API для последующих запросов.",
    topic: "Архитектурные паттерны"
  },
  {
    id: 48,
    question: "Как мониторить производительность и здоровье BFF?",
    options: [
      "Мониторинг не нужен",
      "Использовать APM инструменты, логи, метрики (latency, error rate, throughput)",
      "Только визуально проверять",
      "Перезапускать каждый час"
    ],
    correctAnswer: 1,
    explanation: "BFF нужно мониторить: использовать APM (Application Performance Monitoring), собирать метрики (response time, error rate, throughput), логировать запросы, настроить алерты, использовать distributed tracing для отладки.",
    topic: "Мониторинг и отладка"
  },
  {
    id: 49,
    question: "Что такое schema stitching в контексте GraphQL BFF?",
    options: [
      "Шитье одежды для серверов",
      "Объединение нескольких GraphQL схем из разных сервисов в одну",
      "Удаление полей из схемы",
      "Компиляция GraphQL в REST"
    ],
    correctAnswer: 1,
    explanation: "Schema stitching — это техника объединения нескольких GraphQL схем из разных микросервисов в единую схему в BFF. Это позволяет клиенту работать с одной консистентной GraphQL API, даже если данные приходят из разных источников.",
    topic: "GraphQL паттерны"
  },
  {
    id: 50,
    question: "Когда НЕ стоит использовать BFF?",
    options: [
      "BFF нужен всегда",
      "Когда приложение простое, с одним клиентом и прямолинейным API",
      "Когда используется TypeScript",
      "Когда есть база данных"
    ],
    correctAnswer: 1,
    explanation: "BFF может быть избыточным для: простых приложений с одним типом клиента, CRUD приложений без сложной агрегации данных, прототипов и MVP, команд без ресурсов на поддержку дополнительного слоя. Не стоит добавлять сложность без реальной необходимости.",
    topic: "Когда использовать BFF"
  }
]
