import type { Question } from '@/types/question.ts'

export const ssrQuestions: Question[] = [
  // Тема 1: Основы SSR
  {
    id: 1,
    question: "Что такое SSR (Server-Side Rendering)?",
    options: [
      "Рендеринг HTML на стороне клиента с помощью JavaScript",
      "Процесс генерации HTML на сервере и отправки готовой страницы клиенту",
      "Кеширование статических файлов на сервере",
      "Компиляция JavaScript кода на сервере"
    ],
    correctAnswer: 1,
    explanation: "SSR — это процесс генерации полного HTML-контента на сервере и отправки готовой страницы клиенту. Браузер получает уже отрендеренную страницу, которую можно сразу отобразить.",
    topic: "Основы SSR"
  },
  {
    id: 2,
    question: "В чем главное отличие SSR от CSR (Client-Side Rendering)?",
    options: [
      "SSR быстрее загружает JavaScript",
      "SSR генерирует HTML на сервере, CSR — в браузере",
      "SSR не использует JavaScript",
      "CSR не поддерживает SEO"
    ],
    correctAnswer: 1,
    explanation: "Основное отличие: при SSR HTML генерируется на сервере и отправляется готовым, при CSR браузер получает пустой HTML и JavaScript, который рендерит контент на клиенте.",
    topic: "Основы SSR"
  },
  {
    id: 3,
    question: "Какой процесс происходит при SSR после отправки HTML клиенту?",
    options: [
      "Страница полностью статична и не меняется",
      "Гидратация (hydration) — прикрепление событий к отрендеренному HTML",
      "Повторный рендеринг всего контента на клиенте",
      "Удаление серверного HTML и создание нового"
    ],
    correctAnswer: 1,
    explanation: "После получения серверного HTML происходит гидратация — React/Vue прикрепляет обработчики событий к существующей разметке, делая страницу интерактивной без полного перерендера.",
    topic: "Основы SSR"
  },
  {
    id: 4,
    question: "Какие фреймворки предоставляют встроенную поддержку SSR?",
    options: [
      "Create React App, Vue CLI",
      "Next.js, Nuxt.js, SvelteKit",
      "Vite, Webpack",
      "Express, Fastify"
    ],
    correctAnswer: 1,
    explanation: "Next.js (React), Nuxt.js (Vue), SvelteKit (Svelte), Remix (React) предоставляют встроенную поддержку SSR с удобными API и оптимизациями из коробки.",
    topic: "Основы SSR"
  },
  {
    id: 5,
    question: "Что такое 'Time to First Byte' (TTFB) в контексте SSR?",
    options: [
      "Время загрузки JavaScript бандла",
      "Время от запроса до получения первого байта ответа от сервера",
      "Время до интерактивности страницы",
      "Время парсинга HTML"
    ],
    correctAnswer: 1,
    explanation: "TTFB — это время от момента запроса до получения первого байта ответа. При SSR TTFB может быть выше, чем при CSR, так как сервер должен сгенерировать HTML перед отправкой.",
    topic: "Основы SSR"
  },

  // Тема 2: Преимущества SSR
  {
    id: 6,
    question: "Какое главное преимущество SSR для SEO?",
    options: [
      "Быстрая загрузка JavaScript",
      "Поисковые роботы получают полностью отрендеренный HTML сразу",
      "Меньший размер бандла",
      "Автоматическая генерация метатегов"
    ],
    correctAnswer: 1,
    explanation: "Поисковые роботы получают готовый HTML с контентом при первом запросе, не дожидаясь выполнения JavaScript. Это критично для индексации и ранжирования контента.",
    topic: "Преимущества SSR"
  },
  {
    id: 7,
    question: "Как SSR улучшает метрику First Contentful Paint (FCP)?",
    options: [
      "SSR не влияет на FCP",
      "Браузер может отобразить контент сразу после получения HTML, не дожидаясь JS",
      "SSR уменьшает размер CSS",
      "SSR автоматически оптимизирует изображения"
    ],
    correctAnswer: 1,
    explanation: "При SSR браузер получает готовый HTML и может отобразить контент немедленно, улучшая FCP. При CSR пользователь видит пустую страницу до загрузки и выполнения JavaScript.",
    topic: "Преимущества SSR"
  },
  {
    id: 8,
    question: "В каких случаях SSR особенно важен для бизнеса?",
    options: [
      "Для внутренних admin-панелей",
      "Для контент-ориентированных сайтов, e-commerce, новостных порталов",
      "Для web-приложений за авторизацией",
      "Для простых лендингов"
    ],
    correctAnswer: 1,
    explanation: "SSR критичен для контент-сайтов, e-commerce, новостных порталов, где важны SEO, социальные превью (Open Graph) и быстрое отображение контента для пользователей и поисковиков.",
    topic: "Преимущества SSR"
  },
  {
    id: 9,
    question: "Как SSR влияет на социальные шеринг-превью (Open Graph)?",
    options: [
      "Не влияет, Open Graph работает везде одинаково",
      "Боты соцсетей видят готовые метатеги в HTML, корректно генерируя превью",
      "SSR автоматически создает картинки для превью",
      "Open Graph не работает с SSR"
    ],
    correctAnswer: 1,
    explanation: "Боты Facebook, Twitter, LinkedIn парсят HTML без выполнения JavaScript. SSR гарантирует, что метатеги Open Graph присутствуют в исходном HTML и превью генерируется корректно.",
    topic: "Преимущества SSR"
  },
  {
    id: 10,
    question: "Какое преимущество SSR для пользователей с медленным интернетом?",
    options: [
      "Нет преимуществ для медленного интернета",
      "Контент виден сразу, даже если JS загружается долго",
      "SSR уменьшает размер загружаемых данных",
      "SSR работает без интернета"
    ],
    correctAnswer: 1,
    explanation: "При SSR HTML с контентом загружается первым. Даже если JavaScript грузится медленно, пользователь уже видит контент и может его читать, улучшая воспринимаемую производительность.",
    topic: "Преимущества SSR"
  },

  // Тема 3: Влияние на производительность
  {
    id: 11,
    question: "Как SSR влияет на нагрузку на сервер по сравнению с CSR?",
    options: [
      "Нагрузка одинакова",
      "SSR увеличивает нагрузку на сервер, так как рендеринг происходит на каждый запрос",
      "SSR снижает нагрузку на сервер",
      "SSR полностью переносит нагрузку на клиента"
    ],
    correctAnswer: 1,
    explanation: "SSR требует вычислительных ресурсов сервера для рендеринга HTML на каждый запрос. При CSR сервер просто отдает статические файлы, а рендеринг происходит на клиенте.",
    topic: "Производительность SSR"
  },
  {
    id: 12,
    question: "Что такое Time to Interactive (TTI) и как SSR на него влияет?",
    options: [
      "TTI — время до интерактивности. SSR может увеличить TTI из-за гидратации",
      "TTI — время загрузки. SSR всегда улучшает TTI",
      "TTI не связан с SSR",
      "SSR полностью устраняет TTI"
    ],
    correctAnswer: 0,
    explanation: "TTI — время, когда страница становится полностью интерактивной. При SSR пользователь видит контент быстро, но интерактивность появляется только после загрузки JS и гидратации, что может увеличить TTI.",
    topic: "Производительность SSR"
  },
  {
    id: 13,
    question: "Как кеширование помогает решить проблему производительности SSR?",
    options: [
      "Кеширование не применимо к SSR",
      "Кеш серверных HTML-ответов снижает необходимость повторного рендеринга",
      "Кеширование работает только на клиенте",
      "Кеш увеличивает время рендеринга"
    ],
    correctAnswer: 1,
    explanation: "Кеширование сгенерированного HTML (через CDN, Redis, in-memory кеш) позволяет отдавать готовые страницы без рендеринга, снижая нагрузку на сервер и ускоряя ответ.",
    topic: "Производительность SSR"
  },
  {
    id: 14,
    question: "Что такое 'Streaming SSR' и как это помогает производительности?",
    options: [
      "Загрузка изображений потоком",
      "Отправка HTML частями по мере готовности, без ожидания полного рендера",
      "Потоковая передача JavaScript",
      "Синхронизация с клиентом в реальном времени"
    ],
    correctAnswer: 1,
    explanation: "Streaming SSR (React 18+, Next.js 13+) позволяет отправлять HTML частями по мере готовности. Браузер начинает рендерить страницу раньше, улучшая TTFB и FCP.",
    topic: "Производительность SSR"
  },
  {
    id: 15,
    question: "Какой подход помогает уменьшить размер JavaScript при SSR?",
    options: [
      "Code splitting и lazy loading компонентов",
      "Увеличение размера HTML",
      "Отказ от React",
      "Дублирование кода на сервере и клиенте"
    ],
    correctAnswer: 0,
    explanation: "Code splitting разбивает JS на чанки, загружая только необходимый код. Lazy loading откладывает загрузку компонентов до их использования, уменьшая начальный бандл.",
    topic: "Производительность SSR"
  },

  // Тема 4: Проблемы и вызовы SSR
  {
    id: 16,
    question: "Какая основная проблема с Browser API при SSR?",
    options: [
      "Browser API работают медленнее при SSR",
      "window, document и другие Browser API недоступны на сервере",
      "Browser API полностью совместимы с SSR",
      "SSR блокирует все Browser API"
    ],
    correctAnswer: 1,
    explanation: "На сервере нет Browser API (window, document, localStorage и т.д.). Код, использующий эти API, должен быть обернут в проверки или выполняться только на клиенте (useEffect, componentDidMount).",
    topic: "Проблемы SSR"
  },
  {
    id: 17,
    question: "Что такое 'hydration mismatch' в SSR?",
    options: [
      "Ошибка сети при загрузке",
      "Несоответствие между серверным HTML и клиентским рендером React",
      "Проблема с CSS стилями",
      "Ошибка кеширования"
    ],
    correctAnswer: 1,
    explanation: "Hydration mismatch — когда клиентский React пытается прикрепиться к серверному HTML, но обнаруживает различия (например, разное время, random ID). Это вызывает ошибки и перерендер.",
    topic: "Проблемы SSR"
  },
  {
    id: 18,
    question: "Как правильно использовать localStorage в SSR приложении?",
    options: [
      "localStorage доступен на сервере через Node.js",
      "Обращаться к localStorage только на клиенте (useEffect, проверка typeof window)",
      "Использовать синхронный код с localStorage везде",
      "localStorage автоматически работает в SSR"
    ],
    correctAnswer: 1,
    explanation: "localStorage доступен только в браузере. При SSR нужно использовать проверку: typeof window !== 'undefined' или размещать код в useEffect/componentDidMount, которые выполняются только на клиенте.",
    topic: "Проблемы SSR"
  },
  {
    id: 19,
    question: "Какая проблема с CSS-in-JS библиотеками при SSR?",
    options: [
      "CSS-in-JS не работает с SSR",
      "Требуется специальная настройка для извлечения критических стилей на сервере",
      "CSS-in-JS работает только на клиенте",
      "SSR автоматически обрабатывает все стили"
    ],
    correctAnswer: 1,
    explanation: "CSS-in-JS библиотеки (styled-components, emotion) требуют настройки для SSR: сервер должен собрать критические стили и внедрить их в HTML, иначе будет flash of unstyled content (FOUC).",
    topic: "Проблемы SSR"
  },
  {
    id: 20,
    question: "Что такое 'double data fetching' проблема в SSR?",
    options: [
      "Ошибка сети",
      "Данные загружаются дважды: на сервере при SSR и на клиенте при гидратации",
      "Дублирование запросов в базу данных",
      "Проблема кеширования"
    ],
    correctAnswer: 1,
    explanation: "Без правильной архитектуры данные могут загружаться дважды: сервер делает запрос для рендера HTML, затем клиент повторяет запрос при гидратации. Решение — передача данных от сервера к клиенту.",
    topic: "Проблемы SSR"
  },

  // Тема 5: Взаимодействие с клиентским JavaScript
  {
    id: 21,
    question: "Что происходит с event listeners при гидратации?",
    options: [
      "Они автоматически добавляются к серверному HTML",
      "React/Vue прикрепляет обработчики событий к существующей разметке",
      "Event listeners создаются только на сервере",
      "Требуется ручное добавление listeners"
    ],
    correctAnswer: 1,
    explanation: "При гидратации React/Vue не перерендеривает DOM, а прикрепляет обработчики событий к существующей серверной разметке, делая страницу интерактивной без полного пересоздания.",
    topic: "Клиентский JavaScript и SSR"
  },
  {
    id: 22,
    question: "Как передать данные от сервера клиенту при SSR?",
    options: [
      "Через localStorage",
      "Через глобальную переменную window.__INITIAL_STATE__ или data attributes",
      "Данные автоматически синхронизируются",
      "Через WebSockets"
    ],
    correctAnswer: 1,
    explanation: "Сервер сериализует данные в JSON и внедряет их в HTML через <script>window.__INITIAL_STATE__ = {...}</script> или data-атрибуты. Клиент читает эти данные при гидратации.",
    topic: "Клиентский JavaScript и SSR"
  },
  {
    id: 23,
    question: "Что такое 'progressive hydration'?",
    options: [
      "Загрузка только CSS",
      "Постепенная гидратация компонентов по приоритету или видимости",
      "Полная гидратация всей страницы сразу",
      "Отказ от гидратации"
    ],
    correctAnswer: 1,
    explanation: "Progressive hydration — техника, при которой компоненты гидратируются постепенно (сначала видимые/важные), снижая время до интерактивности (TTI) и улучшая производительность.",
    topic: "Клиентский JavaScript и SSR"
  },
  {
    id: 24,
    question: "Как useEffect взаимодействует с SSR?",
    options: [
      "useEffect выполняется на сервере и на клиенте",
      "useEffect выполняется ТОЛЬКО на клиенте после гидратации",
      "useEffect не работает в SSR приложениях",
      "useEffect заменяется на серверные хуки"
    ],
    correctAnswer: 1,
    explanation: "useEffect (и componentDidMount) выполняются только на клиенте после монтирования. Это безопасное место для Browser API, side effects и подписок.",
    topic: "Клиентский JavaScript и SSR"
  },
  {
    id: 25,
    question: "Что такое 'Islands Architecture' в контексте SSR?",
    options: [
      "Разделение приложения на микросервисы",
      "Архитектура с островками интерактивности в статическом HTML",
      "Использование CDN",
      "Полностью статические сайты"
    ],
    correctAnswer: 1,
    explanation: "Islands Architecture — подход, где страница в основном статична, но содержит 'островки' интерактивных компонентов. Гидратируются только эти островки, снижая размер JS и ускоряя TTI.",
    topic: "Клиентский JavaScript и SSR"
  },

  // Тема 6: Продвинутые концепции SSR
  {
    id: 26,
    question: "Что такое Incremental Static Regeneration (ISR)?",
    options: [
      "Полная перегенерация сайта каждый раз",
      "Гибрид SSG и SSR: статические страницы обновляются в фоне по расписанию",
      "Только SSR без кеша",
      "Чисто клиентский рендеринг"
    ],
    correctAnswer: 1,
    explanation: "ISR (Next.js) — это гибрид: страницы генерируются статически, но могут обновляться в фоне через определенные интервалы. Пользователи получают быстрые статические страницы с актуальным контентом.",
    topic: "Продвинутые концепции"
  },
  {
    id: 27,
    question: "В чем разница между SSR и SSG (Static Site Generation)?",
    options: [
      "Никакой разницы",
      "SSR генерирует HTML на каждый запрос, SSG — на этапе билда",
      "SSG работает только для блогов",
      "SSR не поддерживает dynamic routes"
    ],
    correctAnswer: 1,
    explanation: "SSG генерирует все страницы в HTML на этапе билда (build time). SSR генерирует HTML на сервере при каждом запросе (request time). SSG быстрее, но менее динамичен.",
    topic: "Продвинутые концепции"
  },
  {
    id: 28,
    question: "Что такое 'React Server Components' (RSC)?",
    options: [
      "Компоненты, которые рендерятся только на сервере без JS на клиенте",
      "Обычные React компоненты",
      "Компоненты для Node.js",
      "Устаревшая технология"
    ],
    correctAnswer: 0,
    explanation: "React Server Components — новая парадигма, где компоненты рендерятся только на сервере и не отправляют JS клиенту. Это снижает размер бандла и улучшает производительность.",
    topic: "Продвинутые концепции"
  },
  {
    id: 29,
    question: "Как обрабатывать аутентификацию при SSR?",
    options: [
      "Аутентификация невозможна при SSR",
      "Проверять токены/cookies на сервере при SSR запросе",
      "Вся аутентификация только на клиенте",
      "SSR не поддерживает приватные страницы"
    ],
    correctAnswer: 1,
    explanation: "При SSR сервер может проверять cookies/tokens из запроса, определять авторизован ли пользователь и рендерить соответствующий контент. Защита приватных страниц работает на уровне сервера.",
    topic: "Продвинутые концепции"
  },
  {
    id: 30,
    question: "Что такое 'Selective Hydration' в React 18?",
    options: [
      "Полная гидратация всей страницы",
      "Гидратация компонентов по мере готовности и приоритету (Suspense boundaries)",
      "Отказ от гидратации",
      "Гидратация только CSS"
    ],
    correctAnswer: 1,
    explanation: "Selective Hydration (React 18) позволяет гидратировать компоненты независимо по мере готовности. Suspense boundaries создают приоритеты: важные компоненты гидратируются первыми.",
    topic: "Продвинутые концепции"
  },

  // Тема 7: Практические сценарии
  {
    id: 31,
    question: "Когда стоит выбрать CSR вместо SSR?",
    options: [
      "Для e-commerce сайтов",
      "Для admin-панелей, дашбордов за авторизацией, где SEO не важен",
      "Для контент-сайтов",
      "Никогда, SSR всегда лучше"
    ],
    correctAnswer: 1,
    explanation: "CSR подходит для приложений за авторизацией (admin-панели, CRM, дашборды), где SEO не критично, а важна интерактивность. SSR добавляет сложность без явных преимуществ в таких случаях.",
    topic: "Практические сценарии"
  },
  {
    id: 32,
    question: "Как правильно обрабатывать редиректы при SSR?",
    options: [
      "Редиректы невозможны при SSR",
      "Сервер должен вернуть 301/302 код и Location header",
      "Использовать только клиентские редиректы",
      "Редиректы только через JavaScript"
    ],
    correctAnswer: 1,
    explanation: "При SSR сервер должен обрабатывать редиректы правильно: возвращать HTTP 301/302 статус с Location header. Это важно для SEO и корректной работы браузеров и ботов.",
    topic: "Практические сценарии"
  },
  {
    id: 33,
    question: "Как организовать data fetching при SSR?",
    options: [
      "Только на клиенте через useEffect",
      "На сервере перед рендером (getServerSideProps, loader functions)",
      "Data fetching невозможен при SSR",
      "Через localStorage"
    ],
    correctAnswer: 1,
    explanation: "При SSR данные загружаются на сервере перед рендером (Next.js: getServerSideProps, Remix: loader, SvelteKit: load). Данные передаются в компоненты и сериализуются для клиента.",
    topic: "Практические сценарии"
  },
  {
    id: 34,
    question: "Что делать с third-party скриптами (аналитика, реклама) при SSR?",
    options: [
      "Загружать их на сервере",
      "Добавлять скрипты только на клиенте через useEffect или Script компонент",
      "Third-party скрипты не работают с SSR",
      "Встраивать их в серверный HTML напрямую"
    ],
    correctAnswer: 1,
    explanation: "Third-party скрипты должны загружаться только на клиенте (useEffect, next/script). Многие из них требуют Browser API и не должны выполняться при серверном рендере.",
    topic: "Практические сценарии"
  },
  {
    id: 35,
    question: "Как тестировать SSR приложения?",
    options: [
      "Только unit тесты компонентов",
      "E2E тесты + интеграционные тесты серверного рендера с проверкой HTML",
      "Тестирование SSR невозможно",
      "Только ручное тестирование"
    ],
    correctAnswer: 1,
    explanation: "Для SSR важны: unit тесты компонентов, интеграционные тесты серверного рендера (проверка HTML output), E2E тесты полного флоу (Playwright, Cypress), тесты гидратации.",
    topic: "Практические сценарии"
  },

  // Тема 8: Оптимизация и мониторинг SSR
  {
    id: 36,
    question: "Какие метрики важно отслеживать при SSR?",
    options: [
      "Только время загрузки JavaScript",
      "TTFB, FCP, TTI, hydration time, server response time",
      "Только размер HTML",
      "Метрики не важны для SSR"
    ],
    correctAnswer: 1,
    explanation: "Ключевые метрики SSR: TTFB (время до первого байта), FCP (первая отрисовка), TTI (время до интерактивности), hydration time, server response time. Все они влияют на UX.",
    topic: "Оптимизация SSR"
  },
  {
    id: 37,
    question: "Как оптимизировать время серверного рендеринга?",
    options: [
      "Увеличить количество серверов",
      "Кеширование, code splitting, оптимизация запросов к БД, streaming SSR",
      "Использовать более медленный сервер",
      "Отказаться от SSR"
    ],
    correctAnswer: 1,
    explanation: "Оптимизация SSR: кеширование HTML, code splitting для уменьшения рендера, оптимизация БД запросов, streaming SSR, edge rendering, использование CDN.",
    topic: "Оптимизация SSR"
  },
  {
    id: 38,
    question: "Что такое 'Edge SSR' или 'Edge Rendering'?",
    options: [
      "Рендеринг на устройстве пользователя",
      "SSR на edge серверах CDN близко к пользователям",
      "Рендеринг только браузером Edge",
      "Устаревшая технология"
    ],
    correctAnswer: 1,
    explanation: "Edge SSR — это запуск SSR на edge серверах CDN (Cloudflare Workers, Vercel Edge Functions), расположенных близко к пользователям. Это снижает latency и ускоряет TTFB.",
    topic: "Оптимизация SSR"
  },
  {
    id: 39,
    question: "Как правильно масштабировать SSR приложение?",
    options: [
      "SSR не масштабируется",
      "Горизонтальное масштабирование серверов, load balancing, кеширование, edge rendering",
      "Только вертикальное масштабирование",
      "Отказаться от SSR при росте нагрузки"
    ],
    correctAnswer: 1,
    explanation: "Масштабирование SSR: горизонтальное добавление серверов за load balancer, агрессивное кеширование (CDN, Redis), edge rendering, мониторинг и автомасштабирование.",
    topic: "Оптимизация SSR"
  },
  {
    id: 40,
    question: "Какие инструменты помогают отладке SSR?",
    options: [
      "Только console.log",
      "React DevTools, Next.js Dev Tools, server logs, профилирование Node.js",
      "Отладка SSR невозможна",
      "Только Chrome DevTools"
    ],
    correctAnswer: 1,
    explanation: "Для отладки SSR: React/Vue DevTools (показывают hydration), Next.js Dev Tools, логирование на сервере, Node.js профилирование (--inspect), source maps для серверного кода.",
    topic: "Оптимизация SSR"
  },

  // Дополнительные вопросы по специфике SSR
  {
    id: 41,
    question: "Что такое 'flash of unstyled content' (FOUC) при SSR?",
    options: [
      "Ошибка JavaScript",
      "Мгновенное отображение нестилизованного контента до загрузки CSS",
      "Проблема с HTML",
      "Особенность всех сайтов"
    ],
    correctAnswer: 1,
    explanation: "FOUC — когда контент отображается без стилей до загрузки CSS. При SSR с CSS-in-JS важно внедрить критические стили в HTML, чтобы избежать FOUC.",
    topic: "Проблемы и решения"
  },
  {
    id: 42,
    question: "Как обрабатывать динамические meta-теги при SSR?",
    options: [
      "Meta-теги статичны при SSR",
      "Генерировать meta-теги на сервере на основе данных страницы",
      "Meta-теги обновляются только на клиенте",
      "SSR не поддерживает meta-теги"
    ],
    correctAnswer: 1,
    explanation: "При SSR meta-теги (title, description, Open Graph) генерируются на сервере на основе данных конкретной страницы. Фреймворки предоставляют API (Next.js Head, Nuxt useHead).",
    topic: "Проблемы и решения"
  },
  {
    id: 43,
    question: "Можно ли использовать WebSockets при SSR?",
    options: [
      "Нет, WebSockets не совместимы с SSR",
      "Да, WebSocket подключения устанавливаются на клиенте после гидратации",
      "WebSockets работают только на сервере",
      "SSR блокирует все сетевые соединения"
    ],
    correctAnswer: 1,
    explanation: "WebSocket подключения устанавливаются на клиенте (в useEffect после гидратации). SSR не мешает использовать WebSockets для реального времени, но само соединение клиентское.",
    topic: "Проблемы и решения"
  },
  {
    id: 44,
    question: "Как SSR влияет на bundle size?",
    options: [
      "SSR увеличивает bundle size вдвое",
      "SSR может увеличить размер из-за дублирования кода для сервера и клиента",
      "SSR уменьшает bundle size",
      "SSR не влияет на bundle size"
    ],
    correctAnswer: 1,
    explanation: "При SSR некоторый код может дублироваться для сервера и клиента. Однако с правильным code splitting и tree shaking можно минимизировать клиентский бандл, отправляя лишний код только на сервер.",
    topic: "Проблемы и решения"
  },
  {
    id: 45,
    question: "Что такое 'stale-while-revalidate' стратегия в контексте SSR?",
    options: [
      "Стратегия кеширования: показывать старые данные, обновляя в фоне",
      "Полное обновление данных при каждом запросе",
      "Отказ от кеширования",
      "Стратегия только для CSR"
    ],
    correctAnswer: 0,
    explanation: "SWR стратегия: пользователь получает кешированную версию мгновенно (stale), пока сервер генерирует свежую версию в фоне (revalidate). Баланс между скоростью и актуальностью.",
    topic: "Проблемы и решения"
  },
  {
    id: 46,
    question: "Как обрабатывать ошибки при SSR?",
    options: [
      "Ошибки игнорируются при SSR",
      "Сервер должен возвращать 500 статус и error page, логировать ошибки",
      "Все ошибки обрабатываются только на клиенте",
      "SSR не может содержать ошибок"
    ],
    correctAnswer: 1,
    explanation: "При ошибке в SSR сервер должен: вернуть HTTP 500, отрендерить error page, залогировать ошибку для мониторинга. Важно graceful degradation — fallback на CSR или статичную страницу.",
    topic: "Проблемы и решения"
  },
  {
    id: 47,
    question: "Что такое 'partial hydration'?",
    options: [
      "Гидратация всей страницы",
      "Гидратация только части компонентов, остальные остаются статичными",
      "Отсутствие гидратации",
      "Гидратация только CSS"
    ],
    correctAnswer: 1,
    explanation: "Partial hydration — техника, где гидратируются только интерактивные компоненты, остальные остаются статичным HTML. Это снижает JS бандл и ускоряет TTI.",
    topic: "Продвинутые техники"
  },
  {
    id: 48,
    question: "Как SSR сочетается с Progressive Web App (PWA)?",
    options: [
      "SSR и PWA несовместимы",
      "SSR для начальной загрузки, затем PWA кеширует и работает как CSR",
      "PWA заменяет SSR",
      "SSR работает только без PWA"
    ],
    correctAnswer: 1,
    explanation: "SSR и PWA отлично сочетаются: SSR обеспечивает быстрый FCP и SEO, затем Service Worker кеширует ресурсы и приложение работает как PWA с offline support.",
    topic: "Продвинутые техники"
  },
  {
    id: 49,
    question: "Что такое 'resumability' в контексте SSR?",
    options: [
      "Перезапуск сервера",
      "Способность продолжить выполнение приложения на клиенте без повторного выполнения серверного кода",
      "Возобновление прерванных запросов",
      "Только для мобильных приложений"
    ],
    correctAnswer: 1,
    explanation: "Resumability (Qwik framework) — подход, где приложение 'продолжается' на клиенте без повторного выполнения кода. Вместо гидратации, клиент просто 'подхватывает' состояние сервера.",
    topic: "Продвинутые техники"
  },
  {
    id: 50,
    question: "Какой главный trade-off при выборе SSR?",
    options: [
      "Нет никаких trade-offs",
      "Лучший UX и SEO, но сложность разработки и нагрузка на сервер",
      "SSR всегда хуже CSR",
      "Только технические сложности без преимуществ"
    ],
    correctAnswer: 1,
    explanation: "SSR trade-off: значительные преимущества (FCP, SEO, Social sharing) за счет повышенной сложности (hydration, Browser API, состояние), нагрузки на сервер и инфраструктурных затрат.",
    topic: "Выбор подхода"
  }
]
