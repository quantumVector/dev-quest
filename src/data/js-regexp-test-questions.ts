import type { Question } from '@/types/question.ts'

export const jsRegExpQuestions: Question[] = [
  // Тема 1: Основы RegExp
  {
    id: 1,
    question: "Что такое регулярное выражение в JavaScript?",
    options: [
      "Функция для работы со строками",
      "Паттерн для поиска и сопоставления текста",
      "Метод массива для фильтрации элементов",
      "Способ объявления переменных"
    ],
    correctAnswer: 1,
    explanation: "Регулярное выражение (RegExp) — это паттерн, который используется для поиска и сопоставления последовательностей символов в строках.",
    topic: "Основы RegExp"
  },
  {
    id: 2,
    question: "Какие способы создания регулярных выражений существуют в JavaScript?",
    options: [
      "Только литеральная запись /pattern/",
      "Только конструктор new RegExp()",
      "Литеральная запись /pattern/ и конструктор new RegExp()",
      "Только метод String.regexp()"
    ],
    correctAnswer: 2,
    explanation: "В JavaScript можно создавать регулярные выражения двумя способами: литеральной записью /pattern/flags и с помощью конструктора new RegExp('pattern', 'flags').",
    topic: "Основы RegExp"
  },
  {
    id: 3,
    question: "В чем разница между /pattern/ и new RegExp('pattern')?",
    options: [
      "Никакой разницы нет",
      "Литеральная форма компилируется при загрузке, конструктор — во время выполнения",
      "Конструктор работает быстрее",
      "Литеральная форма поддерживает больше флагов"
    ],
    correctAnswer: 1,
    explanation: "Литеральная форма /pattern/ компилируется во время загрузки скрипта, а new RegExp() — во время выполнения. Это делает литеральную форму быстрее для статических паттернов.",
    topic: "Основы RegExp"
  },
  {
    id: 4,
    question: "Что выведет этот код?\n\nconst regex = /hello/;\nconsole.log(regex.test('Hello world'));",
    options: [
      "true",
      "false",
      "Ошибка",
      "undefined"
    ],
    correctAnswer: 1,
    explanation: "Регулярное выражение /hello/ ищет точное совпадение 'hello' в нижнем регистре. 'Hello' с заглавной буквы не совпадает, поэтому результат false.",
    topic: "Основы RegExp"
  },
  {
    id: 5,
    question: "Какой метод проверяет, соответствует ли строка регулярному выражению?",
    options: [
      "regex.match()",
      "regex.test()",
      "regex.search()",
      "regex.find()"
    ],
    correctAnswer: 1,
    explanation: "Метод test() возвращает boolean значение: true, если строка соответствует паттерну, и false в противном случае.",
    topic: "Основы RegExp"
  },

  // Тема 2: Флаги регулярных выражений
  {
    id: 6,
    question: "Какие основные флаги существуют в JavaScript регулярных выражениях?",
    options: [
      "i, g, m",
      "i, g, m, s, u, y",
      "case, global, multi",
      "ignore, global, match"
    ],
    correctAnswer: 1,
    explanation: "Основные флаги: i (ignoreCase), g (global), m (multiline), s (dotAll), u (unicode), y (sticky).",
    topic: "Флаги RegExp"
  },
  {
    id: 7,
    question: "За что отвечает флаг 'g' в регулярных выражениях?",
    options: [
      "Игнорирование регистра",
      "Глобальный поиск всех совпадений",
      "Многострочный режим",
      "Группировка результатов"
    ],
    correctAnswer: 1,
    explanation: "Флаг 'g' (global) включает глобальный поиск, находя все совпадения в строке, а не только первое.",
    topic: "Флаги RegExp"
  },
  {
    id: 8,
    question: "Что произойдет без флага 'g' при использовании метода match()?",
    options: [
      "Найдутся все совпадения",
      "Найдется только первое совпадение",
      "Выдаст ошибку",
      "Вернет null"
    ],
    correctAnswer: 1,
    explanation: "Без флага 'g' метод match() находит только первое совпадение и возвращает массив с подробной информацией о нем.",
    topic: "Флаги RegExp"
  },
  {
    id: 9,
    question: "Что делает флаг 'm' (multiline)?",
    options: [
      "Позволяет использовать многострочные комментарии",
      "Делает ^ и $ совпадающими с началом/концом каждой строки",
      "Разрешает использование множественных паттернов",
      "Включает режим сопоставления нескольких строк одновременно"
    ],
    correctAnswer: 1,
    explanation: "Флаг 'm' изменяет поведение ^ и $, заставляя их совпадать с началом и концом каждой строки, а не только всего текста.",
    topic: "Флаги RegExp"
  },
  {
    id: 10,
    question: "Что выведет этот код?\n\nconst str = 'Hello\\nworld';\nconst regex = /^world/m;\nconsole.log(regex.test(str));",
    options: [
      "true",
      "false",
      "Ошибка",
      "undefined"
    ],
    correctAnswer: 0,
    explanation: "С флагом 'm' символ ^ совпадает с началом каждой строки. 'world' находится в начале второй строки, поэтому результат true.",
    topic: "Флаги RegExp"
  },
  {
    id: 11,
    question: "За что отвечает флаг 'u' (unicode)?",
    options: [
      "Поддержка Unicode символов и корректная работа с суррогатными парами",
      "Уникальный поиск без повторений",
      "Поиск в верхнем регистре",
      "Расширенный режим поиска"
    ],
    correctAnswer: 0,
    explanation: "Флаг 'u' включает полную поддержку Unicode, включая правильную обработку суррогатных пар для символов вне базовой многоязычной плоскости.",
    topic: "Флаги RegExp"
  },
  {
    id: 12,
    question: "Что делает флаг 'y' (sticky)?",
    options: [
      "Делает поиск 'липким' — начинает поиск с позиции lastIndex",
      "Сохраняет результаты предыдущих поисков",
      "Позволяет использовать переменные в паттерне",
      "Включает режим точного совпадения"
    ],
    correctAnswer: 0,
    explanation: "Флаг 'y' заставляет регулярное выражение искать совпадения строго с позиции lastIndex, не пропуская символы.",
    topic: "Флаги RegExp"
  },

  // Тема 3: Метасимволы и специальные конструкции
  {
    id: 13,
    question: "Что означает точка (.) в регулярных выражениях?",
    options: [
      "Любой символ",
      "Любой символ кроме символа новой строки",
      "Конец строки",
      "Любую цифру"
    ],
    correctAnswer: 1,
    explanation: "Точка (.) соответствует любому символу, кроме символа новой строки (\\n). С флагом 's' она будет соответствовать и символу новой строки.",
    topic: "Метасимволы"
  },
  {
    id: 14,
    question: "Что означает \\d в регулярных выражениях?",
    options: [
      "Любой символ",
      "Любую цифру (0-9)",
      "Любую букву",
      "Знак доллара"
    ],
    correctAnswer: 1,
    explanation: "\\d соответствует любой цифре от 0 до 9. Эквивалентно [0-9].",
    topic: "Метасимволы"
  },
  {
    id: 15,
    question: "Что означает \\s в регулярных выражениях?",
    options: [
      "Начало строки",
      "Любой пробельный символ",
      "Любую букву s",
      "Символ экранирования"
    ],
    correctAnswer: 1,
    explanation: "\\s соответствует любому пробельному символу: пробел, табуляция, перевод строки и другие Unicode пробелы.",
    topic: "Метасимволы"
  },
  {
    id: 16,
    question: "Что выведет этот код?\n\nconst regex = /\\w+/g;\nconst str = 'hello-world';\nconsole.log(str.match(regex));",
    options: [
      "['hello-world']",
      "['hello', 'world']",
      "['hello', '-', 'world']",
      "null"
    ],
    correctAnswer: 1,
    explanation: "\\w соответствует буквенно-цифровым символам и подчеркиванию. Дефис не включается, поэтому 'hello-world' разделится на ['hello', 'world'].",
    topic: "Метасимволы"
  },
  {
    id: 17,
    question: "Как экранировать специальные символы в регулярных выражениях?",
    options: [
      "С помощью одинарных кавычек",
      "С помощью обратного слеша \\",
      "С помощью двойных кавычек",
      "С помощью квадратных скобок"
    ],
    correctAnswer: 1,
    explanation: "Специальные символы экранируются обратным слешем \\. Например, \\. для поиска точки как литерального символа.",
    topic: "Метасимволы"
  },
  {
    id: 18,
    question: "Что означает конструкция [abc] в регулярных выражениях?",
    options: [
      "Последовательность символов abc",
      "Любой из символов a, b или c",
      "Символы a, b и c в любом порядке",
      "Группу символов abc"
    ],
    correctAnswer: 1,
    explanation: "Квадратные скобки [abc] создают символьный класс, который соответствует любому одному символу из указанных: a, b или c.",
    topic: "Метасимволы"
  },

  // Тема 4: Квантификаторы
  {
    id: 19,
    question: "Что означает квантификатор * в регулярных выражениях?",
    options: [
      "Один или более раз",
      "Ноль или более раз",
      "Ровно один раз",
      "Ноль или один раз"
    ],
    correctAnswer: 1,
    explanation: "Квантификатор * означает 'ноль или более раз'. Например, ab* найдет 'a', 'ab', 'abb', 'abbb' и т.д.",
    topic: "Квантификаторы"
  },
  {
    id: 20,
    question: "Что означает квантификатор + в регулярных выражениях?",
    options: [
      "Ноль или более раз",
      "Один или более раз",
      "Ровно один раз",
      "Ноль или один раз"
    ],
    correctAnswer: 1,
    explanation: "Квантификатор + означает 'один или более раз'. Например, ab+ найдет 'ab', 'abb', 'abbb', но не найдет 'a'.",
    topic: "Квантификаторы"
  },
  {
    id: 21,
    question: "Что означает квантификатор ? в регулярных выражениях?",
    options: [
      "Ноль или более раз",
      "Один или более раз",
      "Ноль или один раз",
      "Любое количество раз"
    ],
    correctAnswer: 2,
    explanation: "Квантификатор ? означает 'ноль или один раз' (опциональный элемент). Например, colou?r найдет и 'color', и 'colour'.",
    topic: "Квантификаторы"
  },
  {
    id: 22,
    question: "Что означает {3,5} в регулярном выражении /a{3,5}/?",
    options: [
      "От 3 до 5 любых символов",
      "Символ 'a' от 3 до 5 раз",
      "Ровно 3 или 5 символов 'a'",
      "Символ 'a' максимум 5 раз"
    ],
    correctAnswer: 1,
    explanation: "Конструкция {3,5} означает 'от 3 до 5 раз включительно'. /a{3,5}/ найдет 'aaa', 'aaaa' или 'aaaaa'.",
    topic: "Квантификаторы"
  },
  {
    id: 23,
    question: "В чем разница между жадными и ленивыми квантификаторами?",
    options: [
      "Жадные ищут минимальное совпадение, ленивые — максимальное",
      "Жадные ищут максимальное совпадение, ленивые — минимальное",
      "Никакой разницы нет",
      "Ленивые работают только с числовыми квантификаторами"
    ],
    correctAnswer: 1,
    explanation: "Жадные квантификаторы (*, +, {}) ищут максимально длинное совпадение, а ленивые (*?, +?, {}?) — минимально возможное.",
    topic: "Квантификаторы"
  },
  {
    id: 24,
    question: "Что найдет регулярное выражение /.+/ в строке 'abc def'?",
    options: [
      "'abc'",
      "'abc def'",
      "'a'",
      "['abc', 'def']"
    ],
    correctAnswer: 1,
    explanation: "Жадный квантификатор + в сочетании с . найдет максимально длинную последовательность символов, то есть всю строку 'abc def'.",
    topic: "Квантификаторы"
  },

  // Тема 5: Группы и захват
  {
    id: 25,
    question: "Для чего используются круглые скобки () в регулярных выражениях?",
    options: [
      "Только для группировки",
      "Только для захвата",
      "Для группировки и захвата",
      "Для комментариев"
    ],
    correctAnswer: 2,
    explanation: "Круглые скобки () используются для группировки элементов паттерна и одновременно для захвата (capturing) найденного текста.",
    topic: "Группы и захват"
  },
  {
    id: 26,
    question: "Что такое незахватывающая группа?",
    options: [
      "(?:pattern)",
      "(pattern)",
      "[pattern]",
      "{pattern}"
    ],
    correctAnswer: 0,
    explanation: "Незахватывающая группа (?:pattern) группирует элементы для применения квантификаторов, но не сохраняет результат для обратных ссылок.",
    topic: "Группы и захват"
  },
  {
    id: 27,
    question: "Что выведет этот код?\n\nconst regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nconst match = '2023-12-25'.match(regex);\nconsole.log(match[1]);",
    options: [
      "'2023-12-25'",
      "'2023'",
      "'12'",
      "'25'"
    ],
    correctAnswer: 1,
    explanation: "match[1] содержит результат первой захватывающей группы (\\d{4}), которая соответствует году '2023'.",
    topic: "Группы и захват"
  },
  {
    id: 28,
    question: "Как создать именованную группу захвата?",
    options: [
      "(?<name>pattern)",
      "(?name:pattern)",
      "(name:pattern)",
      "(?=name>pattern)"
    ],
    correctAnswer: 0,
    explanation: "Именованная группа создается синтаксисом (?<name>pattern). К результату можно обращаться через match.groups.name.",
    topic: "Группы и захват"
  },
  {
    id: 29,
    question: "Что означает \\1 в регулярном выражении?",
    options: [
      "Первый символ",
      "Обратная ссылка на первую группу захвата",
      "Один любой символ",
      "Первую позицию в строке"
    ],
    correctAnswer: 1,
    explanation: "\\1 — это обратная ссылка (backreference) на результат первой захватывающей группы, позволяющая искать повторяющиеся части.",
    topic: "Группы и захват"
  },
  {
    id: 30,
    question: "Что найдет регулярное выражение /(\\w+)\\s+\\1/?",
    options: [
      "Любое слово",
      "Два одинаковых слова подряд",
      "Два разных слова",
      "Слово с пробелом"
    ],
    correctAnswer: 1,
    explanation: "Это выражение найдет два одинаковых слова, разделенных пробелами, например 'word word' или 'test test'.",
    topic: "Группы и захват"
  }
]
