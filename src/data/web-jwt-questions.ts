import type { Question } from '@/types/question.ts'

export const webJWTQuestions: Question[] = [
  // Тема 1: Основы JWT
  {
    id: 1,
    question: "Что такое JWT (JSON Web Token)?",
    options: [
      "Протокол шифрования данных",
      "Стандарт для создания токенов доступа, содержащих JSON-данные",
      "База данных для хранения пользовательских сессий",
      "Библиотека для работы с JSON"
    ],
    correctAnswer: 1,
    explanation: "JWT (JSON Web Token) — это открытый стандарт (RFC 7519) для создания токенов доступа, которые содержат JSON-объект с утверждениями (claims). Токен подписывается с помощью секретного ключа или публично-приватной пары ключей.",
    topic: "Основы JWT"
  },
  {
    id: 2,
    question: "Для каких основных целей используется JWT?",
    options: [
      "Только для хранения данных в браузере",
      "Для аутентификации и обмена информацией между сторонами",
      "Только для шифрования пользовательских данных",
      "Для замены HTTP-протокола"
    ],
    correctAnswer: 1,
    explanation: "JWT используется для двух основных целей: 1) Аутентификация — после входа пользователя токен позволяет получать доступ к защищенным ресурсам. 2) Обмен информацией — JWT можно использовать для безопасной передачи информации между сторонами, так как токен подписан.",
    topic: "Основы JWT"
  },
  {
    id: 3,
    question: "Какое главное преимущество JWT перед традиционными сессиями?",
    options: [
      "JWT не требует хранения состояния на сервере (stateless)",
      "JWT работает быстрее всех других методов",
      "JWT автоматически шифрует все данные",
      "JWT не требует базы данных"
    ],
    correctAnswer: 0,
    explanation: "Главное преимущество JWT — это stateless аутентификация. Сервер не хранит информацию о токенах, вся необходимая информация содержится в самом токене. Это упрощает масштабирование и не требует синхронизации сессий между серверами.",
    topic: "Основы JWT"
  },
  {
    id: 4,
    question: "В каком формате передается JWT?",
    options: [
      "В виде XML-документа",
      "В виде зашифрованного бинарного файла",
      "В виде строки, состоящей из трех частей, разделенных точками",
      "В виде JSON-объекта"
    ],
    correctAnswer: 2,
    explanation: "JWT передается как компактная строка формата: xxxxx.yyyyy.zzzzz, где три части разделены точками. Каждая часть закодирована в Base64URL.",
    topic: "Основы JWT"
  },

  // Тема 2: Структура JWT
  {
    id: 5,
    question: "Из каких трех основных частей состоит JWT?",
    options: [
      "Header, Body, Footer",
      "Header, Payload, Signature",
      "Key, Value, Signature",
      "Type, Data, Hash"
    ],
    correctAnswer: 1,
    explanation: "JWT состоит из трех частей: Header (заголовок с метаданными о токене), Payload (полезная нагрузка с данными пользователя), Signature (подпись для проверки целостности).",
    topic: "Структура JWT"
  },
  {
    id: 6,
    question: "Что содержится в Header (заголовке) JWT?",
    options: [
      "Данные пользователя и его роли",
      "Тип токена и алгоритм шифрования/подписи",
      "Секретный ключ для проверки",
      "Время истечения токена"
    ],
    correctAnswer: 1,
    explanation: "Header содержит метаданные о токене: тип (обычно 'JWT') и алгоритм подписи (например, 'HS256' или 'RS256'). Пример: { 'alg': 'HS256', 'typ': 'JWT' }",
    topic: "Структура JWT"
  },
  {
    id: 7,
    question: "Что содержится в Payload (полезной нагрузке) JWT?",
    options: [
      "Только идентификатор пользователя",
      "Claims (утверждения) — данные о пользователе и метаданные токена",
      "Пароль пользователя",
      "Секретный ключ"
    ],
    correctAnswer: 1,
    explanation: "Payload содержит claims (утверждения) — наборы данных о пользователе и метаданные. Существуют зарегистрированные claims (iss, exp, sub, aud), публичные и приватные claims.",
    topic: "Структура JWT"
  },
  {
    id: 8,
    question: "Что такое 'exp' claim в JWT?",
    options: [
      "Имя пользователя (expression)",
      "Время истечения токена (expiration time)",
      "Уровень опыта пользователя (experience)",
      "Экспериментальная функция"
    ],
    correctAnswer: 1,
    explanation: "'exp' (expiration time) — это зарегистрированный claim, который указывает время истечения токена в формате Unix timestamp. После этого времени токен считается недействительным.",
    topic: "Структура JWT"
  },
  {
    id: 9,
    question: "Для чего нужна Signature (подпись) в JWT?",
    options: [
      "Для шифрования данных в токене",
      "Для проверки целостности токена и подтверждения отправителя",
      "Для красивого форматирования токена",
      "Для сжатия размера токена"
    ],
    correctAnswer: 1,
    explanation: "Signature создается путем подписи закодированных header и payload с использованием секретного ключа. Она позволяет проверить, что токен не был изменен, и подтвердить отправителя (если используется асимметричное шифрование).",
    topic: "Структура JWT"
  },
  {
    id: 10,
    question: "Зашифрованы ли данные в Header и Payload JWT?",
    options: [
      "Да, они полностью зашифрованы",
      "Нет, они только закодированы в Base64URL и легко декодируются",
      "Зашифрован только Payload",
      "Зашифрован только Header"
    ],
    correctAnswer: 1,
    explanation: "Header и Payload только закодированы в Base64URL, но НЕ зашифрованы. Любой может декодировать и прочитать содержимое. Поэтому в JWT нельзя хранить чувствительные данные (пароли, номера карт). Для шифрования используют JWE (JSON Web Encryption).",
    topic: "Структура JWT"
  },

  // Тема 3: Механизм работы JWT аутентификации
  {
    id: 11,
    question: "Как происходит первоначальная аутентификация пользователя с JWT?",
    options: [
      "Пользователь отправляет JWT серверу для проверки",
      "Пользователь отправляет логин/пароль, сервер создает и возвращает JWT",
      "JWT создается автоматически в браузере",
      "Сервер заранее генерирует JWT для всех пользователей"
    ],
    correctAnswer: 1,
    explanation: "Процесс: 1) Пользователь отправляет credentials (логин/пароль) на сервер. 2) Сервер проверяет credentials. 3) При успехе сервер создает JWT с данными пользователя и возвращает клиенту. 4) Клиент сохраняет токен для последующих запросов.",
    topic: "Механизм работы"
  },
  {
    id: 12,
    question: "Как клиент использует JWT для доступа к защищенным ресурсам?",
    options: [
      "Отправляет токен в теле каждого запроса",
      "Отправляет токен в заголовке Authorization: Bearer <token>",
      "Сохраняет токен в URL",
      "Токен автоматически добавляется браузером"
    ],
    correctAnswer: 1,
    explanation: "После получения JWT клиент добавляет его в заголовок Authorization каждого запроса в формате: 'Authorization: Bearer <token>'. Сервер извлекает токен, проверяет подпись и предоставляет доступ.",
    topic: "Механизм работы"
  },
  {
    id: 13,
    question: "Как сервер проверяет валидность JWT?",
    options: [
      "Проверяет токен в базе данных",
      "Проверяет подпись с помощью секретного ключа и срок действия",
      "Отправляет токен в auth-сервис",
      "Сравнивает с сохраненной копией токена"
    ],
    correctAnswer: 1,
    explanation: "Сервер проверяет JWT следующим образом: 1) Извлекает header и payload. 2) Пересоздает подпись используя секретный ключ. 3) Сравнивает полученную подпись с подписью в токене. 4) Проверяет срок действия (exp claim). Если все проверки пройдены — токен валиден.",
    topic: "Механизм работы"
  },
  {
    id: 14,
    question: "Что происходит когда истекает срок действия JWT?",
    options: [
      "Токен автоматически обновляется",
      "Токен становится невалидным, требуется повторная аутентификация или refresh token",
      "Пользователь может продолжать использовать токен",
      "Сервер автоматически продлевает токен"
    ],
    correctAnswer: 1,
    explanation: "После истечения срока (exp) токен становится невалидным. Сервер отклонит запросы с таким токеном. Решения: 1) Пользователь заново входит в систему. 2) Используется refresh token для получения нового access token без повторного ввода credentials.",
    topic: "Механизм работы"
  },
  {
    id: 15,
    question: "Что такое Refresh Token в контексте JWT?",
    options: [
      "Резервная копия access token",
      "Долгоживущий токен для получения новых access token без повторной аутентификации",
      "Токен для обновления данных пользователя",
      "Альтернативное название для JWT"
    ],
    correctAnswer: 1,
    explanation: "Refresh Token — это долгоживущий токен, который хранится безопасно и используется только для получения новых access token. Когда access token истекает, клиент отправляет refresh token серверу, который выдает новый access token. Это повышает безопасность: access token короткоживущий, но не нужно постоянно вводить пароль.",
    topic: "Механизм работы"
  },

  // Тема 4: JWT vs традиционные сессии
  {
    id: 16,
    question: "Чем JWT отличается от традиционной сессионной аутентификации?",
    options: [
      "JWT быстрее работает",
      "JWT не требует хранения состояния на сервере (stateless)",
      "JWT более безопасен",
      "JWT работает только с HTTPS"
    ],
    correctAnswer: 1,
    explanation: "Ключевое отличие: JWT — stateless (без состояния на сервере), вся информация в токене. Сессии — stateful (сервер хранит данные сессии), клиент получает только ID сессии. JWT упрощает масштабирование, но сложнее отзывать токены.",
    topic: "JWT vs Сессии"
  },
  {
    id: 17,
    question: "Где хранятся данные при использовании традиционных сессий?",
    options: [
      "Только на клиенте в cookies",
      "На сервере (в памяти, БД, Redis), клиент хранит только session ID",
      "Данные не хранятся",
      "В JWT токене"
    ],
    correctAnswer: 1,
    explanation: "При сессионной аутентификации сервер создает сессию и хранит данные пользователя на сервере (в памяти, БД, Redis). Клиенту отправляется только session ID (обычно в cookie). При каждом запросе сервер находит сессию по ID.",
    topic: "JWT vs Сессии"
  },
  {
    id: 18,
    question: "Какая проблема возникает при масштабировании с традиционными сессиями?",
    options: [
      "Сессии работают медленно",
      "Нужна синхронизация сессий между серверами или sticky sessions",
      "Сессии занимают слишком много памяти",
      "Сессии несовместимы с HTTPS"
    ],
    correctAnswer: 1,
    explanation: "При горизонтальном масштабировании (несколько серверов) возникает проблема: сессия создана на сервере A, но следующий запрос попал на сервер B, где этой сессии нет. Решения: 1) Sticky sessions (привязка к одному серверу). 2) Shared storage (Redis). 3) JWT не имеет этой проблемы.",
    topic: "JWT vs Сессии"
  },
  {
    id: 19,
    question: "Как можно отозвать (revoke) токен JWT до истечения его срока действия?",
    options: [
      "JWT нельзя отозвать, это основной недостаток",
      "Можно вести черный список (blacklist) отозванных токенов, но это усложняет систему",
      "Токен отзывается автоматически",
      "Достаточно удалить токен на клиенте"
    ],
    correctAnswer: 1,
    explanation: "Отзыв JWT — сложная задача из-за stateless природы. Решения: 1) Blacklist — хранить отозванные токены на сервере (теряется stateless). 2) Короткий срок жизни access token + refresh token. 3) Проверка версии токена в БД. Сессии легче отзываются — достаточно удалить запись на сервере.",
    topic: "JWT vs Сессии"
  },
  {
    id: 20,
    question: "Какой метод лучше выбрать: JWT или сессии?",
    options: [
      "JWT всегда лучше",
      "Сессии всегда лучше",
      "Зависит от требований: JWT для stateless API и микросервисов, сессии для монолитов с частым отзывом",
      "Нет разницы"
    ],
    correctAnswer: 2,
    explanation: "Выбор зависит от требований: JWT лучше для: stateless API, микросервисы, мобильные приложения, масштабирование. Сессии лучше для: монолитных приложений, когда нужен частый отзыв доступа, меньше данных передается. Часто используют гибридный подход.",
    topic: "JWT vs Сессии"
  },

  // Тема 5: Безопасность JWT
  {
    id: 21,
    question: "Где безопаснее хранить JWT на стороне клиента?",
    options: [
      "В localStorage",
      "В sessionStorage",
      "В httpOnly cookie",
      "В переменной JavaScript"
    ],
    correctAnswer: 2,
    explanation: "Самое безопасное место — httpOnly cookie с флагами Secure и SameSite. httpOnly защищает от XSS (JavaScript не может прочитать), Secure — передача только через HTTPS, SameSite — защита от CSRF. localStorage/sessionStorage уязвимы к XSS атакам.",
    topic: "Безопасность JWT"
  },
  {
    id: 22,
    question: "Какие чувствительные данные НЕЛЬЗЯ хранить в JWT?",
    options: [
      "ID пользователя",
      "Пароли, номера кредитных карт, приватные ключи",
      "Email пользователя",
      "Роли пользователя"
    ],
    correctAnswer: 1,
    explanation: "В JWT НЕЛЬЗЯ хранить чувствительные данные: пароли, номера карт, токены сторонних сервисов, приватные ключи. JWT только подписан, но НЕ зашифрован — любой может декодировать Base64 и прочитать содержимое. Храните только неконфиденциальную информацию.",
    topic: "Безопасность JWT"
  },
  {
    id: 23,
    question: "Как защититься от XSS атак при использовании JWT?",
    options: [
      "Хранить токен только в httpOnly cookie, санитизировать ввод пользователя",
      "Использовать короткий срок жизни токена",
      "Шифровать токен",
      "Отправлять токен только по HTTPS"
    ],
    correctAnswer: 0,
    explanation: "Защита от XSS: 1) Хранить JWT в httpOnly cookie (недоступен для JavaScript). 2) Санитизировать весь пользовательский ввод. 3) Content Security Policy (CSP). 4) Использовать современные фреймворки с защитой от XSS. Если токен в localStorage — злоумышленник может украсть его через XSS.",
    topic: "Безопасность JWT"
  },
  {
    id: 24,
    question: "Как защититься от CSRF атак при использовании JWT в cookie?",
    options: [
      "Использовать длинный срок жизни токена",
      "Использовать SameSite cookie атрибут и CSRF токены",
      "Хранить токен в localStorage",
      "Шифровать токен"
    ],
    correctAnswer: 1,
    explanation: "Защита от CSRF при JWT в cookie: 1) SameSite=Strict или Lax cookie атрибут. 2) CSRF токены для критичных операций. 3) Проверка origin/referer заголовков. 4) Double submit cookie pattern. Если JWT в Authorization header (не в cookie) — CSRF не проблема.",
    topic: "Безопасность JWT"
  },
  {
    id: 25,
    question: "Почему важно использовать HTTPS при работе с JWT?",
    options: [
      "JWT не работает без HTTPS",
      "HTTPS предотвращает перехват токена в transit (MITM атаки)",
      "HTTPS ускоряет работу JWT",
      "HTTPS автоматически шифрует JWT"
    ],
    correctAnswer: 1,
    explanation: "HTTPS критически важен для JWT, так как: 1) Предотвращает перехват токена при передаче (Man-in-the-middle атаки). 2) JWT не зашифрован, поэтому без HTTPS злоумышленник может прочитать и украсть токен из сетевого трафика. Всегда используйте HTTPS в production.",
    topic: "Безопасность JWT"
  },
  {
    id: 26,
    question: "Что такое JWT jti claim и для чего он используется?",
    options: [
      "JWT тип (JWT type)",
      "JWT ID — уникальный идентификатор токена для отзыва и отслеживания",
      "JWT время создания",
      "JWT имя пользователя"
    ],
    correctAnswer: 1,
    explanation: "jti (JWT ID) — это уникальный идентификатор токена. Используется для: 1) Отзыва конкретного токена (добавление jti в blacklist). 2) Предотвращения replay атак. 3) Отслеживания использования токенов. Хотя добавляет stateful элемент, помогает с безопасностью.",
    topic: "Безопасность JWT"
  },

  // Тема 6: Алгоритмы подписи
  {
    id: 27,
    question: "Какие две основные категории алгоритмов используются для подписи JWT?",
    options: [
      "Быстрые и медленные",
      "Симметричные (HMAC) и асимметричные (RSA, ECDSA)",
      "Шифрующие и дешифрующие",
      "Публичные и приватные"
    ],
    correctAnswer: 1,
    explanation: "Алгоритмы подписи JWT делятся на: 1) Симметричные (HMAC: HS256, HS384, HS512) — используют один секретный ключ для создания и проверки подписи. 2) Асимметричные (RSA: RS256, RS512; ECDSA: ES256, ES512) — используют приватный ключ для подписи, публичный для проверки.",
    topic: "Алгоритмы подписи"
  },
  {
    id: 28,
    question: "Что такое HMAC и как он работает в контексте JWT?",
    options: [
      "Протокол передачи данных",
      "Hash-based Message Authentication Code — симметричный алгоритм с общим секретным ключом",
      "Тип базы данных",
      "Формат хранения токенов"
    ],
    correctAnswer: 1,
    explanation: "HMAC (Hash-based Message Authentication Code) — симметричный алгоритм. Использует один секретный ключ для создания и проверки подписи. Пример: HS256 = HMAC + SHA256. Ключ должен храниться в секрете и на клиенте, и на сервере. Простой, быстрый, но ключ должен быть на обеих сторонах.",
    topic: "Алгоритмы подписи"
  },
  {
    id: 29,
    question: "В чем преимущество асимметричных алгоритмов (RSA, ECDSA) для JWT?",
    options: [
      "Они быстрее работают",
      "Приватный ключ для подписи, публичный для проверки — безопаснее для распределенных систем",
      "Они создают более короткие токены",
      "Они не требуют ключей"
    ],
    correctAnswer: 1,
    explanation: "Преимущество RSA/ECDSA: 1) Приватный ключ только на auth-сервере (создание JWT). 2) Публичный ключ на всех сервисах (проверка JWT). 3) Публичный ключ можно безопасно распространять. 4) Идеально для микросервисов: auth-сервис подписывает, остальные проверяют без доступа к приватному ключу.",
    topic: "Алгоритмы подписи"
  },
  {
    id: 30,
    question: "Что такое алгоритм 'none' в JWT и почему его опасно использовать?",
    options: [
      "Самый безопасный алгоритм",
      "Алгоритм, который не использует подпись — уязвим к подделке токенов",
      "Алгоритм по умолчанию",
      "Алгоритм для тестирования"
    ],
    correctAnswer: 1,
    explanation: "Алгоритм 'none' означает отсутствие подписи. Это ОПАСНО: 1) Любой может создать или изменить токен без проверки. 2) Существуют атаки, где злоумышленник меняет 'alg' на 'none'. 3) Всегда явно проверяйте алгоритм на сервере и отклоняйте 'none'. Используйте только в development для отладки.",
    topic: "Алгоритмы подписи"
  },
  {
    id: 31,
    question: "Какой алгоритм рекомендуется использовать для JWT в большинстве случаев?",
    options: [
      "none",
      "HS256 для простых случаев, RS256 для микросервисов и публичных API",
      "MD5",
      "Любой алгоритм одинаково безопасен"
    ],
    correctAnswer: 1,
    explanation: "Рекомендации: 1) HS256 (HMAC + SHA256) — для простых приложений, где клиент и сервер доверяют друг другу. 2) RS256 (RSA + SHA256) — для микросервисов, публичных API, когда нужно раздавать публичный ключ. 3) ES256 (ECDSA + SHA256) — более производительная альтернатива RSA с меньшими ключами.",
    topic: "Алгоритмы подписи"
  },
  {
    id: 32,
    question: "Что произойдет, если злоумышленник изменит payload JWT и отправит на сервер?",
    options: [
      "Сервер примет измененные данные",
      "Проверка подписи не пройдет, сервер отклонит токен",
      "Токен автоматически восстановится",
      "Ничего не произойдет"
    ],
    correctAnswer: 1,
    explanation: "При изменении payload подпись станет невалидной. Сервер: 1) Извлечет header и payload. 2) Пересоздаст подпись с секретным ключом. 3) Сравнит с подписью в токене. 4) Подписи не совпадут → токен отклонен. Подпись защищает от изменений. Для изменения нужен секретный ключ.",
    topic: "Алгоритмы подписи"
  },

  // Тема 7: Лучшие практики и edge cases
  {
    id: 33,
    question: "Какой оптимальный срок жизни для access token JWT?",
    options: [
      "1 год",
      "15-30 минут для access token, несколько дней/недель для refresh token",
      "1 минута",
      "Бессрочный"
    ],
    correctAnswer: 1,
    explanation: "Рекомендации: 1) Access token: 15-30 минут (короткий срок снижает риск при компрометации). 2) Refresh token: несколько дней или недель. 3) Баланс: короткий access token безопаснее, но требует частого обновления. Refresh token хранится безопаснее и используется реже.",
    topic: "Лучшие практики"
  },
  {
    id: 34,
    question: "Что такое token rotation и зачем он нужен?",
    options: [
      "Изменение порядка токенов",
      "Обновление refresh token при каждом использовании для повышения безопасности",
      "Поворот изображения токена",
      "Удаление старых токенов"
    ],
    correctAnswer: 1,
    explanation: "Token rotation — при использовании refresh token для получения нового access token выдается также НОВЫЙ refresh token (старый становится невалидным). Это: 1) Снижает риск при утечке refresh token. 2) Ограничивает время жизни украденного токена. 3) Позволяет отследить подозрительную активность.",
    topic: "Лучшие практики"
  },
  {
    id: 35,
    question: "Можно ли использовать один JWT для аутентификации в разных сервисах (SSO)?",
    options: [
      "Нет, нужен отдельный токен для каждого сервиса",
      "Да, JWT идеально подходит для Single Sign-On между сервисами",
      "Да, но только с HMAC",
      "Нет, JWT не поддерживает SSO"
    ],
    correctAnswer: 1,
    explanation: "JWT отлично подходит для SSO (Single Sign-On): 1) Пользователь логинится один раз. 2) Получает JWT с claims для доступа ко всем сервисам. 3) Каждый сервис проверяет подпись JWT (с публичным ключом при RSA). 4) Claim 'aud' (audience) указывает для каких сервисов токен валиден. Важна правильная настройка безопасности.",
    topic: "Лучшие практики"
  },
  {
    id: 36,
    question: "Что нужно делать при компрометации секретного ключа JWT?",
    options: [
      "Ничего, ключ защищен",
      "Немедленно сменить ключ, инвалидировать все токены, заставить пользователей заново войти",
      "Подождать пока токены истекут",
      "Только сменить ключ"
    ],
    correctAnswer: 1,
    explanation: "При компрометации ключа: 1) НЕМЕДЛЕННО сменить секретный ключ. 2) Инвалидировать все активные токены (через blacklist или версионирование). 3) Заставить всех пользователей заново аутентифицироваться. 4) Расследовать причину утечки. 5) Уведомить пользователей. 6) Ротация ключей должна быть в disaster recovery плане.",
    topic: "Лучшие практики"
  },
  {
    id: 37,
    question: "Стоит ли добавлять много данных в JWT payload?",
    options: [
      "Да, чем больше данных, тем лучше",
      "Нет, JWT должен быть компактным — большой payload увеличивает размер каждого запроса",
      "Размер не имеет значения",
      "Можно добавлять любое количество данных"
    ],
    correctAnswer: 1,
    explanation: "JWT должен быть компактным: 1) Токен передается в каждом запросе (увеличивает трафик). 2) Большой токен → медленнее запросы. 3) Включайте только необходимое: user ID, роли, permissions. 4) Детальные данные запрашивайте отдельно. 5) Рекомендация: payload < 1-2 KB. Большой payload = antipattern.",
    topic: "Лучшие практики"
  },
  {
    id: 38,
    question: "Что такое JWT claim 'aud' (audience) и зачем он нужен?",
    options: [
      "Количество аудитории пользователей",
      "Указывает для какого сервиса/приложения предназначен токен — предотвращает использование токена в неправильном контексте",
      "Аудиозапись токена",
      "Уровень доступа пользователя"
    ],
    correctAnswer: 1,
    explanation: "'aud' (audience) определяет получателя токена (сервис/приложение). Защита: 1) Токен для API A не сработает на API B. 2) Предотвращает token reuse атаки. 3) Каждый сервис проверяет, что он указан в 'aud'. 4) Можно указать несколько получателей: ['api.example.com', 'admin.example.com'].",
    topic: "Лучшие практики"
  },
  {
    id: 39,
    question: "Нужно ли логировать попытки использования невалидных JWT на сервере?",
    options: [
      "Нет, это не важно",
      "Да, это важно для обнаружения атак и проблем с аутентификацией",
      "Только в development",
      "Только для debug режима"
    ],
    correctAnswer: 1,
    explanation: "Логирование невалидных JWT критично: 1) Обнаружение попыток взлома (измененные токены, bruteforce). 2) Выявление проблем с ротацией ключей. 3) Отслеживание истекших токенов (может быть проблема с refresh flow). 4) Monitoring и алерты при всплесках невалидных токенов. 5) Помогает в forensic анализе.",
    topic: "Лучшие практики"
  },
  {
    id: 40,
    question: "Можно ли обновить данные в уже выданном JWT?",
    options: [
      "Да, токен можно изменить",
      "Нет, JWT immutable после создания — нужно выдать новый токен",
      "Да, но только на сервере",
      "Да, через специальный API"
    ],
    correctAnswer: 1,
    explanation: "JWT immutable (неизменяемый) после создания: 1) Изменение payload сломает подпись. 2) Для обновления данных нужно выдать НОВЫЙ токен. 3) Решения: а) Короткий срок жизни — данные быстро обновятся. б) Использовать claims для версионирования. в) При критичных изменениях (роли, права) — инвалидировать старые токены. г) Храните volatile данные вне JWT.",
    topic: "Лучшие практики"
  }
]
