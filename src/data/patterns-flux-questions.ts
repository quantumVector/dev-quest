import type { Question } from '@/types/question.ts'

export const patternsFluxQuestions: Question[] = [
  {
    id: 1,
    question: "Какую основную проблему решает архитектура Flux?",
    options: [
      "Медленную загрузку приложения",
      "Сложность управления состоянием в больших приложениях с двунаправленным потоком данных",
      "Отсутствие типизации в JavaScript",
      "Проблемы с CSS изоляцией"
    ],
    correctAnswer: 1,
    explanation: "Flux решает проблему сложности управления состоянием в приложениях, где двунаправленный поток данных (two-way data binding) приводит к непредсказуемым изменениям состояния и затрудняет отладку. Flux вводит однонаправленный поток данных, делая изменения состояния предсказуемыми.",
    topic: "Основы Flux"
  },
  {
    id: 2,
    question: "Какие основные компоненты включает архитектура Flux?",
    options: [
      "Model, View, Controller",
      "Actions, Dispatcher, Stores, Views",
      "Services, Controllers, Models",
      "Components, Props, State"
    ],
    correctAnswer: 1,
    explanation: "Flux состоит из четырех основных компонентов: Actions (действия), Dispatcher (диспетчер), Stores (хранилища) и Views (представления). Каждый компонент имеет четко определенную роль в архитектуре.",
    topic: "Основы Flux"
  },
  {
    id: 3,
    question: "Что такое Action в архитектуре Flux?",
    options: [
      "Функция, которая изменяет состояние напрямую",
      "Объект, описывающий намерение изменить состояние приложения",
      "Класс для управления бизнес-логикой",
      "Компонент для отображения UI"
    ],
    correctAnswer: 1,
    explanation: "Action - это простой объект, который описывает намерение изменить состояние. Обычно содержит тип действия (type) и полезную нагрузку (payload). Например: { type: 'ADD_TODO', payload: { text: 'Learn Flux' } }.",
    topic: "Основы Flux"
  },
  {
    id: 4,
    question: "Какова роль Dispatcher в архитектуре Flux?",
    options: [
      "Хранение состояния приложения",
      "Отображение UI компонентов",
      "Центральный координатор, который распределяет actions всем stores",
      "Валидация данных пользователя"
    ],
    correctAnswer: 2,
    explanation: "Dispatcher - это центральный координатор (singleton), который получает actions и распределяет их всем зарегистрированным stores. Он гарантирует, что все stores получат action в правильном порядке.",
    topic: "Основы Flux"
  },
  {
    id: 5,
    question: "Что такое Store в архитектуре Flux?",
    options: [
      "База данных для хранения информации",
      "Контейнер состояния и бизнес-логики для определенной части приложения",
      "UI компонент для отображения списков",
      "Функция для отправки HTTP запросов"
    ],
    correctAnswer: 1,
    explanation: "Store - это контейнер, который хранит состояние приложения и содержит бизнес-логику. Store регистрируется в Dispatcher, получает actions, обновляет свое состояние и уведомляет Views об изменениях через events.",
    topic: "Основы Flux"
  },
  {
    id: 6,
    question: "Как работает однонаправленный поток данных в Flux?",
    options: [
      "View → Action → Store → Dispatcher → View",
      "Action → Dispatcher → Store → View",
      "Store → View → Action → Dispatcher",
      "Dispatcher → Action → View → Store"
    ],
    correctAnswer: 1,
    explanation: "Однонаправленный поток данных в Flux: Action (создается) → Dispatcher (распределяет) → Store (обновляет состояние) → View (обновляется). Данные движутся только в одном направлении, что делает поток данных предсказуемым.",
    topic: "Однонаправленный поток данных"
  },
  {
    id: 7,
    question: "Может ли View напрямую изменить состояние в Store?",
    options: [
      "Да, через методы setState",
      "Нет, только через создание Action",
      "Да, но только в dev режиме",
      "Да, если это root компонент"
    ],
    correctAnswer: 1,
    explanation: "View не может напрямую изменять состояние Store. Единственный способ изменить состояние - создать Action, который пройдет через Dispatcher в Store. Это обеспечивает однонаправленный поток данных.",
    topic: "Однонаправленный поток данных"
  },
  {
    id: 8,
    question: "Что происходит, когда Store обновляет свое состояние?",
    options: [
      "Store автоматически обновляет DOM",
      "Store отправляет новый Action",
      "Store излучает событие изменения (change event), на которое подписаны Views",
      "Store вызывает метод render() у всех компонентов"
    ],
    correctAnswer: 2,
    explanation: "После обновления состояния Store излучает событие изменения (change event). Views, подписанные на это событие, получают уведомление и запрашивают новое состояние у Store для обновления UI.",
    topic: "Однонаправленный поток данных"
  },
  {
    id: 9,
    question: "Почему в Flux нельзя отправлять Action из Store?",
    options: [
      "Это технически невозможно реализовать",
      "Это нарушит однонаправленный поток данных и создаст каскадные обновления",
      "Store не имеет доступа к Dispatcher",
      "Это замедлит работу приложения"
    ],
    correctAnswer: 1,
    explanation: "Отправка Action из Store нарушает однонаправленный поток данных и может привести к каскадным обновлениям и непредсказуемому поведению. Store должен только реагировать на Actions, но не создавать их.",
    topic: "Однонаправленный поток данных"
  },
  {
    id: 10,
    question: "Какое преимущество дает однонаправленный поток данных?",
    options: [
      "Более быструю производительность",
      "Меньший размер bundle",
      "Предсказуемость изменений состояния и упрощение отладки",
      "Автоматическую оптимизацию кода"
    ],
    correctAnswer: 2,
    explanation: "Однонаправленный поток данных делает изменения состояния предсказуемыми: всегда понятно, откуда пришло изменение и как оно распространяется. Это значительно упрощает отладку и понимание работы приложения.",
    topic: "Однонаправленный поток данных"
  },
  {
    id: 11,
    question: "Что такое Action Creator в Flux?",
    options: [
      "Функция, которая создает и отправляет Action в Dispatcher",
      "Класс для валидации Actions",
      "Компонент для отображения форм",
      "Middleware для обработки асинхронных операций"
    ],
    correctAnswer: 0,
    explanation: "Action Creator - это функция, которая создает объект Action и отправляет его в Dispatcher. Это помогает инкапсулировать логику создания Actions и делает код более переиспользуемым. Например: function addTodo(text) { dispatcher.dispatch({ type: 'ADD_TODO', payload: { text } }); }",
    topic: "Передача данных в Flux"
  },
  {
    id: 12,
    question: "Как Views получают данные из Store?",
    options: [
      "Напрямую обращаясь к свойствам Store",
      "Через props от родительского компонента",
      "Подписываясь на события Store и вызывая его getter методы",
      "Через глобальную переменную window"
    ],
    correctAnswer: 2,
    explanation: "Views подписываются на события изменения Store (обычно 'change' event). При получении события View вызывает getter методы Store (например, getState()) для получения актуального состояния и обновления UI.",
    topic: "Передача данных в Flux"
  },
  {
    id: 13,
    question: "Можно ли иметь несколько Dispatcher в Flux приложении?",
    options: [
      "Да, по одному на каждый Store",
      "Нет, Dispatcher должен быть singleton (один экземпляр)",
      "Да, но только в больших приложениях",
      "Зависит от выбранной реализации Flux"
    ],
    correctAnswer: 1,
    explanation: "В классической архитектуре Flux Dispatcher - это singleton, то есть существует в единственном экземпляре для всего приложения. Это обеспечивает централизованное управление потоком данных и правильную последовательность обновлений.",
    topic: "Передача данных в Flux"
  },
  {
    id: 14,
    question: "Что такое waitFor() в Dispatcher?",
    options: [
      "Метод для задержки выполнения Action",
      "Метод для управления зависимостями между Stores при обработке Action",
      "Асинхронная функция для HTTP запросов",
      "Timeout функция для отложенных Actions"
    ],
    correctAnswer: 1,
    explanation: "waitFor() - это метод Dispatcher, который позволяет одному Store дождаться обновления других Stores перед обработкой Action. Это необходимо, когда один Store зависит от данных другого Store. Например: dispatcher.waitFor([OtherStore.dispatchToken]).",
    topic: "Передача данных в Flux"
  },
  {
    id: 15,
    question: "Как обрабатываются асинхронные операции в Flux?",
    options: [
      "Напрямую в Store",
      "В Action Creators, с отправкой Actions до и после асинхронной операции",
      "В Dispatcher через middleware",
      "Асинхронные операции не поддерживаются"
    ],
    correctAnswer: 1,
    explanation: "Асинхронные операции (например, API запросы) выполняются в Action Creators. Обычно отправляется Action перед началом операции (LOADING), затем после успеха (SUCCESS) или ошибки (ERROR). Store реагирует на эти Actions и обновляет состояние соответственно.",
    topic: "Передача данных в Flux"
  },
  {
    id: 16,
    question: "Чем Flux отличается от MVC?",
    options: [
      "Ничем, это одно и то же",
      "В Flux однонаправленный поток данных, в MVC двунаправленный",
      "MVC используется только для backend",
      "Flux быстрее работает"
    ],
    correctAnswer: 1,
    explanation: "Ключевое отличие: Flux использует однонаправленный поток данных (unidirectional data flow), а MVC часто использует двунаправленный (two-way data binding). Во Flux данные идут только в одном направлении: Action → Dispatcher → Store → View, что делает поток данных более предсказуемым.",
    topic: "Сравнение с другими архитектурами"
  },
  {
    id: 17,
    question: "Может ли одно приложение иметь несколько Stores?",
    options: [
      "Нет, должен быть только один Store",
      "Да, каждый Store отвечает за свою часть состояния приложения",
      "Да, но только если они не связаны",
      "Это зависит от размера приложения"
    ],
    correctAnswer: 1,
    explanation: "Flux приложение обычно имеет несколько Stores, каждый из которых управляет определенной частью состояния (например, UserStore, TodoStore, MessageStore). Stores могут иметь зависимости друг от друга, которые управляются через waitFor().",
    topic: "Основы Flux"
  },
  {
    id: 18,
    question: "Что происходит при попытке изменить состояние Store во время обработки Action?",
    options: [
      "Изменения применяются немедленно",
      "Dispatcher блокирует новые dispatch вызовы пока текущий не завершится",
      "Создается новый параллельный поток обновлений",
      "Ничего не происходит"
    ],
    correctAnswer: 1,
    explanation: "Dispatcher не позволяет вызывать dispatch() пока текущий Action обрабатывается (dispatch в процессе). Это предотвращает каскадные обновления и гарантирует, что все Stores получают Action в правильном порядке.",
    topic: "Передача данных в Flux"
  },
  {
    id: 19,
    question: "Как View узнает, какой именно Store изменился?",
    options: [
      "Dispatcher отправляет уведомление",
      "View подписана на конкретные Stores и получает события от них",
      "Все Views автоматически обновляются при любом изменении",
      "View проверяет все Stores на каждом рендере"
    ],
    correctAnswer: 1,
    explanation: "View подписывается на события конкретных Stores, которые ей нужны. Когда Store изменяется, он излучает событие (emit change), и только подписанные на этот Store Views получают уведомление и обновляются.",
    topic: "Передача данных в Flux"
  },
  {
    id: 20,
    question: "Какой современный паттерн управления состоянием вдохновлен Flux?",
    options: [
      "MVC",
      "Redux",
      "MVVM",
      "Singleton"
    ],
    correctAnswer: 1,
    explanation: "Redux - это библиотека управления состоянием, вдохновленная Flux. Redux упрощает архитектуру Flux: использует один Store, reducers вместо множества Stores, и middleware для обработки side effects. Сохраняет однонаправленный поток данных.",
    topic: "Сравнение с другими архитектурами"
  },
  {
    id: 21,
    question: "Что такое Payload в Action?",
    options: [
      "Тип Action",
      "Данные, передаваемые вместе с Action для обновления состояния",
      "Функция для валидации данных",
      "Идентификатор Store"
    ],
    correctAnswer: 1,
    explanation: "Payload - это данные, которые передаются вместе с Action для обновления состояния. Например, в Action { type: 'ADD_TODO', payload: { text: 'Learn Flux', id: 1 } }, payload содержит информацию о новой задаче.",
    topic: "Основы Flux"
  },
  {
    id: 22,
    question: "Могут ли Stores общаться друг с другом напрямую?",
    options: [
      "Да, через методы импорта",
      "Нет, только через Dispatcher и waitFor()",
      "Да, но только в development режиме",
      "Да, через события"
    ],
    correctAnswer: 1,
    explanation: "Stores не должны общаться друг с другом напрямую. Если один Store зависит от данных другого, он использует метод waitFor() Dispatcher'а, чтобы дождаться обновления зависимого Store при обработке того же Action.",
    topic: "Передача данных в Flux"
  },
  {
    id: 23,
    question: "Зачем нужна регистрация callback в Dispatcher?",
    options: [
      "Для валидации Actions",
      "Чтобы Dispatcher знал, какие Stores нужно уведомить при dispatch Action",
      "Для логирования событий",
      "Для отмены Actions"
    ],
    correctAnswer: 1,
    explanation: "Каждый Store регистрирует callback функцию в Dispatcher (обычно через register()). При dispatch Action, Dispatcher вызывает все зарегистрированные callbacks, передавая им Action. Это позволяет всем Stores получить и обработать Action.",
    topic: "Передача данных в Flux"
  },
  {
    id: 24,
    question: "Что такое immutability в контексте Flux?",
    options: [
      "Невозможность удалить Store",
      "Неизменяемость состояния - создание нового объекта вместо изменения существующего",
      "Постоянное хранение данных в localStorage",
      "Защита от SQL инъекций"
    ],
    correctAnswer: 1,
    explanation: "Immutability (неизменяемость) означает, что вместо изменения существующего состояния, Store создает новый объект состояния. Это упрощает отслеживание изменений, отладку и реализацию функций типа undo/redo.",
    topic: "Основы Flux"
  },
  {
    id: 25,
    question: "Как в Flux обрабатываются ошибки при выполнении Action?",
    options: [
      "Автоматически через try-catch в Dispatcher",
      "Через отдельные Actions типа ERROR с информацией об ошибке",
      "Ошибки игнорируются",
      "Приложение перезагружается"
    ],
    correctAnswer: 1,
    explanation: "Ошибки обрабатываются через отдельные Actions. Например, при неудачном API запросе Action Creator отправляет Action типа FETCH_ERROR с информацией об ошибке. Store обрабатывает этот Action и обновляет состояние (например, устанавливает error message).",
    topic: "Передача данных в Flux"
  },
  {
    id: 26,
    question: "Почему View не должен содержать бизнес-логику в Flux?",
    options: [
      "View слишком медленный для вычислений",
      "Бизнес-логика должна быть в Store для переиспользуемости и тестируемости",
      "Это технически невозможно",
      "View предназначен только для стилей"
    ],
    correctAnswer: 1,
    explanation: "В Flux вся бизнес-логика должна находиться в Stores. View отвечает только за отображение данных и создание Actions в ответ на действия пользователя. Это делает логику переиспользуемой, легко тестируемой и независимой от UI.",
    topic: "Основы Flux"
  },
  {
    id: 27,
    question: "Что такое dispatch token в Flux Dispatcher?",
    options: [
      "Уникальный идентификатор для аутентификации",
      "Уникальный идентификатор callback, возвращаемый при регистрации Store",
      "Токен для API запросов",
      "Идентификатор Action"
    ],
    correctAnswer: 1,
    explanation: "При регистрации callback в Dispatcher, он возвращает dispatch token - уникальный идентификатор этого callback. Этот token используется в методе waitFor() для указания зависимостей между Stores.",
    topic: "Передача данных в Flux"
  },
  {
    id: 28,
    question: "Можно ли отменить уже отправленный Action в Flux?",
    options: [
      "Да, через метод dispatcher.cancel()",
      "Нет, после dispatch Action обрабатывается всеми Stores",
      "Да, но только до обновления View",
      "Да, через middleware"
    ],
    correctAnswer: 1,
    explanation: "После того, как Action отправлен через dispatch(), его нельзя отменить. Dispatcher синхронно вызывает все зарегистрированные callbacks. Если нужна отмена операции, создается новый Action (например, CANCEL_REQUEST).",
    topic: "Передача данных в Flux"
  },
  {
    id: 29,
    question: "Как тестировать Stores в Flux архитектуре?",
    options: [
      "Stores нельзя тестировать",
      "Отправлять Actions в Store и проверять результирующее состояние",
      "Только через UI тесты",
      "Через mock'и Dispatcher"
    ],
    correctAnswer: 1,
    explanation: "Stores легко тестировать изолированно: создаем Store, отправляем в него Actions напрямую (минуя Dispatcher), проверяем что состояние изменилось правильно и что излучаются корректные события. Бизнес-логика в Store хорошо отделена от UI.",
    topic: "Основы Flux"
  },
  {
    id: 30,
    question: "Какое преимущество дает разделение на Action Creators?",
    options: [
      "Быстрее работает",
      "Инкапсуляция логики создания Actions, переиспользуемость и удобство тестирования",
      "Меньше памяти использует",
      "Автоматическая валидация данных"
    ],
    correctAnswer: 1,
    explanation: "Action Creators инкапсулируют логику создания Actions в переиспользуемые функции. Это упрощает тестирование (можно тестировать Action Creators отдельно), делает код чище (View не знает о структуре Actions) и упрощает изменения (вся логика создания Action в одном месте).",
    topic: "Передача данных в Flux"
  }
]
