import type { Question } from '@/types/question.ts'

export const patternsBasicFPQuestions: Question[] = [
  // Тема 1: Чистые функции
  {
    id: 1,
    question: "Что такое чистая функция в функциональном программировании?",
    options: [
      "Функция, которая не содержит багов",
      "Функция, которая всегда возвращает одинаковый результат для одинаковых аргументов и не имеет побочных эффектов",
      "Функция, написанная в функциональном стиле",
      "Функция, которая использует только примитивные типы данных"
    ],
    correctAnswer: 1,
    explanation: "Чистая функция — это функция, которая: 1) всегда возвращает одинаковый результат для одинаковых входных данных (детерминированность), 2) не имеет побочных эффектов (не изменяет внешнее состояние).",
    topic: "Чистые функции"
  },
  {
    id: 2,
    question: "Какая из следующих функций является чистой?",
    options: [
      "const add = (a, b) => { console.log(a + b); return a + b; }",
      "const add = (a, b) => a + b",
      "const add = (a, b) => { counter++; return a + b; }",
      "const add = (a, b) => a + b + Math.random()"
    ],
    correctAnswer: 1,
    explanation: "Только вторая функция является чистой: она всегда возвращает одинаковый результат для одинаковых аргументов и не имеет побочных эффектов. Остальные либо используют console.log, изменяют внешнюю переменную, либо используют Math.random().",
    topic: "Чистые функции"
  },
  {
    id: 3,
    question: "Что является побочным эффектом в функции?",
    options: [
      "Возврат значения",
      "Использование параметров функции",
      "Изменение внешнего состояния или взаимодействие с внешним миром (DOM, сеть, файлы)",
      "Создание локальных переменных"
    ],
    correctAnswer: 2,
    explanation: "Побочный эффект — это любое взаимодействие с внешним миром: изменение глобальных переменных, вывод в консоль, изменение DOM, запросы к API, изменение переданных объектов и т.д.",
    topic: "Чистые функции"
  },
  {
    id: 4,
    question: "Почему чистые функции легче тестировать?",
    options: [
      "Они короче по коду",
      "Они всегда возвращают одинаковый результат для одинаковых входных данных, не требуя настройки окружения",
      "Они быстрее выполняются",
      "Они автоматически покрываются тестами"
    ],
    correctAnswer: 1,
    explanation: "Чистые функции легче тестировать, потому что они детерминированы и изолированы: не нужно мокать внешние зависимости, настраивать состояние или очищать побочные эффекты.",
    topic: "Чистые функции"
  },
  {
    id: 5,
    question: "Что произойдет, если функция изменяет переданный ей объект?",
    options: [
      "Функция остается чистой",
      "Функция становится нечистой из-за побочного эффекта (мутации)",
      "Это нормальная практика в FP",
      "Объект автоматически клонируется"
    ],
    correctAnswer: 1,
    explanation: "Изменение (мутация) переданного объекта — это побочный эффект, который делает функцию нечистой. Чистые функции должны возвращать новые объекты вместо изменения существующих.",
    topic: "Чистые функции"
  },
  {
    id: 6,
    question: "Как чистая функция должна работать с массивами?",
    options: [
      "Использовать методы push, pop, splice для изменения оригинала",
      "Создавать новые массивы с помощью map, filter, slice, spread оператора",
      "Всегда изменять оригинальный массив",
      "Использовать глобальные массивы"
    ],
    correctAnswer: 1,
    explanation: "Чистые функции должны возвращать новые массивы, не изменяя оригинальные. Для этого используются методы map, filter, slice, concat, spread оператор и другие иммутабельные операции.",
    topic: "Чистые функции"
  },

  // Тема 2: Функции высшего порядка
  {
    id: 7,
    question: "Что такое функция высшего порядка (Higher-Order Function)?",
    options: [
      "Функция, которая вызывается первой",
      "Функция, которая принимает другие функции как аргументы или возвращает функцию",
      "Функция с большим количеством параметров",
      "Функция, которая выполняется быстрее остальных"
    ],
    correctAnswer: 1,
    explanation: "Функция высшего порядка — это функция, которая либо принимает одну или несколько функций в качестве аргументов, либо возвращает функцию как результат.",
    topic: "Функции высшего порядка"
  },
  {
    id: 8,
    question: "Какие встроенные методы массивов являются функциями высшего порядка?",
    options: [
      "map, filter, reduce",
      "push, pop, shift",
      "toString, valueOf",
      "length, indexOf"
    ],
    correctAnswer: 0,
    explanation: "map, filter, reduce и другие методы массивов (forEach, some, every, find) являются функциями высшего порядка, так как принимают функцию-колбэк в качестве аргумента.",
    topic: "Функции высшего порядка"
  },
  {
    id: 9,
    question: "Что выведет этот код?\n\nconst multiplyBy = (multiplier) => (num) => num * multiplier;\nconst double = multiplyBy(2);\nconsole.log(double(5));",
    options: [
      "7",
      "10",
      "25",
      "Ошибка"
    ],
    correctAnswer: 1,
    explanation: "multiplyBy — функция высшего порядка, которая возвращает новую функцию. double = multiplyBy(2) создает функцию умножения на 2, поэтому double(5) вернет 10.",
    topic: "Функции высшего порядка"
  },
  {
    id: 10,
    question: "В чем преимущество использования функций высшего порядка?",
    options: [
      "Они работают быстрее",
      "Повышают переиспользуемость кода и позволяют создавать абстракции",
      "Занимают меньше памяти",
      "Автоматически оптимизируются компилятором"
    ],
    correctAnswer: 1,
    explanation: "Функции высшего порядка позволяют создавать более абстрактный и переиспользуемый код, отделяя общую логику от специфического поведения.",
    topic: "Функции высшего порядка"
  },
  {
    id: 11,
    question: "Что такое функция-колбэк?",
    options: [
      "Функция, которая вызывает сама себя",
      "Функция, переданная как аргумент другой функции",
      "Функция, которая возвращает объект",
      "Асинхронная функция"
    ],
    correctAnswer: 1,
    explanation: "Колбэк — это функция, переданная в качестве аргумента другой функции, которая затем вызывает эту функцию. Это основной способ использования функций высшего порядка.",
    topic: "Функции высшего порядка"
  },
  {
    id: 12,
    question: "Какой паттерн демонстрирует этот код?\n\nconst withLogging = (fn) => (...args) => {\n  console.log('Вызов функции с:', args);\n  return fn(...args);\n}",
    options: [
      "Каррирование",
      "Декоратор (обертка над функцией)",
      "Мемоизация",
      "Композиция"
    ],
    correctAnswer: 1,
    explanation: "Это паттерн декоратора — функция высшего порядка, которая оборачивает другую функцию, добавляя дополнительное поведение (в данном случае логирование).",
    topic: "Функции высшего порядка"
  },

  // Тема 3: Каррирование
  {
    id: 13,
    question: "Что такое каррирование (currying)?",
    options: [
      "Преобразование функции с несколькими аргументами в последовательность функций с одним аргументом",
      "Передача функции как аргумента",
      "Создание замыкания",
      "Оптимизация производительности функций"
    ],
    correctAnswer: 0,
    explanation: "Каррирование — это преобразование функции вида f(a, b, c) в f(a)(b)(c). Каждая функция принимает один аргумент и возвращает новую функцию до тех пор, пока не будут получены все аргументы.",
    topic: "Каррирование"
  },
  {
    id: 14,
    question: "Что выведет этот код?\n\nconst curry = (a) => (b) => (c) => a + b + c;\nconsole.log(curry(1)(2)(3));",
    options: [
      "123",
      "6",
      "undefined",
      "Ошибка"
    ],
    correctAnswer: 1,
    explanation: "Каррированная функция curry последовательно принимает три аргумента (1, 2, 3) и возвращает их сумму: 1 + 2 + 3 = 6.",
    topic: "Каррирование"
  },
  {
    id: 15,
    question: "В чем разница между каррированием и частичным применением (partial application)?",
    options: [
      "Никакой разницы нет",
      "Каррирование всегда принимает по одному аргументу, частичное применение может принимать несколько",
      "Частичное применение быстрее работает",
      "Каррирование работает только со стрелочными функциями"
    ],
    correctAnswer: 1,
    explanation: "Каррирование преобразует f(a,b,c) в f(a)(b)(c) (по одному аргументу), а частичное применение может зафиксировать любое количество аргументов: f(a,b,c) → f(a)(b,c) или f(a,b)(c).",
    topic: "Каррирование"
  },
  {
    id: 16,
    question: "Какое практическое применение имеет каррирование?",
    options: [
      "Ускорение выполнения кода",
      "Создание специализированных функций путем частичного применения аргументов",
      "Уменьшение размера кода",
      "Автоматическое кэширование результатов"
    ],
    correctAnswer: 1,
    explanation: "Каррирование позволяет создавать специализированные функции, фиксируя часть аргументов. Например, из универсальной функции сложения можно создать функцию add5 = add(5), которая добавляет 5 к любому числу.",
    topic: "Каррирование"
  },
  {
    id: 17,
    question: "Что выведет этот код?\n\nconst multiply = (a) => (b) => a * b;\nconst double = multiply(2);\nconst triple = multiply(3);\nconsole.log(double(5), triple(5));",
    options: [
      "10 15",
      "7 8",
      "25 25",
      "Ошибка"
    ],
    correctAnswer: 0,
    explanation: "multiply — каррированная функция. double = multiply(2) фиксирует множитель 2, triple = multiply(3) фиксирует 3. Поэтому double(5) = 10, triple(5) = 15.",
    topic: "Каррирование"
  },
  {
    id: 18,
    question: "Как реализовать универсальную функцию каррирования?",
    options: [
      "Использовать bind() для каждого аргумента",
      "Рекурсивно проверять количество переданных аргументов и возвращать новую функцию или результат",
      "Использовать eval()",
      "Это невозможно реализовать универсально"
    ],
    correctAnswer: 1,
    explanation: "Универсальная функция каррирования проверяет, получены ли все аргументы (fn.length): если да — вызывает функцию, если нет — возвращает новую функцию, накапливающую аргументы.",
    topic: "Каррирование"
  },

  // Тема 4: Смешанные вопросы
  {
    id: 19,
    question: "Какая связь между чистыми функциями и иммутабельностью?",
    options: [
      "Никакой связи нет",
      "Чистые функции должны работать с данными иммутабельно, не изменяя оригинальные значения",
      "Чистые функции всегда изменяют данные",
      "Иммутабельность замедляет чистые функции"
    ],
    correctAnswer: 1,
    explanation: "Чистые функции должны соблюдать принцип иммутабельности: не изменять входные данные, а создавать и возвращать новые значения. Это гарантирует отсутствие побочных эффектов.",
    topic: "Чистые функции"
  },
  {
    id: 20,
    question: "Что такое композиция функций?",
    options: [
      "Вызов нескольких функций одновременно",
      "Объединение нескольких функций в одну, где результат одной функции передается в другую",
      "Создание массива из функций",
      "Параллельное выполнение функций"
    ],
    correctAnswer: 1,
    explanation: "Композиция функций — это процесс объединения двух или более функций для создания новой функции. Результат одной функции передается как аргумент в следующую: compose(f, g)(x) = f(g(x)).",
    topic: "Функции высшего порядка"
  },
  {
    id: 21,
    question: "Можно ли каррировать нечистую функцию?",
    options: [
      "Нет, каррирование работает только с чистыми функциями",
      "Да, но она останется нечистой",
      "Каррирование автоматически делает функцию чистой",
      "Это приведет к ошибке"
    ],
    correctAnswer: 1,
    explanation: "Каррирование — это просто техника преобразования функции, она не влияет на чистоту функции. Каррированная нечистая функция останется нечистой.",
    topic: "Каррирование"
  },
  {
    id: 22,
    question: "Что выведет этот код?\n\nconst numbers = [1, 2, 3];\nconst doubled = numbers.map(x => x * 2);\nconsole.log(numbers, doubled);",
    options: [
      "[2, 4, 6] [2, 4, 6]",
      "[1, 2, 3] [2, 4, 6]",
      "[1, 2, 3] [1, 2, 3]",
      "Ошибка"
    ],
    correctAnswer: 1,
    explanation: "map — чистая функция высшего порядка, которая создает новый массив. Оригинальный массив numbers остается неизменным [1, 2, 3], а doubled содержит [2, 4, 6].",
    topic: "Функции высшего порядка"
  },
  {
    id: 23,
    question: "Какая из этих функций демонстрирует правильное использование иммутабельности?",
    options: [
      "const addItem = (arr, item) => { arr.push(item); return arr; }",
      "const addItem = (arr, item) => [...arr, item]",
      "const addItem = (arr, item) => { arr[arr.length] = item; return arr; }",
      "const addItem = (arr, item) => arr.concat(item) && arr"
    ],
    correctAnswer: 1,
    explanation: "Правильный вариант использует spread оператор для создания нового массива, не изменяя оригинальный. Остальные варианты мутируют исходный массив.",
    topic: "Чистые функции"
  },
  {
    id: 24,
    question: "Что такое Point-Free стиль в функциональном программировании?",
    options: [
      "Программирование без использования точки с запятой",
      "Определение функций без явного указания аргументов",
      "Использование только стрелочных функций",
      "Программирование без return"
    ],
    correctAnswer: 1,
    explanation: "Point-Free (tacit) стиль — это написание функций без явного упоминания их аргументов, обычно через композицию функций. Например: const isValid = compose(not, isEmpty) вместо const isValid = x => not(isEmpty(x)).",
    topic: "Функции высшего порядка"
  },
  {
    id: 25,
    question: "Зачем использовать функциональное программирование?",
    options: [
      "Это модный тренд",
      "Код становится более предсказуемым, тестируемым и легче рассуждать о нем",
      "Программы работают быстрее",
      "Меньше кода нужно писать"
    ],
    correctAnswer: 1,
    explanation: "Основные преимущества ФП: предсказуемость поведения (чистые функции), легкость тестирования, лучшая композируемость, упрощение рассуждений о коде, меньше багов из-за иммутабельности.",
    topic: "Чистые функции"
  }
]
