import type { Question } from '@/types/question.ts'

export const patternsDryKissYagniQuestions: Question[] = [
  // Тема 1: Расшифровка и основы принципов
  {
    id: 1,
    question: "Как расшифровывается принцип DRY?",
    options: [
      "Do Repeat Yourself",
      "Don't Repeat Yourself",
      "Design Reusable Yields",
      "Duplicate Reduced Yield"
    ],
    correctAnswer: 1,
    explanation: "DRY расшифровывается как Don't Repeat Yourself (Не повторяйся) — принцип разработки ПО, направленный на снижение повторения информации.",
    topic: "Основы принципов"
  },
  {
    id: 2,
    question: "Как расшифровывается принцип KISS?",
    options: [
      "Keep It Simple, Stupid",
      "Keep It Short and Simple",
      "Knowledge Is Software Strength",
      "Keep Interfaces Secure and Safe"
    ],
    correctAnswer: 0,
    explanation: "KISS расшифровывается как Keep It Simple, Stupid (Делай это проще) — принцип проектирования, утверждающий, что большинство систем работают лучше, если они остаются простыми.",
    topic: "Основы принципов"
  },
  {
    id: 3,
    question: "Как расшифровывается принцип YAGNI?",
    options: [
      "You Are Gonna Need It",
      "You Always Get New Ideas",
      "You Aren't Gonna Need It",
      "Your Application Gets New Iterations"
    ],
    correctAnswer: 2,
    explanation: "YAGNI расшифровывается как You Aren't Gonna Need It (Тебе это не понадобится) — принцип экстремального программирования, который говорит, что не следует добавлять функциональность до тех пор, пока она действительно не понадобится.",
    topic: "Основы принципов"
  },
  {
    id: 4,
    question: "Какой принцип нарушает следующий код?\n\nconst calculateUserAge = (birthYear) => 2024 - birthYear;\nconst calculateEmployeeAge = (birthYear) => 2024 - birthYear;",
    options: [
      "KISS",
      "YAGNI",
      "DRY",
      "SOLID"
    ],
    correctAnswer: 2,
    explanation: "Этот код нарушает принцип DRY, так как логика вычисления возраста дублируется. Следует создать одну функцию calculateAge и использовать её в обоих случаях.",
    topic: "Основы принципов"
  },
  {
    id: 5,
    question: "Что является основной целью принципа DRY?",
    options: [
      "Увеличение скорости выполнения кода",
      "Уменьшение дублирования кода и знаний в системе",
      "Упрощение пользовательского интерфейса",
      "Ускорение процесса разработки"
    ],
    correctAnswer: 1,
    explanation: "Основная цель DRY — уменьшение дублирования кода и знаний в системе. Каждая часть знания должна иметь единственное, однозначное и авторитетное представление в системе.",
    topic: "Основы принципов"
  },
  {
    id: 6,
    question: "Что означает 'Simple' в принципе KISS?",
    options: [
      "Код должен быть коротким",
      "Решение должно быть понятным и не содержать излишней сложности",
      "Использовать только базовые конструкции языка",
      "Избегать использования библиотек"
    ],
    correctAnswer: 1,
    explanation: "В контексте KISS 'Simple' означает, что решение должно быть понятным, легко читаемым и не содержать излишней сложности. Это не означает примитивность, а означает отсутствие необоснованной сложности.",
    topic: "Основы принципов"
  },
  {
    id: 7,
    question: "Какой код лучше соответствует принципу KISS?",
    options: [
      "const isEven = n => n % 2 === 0;",
      "const isEven = n => (n & 1) === 0;",
      "const isEven = n => parseInt(n/2) === n/2;",
      "const isEven = n => !(n & 1);"
    ],
    correctAnswer: 0,
    explanation: "Вариант 'n % 2 === 0' наиболее понятен и читаем, что соответствует KISS. Битовые операции (варианты 2 и 4) хоть и могут быть быстрее, но менее понятны. Вариант 3 избыточно сложен.",
    topic: "Основы принципов"
  },
  {
    id: 8,
    question: "Какой принцип нарушает добавление функции 'экспорт в PDF' в MVP продукта, если её никто не запрашивал?",
    options: [
      "DRY",
      "KISS",
      "YAGNI",
      "Не нарушает никакой принцип"
    ],
    correctAnswer: 2,
    explanation: "Это нарушение YAGNI — добавление функциональности, которая может не понадобиться. Такие функции усложняют кодовую базу, увеличивают время разработки и поддержки без реальной пользы.",
    topic: "Основы принципов"
  },

  // Тема 2: Практическое применение DRY
  {
    id: 9,
    question: "Как лучше всего применить DRY к следующему коду?\n\nconst validateEmail = (email) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\nconst checkEmail = (email) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);",
    options: [
      "Оставить как есть",
      "Создать константу с регулярным выражением и использовать в обеих функциях",
      "Удалить одну из функций и использовать другую",
      "Объединить обе функции в одну"
    ],
    correctAnswer: 1,
    explanation: "Лучший подход — создать константу EMAIL_REGEX и использовать её в обеих функциях, если обе функции нужны. Если функции делают одно и то же, то следует использовать вариант 3.",
    topic: "Применение DRY"
  },
  {
    id: 10,
    question: "Какой подход нарушает DRY?",
    options: [
      "Использование utility функций для повторяющейся логики",
      "Создание общих компонентов для повторяющихся UI элементов",
      "Копирование и вставка кода с небольшими изменениями",
      "Создание переиспользуемых хуков в React"
    ],
    correctAnswer: 2,
    explanation: "Копирование и вставка кода с небольшими изменениями — классическое нарушение DRY. Вместо этого следует выделить общую логику и параметризовать различия.",
    topic: "Применение DRY"
  },
  {
    id: 11,
    question: "Что из перечисленного является правильным применением DRY?",
    options: [
      "Создание одной функции для обработки всех возможных случаев",
      "Извлечение повторяющейся логики в переиспользуемые функции/модули",
      "Использование наследования для любого дублирования кода",
      "Создание глобальных переменных для всех повторяющихся значений"
    ],
    correctAnswer: 1,
    explanation: "DRY правильно применяется через извлечение повторяющейся логики в переиспользуемые функции/модули. Это не означает создание монолитных функций или чрезмерное использование наследования.",
    topic: "Применение DRY"
  },
  {
    id: 12,
    question: "Когда дублирование кода может быть приемлемым?",
    options: [
      "Никогда, DRY должен соблюдаться всегда",
      "Когда код похож случайно, но представляет разные концепции (случайное дублирование)",
      "Когда разработчик торопится",
      "Когда код короткий (менее 3 строк)"
    ],
    correctAnswer: 1,
    explanation: "Случайное дублирование допустимо, когда код выглядит похожим, но представляет разные бизнес-концепции, которые могут эволюционировать независимо. Преждевременная абстракция может быть вреднее дублирования.",
    topic: "Применение DRY"
  },

  // Тема 3: Практическое применение KISS
  {
    id: 13,
    question: "Какое решение лучше соответствует KISS для получения уникальных значений массива?",
    options: [
      "const unique = arr => arr.filter((v, i, a) => a.indexOf(v) === i);",
      "const unique = arr => [...new Set(arr)];",
      "const unique = arr => arr.reduce((acc, v) => acc.includes(v) ? acc : [...acc, v], []);",
      "Написать собственную реализацию с hash-таблицей"
    ],
    correctAnswer: 1,
    explanation: "Вариант [...new Set(arr)] самый простой и понятный, использует встроенную функциональность языка. Это идеальное применение KISS — простое, читаемое и эффективное решение.",
    topic: "Применение KISS"
  },
  {
    id: 14,
    question: "Что противоречит принципу KISS?",
    options: [
      "Использование встроенных методов языка",
      "Написание понятных имён переменных",
      "Создание сложной архитектуры 'на будущее'",
      "Разбиение большой функции на несколько маленьких"
    ],
    correctAnswer: 2,
    explanation: "Создание сложной архитектуры 'на будущее' противоречит KISS. Архитектура должна соответствовать текущим требованиям, не быть избыточно сложной для решаемой задачи.",
    topic: "Применение KISS"
  },
  {
    id: 15,
    question: "Какой код проще для понимания (KISS)?",
    options: [
      "const result = data.reduce((a,b)=>({...a,[b.id]:b}),{});",
      "const result = {};\ndata.forEach(item => {\n  result[item.id] = item;\n});",
      "const result = Object.fromEntries(data.map(x=>[x.id,x]));",
      "Все варианты одинаково просты"
    ],
    correctAnswer: 1,
    explanation: "Вариант с forEach наиболее читаем и понятен для большинства разработчиков. Хотя другие варианты более компактны, они требуют большего уровня знаний для понимания.",
    topic: "Применение KISS"
  },
  {
    id: 16,
    question: "Что означает 'простота' в контексте KISS?",
    options: [
      "Минимальное количество строк кода",
      "Отсутствие паттернов проектирования",
      "Код должен быть понятен и легко поддерживаем",
      "Использование только базовых конструкций языка"
    ],
    correctAnswer: 2,
    explanation: "Простота в KISS — это понятность и лёгкость поддержки кода. Это не означает примитивность или отказ от паттернов, а означает отсутствие необоснованной сложности.",
    topic: "Применение KISS"
  },

  // Тема 4: Практическое применение YAGNI
  {
    id: 17,
    question: "Какое действие соответствует принципу YAGNI?",
    options: [
      "Создание универсального API для всех возможных случаев использования",
      "Реализация только той функциональности, которая требуется сейчас",
      "Добавление параметров конфигурации 'на всякий случай'",
      "Создание абстракций для возможного будущего расширения"
    ],
    correctAnswer: 1,
    explanation: "YAGNI предполагает реализацию только необходимой сейчас функциональности. Добавление 'на будущее' увеличивает сложность и может оказаться ненужным или потребовать переработки.",
    topic: "Применение YAGNI"
  },
  {
    id: 18,
    question: "Что из перечисленного нарушает YAGNI?",
    options: [
      "Рефакторинг существующего кода",
      "Добавление поддержки нескольких баз данных, когда используется только одна",
      "Написание unit тестов",
      "Документирование кода"
    ],
    correctAnswer: 1,
    explanation: "Добавление поддержки нескольких БД без реальной необходимости нарушает YAGNI. Это усложняет код и увеличивает время разработки ради гипотетического будущего требования.",
    topic: "Применение YAGNI"
  },
  {
    id: 19,
    question: "Когда YAGNI НЕ следует применять?",
    options: [
      "При добавлении новой фичи по запросу пользователя",
      "При создании базовой архитектуры проекта",
      "При рефакторинге legacy кода",
      "YAGNI следует применять всегда"
    ],
    correctAnswer: 1,
    explanation: "При создании базовой архитектуры нужен разумный баланс. Некоторые архитектурные решения сложно изменить потом, поэтому минимальное планирование необходимо. YAGNI не означает полное отсутствие проектирования.",
    topic: "Применение YAGNI"
  },
  {
    id: 20,
    question: "Разработчик создал систему плагинов для приложения, хотя требуется только один конкретный функционал. Какой принцип нарушен?",
    options: [
      "DRY",
      "KISS",
      "YAGNI",
      "Оба KISS и YAGNI"
    ],
    correctAnswer: 3,
    explanation: "Нарушены оба принципа: YAGNI (система плагинов не нужна сейчас) и KISS (решение излишне сложное для текущей задачи). Достаточно было реализовать конкретный функционал напрямую.",
    topic: "Применение YAGNI"
  },

  // Тема 5: Взаимосвязь принципов
  {
    id: 21,
    question: "Как DRY и YAGNI могут конфликтовать?",
    options: [
      "DRY может привести к преждевременной абстракции, которую запрещает YAGNI",
      "Они никогда не конфликтуют",
      "YAGNI запрещает любое переиспользование кода",
      "DRY требует планирования, а YAGNI его запрещает"
    ],
    correctAnswer: 0,
    explanation: "DRY может привести к созданию абстракций 'на будущее', что противоречит YAGNI. Правило трёх (Rule of Three) помогает: рефакторить при третьем повторении, а не при первом.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 22,
    question: "Как KISS помогает соблюдать YAGNI?",
    options: [
      "KISS запрещает использовать сложные конструкции",
      "KISS напоминает не добавлять излишнюю сложность, что согласуется с YAGNI",
      "KISS требует минимального кода",
      "KISS и YAGNI не связаны"
    ],
    correctAnswer: 1,
    explanation: "KISS и YAGNI дополняют друг друга: KISS фокусируется на простоте решения, YAGNI — на отсутствии лишней функциональности. Оба принципа борются с необоснованной сложностью.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 23,
    question: "Какой подход объединяет все три принципа (DRY, KISS, YAGNI)?",
    options: [
      "Написать минимальное количество простого кода без дублирования для решения текущей задачи",
      "Создать универсальное решение на все случаи жизни",
      "Использовать только встроенные функции языка",
      "Избегать любых абстракций"
    ],
    correctAnswer: 0,
    explanation: "Все три принципа вместе означают: писать простой код (KISS), избегать дублирования (DRY), реализовывать только необходимое сейчас (YAGNI). Это приводит к чистому, поддерживаемому коду.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 24,
    question: "В чём опасность чрезмерного следования DRY?",
    options: [
      "Код станет слишком коротким",
      "Преждевременные абстракции, которые сложно изменить при изменении требований",
      "Уменьшение производительности",
      "Увеличение размера bundle"
    ],
    correctAnswer: 1,
    explanation: "Чрезмерное следование DRY приводит к преждевременным абстракциям. Код, который сейчас похож, может эволюционировать в разных направлениях. Иногда дублирование лучше неправильной абстракции.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 25,
    question: "Как комбинация DRY, KISS и YAGNI влияет на качество кода?",
    options: [
      "Делает код слишком простым и примитивным",
      "Создаёт баланс между переиспользованием, простотой и необходимостью",
      "Замедляет разработку из-за множества правил",
      "Применима только к большим проектам"
    ],
    correctAnswer: 1,
    explanation: "Комбинация этих принципов создаёт баланс: DRY избавляет от дублирования, KISS держит код простым, YAGNI не даёт добавлять лишнее. Результат — чистый, поддерживаемый, эффективный код.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 26,
    question: "Разработчик создал абстрактную фабрику для создания объектов одного типа. Какие принципы, вероятно, нарушены?",
    options: [
      "Только KISS",
      "Только YAGNI",
      "KISS и YAGNI",
      "Только DRY"
    ],
    correctAnswer: 2,
    explanation: "Абстрактная фабрика для одного типа объектов нарушает KISS (излишняя сложность) и YAGNI (паттерн не нужен для одного типа). Паттерны должны решать реальные проблемы, а не применяться 'для красоты'.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 27,
    question: "Что важнее: следовать DRY или YAGNI при разработке новой функции?",
    options: [
      "Всегда DRY",
      "Всегда YAGNI",
      "Зависит от контекста и стадии проекта",
      "Они не конфликтуют, поэтому вопрос некорректен"
    ],
    correctAnswer: 2,
    explanation: "Выбор зависит от контекста. В начале разработки YAGNI важнее (избежать лишней функциональности). При рефакторинге устоявшегося кода DRY может быть приоритетнее. Баланс — ключ к успеху.",
    topic: "Взаимосвязь принципов"
  },
  {
    id: 28,
    question: "Правило трёх (Rule of Three) в контексте DRY означает:",
    options: [
      "Функция не должна быть длиннее трёх строк",
      "Рефакторить код при третьем повторении, а не при первом",
      "Использовать не более трёх параметров в функции",
      "Создавать не более трёх уровней вложенности"
    ],
    correctAnswer: 1,
    explanation: "Правило трёх предлагает дождаться третьего повторения кода перед рефакторингом. Это помогает избежать преждевременных абстракций (YAGNI) и дождаться понимания реального паттерна повторения.",
    topic: "Взаимосвязь принципов"
  },

  // Тема 6: Практические сценарии
  {
    id: 29,
    question: "У вас есть два компонента с похожей логикой валидации формы. Что делать?",
    options: [
      "Оставить как есть (YAGNI)",
      "Немедленно создать универсальный хук валидации",
      "Подождать третьего случая, затем рефакторить (Rule of Three)",
      "Создать сложную систему валидации с поддержкой всех возможных правил"
    ],
    correctAnswer: 2,
    explanation: "Правило трёх — хороший баланс между DRY и YAGNI. Два случая могут быть случайно похожими. Третий случай подтвердит паттерн и покажет, какая именно абстракция нужна.",
    topic: "Практические сценарии"
  },
  {
    id: 30,
    question: "Клиент просит добавить экспорт данных в 5 различных форматов, но использует только один. Как поступить?",
    options: [
      "Реализовать все 5 форматов (соблюдая DRY при реализации)",
      "Реализовать только используемый формат (YAGNI)",
      "Создать универсальную систему экспорта для любых форматов",
      "Реализовать 2-3 самых популярных формата"
    ],
    correctAnswer: 1,
    explanation: "YAGNI: реализовать только то, что используется. Остальные форматы добавлять по мере реальной необходимости. Это экономит время разработки и поддержки.",
    topic: "Практические сценарии"
  },
  {
    id: 31,
    question: "В трёх местах кода используется одна и та же сложная регулярка. Что делать?",
    options: [
      "Оставить как есть, комментарии объяснят",
      "Вынести в константу с понятным именем",
      "Создать класс RegexValidator с методами для всех возможных валидаций",
      "Написать библиотеку валидации"
    ],
    correctAnswer: 1,
    explanation: "DRY: вынести регулярку в константу. KISS: не создавать излишне сложные классы или библиотеки. Константа с говорящим именем — простое и эффективное решение.",
    topic: "Практические сценарии"
  },
  {
    id: 32,
    question: "Вы пишете функцию форматирования даты. Какой подход правильный?",
    options: [
      "Использовать существующую библиотеку (date-fns, dayjs)",
      "Написать свою универсальную библиотеку форматирования",
      "Реализовать только нужный формат без зависимостей",
      "Зависит от требований проекта"
    ],
    correctAnswer: 3,
    explanation: "Для простого случая (один формат) — вариант 3 (YAGNI, KISS). Для сложных требований (множество форматов, локализация) — вариант 1 (не изобретать велосипед). Контекст определяет решение.",
    topic: "Практические сценарии"
  },
  {
    id: 33,
    question: "Код работает, но имеет небольшое дублирование в двух функциях. Рефакторить сейчас или позже?",
    options: [
      "Сейчас, DRY превыше всего",
      "Дождаться третьего повторения или изменения в этом коде",
      "Никогда, если код работает",
      "Создать абстракцию на всякий случай"
    ],
    correctAnswer: 1,
    explanation: "Правило трёх и YAGNI: дождаться третьего повторения или необходимости изменения. Преждевременная оптимизация (включая рефакторинг) может быть вредной. 'Работающий код' — не оправдание для игнорирования проблем, но и не повод для немедленного действия.",
    topic: "Практические сценарии"
  },
  {
    id: 34,
    question: "При code review вы видите сложную цепочку методов в одну строку. Что не так?",
    options: [
      "Ничего, код компактный (DRY)",
      "Нарушен KISS — код сложен для понимания",
      "Нарушен YAGNI — слишком много методов",
      "Нарушен DRY — методы могут дублироваться"
    ],
    correctAnswer: 1,
    explanation: "Сложные цепочки методов в одну строку нарушают KISS. Код должен быть понятным, даже если это требует нескольких строк. Компактность ≠ простота.",
    topic: "Практические сценарии"
  },
  {
    id: 35,
    question: "Вам нужно добавить логирование в 10 функций. Как поступить по DRY?",
    options: [
      "Добавить console.log в каждую функцию",
      "Создать декоратор/wrapper функцию для логирования",
      "Скопировать функцию логирования в каждую функцию",
      "Использовать глобальную переменную для логов"
    ],
    correctAnswer: 1,
    explanation: "DRY: создать переиспользуемое решение (декоратор, wrapper, HOF). Это избавляет от дублирования логики логирования и упрощает её изменение в будущем.",
    topic: "Практические сценарии"
  },
  {
    id: 36,
    question: "Как принципы DRY, KISS, YAGNI помогают в работе команды?",
    options: [
      "Увеличивают скорость написания кода",
      "Делают код более предсказуемым, понятным и поддерживаемым для всех членов команды",
      "Уменьшают количество багов до нуля",
      "Позволяют писать меньше тестов"
    ],
    correctAnswer: 1,
    explanation: "Эти принципы создают общее понимание качества кода в команде. Код становится более предсказуемым (KISS), без дублирования (DRY) и без лишней функциональности (YAGNI), что упрощает работу всей команды.",
    topic: "Практические сценарии"
  }
]
