import type { Question } from '@/types/question.ts'

export const reactVirtualDOMQuestions: Question[] = [
  // Тема 1: Основы Virtual DOM
  {
    id: 1,
    question: "Что такое Virtual DOM?",
    options: [
      "Реальное DOM-дерево браузера",
      "Легковесная JavaScript-копия реального DOM",
      "Библиотека для работы с DOM",
      "Кэш DOM-элементов"
    ],
    correctAnswer: 1,
    explanation: "Virtual DOM — это легковесная копия реального DOM в виде JavaScript-объектов. React использует её для оптимизации обновлений: вместо прямых манипуляций с DOM, изменения сначала применяются к Virtual DOM, затем вычисляются минимальные изменения и только они применяются к реальному DOM.",
    topic: "Основы Virtual DOM"
  },
  {
    id: 2,
    question: "Почему работа с реальным DOM считается медленной?",
    options: [
      "DOM написан на медленном языке",
      "Манипуляции с DOM вызывают перерасчёт layout и перерисовку",
      "Браузеры плохо оптимизированы",
      "DOM устарел как технология"
    ],
    correctAnswer: 1,
    explanation: "Работа с реальным DOM медленная, потому что любое изменение может вызвать reflow (перерасчёт позиций элементов) и repaint (перерисовку). Эти операции вычислительно дорогие, особенно при частых изменениях.",
    topic: "Основы Virtual DOM"
  },
  {
    id: 3,
    question: "Какая главная проблема решается с помощью Virtual DOM?",
    options: [
      "Уменьшение размера приложения",
      "Минимизация дорогих операций с реальным DOM",
      "Ускорение загрузки страницы",
      "Упрощение синтаксиса JavaScript"
    ],
    correctAnswer: 1,
    explanation: "Virtual DOM решает проблему множественных дорогих операций с реальным DOM. Вместо применения каждого изменения напрямую, React сначала обновляет Virtual DOM (быстро), вычисляет разницу (diffing), и применяет только минимально необходимые изменения к реальному DOM (reconciliation).",
    topic: "Основы Virtual DOM"
  },
  {
    id: 4,
    question: "Из чего состоит Virtual DOM узел?",
    options: [
      "HTML-строки",
      "JavaScript-объектов с type, props и children",
      "CSS-классов",
      "DOM-элементов"
    ],
    correctAnswer: 1,
    explanation: "Virtual DOM узел — это обычный JavaScript-объект с полями: type (тип элемента: 'div', компонент), props (свойства и атрибуты), children (дочерние элементы). Это легковесная структура, с которой быстро работать.",
    topic: "Основы Virtual DOM"
  },
  {
    id: 5,
    question: "Что возвращает JSX после компиляции?",
    options: [
      "HTML-строку",
      "DOM-элемент",
      "Вызов React.createElement (Virtual DOM узел)",
      "CSS-объект"
    ],
    correctAnswer: 2,
    explanation: "JSX компилируется в вызовы React.createElement(), которые создают Virtual DOM узлы (React elements). Например, <div>Hello</div> превращается в React.createElement('div', null, 'Hello').",
    topic: "Основы Virtual DOM"
  },

  // Тема 2: Процесс Reconciliation
  {
    id: 6,
    question: "Что такое reconciliation в React?",
    options: [
      "Процесс создания компонентов",
      "Процесс сравнения Virtual DOM и применения изменений к реальному DOM",
      "Процесс рендеринга HTML",
      "Процесс валидации props"
    ],
    correctAnswer: 1,
    explanation: "Reconciliation — это процесс, при котором React сравнивает новое Virtual DOM дерево со старым (diffing), определяет что изменилось, и применяет только необходимые изменения к реальному DOM. Это ключевой механизм оптимизации React.",
    topic: "Reconciliation"
  },
  {
    id: 7,
    question: "Какой алгоритм сложности имеет стандартный алгоритм diffing деревьев?",
    options: [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(n³)"
    ],
    correctAnswer: 3,
    explanation: "Стандартный алгоритм поиска минимального количества операций для трансформации одного дерева в другое имеет сложность O(n³). React использует эвристический алгоритм с O(n), делая разумные предположения.",
    topic: "Reconciliation"
  },
  {
    id: 8,
    question: "Какие два предположения делает алгоритм reconciliation в React?",
    options: [
      "Все элементы уникальны и неизменяемы",
      "Элементы разных типов создают разные деревья; key помогает идентифицировать элементы между рендерами",
      "DOM всегда медленный и его нужно избегать",
      "Компоненты всегда рендерятся в том же порядке"
    ],
    correctAnswer: 1,
    explanation: "React делает два ключевых предположения: 1) Элементы разных типов (<div> vs <span>) создают разные деревья и их поддеревья можно не сравнивать. 2) Разработчик может указать key для стабильной идентификации элементов между рендерами.",
    topic: "Reconciliation"
  },
  {
    id: 9,
    question: "Что происходит, когда тип корневого элемента меняется (например, с <div> на <span>)?",
    options: [
      "React обновляет только тип элемента",
      "React полностью удаляет старое дерево и строит новое",
      "React пытается переиспользовать старые элементы",
      "Ничего не происходит"
    ],
    correctAnswer: 1,
    explanation: "Когда тип корневого элемента меняется, React считает, что это совершенно новое дерево. Старое дерево полностью удаляется (с вызовом componentWillUnmount), и строится новое дерево с нуля (с вызовом componentDidMount).",
    topic: "Reconciliation"
  },
  {
    id: 10,
    question: "Что делает React, когда обновляется элемент того же типа?",
    options: [
      "Создаёт новый элемент",
      "Сохраняет DOM-узел и обновляет только изменившиеся атрибуты",
      "Удаляет и пересоздаёт элемент",
      "Игнорирует изменения"
    ],
    correctAnswer: 1,
    explanation: "Когда элемент того же типа обновляется (например, <div className='old'> → <div className='new'>), React сохраняет тот же DOM-узел и обновляет только изменившиеся атрибуты. Затем рекурсивно обрабатывает дочерние элементы.",
    topic: "Reconciliation"
  },

  // Тема 3: Роль ключей (keys)
  {
    id: 11,
    question: "Зачем нужны keys в списках React?",
    options: [
      "Для стилизации элементов",
      "Для стабильной идентификации элементов между рендерами",
      "Для доступа к элементам из родителя",
      "Для оптимизации памяти"
    ],
    correctAnswer: 1,
    explanation: "Keys помогают React идентифицировать, какие элементы изменились, добавлены или удалены. Стабильные keys позволяют React переиспользовать существующие DOM-узлы и сохранять состояние компонентов при изменении порядка.",
    topic: "Keys в списках"
  },
  {
    id: 12,
    question: "Что произойдёт при рендере списка без keys?",
    options: [
      "Ошибка компиляции",
      "React выдаст warning и будет использовать индексы",
      "Приложение не запустится",
      "React автоматически сгенерирует уникальные keys"
    ],
    correctAnswer: 1,
    explanation: "React выдаст предупреждение в консоли и будет использовать индексы массива как keys. Это может привести к проблемам производительности и багам с состоянием при изменении порядка элементов.",
    topic: "Keys в списках"
  },
  {
    id: 13,
    question: "Почему использование индекса массива как key — плохая практика?",
    options: [
      "Индексы не уникальны",
      "При изменении порядка элементов ключи не отражают реальную идентичность",
      "Индексы замедляют рендеринг",
      "React не поддерживает числовые keys"
    ],
    correctAnswer: 1,
    explanation: "Индекс как key проблематичен при изменении порядка, добавлении или удалении элементов. Элемент с индексом 0 может представлять разные данные в разных рендерах, что нарушает стабильную идентификацию и может вызвать баги с состоянием.",
    topic: "Keys в списках"
  },
  {
    id: 14,
    question: "Какой key следует использовать для элементов списка?",
    options: [
      "Индекс массива",
      "Math.random()",
      "Стабильный уникальный идентификатор из данных (например, id)",
      "Текущую дату"
    ],
    correctAnswer: 2,
    explanation: "Лучший key — это стабильный уникальный идентификатор из ваших данных (например, item.id). Он должен быть уникальным среди соседних элементов и оставаться постоянным между рендерами для одних и тех же данных.",
    topic: "Keys в списках"
  },
  {
    id: 15,
    question: "Что произойдёт, если два элемента в списке будут иметь одинаковый key?",
    options: [
      "React выдаст ошибку и не отрендерит список",
      "React выдаст warning, поведение может быть непредсказуемым",
      "React автоматически сгенерирует новые keys",
      "Ничего не произойдёт"
    ],
    correctAnswer: 1,
    explanation: "React выдаст предупреждение о дублирующихся keys. Поведение становится непредсказуемым: React может неправильно переиспользовать компоненты, что приведёт к багам с отображением и состоянием.",
    topic: "Keys в списках"
  },
  {
    id: 16,
    question: "Нужно ли указывать key для элементов, которые не в массиве?",
    options: [
      "Да, всегда",
      "Нет, key нужен только для элементов в массиве",
      "Только для компонентов",
      "Только для DOM-элементов"
    ],
    correctAnswer: 1,
    explanation: "Key требуется только для элементов в массиве (или других итерируемых структурах). Для единичных элементов key не нужен, так как их идентичность определяется позицией в дереве компонентов.",
    topic: "Keys в списках"
  },

  // Тема 4: Fiber Architecture
  {
    id: 17,
    question: "Что такое Fiber в React?",
    options: [
      "Библиотека для работы с формами",
      "Новая архитектура reconciliation engine в React 16+",
      "Способ стилизации компонентов",
      "Инструмент для тестирования"
    ],
    correctAnswer: 1,
    explanation: "Fiber — это переписанная архитектура reconciliation engine, представленная в React 16. Она позволяет разбивать работу рендеринга на части, приоритизировать обновления, приостанавливать и возобновлять работу.",
    topic: "Fiber Architecture"
  },
  {
    id: 18,
    question: "Какую главную проблему решает Fiber?",
    options: [
      "Уменьшение размера бандла",
      "Блокировку основного потока при длительном рендеринге",
      "Упрощение синтаксиса компонентов",
      "Ускорение первоначальной загрузки"
    ],
    correctAnswer: 1,
    explanation: "До Fiber, reconciliation был синхронным и мог блокировать основной поток, вызывая зависания UI. Fiber позволяет разбивать работу на части и уступать управление браузеру, предотвращая блокировку при больших обновлениях.",
    topic: "Fiber Architecture"
  },
  {
    id: 19,
    question: "Что такое единица работы (unit of work) в Fiber?",
    options: [
      "Один компонент",
      "Fiber-узел, представляющий компонент или элемент",
      "Один рендер всего приложения",
      "Одно событие пользователя"
    ],
    correctAnswer: 1,
    explanation: "В Fiber каждый компонент или элемент представлен fiber-узлом — это единица работы. React может обработать один fiber, затем проверить, есть ли более приоритетная работа, и при необходимости переключиться на неё.",
    topic: "Fiber Architecture"
  },
  {
    id: 20,
    question: "Какие фазы работы есть в Fiber?",
    options: [
      "Render и Mount",
      "Render (reconciliation) и Commit",
      "Create и Update",
      "Build и Deploy"
    ],
    correctAnswer: 1,
    explanation: "Fiber работает в две фазы: 1) Render (reconciliation) — может прерываться, строится новое дерево и вычисляются изменения. 2) Commit — не прерывается, применяются изменения к DOM и вызываются lifecycle методы.",
    topic: "Fiber Architecture"
  },
  {
    id: 21,
    question: "Можно ли прервать фазу commit в Fiber?",
    options: [
      "Да, любую фазу можно прервать",
      "Нет, фаза commit выполняется синхронно",
      "Только в production режиме",
      "Только для функциональных компонентов"
    ],
    correctAnswer: 1,
    explanation: "Фаза commit не может быть прервана — она выполняется синхронно. Это гарантирует, что пользователь видит согласованное состояние UI. Только фаза render (reconciliation) может прерываться.",
    topic: "Fiber Architecture"
  },
  {
    id: 22,
    question: "Что такое приоритеты обновлений в Fiber?",
    options: [
      "Порядок рендеринга компонентов в дереве",
      "Механизм определения срочности обновлений (user input > data fetch)",
      "Последовательность вызова lifecycle методов",
      "Размер компонентов в байтах"
    ],
    correctAnswer: 1,
    explanation: "Fiber позволяет назначать приоритеты обновлениям. Например, обновления от пользовательского ввода имеют высокий приоритет (должны обработаться быстро), а обновления от получения данных — низкий (могут подождать).",
    topic: "Fiber Architecture"
  },

  // Тема 5: Производительность и оптимизация
  {
    id: 23,
    question: "Всегда ли Virtual DOM быстрее прямых манипуляций с DOM?",
    options: [
      "Да, всегда",
      "Нет, для очень простых обновлений прямые манипуляции могут быть быстрее",
      "Да, но только в production",
      "Зависит от браузера"
    ],
    correctAnswer: 1,
    explanation: "Virtual DOM не всегда быстрее. Для очень простого обновления одного атрибута прямая манипуляция с DOM может быть быстрее. Преимущество Virtual DOM проявляется при сложных обновлениях множества элементов, где он минимизирует количество операций с DOM.",
    topic: "Производительность"
  },
  {
    id: 24,
    question: "Что такое batching в React?",
    options: [
      "Группировка импортов",
      "Группировка нескольких setState в одно обновление",
      "Объединение компонентов",
      "Кэширование результатов рендера"
    ],
    correctAnswer: 1,
    explanation: "Batching — это группировка нескольких вызовов setState в одно обновление Virtual DOM и один рендер. Это предотвращает множественные ре-рендеры и улучшает производительность. В React 18 automatic batching работает везде.",
    topic: "Производительность"
  },
  {
    id: 25,
    question: "Как React оптимизирует обновления списков с keys?",
    options: [
      "Кэширует все элементы списка",
      "Использует keys для минимизации создания/удаления DOM-узлов",
      "Рендерит только первые 10 элементов",
      "Использует виртуальный скроллинг"
    ],
    correctAnswer: 1,
    explanation: "С правильными keys React может определить, какие элементы реально изменились, добавились или удалились. Это позволяет переиспользовать существующие DOM-узлы, минимизируя дорогие операции создания/удаления элементов.",
    topic: "Производительность"
  },
  {
    id: 26,
    question: "Что происходит с DOM при ре-рендере компонента?",
    options: [
      "Весь DOM компонента пересоздаётся",
      "React обновляет только те DOM-узлы, которые реально изменились",
      "DOM полностью очищается и строится заново",
      "Ничего не происходит с DOM"
    ],
    correctAnswer: 1,
    explanation: "При ре-рендере React создаёт новое Virtual DOM дерево, сравнивает его со старым (diffing), и применяет к реальному DOM только минимально необходимые изменения. Большинство DOM-узлов переиспользуются.",
    topic: "Производительность"
  },
  {
    id: 27,
    question: "Зачем нужны React.memo, useMemo, useCallback в контексте Virtual DOM?",
    options: [
      "Для работы с памятью",
      "Для предотвращения ненужных ре-рендеров и пересоздания Virtual DOM",
      "Для кэширования DOM-элементов",
      "Для оптимизации CSS"
    ],
    correctAnswer: 1,
    explanation: "Эти инструменты помогают избежать ненужных ре-рендеров компонентов. Даже с Virtual DOM, создание нового дерева и diffing — это работа. Мемоизация позволяет пропустить эту работу, если props/зависимости не изменились.",
    topic: "Производительность"
  },

  // Тема 6: Сравнение с другими подходами
  {
    id: 28,
    question: "Как работают фреймворки без Virtual DOM (например, Svelte)?",
    options: [
      "Они медленнее React",
      "Они компилируют компоненты в императивный код обновления DOM",
      "Они используют настоящий DOM напрямую без оптимизаций",
      "Они не могут создавать интерактивные приложения"
    ],
    correctAnswer: 1,
    explanation: "Фреймворки вроде Svelte не используют Virtual DOM. Вместо этого они компилируют компоненты в оптимизированный императивный код, который точно знает, какие DOM-узлы обновлять при изменении состояния. Это может быть эффективнее для некоторых сценариев.",
    topic: "Сравнение подходов"
  },
  {
    id: 29,
    question: "В чём недостаток Virtual DOM подхода?",
    options: [
      "Он не работает в старых браузерах",
      "Накладные расходы на создание Virtual DOM и diffing",
      "Невозможно создать сложные UI",
      "Плохая поддержка событий"
    ],
    correctAnswer: 1,
    explanation: "Virtual DOM добавляет накладные расходы: нужно создавать Virtual DOM дерево в памяти и выполнять diffing. Для очень простых обновлений это может быть избыточно. Однако для большинства реальных приложений эти расходы оправданы удобством и предсказуемостью.",
    topic: "Сравнение подходов"
  },
  {
    id: 30,
    question: "Почему Virtual DOM называют 'декларативным' подходом?",
    options: [
      "Потому что использует декларации переменных",
      "Разработчик описывает 'что' должно быть, а не 'как' это обновить",
      "Потому что написан на декларативном языке",
      "Потому что требует декларацию типов"
    ],
    correctAnswer: 1,
    explanation: "С Virtual DOM вы описываете желаемое состояние UI декларативно (что должно быть отображено), а React сам разбирается, как эффективно обновить DOM. В отличие от императивного подхода, где вы сами пишете инструкции по манипуляции DOM.",
    topic: "Сравнение подходов"
  },

  // Тема 7: Практические детали
  {
    id: 31,
    question: "Что такое React element?",
    options: [
      "HTML элемент",
      "Неизменяемый объект, описывающий DOM узел или компонент",
      "Класс React",
      "DOM узел"
    ],
    correctAnswer: 1,
    explanation: "React element — это неизменяемый plain JavaScript объект, описывающий что вы хотите видеть на экране. Это базовый строительный блок Virtual DOM. После создания element нельзя изменить его children или props.",
    topic: "Практические детали"
  },
  {
    id: 32,
    question: "Можно ли изменить props React element после создания?",
    options: [
      "Да, props можно изменять свободно",
      "Нет, React elements иммутабельны",
      "Да, но только в development режиме",
      "Зависит от типа элемента"
    ],
    correctAnswer: 1,
    explanation: "React elements иммутабельны — после создания их нельзя изменить. Это упрощает сравнение и отслеживание изменений. Для обновления UI создаётся новый element с новыми props.",
    topic: "Практические детали"
  },
  {
    id: 33,
    question: "В чём разница между React element и React component?",
    options: [
      "Это синонимы",
      "Element — описание что рендерить, component — функция/класс создающий elements",
      "Element используется в классах, component в функциях",
      "Component быстрее element"
    ],
    correctAnswer: 1,
    explanation: "Component — это функция или класс, который принимает props и возвращает element (или дерево elements). Element — это объект, описывающий component instance или DOM узел. Components создают elements.",
    topic: "Практические детали"
  },
  {
    id: 34,
    question: "Что такое Host Component и Composite Component в контексте Virtual DOM?",
    options: [
      "Компоненты на разных серверах",
      "Host — платформенные элементы (div, span), Composite — пользовательские компоненты",
      "Разные версии одного компонента",
      "Компоненты для разных операционных систем"
    ],
    correctAnswer: 1,
    explanation: "Host components — это платформенные примитивы (для браузера: div, span, input). Composite components — ваши пользовательские компоненты (функции, классы). React рекурсивно разворачивает composite компоненты до host компонентов.",
    topic: "Практические детали"
  },
  {
    id: 35,
    question: "Сколько раз может быть вызван render метод при одном обновлении состояния?",
    options: [
      "Всегда один раз",
      "Может быть вызван несколько раз в фазе reconciliation (с Fiber)",
      "Ровно два раза",
      "Зависит от количества компонентов"
    ],
    correctAnswer: 1,
    explanation: "С Fiber архитектурой render может быть вызван несколько раз в прерываемой фазе reconciliation, если React отложил работу для обработки более приоритетных обновлений. Поэтому render должен быть чистой функцией без сайд-эффектов.",
    topic: "Практические детали"
  },

  // Тема 8: React 18+ и Concurrent Features
  {
    id: 36,
    question: "Что такое Concurrent Rendering в React 18?",
    options: [
      "Многопоточный рендеринг",
      "Способность React прерывать, приостанавливать и возобновлять рендеринг",
      "Рендеринг нескольких компонентов одновременно",
      "Асинхронный рендеринг"
    ],
    correctAnswer: 1,
    explanation: "Concurrent Rendering позволяет React работать над несколькими версиями UI одновременно. React может начать рендеринг обновления, приостановить его для более срочной работы, и вернуться позже. Это улучшает отзывчивость приложения.",
    topic: "React 18+"
  },
  {
    id: 37,
    question: "Как Transitions в React 18 связаны с Virtual DOM?",
    options: [
      "Они отключают Virtual DOM",
      "Они помечают обновления как не срочные, позволяя React приоритизировать работу",
      "Они ускоряют diffing",
      "Они кэшируют Virtual DOM"
    ],
    correctAnswer: 1,
    explanation: "useTransition и startTransition помечают обновления как transitions (не срочные). React может прервать работу над transition для обработки более срочных обновлений (например, от пользовательского ввода), сохраняя отзывчивость UI.",
    topic: "React 18+"
  },
  {
    id: 38,
    question: "Что такое Suspense в контексте Virtual DOM?",
    options: [
      "Способ показа loading состояний при асинхронной загрузке",
      "Остановка всего рендеринга",
      "Кэширование компонентов",
      "Ленивая загрузка CSS"
    ],
    correctAnswer: 0,
    explanation: "Suspense позволяет компоненту 'приостановить' рендеринг, пока загружается асинхронный ресурс (данные, код). React отобразит fallback UI и продолжит работу над этим поддеревом, когда ресурс загрузится. Это часть concurrent features.",
    topic: "React 18+"
  },
  {
    id: 39,
    question: "Как работает Automatic Batching в React 18?",
    options: [
      "Группирует все setState в setTimeout",
      "Группирует множественные обновления состояния везде (не только в event handlers)",
      "Автоматически оптимизирует размер бандла",
      "Объединяет похожие компоненты"
    ],
    correctAnswer: 1,
    explanation: "До React 18 batching работал только в event handlers. В React 18+ automatic batching работает везде: в promises, setTimeout, native event handlers. Это уменьшает количество ре-рендеров и улучшает производительность.",
    topic: "React 18+"
  },
  {
    id: 40,
    question: "Что такое time slicing в Fiber?",
    options: [
      "Разделение компонентов на модули",
      "Разбивка работы рендеринга на маленькие кусочки с уступкой контроля браузеру",
      "Оптимизация временных меток",
      "Кэширование результатов за время"
    ],
    correctAnswer: 1,
    explanation: "Time slicing — это возможность Fiber разбивать работу рендеринга на маленькие кусочки и периодически уступать контроль браузеру. Это позволяет браузеру обрабатывать пользовательский ввод и анимации даже во время большого рендеринга, предотвращая зависания.",
    topic: "React 18+"
  }
]
