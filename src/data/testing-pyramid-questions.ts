import type { Question } from '@/types/question.ts'

export const testingPyramidQuestions: Question[] = [
  // Тема 1: Основы пирамиды тестирования
  {
    id: 1,
    question: "Что такое пирамида тестирования?",
    options: [
      "График производительности тестов",
      "Модель распределения тестов по уровням: много юнит-тестов внизу, меньше интеграционных, еще меньше E2E тестов",
      "Иерархия тестировщиков в команде",
      "Последовательность этапов тестирования"
    ],
    correctAnswer: 1,
    explanation: "Пирамида тестирования - это концепция, предложенная Майком Коном, которая визуально представляет оптимальное распределение различных типов тестов: широкое основание из быстрых юнит-тестов, средний слой интеграционных тестов и вершина из небольшого количества E2E тестов.",
    topic: "Основы пирамиды"
  },
  {
    id: 2,
    question: "Какова главная цель пирамиды тестирования?",
    options: [
      "Увеличить количество тестов",
      "Оптимизировать баланс между скоростью выполнения тестов, покрытием и стоимостью поддержки",
      "Упростить процесс написания тестов",
      "Заменить ручное тестирование"
    ],
    correctAnswer: 1,
    explanation: "Основная цель пирамиды - найти оптимальный баланс: максимальное покрытие кода быстрыми и дешевыми юнит-тестами, достаточное количество интеграционных тестов для проверки взаимодействия компонентов, и минимум медленных и дорогих E2E тестов для критических сценариев.",
    topic: "Основы пирамиды"
  },
  {
    id: 3,
    question: "Почему пирамида имеет именно такую форму (широкое основание, узкая вершина)?",
    options: [
      "Так проще визуализировать",
      "Юнит-тесты быстрые и дешевые, их должно быть много; E2E тесты медленные и дорогие, их должно быть мало",
      "Это случайный выбор автора концепции",
      "Чтобы соответствовать организационной структуре"
    ],
    correctAnswer: 1,
    explanation: "Форма пирамиды отражает оптимальное соотношение: юнит-тесты выполняются за миллисекунды, легко поддерживаются и дают точную локализацию ошибок - их должно быть много. E2E тесты медленные (минуты), хрупкие, сложные в отладке - их должно быть минимум для критических путей.",
    topic: "Основы пирамиды"
  },
  {
    id: 4,
    question: "Что происходит, если пирамида 'перевернута' (много E2E тестов, мало юнит-тестов)?",
    options: [
      "Ничего, это тоже рабочая стратегия",
      "Тесты становятся медленными, хрупкими, дорогими в поддержке, обратная связь замедляется",
      "Повышается качество продукта",
      "Упрощается CI/CD процесс"
    ],
    correctAnswer: 1,
    explanation: "Перевернутая пирамида (ice cream cone anti-pattern) приводит к проблемам: долгое выполнение тестов (часы вместо минут), много ложных срабатываний, сложная отладка, высокая стоимость поддержки, медленная обратная связь разработчикам.",
    topic: "Основы пирамиды"
  },
  {
    id: 5,
    question: "Кто предложил концепцию пирамиды тестирования?",
    options: [
      "Мартин Фаулер",
      "Майк Кон (Mike Cohn)",
      "Кент Бек",
      "Роберт Мартин"
    ],
    correctAnswer: 1,
    explanation: "Концепция пирамиды тестирования была впервые описана Майком Коном в книге 'Succeeding with Agile' (2009). Позже она была популяризирована и адаптирована многими другими авторами, включая Мартина Фаулера.",
    topic: "Основы пирамиды"
  },
  {
    id: 6,
    question: "Применима ли классическая пирамида тестирования ко всем типам проектов?",
    options: [
      "Да, это универсальная модель",
      "Нет, нужно адаптировать под контекст проекта (микросервисы, фронтенд, API и т.д.)",
      "Только для backend приложений",
      "Только для legacy систем"
    ],
    correctAnswer: 1,
    explanation: "Классическая пирамида - это руководство, а не догма. Для разных контекстов существуют адаптации: Testing Trophy (React), Testing Diamond (микросервисы), Testing Honeycomb. Важно понимать принципы и адаптировать их под свой проект.",
    topic: "Основы пирамиды"
  },

  // Тема 2: Уровни пирамиды
  {
    id: 7,
    question: "Какие основные уровни включает классическая пирамида тестирования?",
    options: [
      "Frontend, Backend, Database",
      "Unit Tests (юнит), Integration Tests (интеграционные), E2E Tests (end-to-end)",
      "Manual, Automated, Performance",
      "Smoke, Regression, Acceptance"
    ],
    correctAnswer: 1,
    explanation: "Классическая пирамида Майка Кона включает три основных уровня: Unit Tests (основание, ~70%), Integration Tests (середина, ~20%), E2E/UI Tests (вершина, ~10%). Эти проценты - ориентировочные и зависят от проекта.",
    topic: "Уровни пирамиды"
  },
  {
    id: 8,
    question: "Что тестируют юнит-тесты (Unit Tests)?",
    options: [
      "Весь пользовательский сценарий",
      "Отдельные функции/методы/классы в изоляции",
      "Взаимодействие с базой данных",
      "UI интерфейс"
    ],
    correctAnswer: 1,
    explanation: "Юнит-тесты проверяют минимальные тестируемые единицы (функции, методы, классы) в полной изоляции от внешних зависимостей. Все зависимости мокируются или стабируются. Они быстрые (миллисекунды), дают точную локализацию ошибок.",
    topic: "Уровни пирамиды"
  },
  {
    id: 9,
    question: "Что тестируют интеграционные тесты (Integration Tests)?",
    options: [
      "Отдельные функции",
      "Взаимодействие между модулями/компонентами/сервисами",
      "Только UI",
      "Производительность"
    ],
    correctAnswer: 1,
    explanation: "Интеграционные тесты проверяют, как различные модули работают вместе: взаимодействие с БД, внешними API, файловой системой, другими сервисами. Они медленнее юнит-тестов, но быстрее E2E, и выявляют проблемы интеграции.",
    topic: "Уровни пирамиды"
  },
  {
    id: 10,
    question: "Что тестируют E2E (End-to-End) тесты?",
    options: [
      "Отдельные функции",
      "Полные пользовательские сценарии от начала до конца через UI",
      "Только backend логику",
      "Unit тесты в браузере"
    ],
    correctAnswer: 1,
    explanation: "E2E тесты симулируют действия реального пользователя: открытие браузера, клики, ввод данных, навигация. Они проверяют весь стек (UI, backend, БД) в реальном окружении. Самые медленные, хрупкие, но дают максимальную уверенность.",
    topic: "Уровни пирамиды"
  },
  {
    id: 11,
    question: "Какое примерное соотношение тестов рекомендуется в классической пирамиде?",
    options: [
      "50% юнит, 30% интеграционные, 20% E2E",
      "70% юнит, 20% интеграционные, 10% E2E",
      "30% юнит, 30% интеграционные, 40% E2E",
      "Все уровни равномерно по 33%"
    ],
    correctAnswer: 1,
    explanation: "Классическое соотношение: ~70% юнит-тестов (быстрые, дешевые), ~20% интеграционных (средние по скорости/стоимости), ~10% E2E (медленные, дорогие). Но это ориентир - реальное соотношение зависит от проекта, команды, контекста.",
    topic: "Уровни пирамиды"
  },
  {
    id: 12,
    question: "Где в пирамиде находятся компонентные тесты (Component Tests)?",
    options: [
      "Это просто другое название юнит-тестов",
      "Между юнит и интеграционными тестами или вместо E2E для фронтенда",
      "На вершине пирамиды",
      "Компонентные тесты не часть пирамиды"
    ],
    correctAnswer: 1,
    explanation: "Component Tests (например, React Testing Library) тестируют UI компоненты в изоляции, но с реальным рендерингом. В Testing Trophy они занимают центральное место. Быстрее E2E, но тщательнее юнит-тестов для UI.",
    topic: "Уровни пирамиды"
  },

  // Тема 3: Характеристики уровней
  {
    id: 13,
    question: "Сколько времени обычно выполняются юнит-тесты?",
    options: [
      "Секунды-минуты",
      "Миллисекунды",
      "Минуты-часы",
      "Часы"
    ],
    correctAnswer: 1,
    explanation: "Юнит-тесты должны выполняться очень быстро - миллисекунды на тест. Даже тысячи юнит-тестов должны выполняться за секунды. Это позволяет запускать их при каждом сохранении файла (watch mode) и в pre-commit hooks.",
    topic: "Характеристики уровней"
  },
  {
    id: 14,
    question: "Какой тип тестов дает самую точную локализацию ошибки?",
    options: [
      "E2E тесты",
      "Интеграционные тесты",
      "Юнит-тесты",
      "Все одинаково"
    ],
    correctAnswer: 2,
    explanation: "Юнит-тесты дают самую точную локализацию: если тест упал, вы точно знаете, какая функция/метод сломалась. E2E тест может упасть из-за проблемы в любом слое (UI, API, БД), и потребуется время на отладку.",
    topic: "Характеристики уровней"
  },
  {
    id: 15,
    question: "Какие тесты наиболее хрупкие (brittle) и склонны к ложным срабатываниям?",
    options: [
      "Юнит-тесты",
      "Интеграционные тесты",
      "E2E тесты",
      "Все одинаково стабильны"
    ],
    correctAnswer: 2,
    explanation: "E2E тесты наиболее хрупкие: они зависят от таймингов, сетевых задержек, состояния БД, изменений в UI. Любое изменение CSS-класса может сломать селектор. Требуют частого обслуживания и retry механизмов.",
    topic: "Характеристики уровней"
  },
  {
    id: 16,
    question: "Какой тип тестов обеспечивает максимальную уверенность (confidence), что приложение работает для пользователя?",
    options: [
      "Юнит-тесты",
      "Интеграционные тесты",
      "E2E тесты",
      "Все одинаково"
    ],
    correctAnswer: 2,
    explanation: "E2E тесты дают максимальную уверенность, так как тестируют приложение так же, как его использует реальный пользователь: через браузер, с реальными кликами, вводом, навигацией. Они проверяют весь стек интегрированно.",
    topic: "Характеристики уровней"
  },
  {
    id: 17,
    question: "Какие тесты проще всего писать и поддерживать?",
    options: [
      "E2E тесты",
      "Интеграционные тесты",
      "Юнит-тесты",
      "Все одинаково сложны"
    ],
    correctAnswer: 2,
    explanation: "Юнит-тесты проще всего: тестируют чистые функции без побочных эффектов, не требуют setup окружения, моки предсказуемы. E2E требуют браузер, сервер, БД, управление состоянием, обработку таймингов.",
    topic: "Характеристики уровней"
  },
  {
    id: 18,
    question: "Какие тесты наиболее дорогие в разработке и поддержке?",
    options: [
      "Юнит-тесты",
      "Интеграционные тесты",
      "E2E тесты",
      "Все одинаково дороги"
    ],
    correctAnswer: 2,
    explanation: "E2E тесты самые дорогие: требуют инфраструктуру (браузеры, сервера, БД), долго выполняются, хрупкие (частые обновления при изменении UI), сложная отладка падений, нужны специализированные инструменты и навыки.",
    topic: "Характеристики уровней"
  },

  // Тема 4: Распределение и баланс
  {
    id: 19,
    question: "Что означает 'test coverage' (покрытие тестами)?",
    options: [
      "Количество тестов в проекте",
      "Процент кода, который выполняется при запуске тестов",
      "Время выполнения тестов",
      "Количество найденных багов"
    ],
    correctAnswer: 1,
    explanation: "Test coverage (code coverage) - метрика, показывающая процент кода (строки, ветви, функции), который выполняется при запуске тестов. 100% покрытие не гарантирует отсутствие багов, но показывает, какой код вообще не тестируется.",
    topic: "Распределение и баланс"
  },
  {
    id: 20,
    question: "Что лучше: 90% покрытия юнит-тестами или 100% покрытие любой ценой?",
    options: [
      "100% всегда лучше",
      "90% с осмысленными тестами лучше, чем 100% с бессмысленными",
      "Покрытие не важно",
      "Достаточно 50%"
    ],
    correctAnswer: 1,
    explanation: "Гонка за 100% покрытием часто приводит к тестам-заглушкам без реальной проверки поведения. Лучше 90% покрытия с качественными тестами критической логики, чем 100% с тестами 'для галочки'. Фокус должен быть на качестве, а не на метрике.",
    topic: "Распределение и баланс"
  },
  {
    id: 21,
    question: "Какую логику важнее всего покрывать юнит-тестами?",
    options: [
      "Всю без исключения",
      "Бизнес-логику, алгоритмы, утилиты, критические функции",
      "Только UI компоненты",
      "Только getter/setter методы"
    ],
    correctAnswer: 1,
    explanation: "Приоритет юнит-тестам: бизнес-логика (расчеты, валидации), сложные алгоритмы, утилитные функции, критические пути. Простые getter/setter, тривиальный код можно не покрывать. Фокус на value, а не на coverage metric.",
    topic: "Распределение и баланс"
  },
  {
    id: 22,
    question: "Почему не стоит писать только E2E тесты для всех сценариев?",
    options: [
      "E2E тесты ненадежны",
      "Медленные, дорогие, хрупкие, сложная отладка - обратная связь слишком медленная",
      "Они не проверяют реальное поведение",
      "Они требуют слишком много кода"
    ],
    correctAnswer: 1,
    explanation: "E2E тесты для всех сценариев - антипаттерн: часы выполнения, хрупкость (ложные срабатывания), непонятно где ошибка при падении, высокая стоимость поддержки. Разработчики получают feedback через часы вместо секунд.",
    topic: "Распределение и баланс"
  },
  {
    id: 23,
    question: "Как выбрать, какие сценарии покрывать E2E тестами?",
    options: [
      "Все возможные пользовательские сценарии",
      "Критические happy paths и наиболее ценные для бизнеса сценарии",
      "Только авторизацию",
      "Случайно выбранные сценарии"
    ],
    correctAnswer: 1,
    explanation: "E2E тестами покрывайте критические happy paths: регистрация → покупка → оплата, основные пользовательские сценарии, которые приносят доход. Граничные случаи и негативные сценарии лучше покрыть юнит/интеграционными тестами.",
    topic: "Распределение и баланс"
  },
  {
    id: 24,
    question: "Что такое 'test-induced design damage'?",
    options: [
      "Баги, найденные тестами",
      "Ухудшение дизайна кода ради тестируемости",
      "Медленные тесты",
      "Ложные срабатывания"
    ],
    correctAnswer: 1,
    explanation: "Test-induced design damage - когда стремление к 100% тестируемости ухудшает архитектуру: излишняя абстракция, dependency injection везде, сложный setup. Баланс важен: код должен быть тестируемым, но не страдать от этого.",
    topic: "Распределение и баланс"
  },

  // Тема 5: Практика и инструменты
  {
    id: 25,
    question: "Какие инструменты обычно используются для юнит-тестов в JavaScript/TypeScript?",
    options: [
      "Selenium, Puppeteer",
      "Jest, Vitest, Mocha + Chai",
      "Postman, Insomnia",
      "Docker, Kubernetes"
    ],
    correctAnswer: 1,
    explanation: "Для юнит-тестов JS/TS популярны: Jest (React), Vitest (Vite), Mocha/Chai, Jasmine. Они предоставляют test runner, assertions, моки, coverage. Jest/Vitest также имеют встроенную поддержку snapshot testing.",
    topic: "Практика и инструменты"
  },
  {
    id: 26,
    question: "Какие инструменты используются для E2E тестов веб-приложений?",
    options: [
      "Jest, Vitest",
      "Cypress, Playwright, Selenium",
      "ESLint, Prettier",
      "Webpack, Vite"
    ],
    correctAnswer: 1,
    explanation: "Для E2E популярны: Cypress (developer-friendly, быстрый feedback), Playwright (multi-browser, modern), Selenium (старожил, cross-browser). Также TestCafe, Puppeteer. Выбор зависит от требований к браузерам и экосистеме.",
    topic: "Практика и инструменты"
  },
  {
    id: 27,
    question: "Что такое 'test doubles' (моки, стабы, шпионы)?",
    options: [
      "Два одинаковых теста",
      "Замены реальных зависимостей для изоляции юнит-тестов",
      "Дублирование тестов",
      "Запуск тестов дважды"
    ],
    correctAnswer: 1,
    explanation: "Test doubles - замены реальных зависимостей: Mock (проверяет вызовы), Stub (возвращает предопределенные значения), Spy (записывает вызовы), Fake (упрощенная реализация), Dummy (заглушка). Нужны для изоляции юнит-тестов.",
    topic: "Практика и инструменты"
  },
  {
    id: 28,
    question: "Где должны запускаться юнит-тесты?",
    options: [
      "Только в CI/CD",
      "Локально при разработке, в pre-commit hooks, в CI/CD",
      "Только на production",
      "На отдельном тестовом сервере"
    ],
    correctAnswer: 1,
    explanation: "Юнит-тесты должны запускаться везде: локально в watch mode при разработке (instant feedback), в pre-commit hooks (Git hooks), в CI/CD перед каждым merge. Быстрые тесты позволяют это делать без замедления процесса.",
    topic: "Практика и инструменты"
  },
  {
    id: 29,
    question: "Что такое 'flaky tests'?",
    options: [
      "Очень медленные тесты",
      "Тесты, которые нестабильно проходят/падают без изменения кода",
      "Тесты с низким покрытием",
      "Тесты, которые всегда падают"
    ],
    correctAnswer: 1,
    explanation: "Flaky tests - нестабильные тесты, которые иногда проходят, иногда падают без изменения кода. Причины: race conditions, зависимость от времени/сети, недетерминированность, проблемы с cleanup. Особенно характерны для E2E тестов.",
    topic: "Практика и инструменты"
  },
  {
    id: 30,
    question: "Как бороться с flaky E2E тестами?",
    options: [
      "Удалить их все",
      "Retry механизмы, явные ожидания, изоляция тестов, детерминированные данные",
      "Игнорировать падения",
      "Запускать их реже"
    ],
    correctAnswer: 1,
    explanation: "Стратегии борьбы с flaky тестами: умные retry с backoff, явные ожидания (waitFor) вместо sleep, изоляция тестов (независимость), детерминированные тестовые данные, стабилизация окружения, идентификация и исправление root cause.",
    topic: "Практика и инструменты"
  },

  // Тема 6: CI/CD и пирамида
  {
    id: 31,
    question: "Как пирамида тестирования связана с CI/CD?",
    options: [
      "Никак не связана",
      "Быстрые тесты (юнит) запускаются часто, медленные (E2E) реже - для быстрой обратной связи",
      "В CI/CD запускаются только E2E тесты",
      "Пирамида заменяет CI/CD"
    ],
    correctAnswer: 1,
    explanation: "Пирамида критична для CI/CD: юнит-тесты (секунды) запускаются при каждом commit/PR, интеграционные (минуты) - перед merge, E2E (десятки минут) - перед deploy или по расписанию. Это обеспечивает быстрый feedback без блокировки pipeline.",
    topic: "CI/CD и пирамида"
  },
  {
    id: 32,
    question: "Что происходит в CI/CD, если запускать только медленные E2E тесты?",
    options: [
      "Ничего плохого",
      "Pipeline блокируется на часы, feedback медленный, разработка замедляется",
      "Повышается качество",
      "Упрощается конфигурация"
    ],
    correctAnswer: 1,
    explanation: "Если CI/CD запускает только E2E (часы выполнения): разработчики ждут часами результатов PR, множество PR блокируются, падения сложно отлаживать, команда теряет продуктивность. Быстрые тесты критичны для velocity.",
    topic: "CI/CD и пирамида"
  },
  {
    id: 33,
    question: "Какие тесты стоит запускать в pre-commit hooks?",
    options: [
      "Все тесты включая E2E",
      "Только юнит-тесты и быстрые интеграционные",
      "Никакие",
      "Только E2E"
    ],
    correctAnswer: 1,
    explanation: "В pre-commit hooks запускайте только быстрые тесты: юнит + быстрые интеграционные (секунды-пара минут максимум). E2E слишком медленны для pre-commit. Цель - не блокировать разработчика, но отловить очевидные проблемы.",
    topic: "CI/CD и пирамида"
  },
  {
    id: 34,
    question: "Когда следует запускать E2E тесты в CI/CD?",
    options: [
      "При каждом commit",
      "Перед deploy в production, после успешного merge, по расписанию",
      "Никогда",
      "Только вручную"
    ],
    correctAnswer: 1,
    explanation: "E2E тесты обычно запускаются: перед deploy в production (финальная проверка), после merge в main/develop (smoke test), по расписанию (ночью, полный regression suite). Слишком медленны для каждого commit.",
    topic: "CI/CD и пирамида"
  },
  {
    id: 35,
    question: "Что такое 'shift left testing' в контексте пирамиды?",
    options: [
      "Перемещение тестирования влево по экрану",
      "Раннее тестирование в процессе разработки, акцент на юнит-тесты",
      "Тестирование только левой части UI",
      "Аутсорсинг тестирования"
    ],
    correctAnswer: 1,
    explanation: "'Shift left' - философия раннего тестирования: писать тесты при разработке функции (TDD), акцент на юнит-тесты (быстрый feedback), автоматизация в CI/CD, предотвращение дефектов вместо их поиска на поздних этапах.",
    topic: "CI/CD и пирамида"
  },
  {
    id: 36,
    question: "Можно ли полностью отказаться от ручного тестирования при хорошей пирамиде?",
    options: [
      "Да, автоматизация заменяет ручное тестирование",
      "Нет, ручное exploratory тестирование, UX проверки, edge cases дополняют автоматизацию",
      "Ручное тестирование не нужно совсем",
      "Только если есть 100% покрытие"
    ],
    correctAnswer: 1,
    explanation: "Автоматизация не заменяет ручное тестирование полностью. Ручное exploratory testing находит неожиданные баги, проверяет UX, edge cases, доступность. Пирамида автоматизации + ручное исследовательское тестирование дают лучший результат.",
    topic: "CI/CD и пирамида"
  },

  // Тема 7: Адаптации и альтернативы
  {
    id: 37,
    question: "Что такое 'Testing Trophy' (трофей тестирования)?",
    options: [
      "Награда за лучшие тесты",
      "Альтернатива пирамиде с акцентом на интеграционные тесты для React",
      "То же самое, что пирамида",
      "Инструмент тестирования"
    ],
    correctAnswer: 1,
    explanation: "Testing Trophy (Kent C. Dodds) - адаптация для React/фронтенда: статический анализ (TypeScript) в основании, больше интеграционных тестов (React Testing Library), меньше изолированных юнит-тестов, минимум E2E. Фокус на 'как пользователь взаимодействует'.",
    topic: "Адаптации и альтернативы"
  },
  {
    id: 38,
    question: "Почему для React часто рекомендуют больше интеграционных тестов (RTL) вместо юнит?",
    options: [
      "Юнит-тесты не работают для React",
      "Компонентные тесты (RTL) ближе к реальному использованию и менее хрупкие к рефакторингу",
      "Это проще",
      "Так сказал создатель React"
    ],
    correctAnswer: 1,
    explanation: "Testing Trophy рекомендует React Testing Library вместо изолированных юнит-тестов компонентов, потому что: тесты устойчивы к рефакторингу (не зависят от деталей реализации), проверяют поведение как видит пользователь, находят больше реальных багов.",
    topic: "Адаптации и альтернативы"
  },
  {
    id: 39,
    question: "Что такое 'Testing Diamond' для микросервисов?",
    options: [
      "Бриллиант за качество тестов",
      "Больше интеграционных и контрактных тестов между сервисами",
      "Форма тестового покрытия",
      "Инструмент для микросервисов"
    ],
    correctAnswer: 1,
    explanation: "Testing Diamond для микросервисной архитектуры: много юнит-тестов в каждом сервисе, много интеграционных и контрактных тестов (проверка API контрактов между сервисами), меньше E2E всей системы (слишком медленно и сложно).",
    topic: "Адаптации и альтернативы"
  },
  {
    id: 40,
    question: "Что такое 'contract testing' в микросервисах?",
    options: [
      "Тестирование юридических контрактов",
      "Проверка соблюдения API контрактов между сервисами (Pact, Spring Cloud Contract)",
      "Проверка контрактов с пользователями",
      "Тесты производительности"
    ],
    correctAnswer: 1,
    explanation: "Contract Testing (Pact, Spring Cloud Contract) - проверка, что сервис-потребитель и сервис-производитель соблюдают API контракт. Позволяет тестировать интеграцию без запуска всех сервисов, быстрее и надежнее полных E2E тестов.",
    topic: "Адаптации и альтернативы"
  },
  {
    id: 41,
    question: "Как пирамида адаптируется для API-first приложений (без UI)?",
    options: [
      "Никак, пирамида только для UI",
      "Много юнит-тестов логики, API интеграционные тесты (Postman/Rest Assured), минимум E2E",
      "Только E2E тесты",
      "Тестирование не нужно"
    ],
    correctAnswer: 1,
    explanation: "Для API-first: основание - юнит-тесты бизнес-логики, середина - API интеграционные тесты (проверка эндпоинтов, контрактов, ошибок), вершина - E2E через API (полные сценарии). UI E2E заменяются на API E2E.",
    topic: "Адаптации и альтернативы"
  },
  {
    id: 42,
    question: "Стоит ли использовать пирамиду для legacy проектов без тестов?",
    options: [
      "Нет, только для новых проектов",
      "Да, но начинать с критических сценариев E2E, постепенно добавляя юнит-тесты при рефакторинге",
      "Legacy нельзя тестировать",
      "Сразу писать все юнит-тесты"
    ],
    correctAnswer: 1,
    explanation: "Для legacy проекта: начните с 'перевернутой пирамиды' - критические E2E сценарии для защиты при рефакторинге, затем постепенно добавляйте юнит-тесты при изменении кода, рефакторите для тестируемости, движетесь к правильной пирамиде.",
    topic: "Адаптации и альтернативы"
  },

  // Тема 8: Антипаттерны и ошибки
  {
    id: 43,
    question: "Что такое 'ice cream cone' anti-pattern?",
    options: [
      "Тестирование десертов",
      "Перевернутая пирамида: много E2E, мало юнит-тестов",
      "Много юнит-тестов",
      "Отсутствие тестов"
    ],
    correctAnswer: 1,
    explanation: "Ice Cream Cone - антипаттерн, где много E2E тестов (широкая вершина), мало интеграционных, очень мало юнит-тестов (узкое основание). Результат: медленные тесты, хрупкие, дорогие в поддержке, плохая обратная связь.",
    topic: "Антипаттерны и ошибки"
  },
  {
    id: 44,
    question: "Что плохого в стратегии 'только E2E тесты через UI'?",
    options: [
      "Ничего плохого",
      "Очень медленно, хрупко, дорого, сложная отладка, плохая локализация ошибок",
      "E2E тесты не проверяют реальное поведение",
      "Не хватает покрытия"
    ],
    correctAnswer: 1,
    explanation: "Только E2E тесты - катастрофа: часы выполнения (блокировка CI/CD), множество flaky тестов, при падении непонятно где ошибка (UI? API? DB?), изменение CSS ломает тесты, огромная стоимость поддержки.",
    topic: "Антипаттерны и ошибки"
  },
  {
    id: 45,
    question: "Что плохого в стратегии 'только юнит-тесты, никаких интеграционных'?",
    options: [
      "Ничего, юнит-тестов достаточно",
      "Можно пропустить ошибки интеграции: неправильные моки, проблемы в реальном взаимодействии",
      "Юнит-тесты не проверяют код",
      "Слишком быстрые тесты"
    ],
    correctAnswer: 1,
    explanation: "Только юнит-тесты пропускают проблемы: неправильные моки (мок API отличается от реального), SQL запросы не проверены, сетевые ошибки, сериализация данных, конфигурация. Нужны интеграционные тесты для проверки взаимодействия.",
    topic: "Антипаттерны и ошибки"
  },
  {
    id: 46,
    question: "Что такое 'testing for coverage' антипаттерн?",
    options: [
      "Хорошая практика",
      "Написание бессмысленных тестов только ради достижения метрики покрытия",
      "Максимизация покрытия",
      "Использование coverage tools"
    ],
    correctAnswer: 1,
    explanation: "'Testing for coverage' - написание тестов-заглушек без реальных проверок, только чтобы достичь 100% coverage. Такие тесты не находят баги, дают ложное чувство безопасности. Фокус должен быть на качестве и проверке поведения.",
    topic: "Антипаттерны и ошибки"
  },
  {
    id: 47,
    question: "Почему плохо, когда тесты зависят друг от друга (shared state)?",
    options: [
      "Это не плохо",
      "Тесты становятся хрупкими, порядок выполнения важен, сложно отлаживать, нельзя запускать параллельно",
      "Тесты выполняются быстрее",
      "Меньше кода"
    ],
    correctAnswer: 1,
    explanation: "Зависимые тесты - проблема: падение одного ломает другие, порядок выполнения критичен, нельзя запустить один тест изолированно, невозможна параллелизация. Каждый тест должен быть независимым с собственным setup/teardown.",
    topic: "Антипаттерны и ошибки"
  },
  {
    id: 48,
    question: "Что плохого в 'snapshot testing' для всего подряд?",
    options: [
      "Ничего плохого",
      "Снапшоты большие и нечитаемые, не проверяют логику, легко обновить не глядя",
      "Snapshot тесты не работают",
      "Слишком медленные"
    ],
    correctAnswer: 1,
    explanation: "Излишний snapshot testing проблематичен: гигантские снапшоты всего HTML/JSON (никто не ревьюит), не проверяют конкретное поведение, при любом изменении разработчики просто обновляют снапшот (jest -u) не проверяя. Используйте точечно для критичных частей.",
    topic: "Антипаттерны и ошибки"
  },

  // Тема 9: Best Practices
  {
    id: 49,
    question: "Какой подход к написанию тестов рекомендуется?",
    options: [
      "Сначала весь код, потом все тесты",
      "Test-Driven Development (TDD) или писать тесты одновременно с кодом",
      "Тесты не нужны при разработке",
      "Только после релиза"
    ],
    correctAnswer: 1,
    explanation: "TDD (Test-Driven Development) или написание тестов параллельно с кодом - best practice: лучший дизайн (код тестируемый), меньше багов (тесты ловят ошибки сразу), документация кодом, уверенность при рефакторинге.",
    topic: "Best Practices"
  },
  {
    id: 50,
    question: "Как часто нужно запускать юнит-тесты?",
    options: [
      "Раз в неделю",
      "Постоянно в watch mode при разработке, при каждом commit, в CI/CD",
      "Только перед релизом",
      "Вручную когда нужно"
    ],
    correctAnswer: 1,
    explanation: "Юнит-тесты должны запускаться максимально часто: в watch mode при разработке (immediate feedback при каждом сохранении), в pre-commit hooks, при каждом push, в CI/CD при каждом PR. Быстрые тесты это позволяют.",
    topic: "Best Practices"
  }
]
