import type { Question } from '@/types/question.ts'

export const webXssCsrfQuestions: Question[] = [
  // Тема 1: Основы XSS и CSRF
  {
    id: 1,
    question: "Чем принципиально отличается XSS-атака от CSRF-атаки?",
    options: [
      "XSS внедряет вредоносный код в приложение, CSRF использует аутентификацию пользователя для выполнения нежелательных действий",
      "XSS работает только на клиенте, CSRF только на сервере",
      "XSS требует авторизации, CSRF нет",
      "CSRF внедряет скрипты, XSS подделывает запросы"
    ],
    correctAnswer: 0,
    explanation: "XSS (Cross-Site Scripting) внедряет и выполняет вредоносный JavaScript-код на стороне клиента. CSRF (Cross-Site Request Forgery) заставляет аутентифицированного пользователя выполнить нежелательные действия на доверенном сайте без его ведома.",
    topic: "Основы XSS и CSRF"
  },
  {
    id: 2,
    question: "Какую основную угрозу представляет XSS-атака?",
    options: [
      "Перегрузка сервера запросами",
      "Кража данных пользователя, выполнение действий от его имени, модификация контента",
      "Изменение структуры базы данных",
      "Блокировка доступа к сайту"
    ],
    correctAnswer: 1,
    explanation: "XSS позволяет атакующему выполнить вредоносный код в браузере жертвы, что может привести к краже cookies, session tokens, личных данных, перенаправлению на фишинговые сайты, изменению содержимого страницы.",
    topic: "Основы XSS и CSRF"
  },
  {
    id: 3,
    question: "Какую основную угрозу представляет CSRF-атака?",
    options: [
      "Внедрение вредоносного кода в приложение",
      "Выполнение нежелательных действий от имени аутентифицированного пользователя",
      "Кража паролей пользователей",
      "Изменение исходного кода приложения"
    ],
    correctAnswer: 1,
    explanation: "CSRF использует тот факт, что браузер автоматически отправляет cookies с каждым запросом. Атакующий может заставить пользователя выполнить действия (перевод денег, изменение email, удаление данных) без его ведома.",
    topic: "Основы XSS и CSRF"
  },
  {
    id: 4,
    question: "Какие типы XSS-атак существуют?",
    options: [
      "Только Reflected XSS",
      "Reflected, Stored и DOM-based XSS",
      "Client-side и Server-side XSS",
      "Persistent и Non-persistent XSS"
    ],
    correctAnswer: 1,
    explanation: "Существует три основных типа XSS: Reflected (отраженный) - код выполняется сразу из запроса; Stored (хранимый) - код сохраняется на сервере и выполняется у всех пользователей; DOM-based - манипуляция DOM без участия сервера.",
    topic: "Основы XSS и CSRF"
  },

  // Тема 2: Предотвращение XSS
  {
    id: 5,
    question: "Какой основной метод предотвращения XSS-атак?",
    options: [
      "Использование HTTPS",
      "Экранирование (escaping) пользовательского ввода перед отображением",
      "Использование сильных паролей",
      "Отключение JavaScript"
    ],
    correctAnswer: 1,
    explanation: "Экранирование (escaping) пользовательских данных перед выводом в HTML - основной способ предотвращения XSS. Специальные символы (<, >, &, ', \") должны быть заменены на HTML-сущности (&lt;, &gt;, &amp;, &#x27;, &quot;).",
    topic: "Предотвращение XSS"
  },
  {
    id: 6,
    question: "Что такое валидация ввода и как она помогает против XSS?",
    options: [
      "Проверка сложности пароля",
      "Проверка и санитизация пользовательских данных на соответствие ожидаемому формату",
      "Проверка скорости интернет-соединения",
      "Проверка версии браузера"
    ],
    correctAnswer: 1,
    explanation: "Валидация ввода проверяет данные на соответствие ожидаемому формату (например, email должен содержать @, возраст должен быть числом). Санитизация удаляет или экранирует потенциально опасные символы и теги перед сохранением или отображением.",
    topic: "Предотвращение XSS"
  },
  {
    id: 7,
    question: "Почему важно использовать библиотеки для санитизации HTML?",
    options: [
      "Они быстрее работают",
      "Они автоматически удаляют или экранируют опасные теги и атрибуты",
      "Они уменьшают размер кода",
      "Они улучшают SEO"
    ],
    correctAnswer: 1,
    explanation: "Библиотеки санитизации HTML (DOMPurify, sanitize-html) специально разработаны для безопасной обработки HTML. Они знают о всех векторах XSS-атак и правильно обрабатывают edge cases, которые легко пропустить при ручной реализации.",
    topic: "Предотвращение XSS"
  },
  {
    id: 8,
    question: "Как React по умолчанию защищает от XSS?",
    options: [
      "Блокирует все внешние скрипты",
      "Автоматически экранирует все значения, вставляемые в JSX",
      "Использует HTTPS для всех запросов",
      "Проверяет все данные через API"
    ],
    correctAnswer: 1,
    explanation: "React автоматически экранирует все значения перед их рендерингом в JSX. Это предотвращает выполнение вредоносного кода. Опасно только использование dangerouslySetInnerHTML без санитизации.",
    topic: "Предотвращение XSS"
  },
  {
    id: 9,
    question: "В каком случае React НЕ защищает от XSS?",
    options: [
      "При использовании обычных пропсов",
      "При использовании dangerouslySetInnerHTML с несанитизированными данными",
      "При использовании state",
      "При использовании useEffect"
    ],
    correctAnswer: 1,
    explanation: "dangerouslySetInnerHTML позволяет вставить HTML напрямую в DOM, обходя защиту React. Перед использованием необходимо санитизировать данные библиотекой типа DOMPurify.",
    topic: "Предотвращение XSS"
  },
  {
    id: 10,
    question: "Что такое Context-aware encoding в контексте XSS?",
    options: [
      "Кодирование данных в зависимости от контекста их использования (HTML, JavaScript, URL, CSS)",
      "Сжатие данных перед отправкой",
      "Шифрование данных в базе",
      "Кеширование данных в браузере"
    ],
    correctAnswer: 0,
    explanation: "Context-aware encoding означает использование разных методов экранирования в зависимости от контекста: HTML entity encoding для HTML, JavaScript encoding для JS строк, URL encoding для URL параметров, CSS encoding для CSS значений.",
    topic: "Предотвращение XSS"
  },

  // Тема 3: Защита от CSRF
  {
    id: 11,
    question: "Что такое CSRF-токен и как он защищает от CSRF-атак?",
    options: [
      "Уникальный секретный токен, проверяемый сервером при каждом запросе",
      "Токен для авторизации пользователя",
      "Зашифрованный пароль пользователя",
      "Идентификатор сессии"
    ],
    correctAnswer: 0,
    explanation: "CSRF-токен - это уникальное случайное значение, генерируемое сервером для каждой сессии/формы. Сервер проверяет наличие и правильность токена при запросах, изменяющих данные. Атакующий не может получить токен из-за Same-Origin Policy.",
    topic: "Защита от CSRF"
  },
  {
    id: 12,
    question: "Где должен передаваться CSRF-токен?",
    options: [
      "Только в URL параметрах",
      "Только в cookies",
      "В заголовках или теле запроса, но не в URL",
      "В localStorage"
    ],
    correctAnswer: 2,
    explanation: "CSRF-токен должен передаваться в заголовке (например, X-CSRF-Token) или в теле запроса, но никогда в URL. Токены в URL могут попасть в логи, referrer headers или историю браузера. Cookies автоматически отправляются браузером, поэтому их недостаточно.",
    topic: "Защита от CSRF"
  },
  {
    id: 13,
    question: "Что такое SameSite cookie атрибут и как он защищает от CSRF?",
    options: [
      "Атрибут, ограничивающий отправку cookies в cross-site запросах",
      "Атрибут для шифрования cookies",
      "Атрибут для установки времени жизни cookie",
      "Атрибут для указания домена cookie"
    ],
    correctAnswer: 0,
    explanation: "SameSite атрибут контролирует, когда cookies отправляются в cross-site запросах. SameSite=Strict - cookie не отправляется в cross-site запросах. SameSite=Lax - cookie отправляется только при GET-запросах верхнего уровня. Это эффективная защита от CSRF.",
    topic: "Защита от CSRF"
  },
  {
    id: 14,
    question: "Какие HTTP-методы требуют CSRF-защиты?",
    options: [
      "Все методы",
      "Только GET",
      "POST, PUT, DELETE, PATCH (методы, изменяющие данные)",
      "Только POST"
    ],
    correctAnswer: 2,
    explanation: "CSRF-защита нужна для методов, изменяющих состояние на сервере: POST, PUT, DELETE, PATCH. GET-запросы по стандарту не должны изменять данные (idempotent), но если это правило нарушается, они также требуют защиты.",
    topic: "Защита от CSRF"
  },
  {
    id: 15,
    question: "Что такое Double Submit Cookie pattern?",
    options: [
      "Отправка двух разных cookies",
      "Отправка одного значения токена и в cookie, и в запросе, сравнение их на сервере",
      "Двойная проверка пароля",
      "Использование двух серверов"
    ],
    correctAnswer: 1,
    explanation: "Double Submit Cookie: сервер устанавливает CSRF-токен в cookie (без HttpOnly). Клиент читает токен из cookie и отправляет его в заголовке/теле. Сервер сравнивает значения. Атакующий не может прочитать cookie из-за Same-Origin Policy.",
    topic: "Защита от CSRF"
  },
  {
    id: 16,
    question: "Почему проверка Referer/Origin заголовков может помочь против CSRF?",
    options: [
      "Они всегда содержат IP-адрес пользователя",
      "Они показывают, с какого сайта пришел запрос",
      "Они содержат информацию о браузере",
      "Они шифруют данные запроса"
    ],
    correctAnswer: 1,
    explanation: "Referer/Origin заголовки содержат URL источника запроса. Проверка, что запрос пришел с вашего домена, может предотвратить CSRF. Однако это не должно быть единственной защитой: заголовки могут отсутствовать или быть подделаны в некоторых сценариях.",
    topic: "Защита от CSRF"
  },

  // Тема 4: Безопасные заголовки
  {
    id: 17,
    question: "Что такое Content Security Policy (CSP)?",
    options: [
      "Политика паролей пользователей",
      "HTTP-заголовок, определяющий разрешенные источники контента для предотвращения XSS",
      "Способ шифрования данных",
      "Метод аутентификации"
    ],
    correctAnswer: 1,
    explanation: "CSP - это HTTP-заголовок, позволяющий контролировать, какие ресурсы браузер может загружать и выполнять. Это мощная защита от XSS, так как можно запретить inline-скрипты и ограничить источники JavaScript.",
    topic: "Безопасные заголовки"
  },
  {
    id: 18,
    question: "Какая CSP-директива блокирует inline JavaScript?",
    options: [
      "script-src 'self'",
      "default-src 'none'",
      "unsafe-inline: false",
      "block-inline: true"
    ],
    correctAnswer: 0,
    explanation: "script-src 'self' разрешает загрузку скриптов только с того же origin и блокирует inline-скрипты (в том числе eval, onclick атрибуты). Для разрешения inline нужно явно указать 'unsafe-inline' (небезопасно) или использовать nonces/hashes.",
    topic: "Безопасные заголовки"
  },
  {
    id: 19,
    question: "Что делает заголовок X-Frame-Options?",
    options: [
      "Ускоряет загрузку iframe",
      "Контролирует, может ли страница быть загружена во фрейме, защищая от clickjacking",
      "Оптимизирует изображения",
      "Управляет cookies"
    ],
    correctAnswer: 1,
    explanation: "X-Frame-Options предотвращает clickjacking атаки, контролируя возможность загрузки страницы во фрейме. DENY - полный запрет, SAMEORIGIN - разрешено только для того же origin. Современная альтернатива - CSP директива frame-ancestors.",
    topic: "Безопасные заголовки"
  },
  {
    id: 20,
    question: "Что такое nonce в контексте CSP?",
    options: [
      "Номер транзакции",
      "Случайное одноразовое значение для разрешения конкретных inline-скриптов",
      "Имя пользователя",
      "Версия API"
    ],
    correctAnswer: 1,
    explanation: "Nonce (number used once) - это криптографически случайное значение, генерируемое для каждого запроса. CSP: script-src 'nonce-abc123'. HTML: <script nonce='abc123'>. Только скрипты с правильным nonce будут выполнены, что безопаснее 'unsafe-inline'.",
    topic: "Безопасные заголовки"
  },
  {
    id: 21,
    question: "Какой заголовок защищает от MIME-type sniffing?",
    options: [
      "X-Content-Type-Options: nosniff",
      "Content-Type: text/html",
      "X-XSS-Protection: 1",
      "Strict-Transport-Security"
    ],
    correctAnswer: 0,
    explanation: "X-Content-Type-Options: nosniff предотвращает MIME-sniffing - попытку браузера угадать тип контента вопреки указанному Content-Type. Это защищает от атак, где файл загружается как изображение, но содержит JavaScript.",
    topic: "Безопасные заголовки"
  },
  {
    id: 22,
    question: "Что такое Trusted Types API?",
    options: [
      "Новый тип данных в JavaScript",
      "API для типизации в TypeScript",
      "Механизм браузера для предотвращения DOM-based XSS через контроль опасных sink функций",
      "Система авторизации"
    ],
    correctAnswer: 2,
    explanation: "Trusted Types API требует, чтобы данные, передаваемые в опасные DOM API (innerHTML, eval, document.write), были явно помечены как безопасные. Это предотвращает случайную вставку неочищенных данных. Работает с CSP: require-trusted-types-for 'script'.",
    topic: "Безопасные заголовки"
  },

  // Тема 5: Инструменты и методы обнаружения
  {
    id: 23,
    question: "Какие инструменты помогают обнаружить XSS-уязвимости?",
    options: [
      "Только ручное тестирование",
      "OWASP ZAP, Burp Suite, специализированные сканеры безопасности",
      "Только DevTools браузера",
      "Компиляторы языков программирования"
    ],
    correctAnswer: 1,
    explanation: "Для обнаружения XSS используются: сканеры безопасности (OWASP ZAP, Burp Suite, Acunetix), статический анализ кода (ESLint плагины, Semgrep), динамическое тестирование, penetration testing, а также CSP reporting для мониторинга.",
    topic: "Инструменты обнаружения"
  },
  {
    id: 24,
    question: "Что такое CSP reporting и как оно помогает?",
    options: [
      "Отчет о производительности сайта",
      "Механизм отправки отчетов о нарушениях CSP на сервер для мониторинга атак",
      "Статистика посещений",
      "Отчет об ошибках JavaScript"
    ],
    correctAnswer: 1,
    explanation: "CSP может отправлять отчеты о нарушениях политики через директиву report-uri или report-to. Это позволяет отслеживать попытки XSS-атак, тестировать CSP в режиме report-only без блокировки, и обнаруживать проблемные места в приложении.",
    topic: "Инструменты обнаружения"
  },
  {
    id: 25,
    question: "Какой подход к безопасности называется 'Defense in Depth'?",
    options: [
      "Использование одного мощного механизма защиты",
      "Применение нескольких уровней защиты одновременно",
      "Глубокий анализ кода",
      "Шифрование всех данных"
    ],
    correctAnswer: 1,
    explanation: "Defense in Depth - использование множественных слоев защиты: валидация ввода + экранирование вывода + CSP + HttpOnly cookies + SameSite + CSRF-токены. Если один слой пробит, другие защитят систему.",
    topic: "Инструменты обнаружения"
  },
  {
    id: 26,
    question: "Как можно автоматизировать проверку на CSRF-уязвимости?",
    options: [
      "Проверить наличие CSRF-токенов во всех формах, тестировать запросы без токенов",
      "Использовать только manual testing",
      "Проверять только GET-запросы",
      "Тестировать только авторизацию"
    ],
    correctAnswer: 0,
    explanation: "Автоматизация проверки CSRF: убедиться, что все state-changing запросы требуют токен; попытаться выполнить запросы без токена/с неверным токеном; проверить правильность имплементации SameSite cookies; использовать инструменты типа Burp Suite для автоматического тестирования.",
    topic: "Инструменты обнаружения"
  },
  {
    id: 27,
    question: "Что такое Penetration Testing в контексте XSS/CSRF?",
    options: [
      "Тестирование производительности",
      "Имитация реальных атак для обнаружения уязвимостей",
      "Тестирование пользовательского интерфейса",
      "Нагрузочное тестирование"
    ],
    correctAnswer: 1,
    explanation: "Penetration Testing (pen testing) - это имитация действий хакера для обнаружения уязвимостей. Тестировщик пытается провести XSS и CSRF атаки, используя различные векторы и техники обхода защиты, чтобы найти слабые места до реальных атакующих.",
    topic: "Инструменты обнаружения"
  },
  {
    id: 28,
    question: "Какие ESLint плагины помогают предотвратить XSS в React?",
    options: [
      "eslint-plugin-security, eslint-plugin-react",
      "Только стандартные правила ESLint",
      "ESLint не может помочь с безопасностью",
      "Только prettier"
    ],
    correctAnswer: 0,
    explanation: "eslint-plugin-security обнаруживает потенциально опасные паттерны (eval, dangerouslySetInnerHTML без санитизации). eslint-plugin-react предупреждает об опасном использовании dangerouslySetInnerHTML. Статический анализ помогает находить проблемы на этапе разработки.",
    topic: "Инструменты обнаружения"
  }
]
